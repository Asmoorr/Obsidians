## Билет 1
Назовите основные принципы ООП. Дайте определение каждому из них. Объясните зачем каждый из принципов нужен.

4 основных принципа ООП:
1. Абстракция
2. Инкапсуляция
3. Наследование
4. Полиморфизм

### 1. Абстракция

**Абстракция** — это выделение существенных характеристик объекта и игнорирование несущественных деталей с целью упрощения модели предметной области. Абстракция позволяет управлять сложностью и скрыть детали реализации

Иными словами, абстракция отвечает на вопрос:

> _«Что объект делает?»_, а не _«Как он это делает?»_.

Абстракция позволяет:
- упростить сложные системы;
- работать на уровне понятий предметной области;
- изолировать использование объекта от его внутренней реализации.

### 2. Инкапсуляция

**Инкапсуляция** — это объединение данных и методов, работающих с этими данными, в одном объекте с целью ограничения прямого доступа ко внутреннему состоянию объекта.

Инкапсуляция обеспечивает:
- защиту внутреннего состояния объекта;
- сокрытие реализации - доступно только то, что нужно;
- контроль доступа ко внутреннему состоянию объекта;
- снижение связности между компонентами;

В C++ и подобных языка программирования инкапсуляция реализована посредством использования модификатор доступа: (на примере C#)

| Модификатор          | Описание                                                     |
| -------------------- | ------------------------------------------------------------ |
| `private`            | Доступ разрешен только внутри того же класса                 |
| `protected`          | Доступ разрешен внутри класса и производных классов          |
| `internal`           | Доступ разрешен в пределах той же сборки                     |
| `protected internal` | Доступ разрешен в пределах сборки ИЛИ из производных классов |
| `public`             | Доступ разрешен откуда угодно                                |

## Практические рекомендации

- **Сначала делайте поля приватными** — поднимайте уровень доступа только при необходимости
- **Используйте свойства вместо публичных полей** — это дает гибкость для будущих изменений
- **Минимизируйте публичный интерфейс** — чем меньше методов и свойств доступно извне, тем проще поддерживать и изменять код
- **Добавляйте валидацию** в сеттеры свойств и параметры методов
- **Используйте методы для операций**, которые изменяют состояние объекта

## 3. Наследование

**Наследование** — это механизм, позволяющий создавать новый класс на основе существующего с заимствованием его свойств и поведения.

> Отношение наследования часто описывается как _«is-a»_ (является).

Наследование позволяет:
- переиспользование кода;
- строить иерархии классов;
- расширять функциональность без изменения базового класса;
- поддерживать принцип открытости/закрытости (OCP).

| Плюс                                            | Пояснение                                                                                                                               |
| ----------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| Повторное использование кода                    | Дочерние классы автоматически получают поля и методы базового класса, что снижает дублирование кода.                                    |
| Логичная иерархия классов                       | Наследование позволяет моделировать иерархии предметной области, аналогично классификациям в реальном мире.                             |
| Расширение функциональности                     | Можно добавлять новое поведение в дочерних классах без изменения базового класса.                                                       |
| Поддержка полиморфизма                          | Наследование позволяет работать с объектами разных типов через общий базовый класс или интерфейс.                                       |
| Хорошо работает при отношении «is-a»            | Когда дочерний класс действительно является разновидностью базового (например, Admin — это User), наследование естественно и оправдано. |
| Упрощение архитектуры при правильном применении | В корректных случаях делает код более читаемым и понятным.                                                                              |

| Минус                          | Пояснение                                                                                                                     |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------- |
| Сильное связывание классов     | Дочерний класс жёстко зависит от реализации базового, что снижает гибкость архитектуры.                                       |
| Сложность поддержки и развития | Глубокие иерархии усложняют понимание, тестирование и модификацию кода.                                                       |
| Плохая замена композиции       | Наследование часто ошибочно используется там, где логичнее применять отношение «has-a» (агрегацию) или "part-of" (композицию) |

**Когда наследование ОПРАВДАНО:**
- Когда есть четкое, неразрывное отношение **«является (is-a)»**.
- Когда дочерние классы _специализируют_ поведение родителя, не нарушая его контракт.
- Оно обеспечивает повторное использование кода, логичную организацию и полиморфизм.

**Когда наследование ОПАСНО:**

- Когда отношение больше похоже на **«имеет» (has-a)**, а не на «является».
- Когда оно приводит к проблемам, описанным выше:
    - Нарушение контракта **is-a** (Квадрат-Прямоугольник).
    - Избыточная сложность (Бананы-Гориллы-Джунгли) - Вы хотите просто получить **банан** (нужный метод), но вместе с ним получаете **Гориллу** (огромный родительский класс со всеми его полями и методами) и **джунгли** (цепочку зависимостей и всю реализацию родителя).
    - Хрупкость архитектуры (Хрупкий базовый класс). - возникает, когда подклассы зависят от **внутренней реализации** базового класса, а не от его **публичного интерфейса**.
    - Неоднозначность при множественном наследовании (Бриллиантовая проблема).

## 4. Полиморфизм

**Полиморфизм** — это способность объектов с одинаковым интерфейсом вести себя по-разному в зависимости от их конкретного типа, а также единообразно работать с разными типами данных.

Полиморфизм позволяет:
- писать обобщённый код (generics);
- снижать зависимость от конкретных реализаций;
- расширять систему обработкой новых типов;
- поддерживать принцип подстановки Лисков (LSP).

### Виды полиморфизма:
#### Cтатический (компиляционный) полиморфизм
- **Перегрузка методов и операторов (overloading, ad hoc)** — один метод с разными наборами параметров (иногда с разными типами данных)
- **Шаблоны (generics)** работа с произвольным типом данных.
#### Динамический полиморфизм
- **Переопределение методов (overriding)** — методы базового класса переопределяются в производных для изменения поведения.

> [!tip] 
> Дополнительно: **Коэрцирующий полиморфизм** (Coercion Polymorphism)
> **Определение:**  
Полиморфизм, при котором типы неявно или явно преобразуются к совместимому типу.
**Пример (C#):**

```c#
double x = 5; // int → double`
```
### Преимущества и недостатки полиморфизма

| Преимущество                         | Недостаток                               |
| ------------------------------------ | ---------------------------------------- |
| Гибкость и расширяемость             | Повышенные затраты на производительность |
| Упрощение поддержки и изменения кода | Усложнение отладки                       |
| Повышение уровня абстракции          | Потенциальная избыточность кода          |
| Снижение связности (coupling)        | Риск неправильного использования         |

### Краткая историческая сводка

| Принцип      | Суть               | Зачем нужен                             |
| ------------ | ------------------ | --------------------------------------- |
| Абстракция   | Выделение главного | Упрощение и работа на уровне понятий    |
| Инкапсуляция | Сокрытие деталей   | Защита данных и снижение связности      |
| Наследование | Переиспользование  | Расширяемость и повторное использование |
| Полиморфизм  | Разное поведение   | Гибкость и масштабируемость             |
## Билет 2.
Чем класс отличается от объекта. Какие основные этапы жизни объекта вы можете выделить?

### Класс

**Класс** — это и есть такой "чертеж", "шаблон", "формальное описание" для создания объектов. Он описывает:

- **Атрибуты (данные, поля, свойства):** Это характеристики, которые будут у будущего объекта (например, для класса `Car` атрибутами могут быть `color`, `model`, `max_speed`).
- **Методы (функции):** Это действия, которые объект сможет выполнять (например, для класса `Car` методами могут быть `start_engine()`, `drive()`, `brake()`).

Сам по себе класс не занимает места в памяти компьютера. Это просто описание.

### Объект

Если класс — это чертеж, то **объект (или экземпляр) — это конкретное "представление", "реализация" построенное по этому чертежу.**

Вы можете построить несколько разных машин по одному и тому же чертежу: одна — гоночная и красная, другая — грузовая и синяя. Аналогично, из одного класса можно создать множество объектов.

**Объект — это конкретная сущность в памяти компьютера**, созданная по описанию класса. Она имеет конкретные значения атрибутов и может выполнять методы.

| Критерий            | Класс                       | Объект     |
| ------------------- | --------------------------- | ---------- |
| Сущность            | Чертёж                      | Экземпляр  |
| Время существования | Проектирование / компиляция | Выполнение |
| Состояние           | Нет                         | Есть       |
| Память              | Не занимает (как данные)    | Занимает   |
| Количество          | Один                        | Много      |
### Жизненный цикл объекта
0. Объявление объекта
1. Создание объекта (выделение памяти, allocation)
2. Инициализация объекта (выполнение конструктора)
3. Использование объекта
4. Потеря достижимости объекта
5. Финализация (опционально, если определена)
6. Уничтожение объекта (освобождение памяти сборщиком мусора)

## Билет 3
Дайте определение принципу ООП: наследование. Расскажите какие плюсы и минусы наследования вы знаете. Назовите любые 2 проблемы наследования и раскройте их.

См. раздел [[#3. Наследование|Наследование]]

## Билет 4.
Дайте определение принципу ООП: полиморфизм. Расскажите какие плюсы и минусы полиморфизма вы знаете. Назовите 4 разных вида полиморфизма и классифицируйте их.

См. раздел [[#4. Полиморфизм||Полиморфизм]]
## Билет 5.
Дайте определение принципам ООП: инкапсуляция и абстракция. Зачем нужна инкапсуляция, как реализована инкапсуляция в C++ подобных языках программирования

См. раздел [[#1. Абстракция||Абстракция и Инкапсуляция]]

## Билет 6.
Что такое ассоциация, композиция, агрегация, в чем разница? Когда и что лучше из них использовать?

Это виды отношений между классами, они описывают связь объектов
### Ассоциация

Ассоциация это самое общее отношение использования одного объекта другим, когда один объект знает о существовании другого и может с ним взаимодействовать

- Один объект знает о существовании другого и может вызывать его методы или обращаться к свойствам.
- Взаимодействие двунаправленное или одностороннее: А знает про В, но В может не знать про А.
- Нет владения или жёсткого жизненного цикла: объекты существуют независимо.

Например, Водитель и Машина: `Driver` и `Car`. `Driver` имеет метод `drive()` и принимает экземпляр `Car`, который в свою очередь вызывает метод `start()`
Здесь `Driver` и `Car` связаны ассоциацией: водитель пользуется машиной, но не владеет ей.

### Агрегация

Агрегация это более слабая форма владения, когда один объект (целое) содержит или группирует другие объекты (части), но части могут существовать и без целого.

- Семантика «часть-целое», но без жёсткого жизненного цикла.
- При уничтожении контейнера вложенные объекты не обязательно уничтожаются.
- отношение _has-a_

Например, Команда и Игрок: `Team` и `Player`. В классе `Team` хранится список игроков, но игрок при этом может существовать вне команды
`Team` агрегирует `Player`, но игрок может играть в другой команде или существовать отдельно.

### Композиция

Композиция это сильная форма владения: целое полностью управляет жизненным циклом своих частей и часть не может существовать без целого.

- Если контейнер уничтожается, то и его части автоматически уничтожаются.
- Часть не может существовать без целого.
- отношение _part-of_;

Например, Дом и Комнаты: `House` и `Room`. В классе `House` хранится список комнат, но комната **никак не** может существовать вне дома

| Критерий                 | Ассоциация | Агрегация | Композиция       |
| ------------------------ | ---------- | --------- | ---------------- |
| Тип связи                | Использует | Has-a     | Part-of          |
| Владение                 | Нет        | Частичное | Полное           |
| Жизненный цикл           | Независим  | Независим | Зависим          |
| Удаление целого          | Не влияет  | Не влияет | Уничтожает части |
| Сила связи               | Слабая     | Средняя   | Сильная          |

## Билет 7
Что такое интерфейс? Для чего его используют? Чем он отличается от абстрактного класса?

**Интерфейс (interface)** — это своего рода «контракт» на поведение. Он определяет набор методов, свойств (событий или индексаторов), которые объект **должен** реализовать, но сам интерфейс (традиционно) не содержит реализации и полей данных.

### Для чего его используют?

1. **Полиморфизм:** Интерфейс позволяет работать с разными классами как с одним типом
2. **Слабая связность (Low Coupling):** Компоненты системы зависят от абстрактных контрактов, а не от конкретных классов (принцип DIP из SOLID).
3. **Множественное наследование:** В C# класс может наследоваться только от одного класса, но может реализовывать неограниченное количество интерфейсов.
4. **Тестирование:** Интерфейсы позволяют легко подменять реальные объекты «заглушками» (Mock-объектами) при написании Unit-тестов.

## Билет 8.
Что такое абстрактный класс? Зачем он нужен? Чем он отличается от интерфейса?

**Абстрактный класс (abstract class)** — это класс, экземпляр которого нельзя создать. Он служит базовым шаблоном для других классов. Он может содержать как реализованные методы (общая логика), так и абстрактные методы (без реализации), которые обязаны переопределить наследники.

### Зачем он нужен?

1. **Повторное использование кода:** Вынос общей логики для целой группы родственных классов в одно место.
2. **Создание иерархии (Is-a):** Определение базовой сущности, которая сама по себе не существует в реальности (например, «Животное» — это абстракция, а «Кот» — конкретика).
3. **Частичная реализация:** Когда мы знаем, что должны делать все наследники, и часть того, как они это делают.

| Характеристика           | Интерфейс (interface)                                              | Абстрактный класс (abstract)                                 |
| ------------------------ | ------------------------------------------------------------------ | ------------------------------------------------------------ |
| **Смысл (Семантика)**    | Определяет **поведение** («что умеет делать»). Отношение "Can do". | Определяет **сущность** («кто это такой»). Отношение "Is a". |
| **Наследование (C#)**    | Можно реализовать **много** интерфейсов.                           | Можно наследоваться только от **одного** класса.             |
| **Поля (Состояние)**     | Не может содержать поля (только свойства).                         | Может содержать обычные поля (переменные).                   |
| **Реализация**           | По умолчанию методы пустые (до C# 8.0).                            | Может содержать как готовые методы, так и пустые.            |
| **Конструктор**          | Нет конструкторов.                                                 | Есть конструктор (вызывается из наследников).                |
| **Пояснение**            | Контракт для разных классов                                        | Общий функционал и частичная реализация                      |

## Билет 9  
В чем разница статического и динамического полиморфизма, как они реализованы в C#? В каких языках программирования есть статический полиморфизм?
В каких языках программирования есть динамический полиморфизм?

См. раздел [[#4. Полиморфизм||Полиморфизм]]

### 1. Статический полиморфизм (Compile-time)

**Суть:** Решение о том, какой именно код будет вызван, принимается **компилятором** на этапе сборки программы. Это называется **ранним связыванием**.

- **Перегрузка методов (Method Overloading):** Несколько методов с одним именем, но разными сигнатурами (типами или количеством параметров).
- **Перегрузка операторов:** Возможность определить поведение операторов
- **Обобщения (Generics):** Позволяют писать код, который работает с любым типом данных, обеспечивая типизацию еще на этапе компиляции.

Преимуществом является **высокая производительность** (нет проверок во время работы программы), проверка типов на этапе компиляции.

### 2. Динамический полиморфизм (Runtime)

**Суть:** Решение о том, какая реализация метода будет вызвана, принимается **средой выполнения (CLR)** во время работы программы, исходя из реального типа объекта. Это называется **поздним связыванием**.

**Реализация в C#:**

- **Переопределение методов (Method Overriding):** Использование ключевых слов virtual в базовом классе и override в производном.
- **Интерфейсы:** Когда мы вызываем метод через интерфейсную переменную, программа в рантайме ищет реализацию этого метода в конкретном классе.

В C# это реализуется через **таблицу виртуальных методов (V-Table)**. У каждого объекта есть ссылка на таблицу, где хранятся адреса реализаций методов для его конкретного типа.

| Характеристика         | Статический (Static)              | Динамический (Dynamic)                     |
| ---------------------- | --------------------------------- | ------------------------------------------ |
| **Когда связывается?** | Во время компиляции.              | Во время выполнения (Runtime).             |
| **Механизм в C#**      | Overloading, Generics, Operators. | Overriding (Virtual/Abstract), Interfaces. |
| **Скорость**           | Быстрее (прямой вызов адреса).    | Чуть медленнее (поиск в V-Table).          |
| **Гибкость**           | Ниже (нужно знать типы заранее).  | Выше (позволяет подменять логику на лету). |
##### **Ключевое различие - время связывания (Binding time)**
У статического — компиляция
У динамического — выполнение.

### Статический и динамический полиморфизм в языках программирования

|   |   |   |
|---|---|---|
|Язык|Статический полиморфизм (Compile-time)|Динамический полиморфизм (Runtime)|
|**C#**|Перегрузка, Дженерики|Переопределение (Virtual)|
|**C++**|Перегрузка, Шаблоны|Виртуальные функции|
|**Java**|Перегрузка, Дженерики|Переопределение (Override)|
|**Rust**|Трейты (Static Dispatch)|Трейт-объекты (Dynamic Dispatch)|
|**Go**|Обобщения (Generics)|Интерфейсы|
|**Python**|(Почти отсутствует)|Duck Typing (Утиная типизация)|
|**TypeScript**|Перегрузка (сигнатур)|Прототипы, Интерфейсы|
|**Swift**|Перегрузка, Дженерики|Протоколы, Переопределение|

### Короткие пояснения для экзаменатора:

- **Duck Typing (Утиная типизация)** — «если это крякает как утка, то это утка». Проверка наличия метода происходит прямо в момент вызова в работающей программе.

- **Трейты / Протоколы** — современные аналоги интерфейсов, которые могут работать как статически (быстро), так и динамически (гибко).

## Билет 10
Что такое множественное наследование? Какие проблемы множественного наследования вы знаете? Как множественное наследование реализовано в C#?

См. раздел [[#3. Наследование|Наследование]]

**Множественное наследование** — это возможность класса иметь более одного непосредственного базового класса. Это означает, что дочерний класс заимствует состояние (поля) и поведение (методы) сразу у нескольких «родителей».

Множественное наследование усугубляет классические проблемы наследования, однако наиболее ярко ему присуща бриллиантовая проблема

|Проблема|Одиночное наследование|Множественное наследование|
|---|---|---|
|Нарушение `is-a`|Да|Да|
|Бананы–Гориллы–Джунгли|Да|Да (усиливается)|
|Хрупкий базовый класс|Да|Да (усиливается)|
|Бриллиантовая проблема|Нет|**Да (уникальна)**|
### Неоднозначность поведения

Бриллиантовая проблема (The Diamond Problem)
В иерархии:    
- Класс A имеет метод Drive().
- Классы B и C наследуют A и **переопределяют** метод Drive() каждый по-своему.
- Класс D наследуется одновременно от B и C.  
**Вопрос:** Какую версию метода Drive() должен использовать класс D? Возникает неопределенность

### Как множественное наследование реализовано в C#?

В C# принят компромиссный подход: **множественное наследование классов запрещено, но множественная реализация интерфейсов разрешена.**

>[!нюанс]
>#### Нюанс: Default Interface Methods (C# 8.0+)
>В современных версиях C# интерфейсы могут иметь реализацию методов по умолчанию. Это технически возвращает нас к подобию множественного наследования. Если в интерфейсах возникнет конфликт методов по умолчанию, компилятор заставит разработчика явно переопределить этот метод в классе, чтобы устранить неоднозначность.

## Билет 11
Что такое GRASP? Расскажите про Low Coupling High Cohesion, приведите пример системы 
где соблюдается и то и другое

**GRASP** (General Responsibility Assignment Software Patterns) — это набор из 9 принципов (или шаблонов), которые помогают решить одну главную задачу: **как правильно распределить обязанности между классами?**

- **Low Coupling** — это про **внешние связи** - минимум зависимостей между модулями
- **High Cohesion** — это про **внутреннее содержание** - фокусировка на одной задаче внутри модуля.

**9 принципов GRASP:**

1. Information Expert (Информационный эксперт)
2. Creator (Создатель)
3. Controller (Контроллер)
4. **Low Coupling (Слабая связанность)**
5. **High Cohesion (Высокая связность / сцепленность)**
6. Polymorphism (Полиморфизм)
7. Pure Fabrication (Чистая выдумка)
8. Indirection (Посредник)
9. Protected Variations (Устойчивость к изменениям)

### 1. High Cohesion (Высокая связность / сцепленность)

Это мера того, насколько сфокусированы и тесно связаны между собой обязанности внутри одного класса

- **Идея:** Один класс должен делать одну работу и делать её хорошо.
- **Признак высокой связности:** Если вы смотрите на методы класса, и все они логически относятся к одной теме (например, только к работе с заказом).
- **Признак низкой связности:** Класс-«комбайн», который одновременно считает скидки, пишет в базу данных, отправляет email и рисует PDF-отчет.

### 2. Low Coupling (Слабая связанность)

Это мера того, насколько сильно один класс зависит от других классов.

- **Идея:** Классы должны знать друг о друге как можно меньше.
- **Признак слабой связанности:** Вы меняете код в классе Database, и при этом вам **не нужно** менять код в классе User.
- **Признак сильной связанности:** Класс A вызывает приватные поля класса B, создает его экземпляры напрямую через new и жестко завязан на его внутреннюю структуру.

### Пример системы: Обработка заказов в интернет-магазине

#### Плохой дизайн (Low Cohesion, High Coupling):

Один класс делает всё. Если мы решим изменить формат Email, нам придется переписывать класс Order, который отвечает за бизнес-логику заказа.
#### Хороший дизайн (High Cohesion + Low Coupling):

Мы разделяем обязанности (повышаем Cohesion) и заставляем их общаться через интерфейсы (понижаем Coupling)

1. **High Cohesion:** Каждый класс занимается своим делом.
   - Order — только данные о заказе.
   - OrderRepository — только сохранение в базу.
   - NotificationService — только отправка уведомлений.
   
1. **Low Coupling:** Класс OrderProcessor не знает, как работает база или почта. Он работает с интерфейсами.

## Билет 12
Что такое SOLID? Расшифруйте каждую букву из акронима. Для чего нужны эти принципы? Каковы основные преимущества их применения?

**SOLID** — это акроним, объединяющий пять основных принципов объектно-ориентированного проектирования и разработки программного обеспечения. Впервые эти принципы (в разрозненном виде) представил Роберт Мартин («Дядя Боб») в начале 2000-х годов

### Расшифровка акронима

1. **S SRP– Single Responsibility Principle (Принцип единственной ответственности)**
    
    - Класс должен отвечать только за что-то одно. У него должна быть только одна причина для изменения.
    
2. **O OCP– Open/Closed Principle (Принцип открытости/закрытости)**
    
    - Программные сущности (классы, модули) должны быть открыты для расширения, но закрыты для модификации. Мы добавляем новый функционал, создавая новый код, а не исправляя старый.
    
3. **L LSP– Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**
    
    - Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности работы программы. (Наследник не должен «ломать» логику родителя).
    
4. **I ISP– Interface Segregation Principle (Принцип разделения интерфейса)**
    
    - Много специализированных интерфейсов лучше, чем один универсальный. Клиенты не должны зависеть от методов, которые они не используют.
    
5. **D DIP– Dependency Inversion Principle (Принцип инверсии зависимостей)**
    
    - Зависимости внутри системы должны строиться на основе абстракций (интерфейсов), а не на основе конкретных реализаций. Модули верхних уровней не должны зависеть от модулей нижних уровней. Все должны зависеть от абстракций (интерфейсов). Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

### Для чего нужны эти принципы?

Главная цель SOLID — борьба с **«загниванием» программного обеспечения**. Роберт Мартин выделял три основных признака плохого кода, которые лечит SOLID:

1. **Жесткость (Rigidity):** Любое изменение требует исправления множества других частей системы.
    
2. **Хрупкость (Fragility):** После изменений в одном месте программа неожиданно ломается в другом.
    
3. **Неподвижность (Immobility):** Код нельзя переиспользовать в другом проекте, потому что он слишком сильно «сросся» с текущим контекстом.


## Билет 14
Принцип единственной ответственности (Single Responsibility Principle, SRP). Дайте определение, приведите пример ответственности класса. Как SRP связан с понятием "высокая связность" (high cohesion)?

> [!tip] Кратко
> SRP требует, чтобы у класса была только одна причина для изменения.  
Это напрямую связано с высокой связностью (high cohesion): класс с одной ответственностью имеет логически связанный набор обязанностей.  
Соблюдение SRP упрощает сопровождение, тестирование и развитие системы.

**Принцип единственной ответственности (SRP)** гласит: «У класса должна быть только одна причина для изменения». Класс должен отвечать перед одной конкретной группой пользователей или бизнес-задачей, то есть перед одним актором (Дядя Боб)

 Если изменения в логике расчета налогов и изменения в логике сохранения в базу данных заставляют вас менять один и тот же класс — SRP нарушен.
### Пример ответственности класса

Ответственность класса — это набор тесно связанных функций, которые решают одну задачу.

- **Пример 1:** OrderCalculator — отвечает за расчет стоимости заказа, скидок и налогов.
- **Пример 2:** UserRepository — отвечает исключительно за сохранение и загрузку данных пользователя из хранилища.
- **Пример 3:** EmailSender — отвечает за техническую реализацию отправки писем.

### Как SRP связан с понятием "Высокая связность" (High Cohesion)?

**SRP — это инструмент для достижения High Cohesion.**

- **SRP** — это принцип проектирования
- **High Cohesion** — это цель, к которой мы стремимся (качество кода).
- Соблюдая **SRP**, мы разделяем код на маленькие блоки, внутри которых элементы максимально сплочены для решения одной задачи.

### Паттерны:
**Facade**, **Decorator**, **Command**, **Observer**


## Билет 15
Принцип открытости/закрытости (Open/Closed Principle, OCP). Сформулируйте принцип. Что означает "закрыт для …" и "открыт для …"? Какие паттерны проектирования чаще всего помогают следовать OCP? (Приведите 2-3 примера).

**Принцип открытости/закрытости (OCP)** гласит:

> «Программные сущности (классы, модули, функции и т.д.) должны быть **открыты для расширения**, но **закрыты для модификации**».

Это означает, что поведение системы может быть дополнено новыми возможностями без изменения уже существующего и протестированного исходного кода.

1. **Открыт для расширения (Open for extension):**  
    Мы должны иметь возможность добавить новую функциональность.
    
	Например, в интернет-магазине появился новый способ оплаты (криптовалюта) или новый тип скидки. Мы должны иметь возможность «встроить» это поведение в систему.
    
2. **Закрыт для модификации (Closed for modification):**  
    При добавлении этого нового способа оплаты мы **не должны** открывать файл уже работающего класса PaymentProcessor и дописывать туда новые if или switch.  
    Почему? Потому что вмешательство в работающий код может породить новые баги (регрессии), потребовать переписывания Unit-тестов и заново протестировать всю систему.

### Паттерны проектирования, помогающие следовать OCP

**Стратегия (Strategy):**  
Позволяет менять алгоритм (поведение) объекта прямо на лету. Мы создаем новые классы-стратегии, реализующие один интерфейс.
Например: `CreditCardPayment`, `PayPalPayment` реализующие `IPayment`

**Декоратор (Decorator):**  
Позволяет динамически добавлять объекту новые обязанности, не меняя его кода. Мы «оборачиваем» базовый объект в декоратор. 
Например: Базовый сервис отправки уведомлений -> Декоратор с шифрованием -> Декоратор с логированием.

### Основные преимущества OCP:

- **Стабильность:** Старый код остается нетронутым, а значит, риск сломать то, что уже работает — минимален.
- **Легкость тестирования:** Вам нужно написать тесты только для нового класса, а не перепроверять всю цепочку зависимостей.
- **Слабая связанность:** Система состоит из независимых «кирпичиков».

> [!Возможный вопрос]
>  **Как расширить код без модификации?**
>  
> Через **полиморфизм**. Мы создаем новую реализацию интерфейса или наследника абстрактного класса и подставляем его туда, где ожидается базовая версия».


## Билет 16
Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP). Дайте определение. Сформулируйте "инварианты", "постусловия" и "предусловия" в контексте LSP. Какие типичные последствия нарушения LSP для клиентского кода, использующего полиморфизм?

**Принцип подстановки Барбары Лисков (LSP)** гласит:

> Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности работы программы

Простыми словами: если ваш код ожидает базовый класс Bird, он должен работать с любым его наследником (например, Duck или Sparrow) и даже не «заметить» подмены. Если при подстановке наследника программа падает или ведет себя непредсказуемо — LSP нарушен.

### Предусловия, постусловия и инварианты

#### 1. Предусловия (Preconditions)

Это условия, которые должны быть выполнены **до** вызова метода (например, входные аргументы).

- **Правило:** Предусловия не могут быть усилены в подклассе.
    
- **Пример:** Если метод базового класса принимает любое целое число, наследник **не может** сказать: «А я принимаю только положительные». Это «напугает» клиентский код, который привык передавать любые числа.

#### 2. Постусловия (Postconditions)

Это условия, которые гарантируются **после** завершения метода (результат).

- **Правило:** Постусловия не могут быть ослаблены в подклассе.
    
- **Пример:** Если базовый класс гарантирует, что метод всегда возвращает объект (не null), то наследник **обязан** возвращать объект. Он не может вернуть null, так как клиентский код не готов к такой проверке.

#### 3. Инварианты (Invariants)

Это условия состояния объекта, которые остаются истинными всегда (например, «скорость машины не может быть отрицательной»).

- **Правило:** Инварианты базового класса должны быть сохранены в подклассе.
    
- **Пример:** Если в базовом классе Account баланс никогда не может быть меньше нуля, любой наследник (например, CreditAccount) обязан соблюдать это правило (или это не должен быть наследник Account).


### Типичные последствия нарушения LSP

Когда разработчик нарушает LSP, страдает **клиентский код** (код, который использует эти классы). Основные проблемы:

1. **Появление "костылей" (Type Checking):**  Вместо чистого полиморфизма в коде появляются проверки типов:
```c#
   foreach (var bird in birds) {
   if (bird is Ostrich) continue; // Костыль: страус не летает!
   bird.Fly();
   }
   ```

2. **Runtime ошибки (NotImplementedException):**  
   Самый частый признак нарушения LSP в C# — пустые методы-заглушки, которые выбрасывают исключение. Пример: У класса Bird есть метод Fly(). У наследника Ostrich (Страус) этот метод выбрасывает NotImplementedException. Клиентский код вызывает Fly() и неожиданно падает.

3. **Неожиданное поведение:**  Наследник формально выполняет метод, но логика нарушена. Классический пример: **Квадрат и Прямоугольник**. Если Square наследует Rectangle, то изменение ширины квадрата неожиданно меняет и его высоту. Код, который рассчитывал площадь прямоугольника, получит неверный результат.


## Билет 17
Принцип разделения интерфейсов (Interface Segregation Principle, ISP). В чем суть принципа? Что такое "толстый" интерфейс и каковы его недостатки? Как ISP способствует соблюдению принципа единственной ответственности (SRP) на уровне интерфейсов?

### В чем суть принципа?

**Принцип разделения интерфейсов (ISP)** гласит:

> Клиенты не должны зависеть от методов, которые они не используют

Простыми словами: лучше создать много маленьких, узкоспециализированных интерфейсов, чем один огромный.
Если класс реализует интерфейс, он должен реально нуждаться во всех его методах. Если какой-то метод ему не нужен, значит, интерфейс спроектирован неправильно.

### Что такое «толстый» интерфейс и его недостатки?

**«Толстый» (или «раздутый», Fat Interface)** — это интерфейс, который содержит слишком много методов, зачастую покрывающих разные, не связанные друг с другом задачи.

**Недостатки «толстого» интерфейса:**

1. **Загрязнение кода:** Классы-наследники вынуждены реализовывать методы, которые им не нужны. Часто это приводит к «заглушкам» вида throw new NotImplementedException()

2. **Нарушение инкапсуляции:** Клиент, работающий с объектом через «толстый» интерфейс, видит лишние методы, которые ему не полагается использовать.

3. **Сложность тестирования:** Создавать Mock-объекты для гигантских интерфейсов долго и утомительно.

### Как ISP способствует соблюдению SRP на уровне интерфейсов?

Связь между ISP и SRP (Single Responsibility Principle) очень тесная:

**SRP для интерфейсов:** ISP фактически переносит идею «единственной ответственности» с реализации (класса) на контракт (интерфейс). Если интерфейс «толстый», значит, он взял на себя **несколько ответственностей** одновременно, соответственно и реализующий его класс не будет соответствовать SRP


## Билет 18
Принцип инверсии зависимостей (Dependency Inversion Principle, DIP). Сформулируйте два утверждения принципа. Объясните, что такое "модули верхнего уровня" и "низкого уровня". Какая разница между Dependency Inversion (принцип) и Dependency Injection (паттерн внедрения)?

### Два утверждения принципа

1. **Модули верхнего уровня (бизнес логика) не должны зависеть от модулей нижнего (база данных, логирование, отправка sms email, работа с операционкой) уровня. Оба должны зависеть от абстракций.**
    
2. **Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.**
    

Простыми словами: Вместо того чтобы класс «А» жестко создавал внутри себя класс «Б», они оба должны «договориться» об интерфейсе и работать через него.

### Разница между Dependency Inversion и Dependency Injection

Эти понятия часто путают, но они находятся на разных уровнях:

1. **Dependency Inversion (DIP) — это ПРИНЦИП (Стратегия).**  
    Это теоретическое правило проектирования: «завись от абстракций». Это цель, к которой мы стремимся, чтобы достичь слабой связанности (Loose Coupling).
    
2. **Dependency Injection (DI) — это ПАТТЕРН (Тактика).**  
    Это конкретный способ реализации принципа DIP. Это техника, при которой объект не создает свои зависимости сам, а **получает** их извне (обычно через конструктор).


## Билет 19
Объясните, как следование DIP и ISP повышает тестируемость кода (например, использование mock-объектов). Почему код, нарушающий SRP, часто сложнее тестировать?

> [!кратко]
Код, написанный по SOLID, тестируется легко, потому что он **модульный**
**DIP** позволяет «отрезать» класс от реального мира (БД, API) и тестировать его в вакууме с помощью **Mock-объектов**.
**ISP** избавляет от написания лишнего кода в тестах, позволяя имитировать только нужные методы.
**SRP** гарантирует, что тесты будут простыми, их будет легко настраивать, а при поломке одного метода вам не придется переписывать тесты для всей системы.
### Как DIP повышает тестируемость (Использование Mock-объектов)

Если класс верхнего уровня `OrderService` внутри себя создает объект `DatabaseConnection`, мы не можем протестировать логику заказов, не имея реальной базы данных. То есть получается что модуль верхнего уровня всё же зависит от модуля нижнего уровня

**Решение через DIP:** Мы заменяем жесткую зависимость на интерфейс IDatabase. Теперь в тесте мы можем подставить **Mock-объект**

- **Что дает Mock-объект:**
    
    1. **Изоляция:** Мы тестируем только логику OrderService. Если тест упал, мы точно знаем, что ошибка в сервисе, а не в базе.
        
    2. **Скорость:** Тесты выполняются в оперативной памяти за миллисекунды, не обращаясь к диску или сети.
        
    3. **Предсказуемость:** Мы можем заставить Mock вернуть любой результат (например, ошибку или пустой список), чтобы проверить, как наш код обработает крайние случаи.


### Как ISP повышает тестируемость

**Принцип разделения интерфейсов (ISP)** делает тесты чище и проще.
**Проблема «толстых» интерфейсов:** Если ваш класс зависит от интерфейса ISmartMachine с 50 методами, то для написания теста вам придется создать Mock, который реализует (или имитирует) все 50 методов, даже если вы тестируете функцию, использующую только один метод Print().

### Почему код, нарушающий SRP, сложнее тестировать?

**Принцип единственной ответственности (SRP)** напрямую влияет на «стоимость» написания теста. Если класс делает слишком много вещей (например, считает логику, пишет логи и отправляет почту), возникают следующие проблемы:

1. **Комбинаторный взрыв сценариев:**  
    Если в классе 3 ответственности и у каждой по 3 варианта поведения, вам теоретически нужно 3 * 3 * 3 = 27 , чтобы покрыть все возможные сочетания состояний в одном месте. Если разделить их на 3 класса — понадобится всего 9 тестов (3+3+3).
    
2. **Сложная настройка (Setup):**  
    Чтобы протестировать одну маленькую функцию в «классе-комбайне», вам придется разрешить кучу зависимостей, которые к этой функции отношения не имеют, но требуются конструктору класса.
    
3. **Хрупкость тестов:**  
    Изменение в логике отправки почты заставит вас обновлять тесты для логики расчетов, потому что они живут в одном огромном тестовом классе.


## Билет 20
Что такое паттерн проектирования? Дайте определение. Назовите три основные категории паттернов (по GoF) и их назначение. Приведите по 2 примера на каждую из категорий паттернов

### Что такое паттерн проектирования?

**Паттерн (шаблон) проектирования** — это повторяемое решение стандартной проблемы, возникающей при проектировании программного обеспечения в рамках определенного контекста.

- Это не законченный фрагмент кода, который можно скопировать в проект. Это **описание или пример** того, как решить задачу, которую можно использовать в самых разных ситуациях.

- Паттерны делают архитектуру более гибкой, элегантной и создают **общий язык** для разработчиков (проще сказать «здесь мы используем Фасад», чем полчаса объяснять структуру классов).


### Три основные категории паттернов (по GoF)

#### 1. Порождающие паттерны (Creational)

Эти паттерны абстрагируют процесс создания объектов. Они помогают сделать систему независимой от того, как создаются, компонуются и представляются её объекты.

> [!tip]
> Простыми словами: Они отвечают на вопрос **«Как создать объект?»**, скрывая логику создания и избавляя от прямой зависимости от оператора new.

#### 2. Структурные паттерны (Structural)

**Назначение:** Рассматривают вопрос о том, как из классов и объектов образуются более крупные структуры. Они используют наследование и композицию для объединения объектов.

> [!tip]
> Простыми словами: Они отвечают на вопрос **«Как собрать объекты в структуру?»**, чтобы при этом система оставалась гибкой и эффективной.

#### 3. Поведенческие паттерны (Behavioral)

**Назначение:** Занимаются алгоритмами и распределением обязанностей между объектами. Описывают не только структуры объектов, но и типичные шаблоны взаимодействия (связи) между ними.

>[!tip]
>Простыми словами: Они отвечают на вопрос **«Как объекты общаются друг с другом?»** и как распределяются задачи внутри системы.

![[Pasted image 20260110045321.png]]

## Билет 21
Паттерн Наблюдатель (Observer). Дайте определение, опишите основные компоненты (Subject, Observer). В чем разница между push- и pull-моделями? Какие проблемы может решить, а какие создать этот паттерн? (Сильная связь, утечка памяти)

### Определение

**Паттерн Наблюдатель** — это поведенческий паттерн проектирования, который определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него объекты уведомляются и обновляются автоматически.

В книге GoF его также называют **Publish-Subscribe** (Издатель — Подписчик).

### Разница между Push- и Pull-моделями

Когда субъект уведомляет наблюдателей, он должен передать информацию об изменениях. Есть два подхода:

- **Push-модель (Передача данных):**
    
    - Субъект отправляет детальную информацию об изменениях вместе с уведомлением (передает аргументы в метод Update(data)).
        
    - Плюс: Наблюдателю не нужно самому запрашивать данные.
        
    - Минус: Субъект должен знать, какая информация нужна наблюдателям, что немного усиливает связность.
        
- **Pull-модель (Извлечение данных):**
    
    - Субъект только уведомляет наблюдателя: «Я изменился», не передавая конкретных данных.
        
    - Наблюдатель сам обращается к субъекту через публичные методы, чтобы «вытянуть» (pull) нужные ему изменения.
        
    - Плюс: Наблюдатель берет только то, что ему нужно.
        
    - Минус: Наблюдателю нужно знать API субъекта более детально.

### Какие проблемы решает паттерн?

1. **Слабая связность (Low Coupling):** Субъект не знает конкретных классов своих наблюдателей, он знает только то, что они реализуют интерфейс IObserver.
    
2. **Динамическая связь:** Наблюдателей можно добавлять и удалять прямо во время выполнения программы.


### Основные компоненты (по GoF)

Паттерн состоит из 4 ключевых ролей:

#### 1. Subject (Интерфейс или абстрактный класс)

**Его задача:** определить методы Attach() (подписать), Detach() (отписать) и Notify() (оповещать).

```c#
public interface ISubject {
    void Attach(IObserver observer);
    void Detach(IObserver observer);
    void Notify();
}
```
#### 2. ConcreteSubject (Конкретный класс)

**Его задача:** хранить список подписчиков и вызывать у них Update(), когда его внутреннее состояние меняется.

```c#
public class WeatherStation : ISubject {
    private List<IObserver> _observers = new List<IObserver>();
    public float Temperature { get; private set; } // То самое СОСТОЯНИЕ

    public void SetTemperature(float newTemp) {
        Temperature = newTemp;
        Notify(); // Состояние изменилось — оповещаем всех
    }

    public void Attach(IObserver obs) => _observers.Add(obs);
    public void Detach(IObserver obs) => _observers.Remove(obs);
    public void Notify() {
        foreach (var obs in _observers) obs.Update();
    }
}
```

#### 3. Observer (Интерфейс)

**Зачем нужен:** Чтобы Subject мог работать с любым объектом, лишь бы у того был этот метод.

```c#
public interface IObserver {
    void Update(); // Единственный метод, который нужен Издателю
}
```


#### 4. ConcreteObserver (Конкретный класс)

**Его задача:** реализовать метод Update() и как-то отреагировать. Он обычно хранит ссылку на ConcreteSubject, чтобы «подсмотреть» у него новые данные.

```c#
public class PhoneDisplay : IObserver {
    private WeatherStation _station;

    public PhoneDisplay(WeatherStation station) {
        _station = station; // Запоминаем, за кем следим
    }

    public void Update() {
        // Берем данные напрямую у станции (Pull-модель)
        Console.WriteLine($"На экране телефона: {_station.Temperature}°C");
    }
}
```


## Билет 22
Паттерн Фабричный метод (Factory Method). Дайте определение. Объясните понятие "создающий" паттерн и отличие от простого вызова конструктора. В чем ключевое отличие Фабричного метода от Абстрактной фабрики?

### Определение

**Фабричный метод** — это порождающий паттерн проектирования, который определяет интерфейс для создания объекта, но позволяет подклассам решать, объект какого класса будет создан

### Порождающие паттерны (Creational)

Эти паттерны абстрагируют процесс создания объектов. Они помогают сделать систему независимой от того, как создаются, компонуются и представляются её объекты.

> [!tip]
> Простыми словами: Они отвечают на вопрос **«Как создать объект?»**, скрывая логику создания и избавляя от прямой зависимости от оператора new.

**Отличие от простого вызова конструктора (new):**

- **Гибкость:** Конструктор всегда возвращает объект строго определенного класса. Фабричный метод может вернуть любой подтип базового интерфейса
    
- **Инкапсуляция:** Клиент не знает, как именно собирается объект и какой у него конкретный тип. Он работает только с абстракцией.
    
- **Переиспользование:** Фабричный метод может не создавать новый объект каждый раз, а возвращать существующий из кэша (конструктор всегда создает новый).

### Фабричный метод vs Абстрактная фабрика

| Характеристика   | Фабричный метод                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Абстрактная фабрика                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Что создает?** | **Один** продукт.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | **Семейство** связанных продуктов.[[5](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG0B40UZtMFhQfoXYA0Kzdeqojwlq2WAA__7bEJCSUTZFZDAuby-1Pt0IAzgpZ-J-HMnT6Byg9BEy-wzl2HI3ygqFTKrePFqmm-JXC-F5z5vQQp8po5_gqdYyLeMPQqdX3fe0nvGSt_s6mB1q5__h3B)][[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFTKgphsPamgAPh8-l1pt1TArFFxZ2l7w1q3vzdi5yKsZ8s5o-IxH2qjkCaA0elf9GpdXV_L7ck8XDVv_6ClI5aSomouzM38F3IUdVssgUe3KvYzq_Su9-_WzgRt6QVNQG2rNHxt2cWEHsT36MBR64hKW1Xb5NHEN8-jMrdDgYD8xIwcnKQuQ9pLr9f0RNJnE1HSCkUETPSAxuJLqTd9-9thYAQbOo%3D)] |
| **Механизм**     | Основан на **наследовании** (один метод переопределяется в подклассах).[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHFpVWeXgz8j01LXaGfXSN52mTzaMnJvOcKSgAVOLHH-gZaasGf9ZvY4-oJ-dS_9M02OPnC6cMI8c-BE4YUXaloh8nvc9UPRT0-t4J8lghQ1aKqkfHqT2TZr-1PzDyXAd4SrK1ov4tRi1pt6-C35g%3D%3D)][[14](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEetPZxrBIE36pzTVnVA76TQXwCFjFMh_RhNMDW4sJ2SsbJB4iRs5w4fDHH_FpOWOhmUJ-qLJvNJnB-0wzpWfmW5RTT2WKlghkI5075jApS0z1kW_JGDVZydLO2jTZmlfyCFOTikmlBZGz29AvnXRVrNqJAhS6BObWEDvxto8KorYrH-zwyKG3fNtYH)][[17](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHJ3Z_hZoyEcGhGvcT4SypnY41rYye3v7MheCAkwm2EYmDUXK-LYLJLU88rvC4EuoZ57cTtkZMDe945wtaADDpRgHfBeYHh0X0otSn7ltDEg9YgaAOeu2XqNVDTAXCKrgTlZyv_QctU9EhoG-m14vpECbYyam4D2iI7970%3D)] | Основан на **композиции** (целый объект-фабрика передается клиенту).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| **Уровень**      | Реализуется внутри класса самого продукта или его создателя.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Это отдельный объект, чья единственная задача — создавать другие объекты.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
### Пример на C\#

```c#
// 1. Продукт (интерфейс)
public interface ITransport {
    void Deliver();
}

// 2. Конкретные продукты
public class Truck : ITransport {
    public void Deliver() => Console.WriteLine("Доставка по земле в коробке.");
}

public class Ship : ITransport {
    public void Deliver() => Console.WriteLine("Доставка по морю в контейнере.");
}

// 3. Создатель (базовый класс с Фабричным Методом)
public abstract class Logistics {
    // Тот самый Фабричный Метод
    public abstract ITransport CreateTransport();

    public void PlanDelivery() {
        var transport = CreateTransport(); // Работаем с абстракцией
        transport.Deliver();
    }
}

// 4. Конкретные создатели
public class RoadLogistics : Logistics {
    public override ITransport CreateTransport() => new Truck();
}

public class SeaLogistics : Logistics {
    public override ITransport CreateTransport() => new Ship();
}
```


## Билет 23
Паттерн Абстрактная фабрика (Abstract Factory). Определение, назначение. Что такое "семейство продуктов"? Какой принцип SOLID является основой для паттернов Абстрактная фабрика и Фабричный метод? Объясните

### Определение и назначение

**Абстрактная фабрика** — это порождающий паттерн проектирования, который предоставляет интерфейс для создания семейств связанных или зависимых объектов, не специфицируя их конкретных классов.

**Назначение:**

- Обеспечить создание целой группы объектов, которые должны работать вместе.
    
- Изолировать клиента от конкретных классов продуктов.
    
- Гарантировать, что клиент будет использовать объекты только из одного семейства одновременно (например, нельзя смешивать элементы интерфейса macOS и Windows в одном окне).

### Что такое «Семейство продуктов»?

**Семейство продуктов** — это набор различных  объектов предметной области (например, «Кресло», «Диван», «Стол»), которые объединены общим признаком, стилем или платформой.

Например мебельный магазин. У нас есть продукты разных типов:

1. **Типы продуктов:** Стул, Стол.
    
2. **Семейства:** Викторианский стиль, Модерн.
    

- Викторианское семейство: Викторианский Стул + Викторианский Стол.
    
- Модерн семейство: Стул в стиле Модерн + Стол в стиле Модерн.
    

**Задача паттерна** — сделать так, чтобы если клиент выбрал «Модерн», система выдала ему и стул, и стол именно в этом стиле, исключив возможность ошибки (например, выдачи викторианского стула к современному столу).

### Какой принцип SOLID является основой?

#### Принцип открытости/закрытости (Open/Closed Principle - OCP)

- **Почему:** Эти паттерны позволяют расширять систему (добавлять новые типы продуктов или новые семейства), не изменяя существующий код клиента.
    
- **Как это работает:** Чтобы добавить новое семейство (например, «Скандинавский стиль»), вам достаточно создать новый класс конкретной фабрики и реализовать методы создания. Код, который использует фабрику, останется прежним, так как он работает через абстрактный интерфейс.

### Пример структуры на C\#

```c#
// 1. Абстрактные продукты
public interface IChair { void SitOn(); }
public interface ISofa { void LeanOn(); }

// 2. Абстрактная фабрика (Интерфейс для создания СЕМЕЙСТВА)
public interface IFurnitureFactory {
    IChair CreateChair();
    ISofa CreateSofa();
}

// 3. Конкретная фабрика 1 (Семейство Модерн)
public class ModernFactory : IFurnitureFactory {
    public IChair CreateChair() => new ModernChair();
    public ISofa CreateSofa() => new ModernSofa();
}

// 4. Конкретная фабрика 2 (Семейство Викторианское)
public class VictorianFactory : IFurnitureFactory {
    public IChair CreateChair() => new VictorianChair();
    public ISofa CreateSofa() => new VictorianSofa();
}

// Клиентский код
public class Client {
    private readonly IChair _chair;
    public Client(IFurnitureFactory factory) {
        // Мы не знаем, какая именно фабрика пришла, но уверены, 
        // что стул и диван будут из одного семейства.
        _chair = factory.CreateChair(); 
    }
}
```



## Билет 24
Паттерн Декоратор (Decorator). Дайте определение. Чем отличается от наследования? Как реализуется принцип композиции? В чем главный недостаток "классического" Декоратора на многих языках программирования? (Много мелких классов)

### Определение

**Декоратор** **Wrapper (Обертка)****— это структурный паттерн проектирования, который позволяет динамически добавлять объекту новые обязанности. Декораторы представляют собой гибкую альтернативу наследованию для расширения функциональности. Соблюдает **принцип единственной ответственности (SRP)**: каждая обертка делает только свою одну маленькую задачу.

В книге GoF его также называют **Wrapper (Обертка)**


### Чем отличается от наследования?

- **Наследование (статическое расширение):**
    
    - Происходит на этапе компиляции.
        
    - Ведет к «взрывному» росту иерархии классов.
        
    - Нельзя изменить поведение объекта «на лету» во время работы программы.
        
- **Декоратор (динамическое расширение):**
    
    - Происходит во время выполнения (Runtime).
        
    - Позволяет комбинировать обязанности в любом порядке.

### Как реализуется принцип композиции?

Декоратор — это идеальный пример правила **«Предпочитайте композицию наследованию»**

**Механизм реализации:**

1. **Общий интерфейс:** Декоратор реализует тот же интерфейс (или наследует тот же абстрактный класс), что и объект, который он оборачивает. Это позволяет клиенту не замечать разницы между «чистым» объектом и «обернутым».
    
2. **Поле (Композиция):** Внутри декоратора есть ссылка на объект базового типа (интерфейса).
    
3. **Делегирование:** Когда вызывается метод декоратора, он сначала вызывает этот же метод у вложенного объекта, а затем добавляет свою логику (до или после).


#### Пример на C#:

```c#

// 1. Общий интерфейс (Компонент)
public interface INotifier
{
    void Send(string message);
}

// 2. ПАТТЕРН NULL OBJECT
public class NullNotifier : INotifier
{
    public void Send(string message) { /* Ничего не делаем */ }
}

// 3. Базовый класс декоратора
public abstract class NotifierDecorator : INotifier
{
    protected readonly INotifier _wrapped;

    protected NotifierDecorator(INotifier wrapped)
    {
        _wrapped = wrapped;
    }

    public virtual void Send(string message)
    {
        _wrapped.Send(message); // Передаем вызов дальше по цепочке
    }
}

// 4. КОНКРЕТНЫЕ ДЕКОРАТОРЫ (Наши способы связи)

public class SmsDecorator : NotifierDecorator
{
    public SmsDecorator(INotifier wrapped) : base(wrapped) { }

    public override void Send(string message)
    {
        base.Send(message); // Сначала то, что уже было в матрешке
        Console.WriteLine($"[SMS]: {message}"); // Потом добавляем свое
    }
}

public class EmailDecorator : NotifierDecorator
{
    public EmailDecorator(INotifier wrapped) : base(wrapped) { }

    public override void Send(string message)
    {
        base.Send(message);
        Console.WriteLine($"[Email]: {message}");
    }
}
```


### В чем главный недостаток?

Главный минус «классического» Декоратора — **огромное количество мелких классов**.

**Подробности:**

1. **Создание большого количества классов:** Для каждой крошечной функции (добавление сахара, добавление сливок, добавление корицы) нужно создавать отдельный класс. В больших системах это засоряет проект сотнями файлов.
    
2. **Сложность настройки:** Создание объекта превращается в «матрешку»:  
    var order = new Sugar(new Milk(new Cinnamon(new Coffee())));  
    Понять, что там внутри, глядя в дебаггер, бывает очень сложно.
    
3. **Проблема идентификации:** Декоратор и обернутый объект — это разные объекты в памяти. Если ваш код полагается на проверку ссылок (Object.ReferenceEquals), декоратор может нарушить логику.
4. Неудобство Debug'a


## Билет 25
Паттерн Адаптер (Adapter). Определение, сравните с Мостом и Декоратором. Назовите два типа Адаптера (объектный и классовый). Когда использование Адаптера является оправданным, а когда — признаком плохого дизайна системы?
### Определение 

**Адаптер** — это структурный паттерн проектирования, который преобразует интерфейс одного класса в интерфейс, который ожидают клиенты. Адаптер позволяет классам работать вместе, что было бы невозможно из-за несовместимости их интерфейсов.

**Аналогия из жизни:** Переходник для розетки. У вас есть «вилка» европейского стандарта, а «розетка» — американского. Адаптер не меняет напряжение (логику), он просто меняет форму контактов (интерфейс).
### Сравнение с другими паттернами

Паттерны Адаптер, Декоратор и Мост похожи на "обёртку", но имеют существенные отличия:

| Паттерн       | Цель (Для чего?)                                                               | Интерфейс                                        |
| ------------- | ------------------------------------------------------------------------------ | ------------------------------------------------ |
| **Адаптер**   | **Совместимость:** заставить старое/чужое работать в новой системе.            | **Меняет** интерфейс на нужный.                  |
| **Декоратор** | **Расширение:** добавить новую функциональность объекту.                       | **Сохраняет** исходный интерфейс.                |
| **Мост**      | **Разделение:** отделить абстракцию от реализации, чтобы менять их независимо. | Создается **заранее** (на этапе проектирования). |

Главное отличие: Адаптер применяется к **существующему** коду (постфактум), а Мост закладывается в архитектуру **до** написания реализации.
### 3. Два типа Адаптера

В книге GoF описывается два способа реализации:

#### Объектный адаптер (использует композицию) — РЕКОМЕНДУЕТСЯ

Адаптер содержит внутри себя экземпляр адаптируемого класса.

- **Как работает:** Класс-адаптер реализует нужный интерфейс и делегирует вызовы вложенному объекту.
    
- **Плюс:** Может адаптировать не только сам класс, но и любых его наследников.


```c#
// Целевой интерфейс
public interface ITarget { void Request(); }

// Старый класс с несовместимым интерфейсом
public class Adaptee {
    public void SpecificRequest() => Console.WriteLine("Старый код работает!");
}

// Объектный адаптер
public class Adapter : ITarget {
    private readonly Adaptee _adaptee;
    public Adapter(Adaptee adaptee) => _adaptee = adaptee;

    public void Request() => _adaptee.SpecificRequest();
}
```

#### Б) Классовый адаптер (использует наследование)

Адаптер наследуется одновременно и от целевого класса, и от адаптируемого.

- **В C#:** Поскольку множественное наследование классов запрещено, классовый адаптер реализуется через наследование одного класса и реализацию интерфейса.

- **Минус:** Менее гибкий, так как жестко привязан к конкретному классу.


---

### 4. Оправданность использования vs Плохой дизайн

#### Когда использование ОПРАВДАНО:

1. **Интеграция сторонних библиотек:** У вас есть библиотека (например, для работы с JSON), чьи методы не совпадают с вашими интерфейсами.
    
2. **Legacy-код:** Когда нужно использовать старый, проверенный временем класс в новой системе, но менять сам старый класс нельзя (или рискованно).
    
3. **Унификация:** Когда у вас есть несколько разных классов с похожим поведением, и вы хотите работать с ними единообразно через один интерфейс.
    

#### Когда использование — ПРИЗНАК ПЛОХОГО ДИЗАЙНА:

1. **«Заплатка» для своего кода:** Если вы написали два новых модуля в рамках одного проекта, и они не стыкуются — это ошибка проектирования. Нужно провести рефакторинг и привести их к общему интерфейсу, а не плодить адаптеры.
    
2. **Адаптер над адаптером:** Когда система превращается в цепочку «переходников». Это делает код крайне сложным для отладки и понимания.
    
3. **Подмена смысла:** Если вы используете адаптер, чтобы заставить класс делать то, для чего он не предназначен (нарушение семантики).


## Билет 26
Паттерн Фасад (Facade). Определение, цели применения. В чем разница между Фасадом и Адаптером? Нарушает ли Фасад принцип единственной ответственности (SRP)? Почему да или нет?

### Определение и цели применения

**Фасад** — это структурный паттерн проектирования, который предоставляет унифицированный (упрощенный) интерфейс к набору интерфейсов в подсистеме. Фасад определяет интерфейс более высокого уровня, который облегчает использование подсистемы.

**Цели применения:**

1. **Упрощение:** Предоставить клиенту простую «точку входа» в сложную систему из множества классов.
    
2. **Слабая связность (Low Coupling):** Изолировать клиента от деталей реализации сложной подсистемы. Если подсистема изменится, нам нужно будет поправить только Фасад, а не весь клиентский код.

Аналогия: Кнопка "Начать просмотр фильма", когда под капотом приглушается свет, включается телевизор, начинает играть музыка

| Характеристика          | Фасад (Facade)                              | Адаптер (Adapter)                                                     |
| ----------------------- | ------------------------------------------- | --------------------------------------------------------------------- |
| **Основная цель**       | **Упростить** работу с системой.            | Обеспечить **совместимость** интерфейсов.                             |
| **Количество объектов** | Обычно объединяет **целую группу** классов. | Обычно оборачивает **один** конкретный объект.                        |
| **Интерфейс**           | Создает **новый** (упрощенный) интерфейс.   | Реализует **существующий** интерфейс, который ждет клиент.            |
| **Когда использовать?** | Когда система слишком сложная и запутанная. | Когда есть готовый класс, но его методы не подходят под наш стандарт. |
### Нарушает ли Фасад принцип SRP (Single Responsibility Principle)?

**Нет, при правильной реализации**

**Почему НЕТ:**

**Ответственность за оркестрацию:** Ответственность Фасада заключается не в выполнении бизнес-логики, а в **координации** (оркестрации) работы других классов. Его единственная задача — знать, в каком порядке вызвать методы подсистемы.

**Когда МОЖЕТ нарушить:**  
Если вписывать логику прямо в методы Фасада (например, делать там расчеты налогов или валидацию данных). Тогда Фасад превратится в God Object


## Билет 27
Паттерн Одиночка (Singleton). Определение, способы реализации (ленивая, потокобезопасная). Какие проблемы он решает, а какие создает? Почему Одиночку часто называют "антипаттерном"? В каких случаях его использование оправдано?

### Определение

**Одиночка (Singleton)** — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

### Способы реализации в C#

Для реализации Одиночки нужно:

1. Сделать **конструктор приватным**, чтобы нельзя было создать объект через new
2. Создать **статическое поле** для хранения единственного экземпляра.
3. Создать **статическое свойство/метод** для получения этого экземпляра.


### Способы создания в C\#
#### Потокобезопасный с блокировкой (Double-Checked Locking)

Используя объект-заглушку (lock) для синхронизации потоков.

```c#
public sealed class Singleton {
    private static Singleton _instance;
    private static readonly object _syncRoot = new object(); // Объект для синхронизации

    private Singleton() { }

    public static Singleton Instance {
        get {
            if (_instance == null) { // Первая проверка (быстрая, без блокировки)
                lock (_syncRoot) {    // Блокируем вход для других потоков
                    if (_instance == null) { // Вторая проверка (гарантированная)
                        _instance = new Singleton();
                    }
                }
            }
            return _instance;
        }
    }
}
```

### Реализация через Lazy(T) (Современный стандарт)

Начиная с .NET 4.0, появился тип Lazy(T), который инкапсулирует в себе и потокобезопасность, и ленивость.

```c#
public sealed class Singleton {
    // Передаем в конструктор лямбду, которая создаст объект при первом вызове
    private static readonly Lazy<Singleton> _lazy = 
        new Lazy<Singleton>(() => new Singleton());

    private Singleton() { }

    public static Singleton Instance => _lazy.Value;
}
```

**Почему это лучший способ:**

1. **Ленивость:** Объект не создастся, пока вы не обратитесь к _lazy.Value.
    
2. **Потокобезопасность:** Внутри Lazy(T) уже реализован механизм блокировок (аналогичный Double-Check), и он очень надежен.
    
3. **Читаемость:** Код чистый, без лишних if и lock.
### Какие проблемы он решает и создает?

**Решает:**

- **Контроль доступа:** Гарантирует, что к общему ресурсу (БД, файл лога) обращаются через один объект.
- **Экономия ресурсов:** Если объект тяжелый, он создается только один раз.
- **Глобальный доступ:** Удобно обращаться к настройкам или сервисам из любой точки кода.

**Создает:**

- **Скрытые зависимости:** Глядя на сигнатуру метода DoWork(), вы не видите, что он внутри использует Одиночку. Это усложняет чтение кода    
- **Сложность тестирования:** Одиночка хранит состояние между тестами. Если один тест поменял данные в Singleton, второй тест может упасть. Его сложно «подменить» (замокать)    
- **Нарушение SOLID:** Он нарушает **SRP** (класс отвечает и за свою логику, и за свой жизненный цикл).

### Почему Одиночку называют «антипаттерном»?

1. **Глобальное состояние:** Одиночка похож на глобальную переменную доступ к которой возможен из любой точки программы, что нарушает инкапсуляцию
    
2. **Трудностей масштабирования:** Если завтра вам понадобится два подключения к разным БД, переделывать Singleton будет очень больно.
    
3. **Неявное получение зависимостей:** Он поощряет написание кода, который зависит от «магического» глобального объекта, вместо того чтобы получать зависимости через конструктор

### В каких случаях использование оправдано?

- **Логирование:** Один файл лога, в который все пишут.
    
- **Работа с оборудованием:** Например, доступ к драйверу принтера или видеокарты.
    
- **Кэш данных:** Единое хранилище кэша для всего приложения.
    
- **Пул соединений:** Менеджер, распределяющий подключения к БД.

Одиночку лучше реализовывать через **Dependency Injection (DI)**. В .NET Core можно зарегистрировать сервис как Singleton, и контейнер сам проследит, чтобы экземпляр был один, при этом класс останется «чистым» (без статических полей и приватных конструкторов).


## Билет 28
Паттерн Команда (Command). Определение, структура (Invoker, Command, Receiver). В чем преимущество отделения инициатора операции от ее исполнителя? Как паттерн Команда связан с возможностью реализации отмены/повтора операций (Undo/Redo)?

### Определение

**Команда** — это поведенческий паттерн проектирования, который превращает запрос в самостоятельный объект, содержащий всю информацию о запросе.

### Структура паттерна

1. **Command (Интерфейс команды):**  
    Определяет интерфейс для выполнения операции. Например метод Execute().
2. **ConcreteCommand (Конкретная команда):**  
    Реализует метод Execute(), вызывая соответствующие операции у Получателя.
3. **Receiver (Исполнитель):**  
    Класс, который содержит реальную бизнес-логику. Он знает, **как** выполнить работу.
4. **Invoker (Инициатор / Вызыватель):**  
    Отвечает за запуск команды. Он хранит команду и вызывает её метод Execute(). Он не знает, что именно делает команда и кто её выполняет.
5. **Client (Клиент):**  
    Создает объект конкретной команды и назначает ей получателя.


### Реализация Отмены (Undo) и Повтора (Redo)

Паттерн Команда — это классический способ реализации «отмены».

**Как это работает:**

1. **Интерфейс:** В интерфейс ICommand добавляется метод Unexecute() (или Undo()).
    
2. **Состояние:** Конкретная команда перед выполнением сохраняет состояние Получателя (или обратную операцию). Например, если команда — «Прибавить 10», то Undo будет «Вычесть 10».
    
3. **Стек истории:** Приложение хранит список (стек) выполненных объектов-команд.
    
    - **Undo:** Мы берем последнюю команду из стека и вызываем у неё Undo().
        
    - **Redo:** Мы берем команду из стека отмененных и снова вызываем Execute().

### Пример на C# (Текстовый редактор)

```c#
// 1. Receiver
public class Document {
    public string Text { get; set; } = "";
    public void Insert(string text) => Text += text;
    public void DeleteLast(int length) => Text = Text.Substring(0, Text.Length - length);
}

// 2. Interface
public interface ICommand {
    void Execute();
    void Undo();
}

// 3. ConcreteCommand
public class InsertTextCommand : ICommand {
    private Document _doc;
    private string _text;

    public InsertTextCommand(Document doc, string text) {
        _doc = doc;
        _text = text;
    }

    public void Execute() => _doc.Insert(_text);
    public void Undo() => _doc.DeleteLast(_text.Length);
}

// 4. Invoker (хранит историю)
public class CommandManager {
    private Stack<ICommand> _history = new Stack<ICommand>();

    public void Execute(ICommand cmd) {
        cmd.Execute();
        _history.Push(cmd);
    }

    public void Undo() {
        if (_history.Count > 0) _history.Pop().Undo();
    }
}
```


## Билет 29
Паттерн Строитель (Builder). Определение, сравнение с Фабрикой. Зачем нужен отдельный Director? В чем разница между Строителем (Builder) и паттерном "[Телескопический конструктор](https://ru.stackoverflow.com/questions/1292339/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D1%82%D0%B5%D0%BB%D0%B5%D1%81%D0%BA%D0%BE%D0%BF%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80)"?

### Определение

**Строитель** — это порождающий паттерн проектирования, который отделяет конструирование сложного объекта от его представления

**Главная идея:** Если объект слишком сложен и его создание требует множества этапов, мы не пишем гигантский конструктор, а поручаем создание отдельному объекту-строителю.

---

### Сравнение со «Стратегией» и «Фабриками»

| Характеристика        | Фабрики (Метод / Абстрактная)                | Строитель (Builder)                                |
| --------------------- | -------------------------------------------- | -------------------------------------------------- |
| **Сложность объекта** | Создают простые объекты или семейства.       | Создает **сложные** составные объекты.             |
| **Процесс**           | Объект возвращается **сразу** за один вызов. | Объект создается **пошагово** под контролем.       |
| **Результат**         | Клиент получает готовый продукт сразу.       | Клиент забирает продукт в самом конце (GetResult). |
| **Акцент**            | Акцент на том, **какой** объект создать.     | Акцент на том, **как** собрать объект.             |

### Director (Распорядитель?

- **Его задача:** Он определяет **порядок (алгоритм)** вызова шагов строительства.
    
- **Зачем он нужен:**
    
    1. Он инкапсулирует логику того, в какой последовательности нужно «собирать» объект. Например, нельзя ставить крышу, пока не готов фундамент.
        
    2. Он позволяет полностью скрыть от клиента детали сборки. Клиент просто говорит: «Директор, собери мне спортивный автомобиль», и Директор дает команды Строителю.
        
    3. Один и тот же Директор может использовать разные Строители (например, один для деревянных домов, другой для кирпичных), сохраняя порядок шагов.
        

### Строитель vs «Телескопический конструктор»

Это практическая причина, по которой Строитель так популярен в C#.

**Телескопический конструктор** — это антипаттерн, когда в классе создается десяток конструкторов с разным набором параметров:

```c#
public Pizza(int size) { ... }
public Pizza(int size, bool cheese) { ... }
public Pizza(int size, bool cheese, bool bacon) { ... }
// И так далее...
```

**Проблемы телескопа:**

1. **Нечитаемость:** Когда вы видите new Pizza(30, true, false, true, false), непонятно, что значит каждый true.
    
2. **Негибкость:** Если добавить еще 5 ингредиентов, количество конструкторов станет неуправляемым.

**Решение Строителя:**  
Он превращает это в цепочку понятных вызовов (Fluent Interface):

```c
var pizza = new PizzaBuilder()
    .SetSize(30)
    .AddCheese()
    .AddBacon()
    .Build();
```


## Билет 30
Паттерн Прототип (Prototype). Определение. Что такое "глубокое" и "поверхностное" копирование? Когда необходимо каждое из них?

### Определение (по GoF)

**Прототип** — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации. Паттерн задает интерфейс для клонированием объектом самого себя

**Зачем он нужен?**

1. **Снижение затрат на создание:** Если создание объекта «с нуля» слишком дорогое (например, требует тяжелых запросов к БД или сложных вычислений), проще скопировать уже готовый объект и немного его подправить.
    
2. **Клонирование сложных структур:** Когда объект состоит из множества вложенных подобъектов, Прототип позволяет сделать его точную копию одной командой.

### Поверхностное и глубокое копирование

#### А) Поверхностное копирование

- **Что происходит:** Копируются только значения полей самого объекта.
    
- **Типы данных:**
    
    - **Value types** (int, double, struct) копируются полностью
    - **Reference types** (классы, массивы) копируются **только по ссылке**.
        
- **Результат:** Оригинал и клон будут ссылаться на **одни и те же** вложенные объекты. Если вы измените адрес в клоне, он изменится и в оригинале.
    
- **Реализация в C#:** Через встроенный защищенный метод MemberwiseClone().
    

#### Б) Глубокое копирование (Deep Copy)

- **Что происходит:** Рекурсивно копируется не только сам объект, но и все объекты, на которые он ссылается, а также объекты, на которые ссылаются они, и так далее
    
- **Результат:** Оригинал и клон становятся **полностью независимыми**. Любые изменения в «глубине» одного объекта никак не отразятся на другом.
    
- **Реализация в C#:** Стандартного метода нет. Реализуется вручную (перебором полей), через конструкторы копирования или через сериализацию (превращение объекта в поток байтов и обратно).

### Когда необходимо каждое из них?

| Тип копирования   | Когда использовать?                                                                                                                                                                                                                         |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Поверхностное** | 1. Когда объект содержит только простые типы (числа, строки). <br>2. Когда вложенные объекты являются **неизменяемыми (immutable)** — например, string. <br>3. Когда вы специально хотите, чтобы несколько клонов делили один общий ресурс. |
| **Глубокое**      | 1. Когда вложенные объекты **изменяемы** и каждый клон должен работать со своей версией (например, список товаров в корзине). <br>2. Когда важно обеспечить полную изоляцию объектов друг от друга.                                         |

## Билет 31
Паттерн Мост (Bridge). Определение. Объясните разделение "абстракции" и "реализации" на примере. Как Мост помогает следовать принципу открытости/закрытости (OCP)? В чем отличие Моста от Стратегии?

### Определение

**Мост** — это структурный паттерн проектирования, который разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо друг от друга.

**Зачем он нужен?**  
Обычно, когда класс может иметь несколько вариантов реализации, мы используем наследование. Но это ведет к «взрывному» росту иерархии. Мост заменяет наследование **композицией**, разделяя одну огромную иерархию на две независимые.

### Разделение «Абстракции» и «Реализации» на примере

- **Абстракция (Abstraction):** Это интерфейс управления (высокий уровень). Например, кнопки на пульте: «Вкл/Выкл», «Громкость». Пульты бывают разные: обычные и продвинутые (с кнопкой Mute).

- **Реализация (Implementation):** Это конкретные железки (низкий уровень). Например, телевизоры Sony, Samsung, LG. У каждого свои команды для включения или смены звука.


**Без Моста (Проблема):**  
Пришлось бы создавать
SonyBasicRemote SonyAdvancedRemote
SamsungBasicRemoteSamsungAdvancedRemote
и так далее.

**С Мостом (Решение):**  
Мы создаем две иерархии:
1. **Пульты (Абстракция):** BasicRemote, AdvancedRemote.
2. **Телевизоры (Реализация):** ITv (интерфейс) и классы SonyTv, SamsungTv.
Пульт **содержит ссылку** на интерфейс ITv. Это и есть «Мост».
### Как Мост помогает следовать OCP?

1. **Открыто для расширения:** Мы можем добавлять новые устройства (реализации), например LGTv, не меняя код пультов. Мы также можем добавлять новые пульты (абстракции), например VoiceRemote, не меняя код телевизоров.

2. **Закрыто для модификации:** Существующие классы не меняются при добавлении новых типов в любую из двух иерархий.

### В чем отличие Моста от Стратегии?

Внешне оба используют композицию (один объект содержит другой). Разница в **намерении**:

| Характеристика  | Мост (Bridge)                                                               | Стратегия (Strategy)                                                |
| --------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| **Категория**   | **Структурный** паттерн.                                                    | **Поведенческий** паттерн.                                          |
| **Цель**        | Разделить сложную иерархию классов, чтобы избежать «комбинаторного взрыва». | Позволить менять **алгоритм** внутри объекта на лету.               |
| **Связь**       | Абстракция и Реализация рассматриваются как **две части одного целого**.    | Стратегия — это просто **сменный инструмент** для объекта.          |
| **Время жизни** | Обычно связь устанавливается при создании и редко меняется.                 | Подразумевает частую смену поведения во время выполнения программы. |

## Билет 32
Паттерн Заместитель (Proxy). Определение, назовите основные виды (виртуальный, защищающий, логирующий, удаленный и др.). Чем отличается Заместитель от Декоратора по цели применения?

### Определение (по GoF)

**Заместитель (Proxy)** — это структурный паттерн проектирования, который предоставляет объект-суррогат или заполнитель для другого объекта, чтобы контролировать доступ к нему.

**Суть паттерна:** Заместитель имеет тот же интерфейс, что и реальный объект. Клиент взаимодействует с Заместителем, думая, что работает с оригиналом, в то время как Заместитель выполняет вспомогательную работу (проверку прав, загрузку данных и т.д.) и только потом (если нужно) перенаправляет вызов реальному объекту.

### Основные виды Заместителей

В зависимости от задачи, которую решает паттерн, выделяют следующие виды:

1. **Виртуальный заместитель (Virtual Proxy):**
    
    - **Зачем:** Используется для «ленивой загрузки» тяжелых объектов. Реальный объект создается только тогда, когда к нему происходит первое реальное обращение.
        
    - Пример: Загрузка большой картинки или тяжелого отчета из базы данных.
        
2. **Защищающий заместитель (Protection Proxy):**
    
    - **Зачем:** Контролирует доступ к объекту, проверяя права пользователя.
        
    - Пример: Объект «Документ», методы которого (чтение/запись) прокси проверяет на соответствие роли текущего пользователя.
        
3. **Логирующий заместитель (Logging Proxy):**
    
    - **Зачем:** Сохраняет историю (логи) обращений к методам реального объекта.
        
    - Пример: Протоколирование всех запросов к сервису оплаты.
        
4. **Удаленный заместитель (Remote Proxy):**
    
    - **Зачем:** Представляет объект, находящийся в другом адресном пространстве (на другом сервере или в другом процессе). Прокси берет на себя всю сложность работы с сетью.
        
    - Пример: Клиентский код в gRPC или веб-сервисах.
        
5. **Кэширующий заместитель (Caching Proxy):**
    
    - **Зачем:** Сохраняет результаты тяжелых вычислений и отдает их при повторных запросах с теми же параметрами.

### Сравнение: Заместитель vs Декоратор

Эти паттерны имеют почти идентичную структуру (оба оборачивают объект и реализуют тот же интерфейс), но они кардинально различаются по **цели применения (Intent)**:

| Характеристика            | Заместитель (Proxy)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Декоратор (Decorator)                                       |
| ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| **Основная цель**         | **Контроль доступа** и управление жизненным циклом объекта.[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQH28_zyVsQBRAYJSJsgAYgS71cQgre0RzpzLKd0ONpUsTLCrj13C9vjw7QZAXskhTVBUF48C8F1BmSt0IFXFmxBxN5YxvsQoEBaWQcUzOiSt0PmQ1PcPzX-UXghujwCVVcvzldaLutVj813Bx8%3D)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQH5T9bfuya4ANK2ZM87DlZzfzUPLfsx6tgxMD8IkyWRdO-8qH-7nL3G0YReI5PQXH7oLGQ6AZUMcs81Fue6YMnlUCfu85-fPZmDF1XLmCjQZM-oXG6wZTKbCFtZ0yssAxIjJmv_e_0%3D)][[5](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQG2L-71-NObgx31iyMNxFS4rLWwgRSkB-of4ZXtSOViB9ozWj0sCEi2aGCv2xnOxP7Gh5kbHnafVQMcrXNeGLDjQg78g3oTi9y1ZPyUWd5f4ZZ5_dMH3-Hb1Z8RHqHKiD6_l41I34Y%3D)][[8](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHRze27sbYnf7LloAKsXq3BTfTnvt-dK4urtgWdHqUAgyl-QV8G3WtPU1NfqWHNcdwmSquyiKjGwT7c4G27m5rb7vXs-TmezmAbW6LmJlvbo9CL_QvBdHSaBW56ZCKEfHf_BkUq6olqkMc0yw-cZ44d5VIj4lZhJ4IqjLaT3HQemki-a8RNkUsZTlzAxcdIHKExSwWyK53c5h5MV4U_C5c%3D)][[9](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFcgriPzpcZjZ850qEa20C1csoHVVqKmkYzF58qXOW-E5SAwQwpo8owJG-DnqT78PmeGTgAcUA-2PSzieTjxB6HbDUd1Pd0UVL0x6EVD8NQ6O7lD_Vc_OF1pqeQa-GM7Db8POE7tgUUwLpkVFxg2xeq7oIP5GxVTwW6b_uQ3QZSrBMj-vqVhILfxrmmXx5t5cIIJQDsKZCvmTEIAsvJJyWan37i3PMz4fO_P-gdbDecSm6z77qPNHjaXTdjI-ksXE5vmyPGzBYPbDiqMsnGCS0rnDwvNW4vmJX2rgxVfAd5j2F89XaR4cUb1ECS96K3U9NIsTjWnylnLJMp60NvZVIQ0SEOUuqpfXTXclusHSAPMhmj26jq-DHX)][[10](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFdQewKl1JvMr_UKD7i_cSBhL6fVJS__X5LbKjCeeMfq-a2DXW0bHowNCYXjXum3gYFUTXd-Ec8NSnS8RrXDf9y5L6mwYY4YA6nRIT-um-Ziir9rZSvUfozZxpHNDgWQ6rh4r5Tut8MrszQdLefyq29LKq-GtVBBD3jEqw89ESb23V2B2XTPnusnosF5UWCcJ5fHy6uK6x5)] | **Добавление обязанностей** и расширение функционала.       |
| **Отношение к объекту**   | Обычно **сам управляет** созданием и удалением реального объекта.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Получает уже готовый объект от клиента (агрегация).         |
| **Видимость для клиента** | Стремится быть **незаметным** (клиент не должен знать, что работает с прокси).[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQH28_zyVsQBRAYJSJsgAYgS71cQgre0RzpzLKd0ONpUsTLCrj13C9vjw7QZAXskhTVBUF48C8F1BmSt0IFXFmxBxN5YxvsQoEBaWQcUzOiSt0PmQ1PcPzX-UXghujwCVVcvzldaLutVj813Bx8%3D)]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Клиент обычно сам собирает цепочку декораторов, зная о них. |
| **Изменение поведения**   | Почти не меняет бизнес-логику, только условия её вызова.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Напрямую дополняет бизнес-логику новыми действиями.         |

**Цитата из GoF:**

> «Декоратор добавляет объекту новые обязанности, а Заместитель контролирует доступ к нему».
## Билет 33
Паттерны Состояние (State) и Стратегия (Strategy). Дайте определения. В чем ключевое различие в их назначении, несмотря на схожую структуру? Может ли объект класса Состояние хранить ссылку на контекст (Context)? Зачем это нужно?

### Определения (по GoF)

- **Стратегия (Strategy)** — это поведенческий паттерн проектирования, который определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Стратегия позволяет выбирать и менять алгоритм независимо от клиентов, которые его используют.
  
- **Состояние (State)** — это поведенческий паттерн проектирования, который позволяет объекту варьировать свое поведение в зависимости от внутреннего состояния. Извне создается впечатление, что объект изменил свой класс.

### Ключевое различие в назначении

Несмотря на то, что оба паттерна используют **композицию** (Контекст содержит ссылку на объект-интерфейс и делегирует ему работу), их цели и логика использования различаются:


| Характеристика      | Стратегия (Strategy)                                                   | Состояние (State)                                                                |
| ------------------- | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| **Цель**            | **Как сделать?** Выбор конкретного способа решения задачи (алгоритма). | **В каком я режиме?** Изменение поведения в ответ на внутренние изменения.       |
| **Кто выбирает?**   | **Клиент** обычно сам устанавливает нужную стратегию в контекст.       | **Сами состояния** или Контекст управляют переходами автоматически.              |
| **Знание о других** | Стратегии обычно **не знают** о существовании друг друга.              | Состояния часто **знают** друг о друге, так как инициируют переходы к «соседям». |
| **Смена**           | Обычно устанавливается один раз или меняется редко по команде извне.   | Меняется постоянно в процессе жизненного цикла объекта (как автомат).            |

**Пример для Стратегии:** Выбор способа оплаты в корзине (Карта, PayPal, Крипта). Вы сами выбираете «инструмент».  
**Пример для Состояния:** Кнопка плеера «Play». Если песня играет — она работает как «Pause», если на паузе — как «Play». Поведение кнопки зависит от того, в каком состоянии сейчас плеер.

В паттерне Состояние переходы между состояниями (например, из Draft в Published) обычно инициируются **самими объектами состояний**. Чтобы сменить состояние всего Контекста, объект состояния должен иметь возможность вызвать у него метод вроде SetState()


## Билет 34
Паттерн Итератор (Iterator). Определение. Как он связан с принципом единственной ответственности? Что такое "внутренний" и "внешний" итератор? Почему в современных языках паттерн Итератор часто реализуется на уровне языка (ключевые слова foreach, yield, интерфейсы Iterable)?

### Определение

**Итератор** — это поведенческий паттерн проектирования, который дает возможность последовательно обходить элементы составного объекта (коллекции), не раскрывая его внутреннее представление (структуру данных).

**Главная идея:** Скрыть от клиента то, как именно хранятся данные (в массиве, связном списке или дереве) и предоставить единый стандартный способ их перебора.

### 2. Связь с принципом единственной ответственности (SRP)

Паттерн Итератор — это чистая реализация **SRP**:

- **Ответственность коллекции:** Эффективное хранение данных и управление ими (добавление, удаление).

- **Ответственность итератора:** Навигация по коллекции и отслеживание текущей позиции обхода.

Если бы мы поместили логику обхода в саму коллекцию, она бы нарушила SRP, так как у нее появилось бы две причины для изменения. 

### 3. «Внутренний» и «Внешний» итератор

В зависимости от того, кто управляет процессом обхода, итераторы делятся на два типа:

#### А) Внешний итератор — Стандарт C\#

Процессом обхода управляет **клиент**. Клиент сам запрашивает следующий элемент и сам решает, когда остановиться.

- **Пример в C#:** Интерфейс IEnumerator с методами MoveNext() и свойством Current.

- **Плюс:** Гибкость. Можно остановиться на полпути, пропустить элементы или передать итератор в другой метод.


#### Б) Внутренний итератор (Internal Iterator)

Процессом обхода управляет **сама коллекция**. Клиент лишь передает действие (лямбда-выражение или делегат), которое нужно применить к каждому элементу.

- **Пример в C#:** Метод List.ForEach(x => Console.WriteLine(x)).

- **Плюс:** Код клиента выглядит чище и проще.

### Реализация на уровне языка

В современных языках (C#, Java, Python) паттерн стал настолько фундаментальным, что его вшили в синтаксис.

**Механизмы в C#:**

- **Интерфейсы IEnumerable / IEnumerator:** Стандартные контракты паттерна.
   
- **Цикл foreach:** Это «синтаксический сахар». Компилятор превращает его в вызов методов GetEnumerator(), MoveNext() и Current

- **Ключевое слово yield:** При его использовании, компилятор **автоматически генерирует класс-итератор**. Это позволяет писать логику перебора так, будто это обычный линейный список, даже если данные генерируются «на лету» или читаются из сети.


## Билет 35
Паттерн Цепочка обязанностей (Chain of Responsibility). Определение. Приведите пример из реальной жизни (не IT). Чем Цепочка обязанностей отличается от обычного последовательного вызова обработчиков в цикле?


### Определение 

**Цепочка обязанностей** — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке потенциальных обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

**Основная цель:** Избежать жесткой привязки отправителя запроса к его получателю, давая возможность нескольким объектам обработать запрос.

### Пример из реальной жизни

Самый наглядный пример — **система технической поддержки** или **многоуровневая бюрократия**.

Например звонок в какой-нибудь МТС

1. **Уровень 1 (Автоответчик/Робот):** Предлагает стандартные решения (перезагрузите роутер). Если проблема не решена, он «передает» тебя дальше.
    
2. **Уровень 2 (Оператор первой линии):** Проверяет базовые настройки и баланс счета. Если проблема сложнее (например, обрыв кабеля в подъезде), он переводит звонок на технического специалиста.
    
3. **Уровень 3 (Инженер):** Выполняет глубокую диагностику. Если проблема на магистрали, запрос идет к ремонтной бригаде.
    

**Суть:** в том, что клиент не знает заранее, кто именно решит вопрос. Просто запускаем систему и «запрос» движется по цепочке, пока не найдется компетентный сотрудник.
### Отличие от обычного последовательного вызова в цикле

| Характеристика      | Цепочка обязанностей (Chain)                                                                                                                                                                                                                                                                                                                                                               | Цикл (Foreach / Pipeline)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Структура**       | **Связанный список:** Каждый обработчик сам хранит ссылку на «следующего».                                                                                                                                                                                                                                                                                                                 | **Коллекция:** Обработчики хранятся в массиве/списке, ими управляет внешний код.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| **Логика перехода** | **Внутри обработчика:** Сам объект решает, передавать ли запрос дальше, кому именно и в какой момент (до или после своей работы).                                                                                                                                                                                                                                                          | **Вне обработчика:** Логика перебора зашита в вызывающем коде.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **Гибкость**        | **Динамическая:** Цепочку можно перестраивать на лету, просто меняя ссылки Successor у объектов.                                                                                                                                                                                                                                                                                           | **Статическая:** Обычно список задается один раз при инициализации.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| **Завершение**      | Подразумевает, что **один** (первый подошедший) объект обработает запрос и остановит цепь.[[3](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbkBhkfF_5DIqCUVC8iNlXWLLNXgTZy7uniqmfrXWp8RnIbBYeCAtEqbOyo0yVVade4T3c5TXPOueeH8hNdW0zEvkPR5818KBauy0bZIL-X7wTBd56ibmA97QSFeK22MO7zSTfvAEXSvEyWQkfKTgfOfmEaiTgxoKr8nw%3D)] | Обычно подразумевает, что **все** объекты в списке должны по очереди выполнить свою часть работы.[[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGoJPOcRexL5s7Rv5xIDG9mULkS-piFVpje515v6Qcki_3bHukBAEneeJHiGaYXgdF4FGcjKgDgmjUctGi5KGuD5HMvN0Q2S4UI4s0Rq7ZBaXsQM0NBadFc7dB4Wmcq_2yxTm-ciex_t8W7OXqAyHTLTXg07yuKxBfGgehKJ979l6LEX2ooZFRENvsxmfXWd_GA-9DgKPfbrFrIe8Q9WgMhg8jKV4YQjxENRlhEwm0nsGYXMNyI-tEUHKoGR-31iuGpZ1E%3D)][[5](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQE-oHh8b4ob_aW9o6WVy4cFMhfq-HQTuTcRKyZPuPLuNv5afDkP02OPsJqH0tQL1b0qPD-KFnfpQtGKYGt82maIheczCYnIc8hx1PBJpm7CfXA8K8GvScHC6fMR_VW1RLvJI8nuqCLPfeh3ETl6j6uL6Hx6PoNiCqKlysIcBA8hQ1Ti8eCil_9XZlA2mLbnHH6e4MLM83uN6kdxbgRnUut9TJJnKcKXZ1KYFUS1zd07NDpkkxKk3g%3D%3D)] |



## Билет 36
Сравнительный анализ. Сравните паттерны Адаптер, Мост, Декоратор, Заместитель. Укажите основную цель каждого. Как знание паттернов помогает при рефакторинге "запахов кода" (code smells)? Приведите пример (например, "Длинный метод" -> Стратегия или Шаблонный метод).

### Сравнение структурных паттернов (GoF)

Все эти четыре паттерна используют композицию (один объект содержит ссылку на другой), но решают разные задачи:


| Паттерн                   | Основная цель (Intent) | Краткая суть                                                                                            |
| ------------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------- |
| **Адаптер (Adapter)**     | **Совместимость**      | Преобразует интерфейс старого/чужого класса в тот, который ожидает клиент. «Переходник».                |
| **Мост (Bridge)**         | **Разделение**         | Разделяет абстракцию и реализацию на две независимые иерархии. Борется с комбинаторным взрывом классов. |
| **Декоратор (Decorator)** | **Расширение**         | Динамически добавляет объекту новые обязанности «на лету», не меняя его код и интерфейс.                |
| **Заместитель (Proxy)**   | **Контроль**           | Подменяет собой реальный объект, чтобы контролировать доступ к нему (ленивая загрузка, права, логи).    |


### 2. Паттерны и «запахи кода» (Code Smells)

**«Запахи кода»** — это признаки того, что в архитектуре программы есть проблемы, которые могут привести к багам или затруднить развитие. Паттерны проектирования являются **целями рефакторинга**: мы меняем плохую структуру на проверенную временем шаблонную структуру.

**Как паттерны помогают:**

1. **Снижают связность (Coupling):** Заменяют зависимости от конкретных классов зависимостями от интерфейсов.
    
2. **Повышают связность (Cohesion):** Распределяют обязанности так, чтобы каждый класс делал только одну задачу (SRP).
    
3. **Устраняют дублирование:** Выносят общую логику в базовые классы или стратегии.


### 3. Примеры рефакторинга «запах -> паттерн»

#### А) Запах: Длинный метод (Long Method) или Ветвистые условные операторы (Switch Statements)

- **Проблема:** Метод на 500 строк с огромным switch, который выбирает способ расчета в зависимости от типа данных.
    
- **Решение — паттерн Стратегия (Strategy):** Каждый вариант из switch выносится в отдельный класс-стратегию. Основной метод становится коротким и просто вызывает strategy.Calculate().
    
- **Результат:** Соблюдается принцип **OCP** (добавляем новые расчеты, не меняя старый код).
    

#### Б) Запах: Дублирование кода в подклассах

- **Проблема:** Несколько наследников делают почти одно и то же, но с небольшими отличиями в середине процесса.
    
- **Решение — паттерн Шаблонный метод (Template Method):** Общий алгоритм выносится в базовый абстрактный класс, а «вариативные» части помечаются как abstract или virtual и реализуются в потомках.
    
- **Результат:** Устранение дублирования.
    

#### В) Запах: Раздутый класс

- **Проблема:** Один класс меняется каждый раз, когда меняются правила логирования, правила БД и бизнес-логика.
    
- **Решение — паттерн Фасад (Facade) или Состояние (State):**
    
    - Если класс перегружен управлением сложной системой — внедряем **Фасад**.
        
    - Если поведение класса зависит от множества if (status == ...) — внедряем **Состояние**.


## Билет 37
Как паттерны проектирования в целом связаны с принципами SOLID? Являются ли они "рецептами" для следования этим принципам? Что важнее: механическое применение паттернов из каталога или глубокое понимание принципов проектирования (SOLID, GRASP)? Аргументируйте

### Как паттерны связаны с принципами SOLID?

Связь между ними — это связь между **теорией** и **практикой**.

- **SOLID/GRASP** — это фундаментальные законы «здоровой» архитектуры. Это критерии качества: «Код должен быть расширяемым, слабосвязанным и понятным».
    
- **Паттерны проектирования** — это конкретные, проверенные временем архитектурные конструкции, которые **автоматически** реализуют принципы SOLID в конкретных ситуациях.


**Примеры связи:**

- **OCP (Принцип открытости/закрытости):** На нем основаны паттерны **Стратегия**, **Декоратор**, **Фабричный метод**. Они позволяют добавлять функции, не меняя старый код.
    
- **DIP (Инверсия зависимостей):** Лежит в основе **Абстрактной фабрики**, **Моста**, **Заместителя**. Они заставляют код зависеть от интерфейсов, а не от «железа».
    
- **SRP (Единственная ответственность):** Явно виден в **Команде** (отделение вызова от логики) и **Итераторе** (отделение обхода от хранения).


### Являются ли паттерны «рецептами» для SOLID?

**Да, но с большой оговоркой.**

Паттерны можно назвать «типовыми решениями». Если ты видишь, что твой код нарушает SOLID (например, один класс делает слишком много), ты открываешь каталог паттернов и находишь «рецепт» (например, Цепочку обязанностей), который поможет разбить этот класс на части, соблюдая принципы.

Однако паттерны — это **не догма**. В отличие от кулинарного рецепта, паттерн почти всегда нужно адаптировать под конкретный язык программирования и бизнес-задачу.

### Что важнее: механическое применение или понимание принципов?

**Аргументация в пользу Глубокого Понимания Принципов:**

Безусловно, **глубокое понимание принципов важнее**. Вот 4 причины, почему механическое заучивание каталога GoF может быть вредным:

1. **Проблема «Золотого молотка» (Patternitis):**  
    Разработчик, знающий паттерны механически, начинает видеть их везде. Он может внедрить сложный «Посетитель» там, где хватило бы простого if. Это приводит к **over-engineering** (избыточному усложнению), когда код становится невозможно читать.
    
2. **Контекст важнее шаблона:**  
    Принципы SOLID универсальны. Паттерны — нет. Например, с появлением лямбда-выражений в C# паттерн «Стратегия» часто превращается в передачу одной функции, и городить иерархию классов (как в книге 1994 года) уже не нужно. Зная принцип, ты упростишь решение. Зная только паттерн — создашь лишнюю сущность.
    
3. **Эволюция языков:**  
    Многие паттерны прошлого сегодня встроены в языки (как Итератор в C# через yield). Если ты понимаешь принципы, ты поймешь, почему язык устроен так. Если ты знаешь только паттерн, ты будешь пытаться «изобретать велосипед» вручную.

## Связь паттернов с SOLID

| Принцип | Проблема                                                   | Паттерны, которые помогают                                         |
| ------- | ---------------------------------------------------------- | ------------------------------------------------------------------ |
| **SRP** | Класс берёт на себя слишком много обязанностей             | **Facade**, **Decorator**, **Command**, **Observer**               |
| **OCP** | Изменения требуют правки существующего кода                | **Strategy**, **Template Method**, **Chain of Responsibility**     |
| **LSP** | Наследники нарушают поведение базового класса              | **State**, **Bridge** — позволяют изолировать вариации поведения   |
| **ISP** | Интерфейсы перегружены методами, которые не нужны клиентам | **Adapter**, **Proxy**, **Mediator**                               |
| **DIP** | Класс зависит от конкретных реализаций, а не от абстракций | **Factory Method**, **Abstract Factory**, **Dependency Injection** |
## Билет 38
Какие бывают типы данных в C#, где они хранятся в памяти? Что такое value type, что такое reference type?

В C# все типы данных делятся на две основные группы: **Value Types** (Типы-значения) и **Reference Types** (Ссылочные типы). Все они являются наследниками базового класса System.Object.

### 1. Value Types (Типы-значения)

Эти типы хранят свои данные непосредственно в переменной.

- **Что к ним относится:**
    
    - Простые типы: `int`, `float`, `double`, `decimal`, `bool`, `char`, `byte` и др.
    - Структуры (`struct`): например, `DateTime`, `TimeSpan`, `Color`.
    - Перечисления (`enum`).
        
- **Где хранятся:**
    
    - Хранятся в **Стеке (Stack)**.
    
- **Особенности:**
    
    - При копировании (a = b) создается **полная копия данных**. Изменение a никак не повлияет на b.

### 2. Reference Types (Ссылочные типы)

Переменная этого типа хранит не сами данные, а **адрес (ссылку)** на место в памяти, где лежат данные.

- **Что к ним относится:**
    
    - Классы (class).
    - Интерфейсы (interface).
    - Массивы 
    - Специфические типы: string, object, dynamic.
    
- **Где хранятся:**
    
    - Сами данные (объект) хранятся в **Куче (Heap)**.
    - В **Стеке (Stack)** хранится только адрес (указатель) на этот объект в куче.
    
- **Особенности:**
    
    - При копировании (a = b) копируется **только адрес**. В итоге обе переменные указывают на один и тот же объект в памяти. Изменение через a будет видно через b.
    - Память в Куче очищается автоматически **Сборщиком мусора (Garbage Collector)**.


### Сравнение Стека (Stack) и Кучи (Heap)

| Характеристика  | Стек (Stack)                                                        | Куча (Heap)                                    |
| --------------- | ------------------------------------------------------------------- | ---------------------------------------------- |
| **Тип доступа** | LIFO (Last In, First Out) — очень быстрый.                          | Произвольный доступ — медленнее.               |
| **Размер**      | Ограничен (обычно 1 МБ). При переполнении — StackOverflowException. | Намного больше, ограничен оперативной памятью. |
| **Управление**  | Самоочищается при выходе из метода (области видимости).             | Управляется Garbage Collector (GC).            |


## Билет 39
## Билет 40

Что такое virtual, override приведите пример, когда целесообразно это использовать? В чем минус динамического полиморфизма?

### Что это такое?

- `virtual` (виртуальный метод)** — это ключевое слово, которое ставится в базовом классе, чтобы разрешить наследникам изменять поведение этого метода. Виртуальный метод **обязательно имеет реализацию** по умолчанию.
    
- `override` (переопределение)** — это ключевое слово в производном классе, которое указывает, что этот класс предоставляет свою собственную реализацию метода, помеченного как virtual (или abstract).

**Важное правило:** Чтобы метод можно было переопределить через `override`, в базовом классе он обязательно должен быть помечен как `virtual`, `abstract` или `override`.


### Когда целесообразно это использовать?

1. **Работа с коллекциями разнородных объектов:** Когда у вас есть List(Employee), в котором лежат и обычные сотрудники, и менеджеры, и продавцы. Вы просто пробегаете циклом и вызываете CalculatePay(), а программа сама понимает, какую версию метода вызвать для каждого объекта.

2. **Паттерн «Шаблонный метод» (Template Method):** Когда основной алгоритм описан в базовом классе, но отдельные его шаги (виртуальные методы) могут быть изменены в наследниках.

### В чем минус динамического полиморфизма?

1. **Снижение производительности (V-Table):**  
При вызове обычного метода процессор просто прыгает по известному адресу. При вызове виртуального метода программа должна сначала заглянуть в специальную **таблицу виртуальных методов (V-Table)**, найти там адрес нужной реализации для текущего типа объекта и только потом выполнить его. Это занимает чуть больше времени.

2. **Усложнение отладки и чтения кода:**  
Когда вы смотрите на строку emp.CalculatePay(), вы не всегда сразу понимаете, в какой конкретно класс провалитесь при нажатии F12, если иерархия наследования большая. Это может запутать логику программы.


### Пример реализации

В системе расчёта зарплаты для сотрудников

```c#
public class Employee
{
    public string Name { get; set; }
    public decimal BaseSalary { get; set; }

    // Виртуальный метод: есть базовая логика
    public virtual decimal CalculatePay()
    {
        return BaseSalary;
    }
}

public class SalesPerson : Employee
{
    public decimal Commission { get; set; }

    // Переопределяем метод: добавляем комиссионные к базе
    public override decimal CalculatePay()
    {
        return BaseSalary + Commission;
    }
}
```


## Билет 41
Что такое управляемая куча (managed heap) и стек (stack)? Как в них распределяются value types и reference types?

В .NET память для приложения разделена на две основные структуры: **Стек (Stack)** и **Управляемая куча (Managed Heap)**.

### 1. Стек (Stack)

**Стек** — это область памяти, работающая по принципу **LIFO** (Last In, First Out — «последним пришел, первым ушел»).

- **Управление:** Стек управляется автоматически процессором. Когда метод вызывается, в стеке создается «фрейм» (блок) для его переменных. Когда метод завершается, весь блок памяти мгновенно освобождается.
- **Скорость:** Очень высокая. Доступ к памяти в стеке практически мгновенный.
- **Размер:** Ограничен (по умолчанию 1 МБ на поток). Если вложенность вызовов слишком глубокая (например, бесконечная рекурсия), возникает ошибка StackOverflowException.


### 2. Управляемая куча (Managed Heap)

**Куча** — это большой блок памяти, предназначенный для динамического распределения. Она называется «управляемой», потому что за её очистку отвечает **Garbage Collector (GC)**.

- **Управление:** Память выделяется при создании объекта (оператор new). Очистка происходит не сразу, а когда сборщик мусора решит, что объект больше не используется.
- **Скорость:** Медленнее, чем стек. Выделение памяти требует поиска свободного места, а очистка (GC) — это ресурсозатратный процесс.
- **Размер:** Ограничен только объемом оперативной памяти компьютера.

### 3. Распределение Value и Reference типов

Главное правило в .NET звучит так: **Место хранения зависит не только от типа данных, но и от контекста, в котором объявлена переменная.**

#### А) Value Types (Типы-значения: int, struct, bool и др.)

- **Локальные переменные:** Если вы создали int x = 5 внутри метода, она попадет в **Стек**.
    
- **Поля классов:** Если int x — это поле внутри класса (class User { int x; }), то она будет храниться в **Куче** вместе со всем объектом этого класса.
    
- **Упаковка (Boxing):** Если вы приведете int к типу object, его значение будет скопировано со стека в **Кучу**.
    

#### Б) Reference Types (Ссылочные типы: class, string, массивы)

Здесь всегда задействованы обе области памяти:

1. **В Куче** хранится само «тело» объекта (все его данные).
2. **В Стеке** хранится **ссылка** (адрес) на этот объект в куче.

| Характеристика      | Стек (Stack)                                     | Управляемая куча (Heap)                           |
| ------------------- | ------------------------------------------------ | ------------------------------------------------- |
| **Что хранится**    | Локальные переменные, параметры методов, адреса. | Объекты классов, массивы, данные ссылочных типов. |
| **Value Types**     | Да (если локальные).                             | Да (если это поля класса).                        |
| **Reference Types** | Только ссылка (адрес).                           | Сам объект (данные).                              |
| **Жизненный цикл**  | Пока выполняется метод.                          | Пока есть ссылки на объект + время до очистки GC. |
| **Скорость**        | Очень высокая.                                   | Средняя.                                          |
## Билет 42
Объясните принцип работы сборщика мусора (Garbage Collector) в .NET. Что такое поколения (Generations 0, 1, 2) и зачем они нужны?

### Что такое GC и как он работает?

**Garbage Collector (GC)** — это автоматический менеджер памяти в .NET. Его задача — выделять память для объектов в управляемой куче (Managed Heap) и освобождать её, когда объекты больше не используются.

**Принцип работы (Алгоритм Mark-and-Sweep):**  
Сборка мусора происходит в несколько этапов:

1. **Маркировка (Mark):** GC составляет список всех «живых» объектов. Он начинает с **корней (GC Roots)** — это статические поля, локальные переменные в текущих стеках потоков и регистры процессора. Все объекты, до которых можно «дотянуться» от корней, помечаются как живые.
    
2. **Перемещение (Relocate):** GC обновляет ссылки на объекты, которые будут перемещены в процессе сжатия.
    
3. **Сжатие (Compact):** Неиспользуемые объекты (мусор) удаляются, а «живые» объекты сдвигаются вплотную друг к другу в памяти. Это устраняет фрагментацию и делает выделение памяти для новых объектов очень быстрым (просто сдвиг указателя).


### Поколения объектов (Generations)

Для оптимизации производительности GC в .NET использует **поколения**

- Новые объекты живут недолго (например, локальная переменная внутри метода).
- Старые объекты живут долго (например, кэш или главное окно приложения).

#### Всего в .NET 3 поколения:
#### Поколение 0 (Gen 0)

- **Что там:** Самые «молодые», только что созданные объекты.
    
- **Особенности:** Сборка в 0-м поколении происходит чаще всего. Это очень быстрая операция. Большинство объектов (около 80-90%) «умирают» именно здесь.
#### Поколение 1 (Gen 1)

- **Что там:** Объекты, которые «выжили» после одной сборки мусора в Gen 0.
    
- **Особенности:** Служит буфером между короткоживущими и долгоживущими объектами. Сборка здесь происходит реже, чем в Gen 0.

#### Поколение 2 (Gen 2)

- **Что там:** Долгоживущие объекты (статические данные, крупные долговечные сервисы).
    
- **Особенности:** Сюда попадают объекты, выжившие после сборок в Gen 0 и Gen 1. Сборка мусора в Gen 2 (она же «Full GC») — самая дорогая и долгая операция, так как GC приходится проверять всю кучу.

### Зачем нужны поколения?

Главная цель — **производительность**.

Если бы поколений не было, GC при каждой очистке памяти приходилось бы проверять **все** объекты в приложении. Это бы приводило к огромным паузам когда приложение замирает на секунды.  

>[!Нюанс] 
>**Large Object Heap (LOH)**
> Для полноты ответа стоит упомянуть **LOH**. Объекты размером **более 85 000 байт** (например, огромные массивы) сразу попадают в специальную «кучу больших объектов». LOH технически считается частью **Gen 2**.


## Билет 43
1. Какова структура иерархии исключений в C# (базовый класс Exception)? Что такое SystemException и ApplicationException (и почему последним не рекомендуют пользоваться)?
2. Объясните назначение и правильный порядок использования блоков try, catch, finally. Что такое фильтры исключений (when)?

### 1. Иерархия исключений и классы SystemException / ApplicationException

В .NET все исключения являются объектами классов, которые выстраиваются в четкую иерархию.

**Базовый класс Exception**  
Вершиной всей иерархии является класс System.Exception.
Он содержит основные свойства:

- Message: текстовое описание ошибки.
- StackTrace: строка, описывающая путь вызова методов до места возникновения ошибки.
- InnerException: ссылка на «внутреннее» исключение (если текущее возникло в результате другого).

**Классы SystemException и ApplicationException**  
Изначально Microsoft планировала разделить исключения на две большие ветви

1. **System.SystemException**: базовый класс для всех исключений, генерируемых самой средой исполнения (CLR) или операционной системой
2. **System.ApplicationException**: предполагался как базовый класс для всех исключений, которые создает сам разработчик в своем приложении.

**Почему ApplicationException не рекомендуют использовать?**  
На практике эта задумка провалилась:

- **Путаница**: Сама Microsoft не всегда следовала этому правилу (некоторые системные исключения случайно наследовались от ApplicationException)
- **Отсутствие пользы**: Разделение не дало разработчикам реальных преимуществ при обработке ошибок
- **Современная рекомендация**: В официальных руководствах Microsoft теперь указано, что новые пользовательские исключения следует наследовать напрямую от **System.Exception** (или других подходящих системных классов, например ArgumentException), игнорируя ApplicationException.


---

### 2. Структура try-catch-finally и фильтры исключений

#### Правильный порядок блоков

1. **try**: В этот блок помещается «опасный» код, который может вызвать ошибку
    
2. **catch**: Обработчики ошибок. Их может быть несколько.
    **Важное правило**: Catch-блоки должны идти от **частных к общим**. Сначала ловим FileNotFoundException, затем IOException, и только в самом конце — базовый Exception. Если поставить базовый класс первым, он перехватит всё, и более специфичные блоки никогда не сработают.
    
3. **finally**: Блок для очистки ресурсов (закрытие файлов, соединений с БД).
    **Гарантия исполнения**: Этот блок выполняется **всегда**, вне зависимости от того, возникла ошибка или нет, и был ли выполнен return из блока try или catch. (Единственное исключение — принудительное завершение процесса через Environment.FailFast()).
    

#### Фильтры исключений (when)

Начиная с C# 6.0, в блоке catch можно использовать ключевое слово **when** для уточнения условий перехвата.

**Пример:

```c#
try {
    // Код...
}
catch (HttpException ex) when (ex.StatusCode == 404) {
    // Ловим только 404 ошибку
}
catch (HttpException ex) when (ex.StatusCode == 500) {
    // Ловим только 500 ошибку
}
```

**Преимущества фильтров when перед if внутри catch:**

1. **Состояние стека**: Если фильтр when возвращает false, среда исполнения продолжает искать подходящий catch, **не «разматывая» стек**. Это крайне полезно при отладке, так как вы видите реальное место ошибки в логах.
2. **Чистота кода**: Позволяет избежать громоздких проверок внутри одного общего блока обработки.


## Билет 43.
1. Для чего нужны обобщенные типы (Generics)? В чем их преимущества перед использованием необобщенных коллекций (например, ArrayList) или типа object?
2. Что такое ограничения (constraints) для generic-параметров (where T : ...)? Перечислите и приведите примеры основных видов ограничений.

### Для чего нужны обобщенные типы (Generics)?

**Обобщения (Generics)** позволяют определять классы, методы, интерфейсы или делегаты с «метками-заполнителями» (параметрами типа) вместо указания конкретных типов данных. Реальный тип данных указывается только в момент создания объекта или вызова метода.

#### Преимущества перед необобщенными коллекциями (ArrayList) и типом object:

1. **Строгая типизация (Type Safety):**
    
    - **Generics:** Ошибки несоответствия типов выявляются на этапе **компиляции**. Если вы создали List(int), вы не сможете случайно положить туда строку.
        
    - **ArrayList / object:** Работают с типом object. Ошибка обнаружится только во время **выполнения**, когда вы попытаетесь привести объект к нужному типу.
        
2. **Производительность (Отсутствие Boxing/Unboxing):**
    
    - **Generics:** Для значимых типов (value types, например int) коллекции создают массив именно этого типа. Данные хранятся в стеке или внутри массива напрямую.
        
    - **object:** Каждое добавление int в ArrayList вызывает **Boxing** (упаковку) — копирование значения из стека в кучу. Извлечение требует **Unboxing** (распаковки). Это сильно нагружает процессор и сборщик мусора (GC).
        
3. **Переиспользование кода (Reusability):**
    
    - Вам не нужно писать отдельный класс IntStack и StringStack. Один класс Stack(T) работает со всеми типами одинаково эффективно.

### Сводная таблица ограничений generic-параметров

| Синтаксис               | Название           | Что это значит для типа T                                     |
| ----------------------- | ------------------ | ------------------------------------------------------------- |
| where T : struct        | Значимый тип       | T обязан быть int, bool, struct и т.д. (Value Type).          |
| where T : class         | Ссылочный тип      | T обязан быть классом, интерфейсом или делегатом.             |
| where T : notnull       | Ненуллабельный тип | T не может быть типом, допускающим null (появилось в C# 8.0). |
| where T : new()         | Конструктор        | T обязан иметь публичный конструктор без параметров.          |
| where T : ИмяКласса     | Базовый класс      | T обязан быть этим классом или его наследником.               |
| where T : ИмяИнтерфейса | Интерфейс          | T обязан реализовывать данный интерфейс.                      |
| where T : unmanaged     | Неуправляемый тип  | T должен быть простым типом, не содержащим ссылок внутри.     |


## Билет 44. LINQ
Что такое LINQ? В чем разница между синтаксисом запросов (query syntax) и синтаксисом методов (method syntax)? Приведите примеры


### Что такое LINQ?

**LINQ (Language Integrated Query)** — это встроенный в язык C# мощный механизм запросов к данным из различных источников. Он позволяет использовать единообразный синтаксис для фильтрации, сортировки и преобразования данных, независимо от того, где они хранятся.

**Основные источники данных для LINQ:**

- **LINQ to Objects:** Работа с коллекциями в памяти (List(T), массивы).
- **LINQ to Entities:** Работа с базами данных через Entity Framework.
- **LINQ to XML:** Работа с XML-документами.

**Зачем он нужен?**  
До появления LINQ для фильтрации списка нужно было писать циклы foreach и вложенные if. LINQ заменяет императивный код («как сделать») на декларативный («что я хочу получить»), делая код короче и читабельнее.

### Синтаксис запросов vs Синтаксис методов

В C# существует два способа написания LINQ-запросов. Важно понимать: **функционально они идентичны**. Компилятор всегда превращает «синтаксис запросов» в «синтаксис методов» перед сборкой программы.

#### А) Синтаксис запросов (Query Syntax)

Напоминает SQL. Он декларативен и часто легче читается для людей, имеющих опыт работы с базами данных.

- **Ключевые слова:** from, where, select, orderby, group.

#### Б) Синтаксис методов (Method Syntax / Fluent Syntax)

Использует цепочки расширяющих методов (extension methods) и лямбда-выражения. Он более «родной» для C# и обладает большей мощностью (некоторые операторы, такие как Take, Skip или First, доступны только здесь).

### Примеры

Представим, что у нас есть список имен:  
`string[]names = { "Иван", "Анна", "Алексей", "Борис", "Антон" };  `
Задача: выбрать имена на букву «А», отсортировать их по алфавиту и привести к верхнему регистру.

**Пример 1. Синтаксис запросов:**

```c#
var result = from n in names
             where n.StartsWith("А")
             orderby n
             select n.ToUpper();
```

**Пример 2. Синтаксис методов:**

```c#
var result = names.Where(n => n.StartsWith("А"))
                  .OrderBy(n => n)
                  .Select(n => n.ToUpper());
```


| Характеристика       | Синтаксис запросов                    | Синтаксис методов                            |
| -------------------- | ------------------------------------- | -------------------------------------------- |
| **Внешний вид**      | Похож на SQL.                         | Цепочка вызовов методов.                     |
| **Читаемость**       | Выше при сложных объединениях (Join). | Выше для коротких операций фильтрации.       |
| **Мощность**         | Поддерживает не все операторы.        | **Поддерживает всё** (полный набор методов). |
| **Лямбда-выражения** | Скрыты внутри ключевых слов.          | Используются явно (n => ...).                |