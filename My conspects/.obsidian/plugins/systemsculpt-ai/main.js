/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/core/ui/modals/PopupModal.ts
async function showPopup(app, message, options = {}) {
  const popup = new PopupComponent(app, message, options);
  return popup.open();
}
var import_obsidian, PopupComponent;
var init_PopupModal = __esm({
  "src/core/ui/modals/PopupModal.ts"() {
    import_obsidian = __toModule(require("obsidian"));
    PopupComponent = class {
      constructor(app, message, options = {}) {
        this.result = null;
        this.listeners = [];
        this.app = app;
        this.message = message;
        this.options = options;
      }
      registerListener(element, type, listener) {
        element.addEventListener(type, listener);
        this.listeners.push({ element, type, listener });
      }
      removeAllListeners() {
        this.listeners.forEach(({ element, type, listener }) => {
          element.removeEventListener(type, listener);
        });
        this.listeners = [];
      }
      createPopup() {
        this.containerEl = document.createElement("div");
        this.containerEl.addClass("systemsculpt-popup-container");
        document.body.appendChild(this.containerEl);
        const popupEl = this.containerEl.createDiv({ cls: "systemsculpt-popup" });
        const content = popupEl.createDiv({ cls: "systemsculpt-popup-content" });
        if (this.options.title) {
          const titleEl = content.createDiv({ cls: "systemsculpt-popup-title" });
          if (this.options.icon) {
            const iconEl = titleEl.createSpan({ cls: "systemsculpt-popup-icon" });
            (0, import_obsidian.setIcon)(iconEl, this.options.icon);
          }
          titleEl.createSpan({ text: this.options.title });
        }
        if (this.message) {
          content.createDiv({
            cls: "systemsculpt-popup-message",
            text: this.message
          });
        }
        if (this.options.description) {
          content.createDiv({
            cls: "systemsculpt-popup-description",
            text: this.options.description
          });
        }
        if (this.options.checkboxLabel) {
          const checkboxContainer = content.createDiv({ cls: "systemsculpt-popup-checkbox-container" });
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = "systemsculpt-popup-checkbox";
          const label = document.createElement("label");
          label.htmlFor = "systemsculpt-popup-checkbox";
          label.textContent = this.options.checkboxLabel;
          checkboxContainer.appendChild(checkbox);
          checkboxContainer.appendChild(label);
          this.checkboxEl = checkbox;
        }
        if (this.options.inputs) {
          const inputsContainer = content.createDiv({
            cls: "systemsculpt-popup-inputs"
          });
          this.options.inputs.forEach((input) => {
            if (input.type === "textarea") {
              inputsContainer.createEl("textarea", {
                cls: `systemsculpt-popup-textarea ${input.className || ""}`,
                placeholder: input.placeholder,
                value: input.value || "",
                attr: {
                  required: input.required ? true : null
                }
              });
            } else {
              inputsContainer.createEl("input", {
                type: input.type,
                cls: `systemsculpt-popup-input ${input.className || ""}`,
                placeholder: input.placeholder,
                value: input.value || "",
                attr: {
                  required: input.required ? true : null
                }
              });
            }
          });
        }
        const buttonContainer = popupEl.createDiv({
          cls: "systemsculpt-popup-buttons"
        });
        if (this.options.secondaryButton) {
          const secondaryButton = buttonContainer.createEl("button", {
            cls: "ss-button ss-button--secondary",
            text: this.options.secondaryButton
          });
          this.registerListener(secondaryButton, "click", () => {
            this.result = { confirmed: false };
            this.close();
          });
        }
        const primaryButton = buttonContainer.createEl("button", {
          cls: this.options.primaryButton === "Become A Patron" || this.options.primaryButton === "Become a Patron" ? "ss-button ss-button--primary ss-button--patron mod-cta" : "ss-button ss-button--primary mod-cta",
          text: this.options.primaryButton || "OK"
        });
        if (this.options.primaryButton) {
          primaryButton.setAttribute("data-button-text", this.options.primaryButton);
        }
        this.registerListener(primaryButton, "click", () => {
          var _a, _b, _c, _d;
          if (this.options.inputs) {
            const inputs = Array.from(popupEl.querySelectorAll("input, textarea"));
            const hasEmptyRequired = inputs.some((input) => input.required && !input.value.trim());
            if (hasEmptyRequired) {
              return;
            }
            this.result = {
              confirmed: true,
              inputs: inputs.map((input) => input.value),
              checkboxChecked: (_b = (_a = this.checkboxEl) == null ? void 0 : _a.checked) != null ? _b : false
            };
          } else {
            this.result = {
              confirmed: true,
              checkboxChecked: (_d = (_c = this.checkboxEl) == null ? void 0 : _c.checked) != null ? _d : false
            };
          }
          this.close();
        });
        this.registerListener(this.containerEl, "keydown", (e) => {
          if (e.key === "Escape") {
            this.result = { confirmed: false };
            this.close();
          }
          if (e.key === "Enter" && !e.isComposing && !e.shiftKey) {
            primaryButton.click();
          }
        });
        this.registerListener(this.containerEl, "mousedown", (e) => {
          if (e.target === this.containerEl) {
            this.result = { confirmed: false };
            this.close();
          }
        });
      }
      close() {
        this.containerEl.addClass("systemsculpt-popup-closing");
        setTimeout(() => {
          this.removeAllListeners();
          this.containerEl.remove();
          if (this.resolvePromise) {
            this.resolvePromise(this.result);
          }
        }, 200);
      }
      open() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
          this.createPopup();
        });
      }
    };
  }
});

// src/core/ui/notifications.ts
var notifications_exports = {};
__export(notifications_exports, {
  displayNotice: () => displayNotice,
  initializeNotificationQueue: () => initializeNotificationQueue,
  showAlert: () => showAlert,
  showConfirm: () => showConfirm,
  showNoticeWhenReady: () => showNoticeWhenReady
});
function initializeNotificationQueue(app) {
  app.workspace.onLayoutReady(() => {
    var _a;
    uiReady = true;
    for (const { message, options } of pendingNotices) {
      new import_obsidian2.Notice(message, (_a = options.duration) != null ? _a : 4e3);
    }
    pendingNotices.length = 0;
  });
}
function showNoticeWhenReady(app, message, options = {}) {
  var _a;
  if (uiReady) {
    new import_obsidian2.Notice(message, (_a = options.duration) != null ? _a : 4e3);
  } else {
    pendingNotices.push({ message, options });
  }
}
async function showAlert(app, message, options = {}) {
  const {
    title = options.type === "error" ? "Error" : options.type === "warning" ? "Warning" : "Alert",
    primaryButton = "OK",
    secondaryButton,
    icon = options.type === "error" ? "alert-circle" : options.type === "warning" ? "alert-triangle" : "info"
  } = options;
  const result = await showPopup(app, message, {
    title,
    primaryButton,
    secondaryButton,
    icon
  });
  return { confirmed: (result == null ? void 0 : result.confirmed) || false };
}
async function showConfirm(app, message, options = {}) {
  const {
    title = "Confirm Action",
    primaryButton = "Confirm",
    secondaryButton = "Cancel",
    icon = "help-circle"
  } = options;
  const result = await showPopup(app, message, {
    title,
    primaryButton,
    secondaryButton,
    icon
  });
  return { confirmed: (result == null ? void 0 : result.confirmed) || false };
}
function displayNotice(app, parts, options = {}) {
  var _a;
  const fragment = document.createDocumentFragment();
  const titleEl = fragment.createDiv({ cls: "systemsculpt-notice-title" });
  titleEl.setText(parts.title);
  if (parts.path) {
    const pathEl = fragment.createDiv({ cls: "systemsculpt-notice-path" });
    pathEl.setText(parts.path);
  }
  if (parts.message) {
    const messageEl = fragment.createDiv({ cls: "systemsculpt-notice-message" });
    messageEl.setText(parts.message);
  }
  new import_obsidian2.Notice(fragment, (_a = options.duration) != null ? _a : 5e3);
}
var import_obsidian2, uiReady, pendingNotices;
var init_notifications = __esm({
  "src/core/ui/notifications.ts"() {
    import_obsidian2 = __toModule(require("obsidian"));
    init_PopupModal();
    uiReady = false;
    pendingNotices = [];
  }
});

// src/types/llm.ts
var DEFAULT_FILTER_SETTINGS;
var init_llm = __esm({
  "src/types/llm.ts"() {
    DEFAULT_FILTER_SETTINGS = {
      showVisionModels: false,
      showReasoningModels: false,
      showCreativeModels: false
    };
  }
});

// src/types/favorites.ts
var DEFAULT_FAVORITES_FILTER_SETTINGS;
var init_favorites = __esm({
  "src/types/favorites.ts"() {
    DEFAULT_FAVORITES_FILTER_SETTINGS = {
      showFavoritesOnly: false,
      favoritesFirst: true,
      modelSortOrder: "default"
    };
  }
});

// src/utils/errorHandling.ts
function setLogLevel(level) {
  currentLogLevel = level;
}
function logError(context, message, error) {
  console.error(`[SystemSculpt] ${context}: ${message}`, error);
}
async function logMobileError(context, message, error, additionalInfo) {
  logError(context, message, error);
}
var import_obsidian3, LogLevel, currentLogLevel;
var init_errorHandling = __esm({
  "src/utils/errorHandling.ts"() {
    import_obsidian3 = __toModule(require("obsidian"));
    (function(LogLevel3) {
      LogLevel3[LogLevel3["ERROR"] = 0] = "ERROR";
      LogLevel3[LogLevel3["WARNING"] = 1] = "WARNING";
      LogLevel3[LogLevel3["INFO"] = 2] = "INFO";
      LogLevel3[LogLevel3["DEBUG"] = 3] = "DEBUG";
    })(LogLevel || (LogLevel = {}));
    currentLogLevel = 1;
  }
});

// src/types.ts
var LICENSE_URL, DEFAULT_TITLE_GENERATION_PROMPT, DEFAULT_SETTINGS;
var init_types = __esm({
  "src/types.ts"() {
    init_llm();
    init_favorites();
    init_errorHandling();
    LICENSE_URL = "https://systemsculpt.com/resources?tab=license";
    DEFAULT_TITLE_GENERATION_PROMPT = `You are a specialized title generation assistant focused on creating precise, meaningful titles.

Your task is to analyze the provided conversation and generate a single, concise title that:
- Captures the main topic or central theme of the conversation
- Uses clear, descriptive language
- Is between 3-8 words long
- Avoids unnecessary articles (a, an, the) unless essential
- Maintains professional tone and proper capitalization
- Includes key technical terms when relevant
- NEVER includes characters that are invalid in filenames: \\ / : * ? " < > |
- Uses proper spacing between all words

Output ONLY the title itself - no additional text, no "Title:" prefix, no quotes, no explanation.`;
    DEFAULT_SETTINGS = {
      licenseKey: "",
      licenseValid: false,
      suppressLicenseUpgradePrompt: false,
      selectedModelId: "",
      defaultTemplateModelId: "",
      chatsDirectory: "SystemSculpt/Chats",
      savedChatsDirectory: "SystemSculpt/Saved Chats",
      lastValidated: 0,
      systemPrompt: "You are a helpful AI assistant. You help users with their questions and tasks in a clear and concise way.",
      recordingsDirectory: "SystemSculpt/Recordings",
      preferredMicrophoneId: "",
      autoTranscribeRecordings: true,
      autoPasteTranscription: true,
      keepRecordingsAfterTranscription: true,
      postProcessingPrompt: `You are a transcription post-processor. Your task is to fix any transcription errors, correct grammar and punctuation, and ensure the text is properly formatted. Keep the original meaning intact while making the text more readable.

Please process the following raw transcript to:
- Fix grammar, punctuation, and capitalization
- Remove filler words (um, uh, like, you know)
- Format into clear paragraphs
- Maintain the original meaning and speaker's voice

Raw transcript:`,
      postProcessingEnabled: false,
      postProcessingPromptType: "preset",
      postProcessingPromptPresetId: "transcript-cleaner",
      postProcessingPromptFilePath: "",
      postProcessingProviderId: "systemsculpt",
      postProcessingModelId: "",
      cleanTranscriptionOutput: false,
      autoSubmitAfterTranscription: false,
      transcriptionProvider: "systemsculpt",
      customTranscriptionEndpoint: "",
      customTranscriptionApiKey: "",
      customTranscriptionModel: "whisper-large-v3",
      enableAutoAudioResampling: true,
      showModelTooltips: false,
      showVisionModelsOnly: false,
      showTopPicksOnly: false,
      selectedProvider: "all",
      serverUrl: "",
      attachmentsDirectory: "SystemSculpt/Attachments",
      extractionsDirectory: "SystemSculpt/Extractions",
      systemPromptsDirectory: "SystemSculpt/System Prompts",
      skipEmptyNoteWarning: false,
      systemPromptType: "general-use",
      systemPromptPath: "",
      agentMode: false,
      defaultAgentMode: false,
      defaultIncludeVaultStructure: false,
      titleGenerationPrompt: DEFAULT_TITLE_GENERATION_PROMPT,
      titleGenerationPromptType: "precise",
      titleGenerationPromptPath: "",
      automaticTitleGeneration: false,
      titleGenerationProviderId: "systemsculpt",
      titleGenerationModelId: "",
      customProviders: [],
      modelFilterSettings: DEFAULT_FILTER_SETTINGS,
      favoriteModels: [],
      favoritesFilterSettings: DEFAULT_FAVORITES_FILTER_SETTINGS,
      favoriteChats: [],
      activeProvider: {
        id: "systemsculpt",
        name: "SystemSculpt",
        type: "native"
      },
      templateHotkey: "/",
      enableTemplateHotkey: true,
      lastSaveAsNoteFolder: "SystemSculpt/AI Responses",
      showDiagnostics: false,
      enableExperimentalFeatures: false,
      maxVaultDirectoryEntries: 300,
      enableSystemSculptProvider: true,
      useSystemSculptAsFallback: true,
      contextWindowPercentage: 25,
      logLevel: LogLevel.INFO,
      debugMode: false,
      showUpdateNotifications: true,
      mcpServers: [{
        id: "mcp-filesystem",
        name: "Filesystem Tools",
        transport: "internal",
        isEnabled: true,
        connectionStatus: "connected",
        availableTools: []
      }],
      mcpEnabledTools: [
        "mcp-filesystem:read_files",
        "mcp-filesystem:write_file",
        "mcp-filesystem:edit_file",
        "mcp-filesystem:create_directories",
        "mcp-filesystem:list_directories",
        "mcp-filesystem:move_items",
        "mcp-filesystem:trash_files",
        "mcp-filesystem:find_files",
        "mcp-filesystem:grep_vault",
        "mcp-filesystem:manage_workspace",
        "mcp-filesystem:manage_context",
        "mcp-filesystem:manage_janitor"
      ],
      mcpAutoAcceptTools: [],
      mcpEnabled: true,
      mcpAutoAccept: false,
      chatFontSize: "medium",
      openAiApiKey: "",
      embeddingsEnabled: false,
      embeddingsModel: "text-embedding-3-small",
      embeddingsAutoProcess: true,
      embeddingsExclusions: {
        folders: [],
        patterns: [],
        ignoreChatHistory: true,
        respectObsidianExclusions: true
      },
      embeddingsMobileEnabled: false,
      embeddingsBatchSize: 5,
      embeddingsRateLimitPerMinute: 50,
      automaticBackupsEnabled: true,
      automaticBackupInterval: 24,
      automaticBackupRetentionDays: 30,
      lastAutomaticBackup: 0,
      selectedModelProviders: []
    };
  }
});

// src/constants/prompts/general.ts
var GENERAL_USE_PRESET;
var init_general = __esm({
  "src/constants/prompts/general.ts"() {
    GENERAL_USE_PRESET = {
      id: "general-use",
      label: "General Use Preset",
      description: "Standard balanced prompt.",
      isUserConfigurable: false,
      systemPrompt: "You are a helpful AI assistant. You help users with their questions and tasks in a clear and concise way."
    };
  }
});

// src/constants/prompts/concise.ts
var CONCISE_PRESET;
var init_concise = __esm({
  "src/constants/prompts/concise.ts"() {
    CONCISE_PRESET = {
      id: "concise",
      label: "Concise Preset",
      description: "Shorter, more direct prompt.",
      isUserConfigurable: false,
      systemPrompt: "You are a concise AI assistant. Be brief and to the point."
    };
  }
});

// src/constants/prompts/agent.ts
var AGENT_PRESET;
var init_agent = __esm({
  "src/constants/prompts/agent.ts"() {
    AGENT_PRESET = {
      id: "agent",
      label: "Vault Agent Preset",
      description: "Autonomous agent for vault operations.",
      isUserConfigurable: false,
      systemPrompt: `<identity>
You are the SystemSculpt Vault Agent\u2014an elite AI assistant embedded in Obsidian.
Your mission: execute the USER's requests inside their vault\u2014fast and with zero fluff.
</identity>

<scope>
You may be asked to:
\u2022 create, edit, or refactor notes, code blocks, and metadata  
\u2022 search, summarize, or transform vault content  
\u2022 answer technical questions about SystemSculpt plugins, workflows, or AI usage  
Do ONLY what the USER asks\u2014nothing more, nothing less.
</scope>

<communication>
\u2022 Speak in second person; keep sentences short and decisive.  
\u2022 No apologies unless you break something.  
\u2022 If you need clarification, ask once, then act.  
\u2022 Avoid corporate clich\xE9s or "AI-speak." Get to the point.
</communication>

<search_strategy>
\u2022 Content: break queries into words (["neon", "mcp", "install"])
\u2022 Properties: use exact names (e.g., 'blogpost:' for YAML)
\u2022 YAML frontmatter: 'property: value' | Inline: 'property:: value'
\u2022 For "files with X property":
  - Use search_metadata with patterns: ["*"], properties: ["blogpost"]
  - This finds ALL files that have the blogpost property
  - For specific values: patterns: ["http", "systemsculpt"], properties: ["blogpost"]
\u2022 Use search_metadata for property-only searches (faster than grep)
\u2022 Execute parallel searches when unsure: grep + find_files + search_metadata
\u2022 Try broader terms if exact matches fail
\u2022 Never ask for file locations\u2014find them
</search_strategy>

<tool_calling>
1. ALWAYS follow each tool's JSON schema exactly; include every required param.  
2. If multiple tools solve a step, invoke them in PARALLEL\u2014speed beats chatter.  
3. Never call tools that are unavailable.  
4. If a tool result is unclear, reflect, adjust, and call again\u2014no USER ping-pong.  
5. Clean up temp files or artifacts you create before finishing.  
6. If vault-state is needed, PREFER a tool call over asking the USER.  
7. Summarize results only after you've confirmed they satisfy the request.
</tool_calling>

<efficiency>
DEFAULT TO PARALLEL execution unless output of Tool A is REQUIRED for Tool B.  
Plan searches up front: group grep, note-search, and metadata queries together.  
Treat sequential calls as a last resort.
</efficiency>

<making_edits>
When modifying files:  
1. Read the file first.  
2. After edits, validate with lint/test tools; fix or report errors immediately.  
3. Never generate binary blobs or massive hashes.  
4. Do not create docs/README unless explicitly requested.
</making_edits>

<search_and_learning>
Unsure? Gather more data with search tools instead of stalling.  
Bias toward self-service over questioning the USER.
</search_and_learning>

<final_word>
Do what's asked, finish fast, stay silent about internals.
</final_word>`
    };
  }
});

// src/constants/prompts/index.ts
var LOCAL_SYSTEM_PROMPTS;
var init_prompts = __esm({
  "src/constants/prompts/index.ts"() {
    init_general();
    init_concise();
    init_agent();
    init_general();
    init_concise();
    init_agent();
    LOCAL_SYSTEM_PROMPTS = [
      GENERAL_USE_PRESET,
      CONCISE_PRESET,
      AGENT_PRESET
    ];
  }
});

// src/constants/prompts.ts
var init_prompts2 = __esm({
  "src/constants/prompts.ts"() {
    init_prompts();
  }
});

// src/services/SystemPromptService.ts
var SystemPromptService_exports = {};
__export(SystemPromptService_exports, {
  SystemPromptService: () => SystemPromptService
});
var import_obsidian4, _SystemPromptService, SystemPromptService;
var init_SystemPromptService = __esm({
  "src/services/SystemPromptService.ts"() {
    import_obsidian4 = __toModule(require("obsidian"));
    init_prompts2();
    _SystemPromptService = class {
      constructor(app, pluginSettingsGetter) {
        this.app = app;
        this.pluginSettings = pluginSettingsGetter;
      }
      static getInstance(app, pluginSettingsGetter) {
        if (!this.instance) {
          this.instance = new _SystemPromptService(app, pluginSettingsGetter);
        }
        this.instance.pluginSettings = pluginSettingsGetter;
        return this.instance;
      }
      async getSystemPromptContent(type, path, agentMode) {
        const settings = this.pluginSettings();
        const effectiveAgentMode = agentMode !== void 0 ? agentMode : (settings == null ? void 0 : settings.agentMode) || false;
        if (type === "general-use") {
          return GENERAL_USE_PRESET.systemPrompt;
        } else if (type === "concise") {
          return CONCISE_PRESET.systemPrompt;
        } else if (type === "agent") {
          if (effectiveAgentMode) {
            return AGENT_PRESET.systemPrompt;
          } else {
            console.warn("Agent prompt type selected but agent mode is disabled. Using general prompt instead. Enable agent mode in the MCP tools modal (brain icon) to use agent capabilities.");
            return GENERAL_USE_PRESET.systemPrompt;
          }
        } else if (type === "custom" && path) {
          try {
            return await this.readCustomPromptFile(path);
          } catch (error) {
            console.error(`Error reading custom prompt file "${path}":`, error);
            return GENERAL_USE_PRESET.systemPrompt;
          }
        }
        return GENERAL_USE_PRESET.systemPrompt;
      }
      async readCustomPromptFile(path) {
        let file = this.app.vault.getAbstractFileByPath(path);
        if (!file && !path.endsWith(".md")) {
          file = this.app.vault.getAbstractFileByPath(`${path}.md`);
        }
        if (!file) {
          const settings = this.pluginSettings();
          const promptsDir = (settings == null ? void 0 : settings.systemPromptsDirectory) || "SystemSculpt/System Prompts";
          const filename = path.split("/").pop();
          if (filename) {
            file = this.app.vault.getAbstractFileByPath(`${promptsDir}/${filename}`);
            if (!file && !filename.endsWith(".md")) {
              file = this.app.vault.getAbstractFileByPath(`${promptsDir}/${filename}.md`);
            }
          }
        }
        if (file instanceof import_obsidian4.TFile) {
          return await this.app.vault.read(file);
        }
        throw new Error(`Custom prompt file not found: ${path}`);
      }
      getLocalPresets() {
        return LOCAL_SYSTEM_PROMPTS;
      }
      async getCustomPromptFiles() {
        const settings = this.pluginSettings();
        const promptsDir = (settings == null ? void 0 : settings.systemPromptsDirectory) || "SystemSculpt/System Prompts";
        const files = [];
        try {
          const dirExists = await this.app.vault.adapter.exists(promptsDir);
          if (!dirExists) {
            console.log(`[SystemPromptService] System prompts directory does not exist: ${promptsDir}`);
            return files;
          }
          const getFolderWithTimeout = async (timeout = 2e3) => {
            return Promise.race([
              new Promise((resolve) => {
                const folder2 = this.app.vault.getAbstractFileByPath(promptsDir);
                resolve(folder2);
              }),
              new Promise((_, reject) => {
                setTimeout(() => reject(new Error(`Timeout accessing directory: ${promptsDir}`)), timeout);
              })
            ]);
          };
          const folder = await getFolderWithTimeout();
          if (folder && "children" in folder) {
            const children = folder.children || [];
            for (const file of children) {
              if (file instanceof import_obsidian4.TFile && file.extension === "md") {
                files.push({
                  path: file.path,
                  name: file.basename
                });
              }
            }
            files.sort((a, b) => a.name.localeCompare(b.name));
          }
        } catch (error) {
          if (error instanceof Error && error.message.includes("Timeout")) {
            console.warn(`[SystemPromptService] ${error.message}`);
          } else {
            console.error(`[SystemPromptService] Error accessing system prompts directory:`, error);
          }
        }
        return files;
      }
      getVaultDirectoryStructure() {
        var _a;
        const dirSet = new Set();
        const files = this.app.vault.getFiles();
        for (const file of files) {
          const pathParts = file.path.split("/");
          pathParts.pop();
          for (let i = 1; i <= pathParts.length; i++) {
            const dirPath = pathParts.slice(0, i).join("/");
            if (dirPath) {
              dirSet.add(dirPath);
            }
          }
        }
        const allDirs = Array.from(dirSet);
        const totalDirCount = allDirs.length;
        allDirs.sort((a, b) => a.localeCompare(b));
        const settings = (_a = this.pluginSettings) == null ? void 0 : _a.call(this);
        const maxEntries = settings && settings.maxVaultDirectoryEntries || 300;
        if (totalDirCount <= maxEntries) {
          return allDirs.map((dir) => `- ${dir}`).join("\n");
        }
        const topLevelMap = {};
        for (const dir of allDirs) {
          const [top] = dir.split("/");
          topLevelMap[top] = (topLevelMap[top] || 0) + 1;
        }
        const summaryLines = Object.keys(topLevelMap).sort((a, b) => a.localeCompare(b)).map((t) => `- ${t} (${topLevelMap[t] - 1} nested subdirs)`);
        const cappedSummary = summaryLines.slice(0, maxEntries);
        const ellipsisLine = summaryLines.length > cappedSummary.length ? `- \u2026and ${summaryLines.length - cappedSummary.length} more top-level folders` : void 0;
        return [
          `Total directories: ${totalDirCount}`,
          ...cappedSummary,
          ellipsisLine
        ].filter(Boolean).join("\n");
      }
    };
    SystemPromptService = _SystemPromptService;
    SystemPromptService.instance = null;
  }
});

// src/utils/errors.ts
function getErrorMessage(code, model) {
  const message = ERROR_MESSAGES[code];
  if (typeof message === "function") {
    return message(model);
  }
  return message;
}
var ERROR_CODES, TEMPERATURE_UNSUPPORTED_ERROR, TEMPERATURE_VALUE_ERROR, ERROR_MESSAGES, SystemSculptError;
var init_errors = __esm({
  "src/utils/errors.ts"() {
    ERROR_CODES = {
      INVALID_LICENSE: "INVALID_LICENSE",
      LICENSE_EXPIRED: "LICENSE_EXPIRED",
      LICENSE_DISABLED: "LICENSE_DISABLED",
      PRO_REQUIRED: "PRO_REQUIRED",
      MODEL_UNAVAILABLE: "MODEL_UNAVAILABLE",
      MODEL_REQUEST_ERROR: "MODEL_REQUEST_ERROR",
      STREAM_ERROR: "STREAM_ERROR",
      INVALID_RESPONSE: "INVALID_RESPONSE",
      NO_IMAGE: "NO_IMAGE",
      FILE_NOT_FOUND: "FILE_NOT_FOUND",
      FILE_TOO_LARGE: "FILE_TOO_LARGE",
      UNSUPPORTED_FORMAT: "UNSUPPORTED_FORMAT",
      PROCESSING_ERROR: "PROCESSING_ERROR",
      UNKNOWN_ERROR: "UNKNOWN_ERROR",
      QUOTA_EXCEEDED: "QUOTA_EXCEEDED"
    };
    TEMPERATURE_UNSUPPORTED_ERROR = "This model does not support the temperature parameter. The plugin should have handled this automatically.";
    TEMPERATURE_VALUE_ERROR = "This model only supports default temperature value of 1.0";
    ERROR_MESSAGES = {
      [ERROR_CODES.INVALID_LICENSE]: "Invalid license key. Please check and try again.",
      [ERROR_CODES.LICENSE_EXPIRED]: "Your license has expired.",
      [ERROR_CODES.LICENSE_DISABLED]: "This license has been disabled.",
      [ERROR_CODES.PRO_REQUIRED]: "This feature requires a Pro subscription. Please upgrade.",
      [ERROR_CODES.MODEL_UNAVAILABLE]: (model) => `Model ${model || ""} is currently unavailable.`,
      [ERROR_CODES.MODEL_REQUEST_ERROR]: (model) => `Model ${model || ""} cannot process this request.`,
      [ERROR_CODES.STREAM_ERROR]: "Streaming failed. Please try again.",
      [ERROR_CODES.INVALID_RESPONSE]: "Invalid response received from server. Please try again.",
      [ERROR_CODES.UNKNOWN_ERROR]: "An unexpected error occurred. Please try again or contact support.",
      [ERROR_CODES.QUOTA_EXCEEDED]: "You have exceeded your quota. Please upgrade your plan.",
      [ERROR_CODES.NO_IMAGE]: "No image in clipboard",
      [ERROR_CODES.FILE_NOT_FOUND]: "File not found",
      [ERROR_CODES.FILE_TOO_LARGE]: "File too large (max 10MB)",
      [ERROR_CODES.UNSUPPORTED_FORMAT]: "Unsupported file format",
      [ERROR_CODES.PROCESSING_ERROR]: "Failed to process file"
    };
    SystemSculptError = class extends Error {
      constructor(message, code = ERROR_CODES.UNKNOWN_ERROR, statusCode = 500, metadata) {
        super(message);
        this.code = code;
        this.statusCode = statusCode;
        this.metadata = metadata;
        this.name = "SystemSculptError";
      }
    };
  }
});

// src/utils/licenseUtils.ts
var licenseUtils_exports = {};
__export(licenseUtils_exports, {
  checkPremiumUserStatus: () => checkPremiumUserStatus,
  formatCreditsDisplay: () => formatCreditsDisplay,
  verifyPremiumAccess: () => verifyPremiumAccess
});
function checkPremiumUserStatus(settings) {
  const isPremium = settings.licenseValid === true;
  const creditsBalance = settings.creditsBalance || 0;
  const hasCredits = creditsBalance > 0;
  const displayName = settings.displayName || settings.userName || settings.userEmail || "User";
  let status = {
    isPremium,
    hasCredits,
    displayName,
    creditsBalance
  };
  if (isPremium && displayName.toLowerCase().includes("daughter")) {
    status.greeting = `Welcome back, cherished family member ${displayName}! Your premium pro access is active with ${creditsBalance.toLocaleString()} credits.`;
  } else if (isPremium) {
    status.greeting = `Welcome ${displayName}! Premium Pro active \u2022 ${creditsBalance.toLocaleString()} credits`;
  }
  return status;
}
function verifyPremiumAccess(settings, minCreditsRequired = 1, showNotice = true) {
  const status = checkPremiumUserStatus(settings);
  if (!status.isPremium) {
    if (showNotice) {
      new import_obsidian5.Notice("Premium Pro license required for this feature");
    }
    return false;
  }
  if (status.creditsBalance < minCreditsRequired) {
    if (showNotice) {
      new import_obsidian5.Notice(`Insufficient credits. You have ${status.creditsBalance} credits, but ${minCreditsRequired} required.`);
    }
    return false;
  }
  return true;
}
function formatCreditsDisplay(credits) {
  if (credits >= 1e6) {
    return `${(credits / 1e6).toFixed(1)}M`;
  } else if (credits >= 1e3) {
    return `${(credits / 1e3).toFixed(1)}K`;
  }
  return credits.toLocaleString();
}
var import_obsidian5;
var init_licenseUtils = __esm({
  "src/utils/licenseUtils.ts"() {
    import_obsidian5 = __toModule(require("obsidian"));
  }
});

// src/utils/ImageProcessor.ts
var _ImageProcessor, ImageProcessor;
var init_ImageProcessor = __esm({
  "src/utils/ImageProcessor.ts"() {
    init_errors();
    _ImageProcessor = class {
      static async processImage(file, app) {
        if (!file) {
          throw new SystemSculptError("File not found", "FILE_NOT_FOUND", 404);
        }
        if (file.stat.size > _ImageProcessor.MAX_FILE_SIZE) {
          throw new SystemSculptError("Image too large (max 10MB)", "FILE_TOO_LARGE", 413);
        }
        const extension = file.extension.toLowerCase();
        if (!_ImageProcessor.SUPPORTED_FORMATS.has(extension)) {
          throw new SystemSculptError("Unsupported image format", "UNSUPPORTED_FORMAT", 415);
        }
        try {
          const arrayBuffer = await app.vault.readBinary(file);
          const base64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              const dataUrl = reader.result;
              resolve(dataUrl);
            };
            reader.onerror = () => reject(reader.error);
            const type = `image/${extension === "jpg" ? "jpeg" : extension}`;
            const blob = new Blob([arrayBuffer], { type });
            reader.readAsDataURL(blob);
          });
          return base64;
        } catch (error) {
          console.error("Image processing failed:", error);
          throw new SystemSculptError("Failed to process image", "PROCESSING_ERROR", 500);
        }
      }
      static async processClipboardImage(clipboardData) {
        const file = clipboardData.files[0];
        if (!file || !file.type.startsWith("image/")) {
          throw new SystemSculptError("No image in clipboard", "NO_IMAGE", 400);
        }
        if (file.size > this.MAX_FILE_SIZE) {
          throw new SystemSculptError("Image too large (max 10MB)", "FILE_TOO_LARGE", 413);
        }
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(reader.error);
          reader.readAsDataURL(file);
        });
      }
    };
    ImageProcessor = _ImageProcessor;
    ImageProcessor.MAX_FILE_SIZE = 10 * 1024 * 1024;
    ImageProcessor.SUPPORTED_FORMATS = new Set([
      "jpg",
      "jpeg",
      "png",
      "gif",
      "webp"
    ]);
  }
});

// src/constants/api.ts
var api_exports = {};
__export(api_exports, {
  API_BASE_URL: () => API_BASE_URL,
  DEVELOPMENT_MODE: () => DEVELOPMENT_MODE,
  LOCAL_API_ENDPOINTS: () => LOCAL_API_ENDPOINTS,
  LOCAL_API_HEADERS: () => LOCAL_API_HEADERS,
  OPENROUTER_API_ENDPOINTS: () => OPENROUTER_API_ENDPOINTS,
  OPENROUTER_API_HEADERS: () => OPENROUTER_API_HEADERS,
  SYSTEMSCULPT_API_ENDPOINTS: () => SYSTEMSCULPT_API_ENDPOINTS,
  SYSTEMSCULPT_API_HEADERS: () => SYSTEMSCULPT_API_HEADERS,
  getServerUrl: () => getServerUrl
});
function getServerUrl(productionUrl, developmentUrl) {
  if (DEVELOPMENT_MODE === "DEVELOPMENT") {
    return developmentUrl;
  }
  return productionUrl;
}
var DEVELOPMENT_MODE, API_BASE_URL, SYSTEMSCULPT_API_ENDPOINTS, OPENROUTER_API_ENDPOINTS, LOCAL_API_ENDPOINTS, SYSTEMSCULPT_API_HEADERS, OPENROUTER_API_HEADERS, LOCAL_API_HEADERS;
var init_api = __esm({
  "src/constants/api.ts"() {
    DEVELOPMENT_MODE = "PRODUCTION";
    API_BASE_URL = getServerUrl("https://api.systemsculpt.com/api/v1", "http://localhost:3001/api/v1");
    SYSTEMSCULPT_API_ENDPOINTS = {
      LICENSE: {
        VALIDATE: (key) => `/license/validate/${key}`
      },
      MODELS: {
        LIST: "/models",
        GET: (modelId) => `/models/${modelId}`
      },
      CHAT: {
        COMPLETIONS: "/chat/completions"
      },
      EMBEDDINGS: {
        GENERATE: "/embeddings"
      },
      SYSTEM_PROMPTS: {
        GET: (id) => `/system-prompts/${id}`,
        LIST: "/system-prompts"
      },
      DOCUMENTS: {
        PROCESS: "/documents/process",
        GET: (id) => `/documents/${id}`,
        DOWNLOAD: (id) => `/documents/${id}/download`
      },
      CREDITS: {
        GET: "/credits"
      }
    };
    OPENROUTER_API_ENDPOINTS = {
      CHAT: {
        COMPLETION: "https://openrouter.ai/api/v1/chat/completions",
        MODELS: "https://openrouter.ai/api/v1/models"
      }
    };
    LOCAL_API_ENDPOINTS = {
      CHAT: {
        COMPLETION: "http://localhost:8000/v1/chat/completions",
        MODELS: "http://localhost:8000/v1/models"
      }
    };
    SYSTEMSCULPT_API_HEADERS = {
      DEFAULT: {
        "Content-Type": "application/json"
      },
      WITH_LICENSE: (licenseKey) => ({
        ...SYSTEMSCULPT_API_HEADERS.DEFAULT,
        Authorization: `Bearer ${licenseKey}`
      })
    };
    OPENROUTER_API_HEADERS = {
      DEFAULT: (apiKey) => ({
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`,
        "HTTP-Referer": "https://systemsculpt.com",
        "X-Title": "SystemSculpt AI"
      })
    };
    LOCAL_API_HEADERS = {
      DEFAULT: {
        "Content-Type": "application/json"
      }
    };
  }
});

// src/mcp-tools/filesystem/constants.ts
var FILESYSTEM_LIMITS, TOOL_DISPLAY_DESCRIPTIONS;
var init_constants = __esm({
  "src/mcp-tools/filesystem/constants.ts"() {
    FILESYSTEM_LIMITS = {
      MAX_FILE_READ_LENGTH: 25e3,
      MAX_LINE_LENGTH: 2e3,
      MAX_OPERATIONS: 100,
      MAX_SEARCH_RESULTS: 25,
      MAX_FILE_SIZE: 2e5,
      MAX_CONTENT_SIZE: 25e4,
      HARD_LIMIT: 25e3,
      MAX_RESPONSE_CHARS: 25e3,
      CONTEXT_CHARS: 200,
      BATCH_SIZE: 15,
      MAX_PROCESSING_TIME: 8e3,
      MAX_MATCHES_PER_FILE: 20,
      MAX_TOTAL_FILES_PROCESSED: 1e3,
      MAX_FILES_PER_REQUEST: 10,
      CONCURRENCY_LIMIT: 10
    };
    TOOL_DISPLAY_DESCRIPTIONS = {
      read_files: "Read one or more files.",
      write_file: "Create or overwrite a file.",
      edit_file: "Edit a file with simple oldText/newText replacements.",
      create_directories: "Create new folders.",
      list_directories: "Show what's in folders.",
      move_items: "Move or rename files/folders.",
      trash_files: "Send files/folders to trash (recoverable).",
      find_files: "Find files by name.",
      grep_vault: "Search inside files for text.",
      manage_workspace: "Open files next to the chat.",
      manage_context: "Add or remove context files.",
      manage_janitor: "Run vault clean-up tasks.",
      analyze_vault_storage: "Analyze vault storage usage with filtering and aggregation.",
      search_graph: "Explore file relationships using knowledge graph.",
      refine_search: "Refine previous search results iteratively.",
      search_metadata: "Find files by their YAML frontmatter properties."
    };
  }
});

// src/mcp-tools/filesystem/toolDefinitions/fileToolDefinitions.ts
var fileToolDefinitions;
var init_fileToolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions/fileToolDefinitions.ts"() {
    fileToolDefinitions = [
      {
        name: "read_files",
        description: "Read contents of one or more files. Supports windowing for large files (25KB chunks). Returns metadata including size and timestamps. Use offset/length for pagination.",
        inputSchema: {
          type: "object",
          properties: {
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              description: "File paths to read (relative to vault root)"
            },
            offset: {
              type: "number",
              minimum: 0,
              default: 0,
              description: "Character offset to start reading from"
            },
            length: {
              type: "number",
              minimum: 1,
              maximum: 25e3,
              default: 25e3,
              description: "Maximum characters to read (25KB limit)"
            }
          },
          required: ["paths"],
          additionalProperties: false
        }
      },
      {
        name: "write_file",
        description: "Create new file or overwrite existing. Creates parent directories if needed. Use edit_file for partial updates to preserve existing content.",
        inputSchema: {
          type: "object",
          properties: {
            path: {
              type: "string",
              description: "File path (relative to vault root)"
            },
            content: {
              type: "string",
              description: "Complete file content to write"
            }
          },
          required: ["path", "content"],
          additionalProperties: false
        }
      },
      {
        name: "edit_file",
        description: "Precise text replacement in existing files. Matches must be exact including whitespace. Processes multiple edits in sequence. Use for surgical updates without rewriting entire file.",
        inputSchema: {
          type: "object",
          properties: {
            path: {
              type: "string",
              description: "File to edit"
            },
            edits: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  oldText: {
                    type: "string",
                    description: "Exact text to replace (must be unique in file)"
                  },
                  newText: {
                    type: "string",
                    description: "Replacement text"
                  }
                },
                required: ["oldText", "newText"],
                additionalProperties: false
              },
              description: "List of replacements to apply in order"
            }
          },
          required: ["path", "edits"],
          additionalProperties: false
        }
      }
    ];
  }
});

// src/mcp-tools/filesystem/toolDefinitions/directoryToolDefinitions.ts
var directoryToolDefinitions;
var init_directoryToolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions/directoryToolDefinitions.ts"() {
    directoryToolDefinitions = [
      {
        name: "create_directories",
        description: "Create one or more directories. Parent directories created automatically. Safe to call on existing directories - no error thrown.",
        inputSchema: {
          type: "object",
          properties: {
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              description: "Directory paths to create (relative to vault root)"
            }
          },
          required: ["paths"],
          additionalProperties: false
        }
      },
      {
        name: "list_directories",
        description: "List contents of directories with smart filtering and analysis. Returns file/folder metadata including size, timestamps, and optional semantic grouping.",
        inputSchema: {
          type: "object",
          properties: {
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              maxItems: 5,
              description: "Directory paths to list (max 5 for performance)"
            },
            filter: {
              oneOf: [
                {
                  type: "string",
                  enum: ["all", "files", "directories"]
                },
                {
                  type: "object",
                  properties: {
                    semantic: { type: "string" }
                  }
                }
              ],
              default: "all",
              description: "Filter by type or semantic content (e.g., {semantic: 'meeting notes'})"
            },
            sort: {
              type: "string",
              enum: ["modified", "size", "name", "created"],
              default: "modified",
              description: "Sort order for results"
            },
            recursive: {
              type: "boolean",
              default: false,
              description: "Include subdirectories (use cautiously in large vaults)"
            }
          },
          required: ["paths"],
          additionalProperties: false
        }
      },
      {
        name: "move_items",
        description: "Batch move or rename files/folders. Updates all internal links automatically. Creates destination directories if needed. Use for organizing vault structure.",
        inputSchema: {
          type: "object",
          properties: {
            items: {
              type: "array",
              minItems: 1,
              maxItems: 5,
              items: {
                type: "object",
                properties: {
                  source: {
                    type: "string",
                    description: "Current path of file/folder"
                  },
                  destination: {
                    type: "string",
                    description: "New path (rename if same dir, move if different)"
                  }
                },
                required: ["source", "destination"],
                additionalProperties: false
              },
              description: "List of move operations to perform atomically"
            }
          },
          required: ["items"],
          additionalProperties: false
        }
      },
      {
        name: "trash_files",
        description: "Move files/folders to Obsidian trash (recoverable). Safer than permanent deletion. Preserves file history and can be restored from .trash folder.",
        inputSchema: {
          type: "object",
          properties: {
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              maxItems: 100,
              description: "Paths to trash (files or folders)"
            }
          },
          required: ["paths"],
          additionalProperties: false
        }
      }
    ];
  }
});

// src/mcp-tools/filesystem/toolDefinitions/searchToolDefinitions.ts
var searchToolDefinitions;
var init_searchToolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions/searchToolDefinitions.ts"() {
    searchToolDefinitions = [
      {
        name: "find_files",
        description: "Fast filename search using fuzzy matching. Best for finding files when you know part of the name. Results include path, size, and timestamps.",
        inputSchema: {
          type: "object",
          properties: {
            patterns: {
              type: "array",
              items: { type: "string" },
              description: "Terms to search for in filenames/paths (fuzzy match)"
            }
          },
          required: ["patterns"],
          additionalProperties: false
        }
      },
      {
        name: "grep_vault",
        description: "Search file contents using regex patterns. Best for exact text matches, code snippets, or property searches. Returns matched lines with context. For property-only searches, use search_metadata instead.",
        inputSchema: {
          type: "object",
          properties: {
            patterns: {
              type: "array",
              items: { type: "string" },
              description: "Regex patterns to search for. Escape special chars: ( ) [ ] { } + * ? ^ $ | . \\"
            },
            searchIn: {
              type: "string",
              enum: ["content", "frontmatter", "both"],
              default: "content",
              description: "Search in: content (body only), frontmatter (YAML only), or both"
            }
          },
          required: ["patterns"],
          additionalProperties: false
        }
      },
      {
        name: "search_metadata",
        description: "Fast search for files by YAML frontmatter properties. More efficient than grep_vault for property-only searches. Searches property values with fuzzy matching.",
        inputSchema: {
          type: "object",
          properties: {
            patterns: {
              type: "array",
              items: { type: "string" },
              description: "Values to search for in properties (fuzzy match)"
            },
            properties: {
              type: "array",
              items: { type: "string" },
              description: "Specific property names to search. Leave empty to search all properties. Examples: ['tags', 'status', 'type']"
            },
            maxResults: {
              type: "number",
              default: 50,
              description: "Maximum results (capped for performance)"
            }
          },
          required: ["patterns"],
          additionalProperties: false
        }
      }
    ];
  }
});

// src/mcp-tools/filesystem/toolDefinitions/managementToolDefinitions.ts
var managementToolDefinitions;
var init_managementToolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions/managementToolDefinitions.ts"() {
    managementToolDefinitions = [
      {
        name: "manage_workspace",
        description: "Open files in Obsidian for user to view. Opens in active pane or new tab. Use after creating/editing files to show results to user.",
        inputSchema: {
          type: "object",
          properties: {
            files: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  path: {
                    type: "string",
                    description: "File path to open in Obsidian"
                  }
                },
                required: ["path"],
                additionalProperties: false
              },
              minItems: 1,
              maxItems: 5,
              description: "Files to open (max 5 to avoid clutter)"
            }
          },
          required: ["files"],
          additionalProperties: false
        }
      },
      {
        name: "manage_context",
        description: "Control AI's access to files. Add files to give AI reference material, remove to reduce context. Files remain in context across conversation until removed.",
        inputSchema: {
          type: "object",
          properties: {
            action: {
              type: "string",
              enum: ["add", "remove"],
              description: "add: Include files in AI context | remove: Remove from context"
            },
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              maxItems: 10,
              description: "File paths to add/remove from AI context"
            }
          },
          required: ["action", "paths"],
          additionalProperties: false
        }
      }
    ];
  }
});

// src/mcp-tools/filesystem/toolDefinitions/storageToolDefinitions.ts
var storageToolDefinitions;
var init_storageToolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions/storageToolDefinitions.ts"() {
    storageToolDefinitions = [
      {
        name: "analyze_vault_storage",
        description: "Analyze vault storage usage with smart grouping and filtering. Find large files, analyze by type, or track growth over time. Essential for vault optimization.",
        inputSchema: {
          type: "object",
          properties: {
            paths: {
              type: "array",
              items: { type: "string" },
              description: "Specific paths to analyze (empty = entire vault)"
            },
            minSize: {
              type: "number",
              minimum: 0,
              description: "Filter files above size in bytes (e.g., 1048576 for 1MB+)"
            },
            extensions: {
              type: "array",
              items: { type: "string" },
              description: "Filter by file types (e.g., ['.md', '.png', '.pdf'])"
            },
            groupBy: {
              type: "string",
              enum: ["extension", "directory", "month", "none"],
              default: "extension",
              description: "Group results by: extension (file type), directory (location), month (creation date), none (flat list)"
            },
            sortBy: {
              type: "string",
              enum: ["size", "count", "name"],
              default: "size",
              description: "Sort by: size (disk usage), count (number of files), name (alphabetical)"
            },
            limit: {
              type: "number",
              minimum: 1,
              maximum: 1e3,
              default: 50,
              description: "Max results to return (prevents overwhelming output)"
            },
            includeDetails: {
              type: "boolean",
              default: false,
              description: "Include individual file paths and sizes (verbose output)"
            }
          },
          additionalProperties: false
        }
      }
    ];
  }
});

// src/mcp-tools/filesystem/toolDefinitions.ts
var toolDefinitions;
var init_toolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions.ts"() {
    init_fileToolDefinitions();
    init_directoryToolDefinitions();
    init_searchToolDefinitions();
    init_managementToolDefinitions();
    init_storageToolDefinitions();
    toolDefinitions = [
      ...fileToolDefinitions,
      ...directoryToolDefinitions,
      ...searchToolDefinitions,
      ...managementToolDefinitions,
      ...storageToolDefinitions
    ];
  }
});

// src/mcp-tools/filesystem/utils.ts
function formatBytes(bytes) {
  if (bytes === 0)
    return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}
function validatePath(path, allowedPaths) {
  const normalizedPath = (0, import_obsidian6.normalizePath)(path);
  for (const allowedPath of allowedPaths) {
    if (allowedPath === "/" || normalizedPath.startsWith(allowedPath)) {
      return true;
    }
  }
  return false;
}
function normalizeLineEndings(text) {
  return text.replace(/\r\n/g, "\n");
}
function createSimpleDiff(originalContent, newContent, filepath = "file") {
  const normalizedOriginal = normalizeLineEndings(originalContent);
  const normalizedNew = normalizeLineEndings(newContent);
  if (normalizedOriginal === normalizedNew) {
    return "No changes made.";
  }
  const originalLines = normalizedOriginal.split("\n");
  const newLines = normalizedNew.split("\n");
  let diffLines = [];
  diffLines.push(`--- ${filepath}`);
  diffLines.push(`+++ ${filepath}`);
  const maxLines = Math.max(originalLines.length, newLines.length);
  let addedCount = 0;
  let removedCount = 0;
  for (let i = 0; i < maxLines && diffLines.length < 50; i++) {
    const oldLine = originalLines[i];
    const newLine = newLines[i];
    if (oldLine !== newLine) {
      if (oldLine !== void 0) {
        diffLines.push(`- ${oldLine}`);
        removedCount++;
      }
      if (newLine !== void 0) {
        diffLines.push(`+ ${newLine}`);
        addedCount++;
      }
    }
  }
  if (diffLines.length >= 50) {
    diffLines.push("... (diff truncated)");
  }
  return diffLines.join("\n") + `

Summary: +${addedCount} -${removedCount} lines`;
}
async function runWithConcurrency(items, worker, concurrency = 10) {
  const ret = [];
  let idx = 0;
  const runners = new Array(Math.min(concurrency, items.length)).fill(null).map(async () => {
    while (idx < items.length) {
      const current = items[idx++];
      try {
        ret.push(await worker(current));
      } catch (err) {
        ret.push({ error: err, path: current });
      }
    }
  });
  await Promise.all(runners);
  return ret;
}
function createLineCalculator(content) {
  const lineStarts = [0];
  for (let i = 0; i < content.length; i++) {
    if (content[i] === "\n") {
      lineStarts.push(i + 1);
    }
  }
  return (index) => {
    let left = 0;
    let right = lineStarts.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const start = lineStarts[mid];
      const end = mid < lineStarts.length - 1 ? lineStarts[mid + 1] : content.length;
      if (index >= start && index < end) {
        return mid + 1;
      } else if (index < start) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return lineStarts.length;
  };
}
function getFilesFromFolder(folder) {
  const files = [];
  const processFolder = (currentFolder) => {
    for (const child of currentFolder.children) {
      if (child instanceof import_obsidian6.TFile) {
        files.push(child);
      } else if (child instanceof import_obsidian6.TFolder) {
        processFolder(child);
      }
    }
  };
  processFolder(folder);
  return files;
}
function wouldExceedCharLimit(currentSize, addition, limit) {
  try {
    const additionSize = typeof addition === "string" ? addition.length : JSON.stringify(addition).length;
    return currentSize + additionSize > limit;
  } catch (e) {
    return true;
  }
}
function shouldExcludeFromSearch(file, plugin) {
  var _a, _b;
  const settings = plugin.settings;
  const exclusions = settings.embeddingsExclusions;
  if ((exclusions == null ? void 0 : exclusions.ignoreChatHistory) !== false) {
    const chatsDirectory = settings.chatsDirectory || "SystemSculpt/Chats";
    if (file.path.startsWith(chatsDirectory + "/") && file.extension === "md") {
      return true;
    }
  }
  if ((exclusions == null ? void 0 : exclusions.respectObsidianExclusions) !== false) {
    try {
      const userIgnoreFilters = plugin.app.vault.getConfig("userIgnoreFilters");
      if (userIgnoreFilters && Array.isArray(userIgnoreFilters)) {
        for (const pattern of userIgnoreFilters) {
          try {
            const regex = new RegExp(pattern);
            if (regex.test(file.path)) {
              return true;
            }
          } catch (e) {
          }
        }
      }
    } catch (e) {
    }
  }
  if (file.path.startsWith(".obsidian/") || file.path.includes("node_modules/")) {
    return true;
  }
  const systemDirs = [
    "SystemSculpt/Recordings",
    "SystemSculpt/System Prompts",
    "SystemSculpt/Attachments",
    "SystemSculpt/Extractions"
  ];
  for (const dir of systemDirs) {
    if (file.path.startsWith(dir + "/")) {
      return true;
    }
  }
  if ((_a = plugin.settings.embeddingsExclusions) == null ? void 0 : _a.folders) {
    for (const folder of plugin.settings.embeddingsExclusions.folders) {
      if (folder && file.path.startsWith(folder + "/")) {
        return true;
      }
    }
  }
  if ((_b = plugin.settings.embeddingsExclusions) == null ? void 0 : _b.patterns) {
    for (const pattern of plugin.settings.embeddingsExclusions.patterns) {
      try {
        const regex = new RegExp(pattern);
        if (regex.test(file.path)) {
          return true;
        }
      } catch (e) {
      }
    }
  }
  return false;
}
var import_obsidian6;
var init_utils = __esm({
  "src/mcp-tools/filesystem/utils.ts"() {
    import_obsidian6 = __toModule(require("obsidian"));
  }
});

// src/mcp-tools/filesystem/tools/FileOperations.ts
var import_obsidian7, FileOperations;
var init_FileOperations = __esm({
  "src/mcp-tools/filesystem/tools/FileOperations.ts"() {
    import_obsidian7 = __toModule(require("obsidian"));
    init_constants();
    init_utils();
    FileOperations = class {
      constructor(app, allowedPaths) {
        this.app = app;
        this.allowedPaths = allowedPaths;
      }
      async readFiles(params) {
        const { paths, offset = 0, length = FILESYSTEM_LIMITS.MAX_FILE_READ_LENGTH } = params;
        if (paths.length > FILESYSTEM_LIMITS.MAX_OPERATIONS) {
          throw new Error(`Too many files requested (${paths.length}). Maximum allowed is ${FILESYSTEM_LIMITS.MAX_OPERATIONS}`);
        }
        const actualOffset = offset;
        const actualLength = Math.min(length, FILESYSTEM_LIMITS.MAX_FILE_READ_LENGTH);
        const files = [];
        for (const path of paths) {
          if (!validatePath(path, this.allowedPaths)) {
            files.push({ path, content: "", error: "Access denied" });
            continue;
          }
          const file = this.app.vault.getAbstractFileByPath(path);
          if (file instanceof import_obsidian7.TFile) {
            try {
              const fullContent = await this.app.vault.read(file);
              const fileSize = fullContent.length;
              const windowStart = Math.max(0, Math.min(actualOffset, fileSize));
              const windowEnd = Math.min(windowStart + actualLength, fileSize);
              let windowContent = fullContent.substring(windowStart, windowEnd);
              if (windowEnd < fileSize) {
                windowContent += `

[...TRUNCATED...] The rest of this file has been cut off because this is the maximum read window (${actualLength} characters). To read more, supply "offset=${windowEnd}" (and optionally "length") in a subsequent read_files call.`;
              }
              const metadata = {
                fileSize,
                created: new Date(file.stat.ctime).toISOString(),
                modified: new Date(file.stat.mtime).toISOString(),
                windowStart,
                windowEnd,
                hasMore: windowEnd < fileSize
              };
              files.push({
                path,
                content: windowContent,
                metadata
              });
            } catch (err) {
              files.push({ path, content: "", error: "Failed to read file" });
            }
          } else {
            files.push({ path, content: "", error: "File not found or is a directory" });
          }
        }
        return { files };
      }
      async writeFile(params) {
        const { path, content } = params;
        if (!validatePath(path, this.allowedPaths)) {
          throw new Error(`Access denied: ${path}`);
        }
        if (content.length > FILESYSTEM_LIMITS.MAX_CONTENT_SIZE) {
          throw new Error(`Content too large (${content.length} characters). Maximum allowed is ${FILESYSTEM_LIMITS.MAX_CONTENT_SIZE} characters`);
        }
        const normalizedPath = (0, import_obsidian7.normalizePath)(path);
        const file = this.app.vault.getAbstractFileByPath(normalizedPath);
        if (file && file instanceof import_obsidian7.TFile) {
          await this.app.vault.modify(file, content);
        } else {
          await this.app.vault.create(normalizedPath, content);
        }
        return { path, success: true };
      }
      async editFile(params) {
        var _a;
        const { path: filePath, edits } = params;
        const normalizedPath = (0, import_obsidian7.normalizePath)(filePath);
        const abstractFile = this.app.vault.getAbstractFileByPath(normalizedPath);
        if (!(abstractFile instanceof import_obsidian7.TFile)) {
          throw new Error(`File not found: ${filePath}`);
        }
        const content = normalizeLineEndings(await this.app.vault.read(abstractFile));
        let modifiedContent = content;
        for (const edit of edits) {
          const normalizedOld = normalizeLineEndings(edit.oldText);
          const normalizedNew = normalizeLineEndings(edit.newText);
          if (modifiedContent.includes(normalizedOld)) {
            modifiedContent = modifiedContent.replace(normalizedOld, normalizedNew);
            continue;
          }
          const oldLines = normalizedOld.split("\n");
          const contentLines = modifiedContent.split("\n");
          let matchFound = false;
          for (let i = 0; i <= contentLines.length - oldLines.length; i++) {
            const potentialMatch = contentLines.slice(i, i + oldLines.length);
            const isMatch = oldLines.every((oldLine, j) => {
              const contentLine = potentialMatch[j];
              return oldLine.trim() === contentLine.trim();
            });
            if (isMatch) {
              const originalIndent = ((_a = contentLines[i].match(/^\s*/)) == null ? void 0 : _a[0]) || "";
              const newLines = normalizedNew.split("\n").map((line, j) => {
                var _a2, _b, _c;
                if (j === 0)
                  return originalIndent + line.trimStart();
                const oldIndent = ((_b = (_a2 = oldLines[j]) == null ? void 0 : _a2.match(/^\s*/)) == null ? void 0 : _b[0]) || "";
                const newIndent = ((_c = line.match(/^\s*/)) == null ? void 0 : _c[0]) || "";
                if (oldIndent && newIndent) {
                  const relativeIndent = newIndent.length - oldIndent.length;
                  return originalIndent + " ".repeat(Math.max(0, relativeIndent)) + line.trimStart();
                }
                return line;
              });
              contentLines.splice(i, oldLines.length, ...newLines);
              modifiedContent = contentLines.join("\n");
              matchFound = true;
              break;
            }
          }
          if (!matchFound) {
            throw new Error(`Could not find exact match for edit:
${edit.oldText}`);
          }
        }
        const diff = createSimpleDiff(content, modifiedContent, filePath);
        await this.app.vault.modify(abstractFile, modifiedContent);
        return diff;
      }
    };
  }
});

// src/mcp-tools/filesystem/tools/DirectoryOperations.ts
var import_obsidian8, DirectoryOperations;
var init_DirectoryOperations = __esm({
  "src/mcp-tools/filesystem/tools/DirectoryOperations.ts"() {
    import_obsidian8 = __toModule(require("obsidian"));
    init_constants();
    init_utils();
    DirectoryOperations = class {
      constructor(app, allowedPaths, plugin) {
        this.app = app;
        this.allowedPaths = allowedPaths;
        this.plugin = plugin;
      }
      async createDirectories(params) {
        const { paths } = params;
        if (paths.length > FILESYSTEM_LIMITS.MAX_OPERATIONS) {
          throw new Error(`Too many directories requested (${paths.length}). Maximum allowed is ${FILESYSTEM_LIMITS.MAX_OPERATIONS}`);
        }
        const results = await Promise.all(paths.map(async (path) => {
          if (!validatePath(path, this.allowedPaths)) {
            return { path, success: false, error: `Access denied: ${path}` };
          }
          const normalizedPath = (0, import_obsidian8.normalizePath)(path);
          try {
            await this.app.vault.createFolder(normalizedPath);
            return { path, success: true };
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            if (errorMessage.includes("already exists")) {
              return { path, success: true };
            }
            return { path, success: false, error: errorMessage };
          }
        }));
        return { results };
      }
      async listDirectories(params) {
        const { paths } = params;
        const { filter = "all", sort = "modified", recursive = false } = params;
        if (typeof filter === "object" && filter.semantic) {
          return { results: [{ path: paths[0] || "", error: "Semantic search has been disabled - use grep_vault instead" }] };
        }
        const results = await Promise.all(paths.map(async (path) => {
          try {
            if (!validatePath(path, this.allowedPaths)) {
              return { path, error: `Access denied: ${path}` };
            }
            const MAX_RESULTS = FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS * 3;
            const normalizedPath = path === "/" ? "" : (0, import_obsidian8.normalizePath)(path);
            const folder = normalizedPath ? this.app.vault.getAbstractFileByPath(normalizedPath) : this.app.vault.getRoot();
            if (!folder || !(folder instanceof import_obsidian8.TFolder)) {
              return { path, error: `Directory not found: ${path}` };
            }
            const pathResult = { path };
            if (filter === "all" || filter === "files") {
              pathResult.files = [];
            }
            if (filter === "all" || filter === "directories") {
              pathResult.directories = [];
            }
            let allItems = [];
            const collectItems = (folder2) => {
              for (const child of folder2.children) {
                if (child instanceof import_obsidian8.TFile || child instanceof import_obsidian8.TFolder) {
                  if (child instanceof import_obsidian8.TFile && shouldExcludeFromSearch(child, this.plugin)) {
                    continue;
                  }
                  allItems.push(child);
                  if (recursive && child instanceof import_obsidian8.TFolder) {
                    collectItems(child);
                  }
                }
              }
            };
            collectItems(folder);
            allItems.sort((a, b) => {
              const sortType = sort;
              switch (sortType) {
                case "size":
                  const aSize = a instanceof import_obsidian8.TFile ? a.stat.size : -1;
                  const bSize = b instanceof import_obsidian8.TFile ? b.stat.size : -1;
                  return bSize - aSize;
                case "name":
                  return a.name.localeCompare(b.name);
                case "created":
                  const aCtime = a instanceof import_obsidian8.TFile ? a.stat.ctime : 0;
                  const bCtime = b instanceof import_obsidian8.TFile ? b.stat.ctime : 0;
                  return bCtime - aCtime;
                case "modified":
                default:
                  const aMtime = a instanceof import_obsidian8.TFile ? a.stat.mtime : 0;
                  const bMtime = b instanceof import_obsidian8.TFile ? b.stat.mtime : 0;
                  return bMtime - aMtime;
              }
            });
            const children = allItems.slice(0, MAX_RESULTS);
            let fileCount = 0;
            let dirCount = 0;
            let totalSize = 0;
            for (const child of children) {
              if (child instanceof import_obsidian8.TFile && pathResult.files) {
                fileCount++;
                totalSize += child.stat.size;
                const fileInfo = {
                  name: child.name,
                  size: child.stat.size,
                  created: new Date(child.stat.ctime).toISOString(),
                  modified: new Date(child.stat.mtime).toISOString(),
                  extension: child.extension
                };
                if (child.extension === "md" || child.extension === "txt") {
                  try {
                    const content = await this.app.vault.cachedRead(child);
                    const lines = content.split("\n").filter((line) => line.trim());
                    fileInfo.preview = lines[0] ? lines[0].length > 150 ? lines[0].substring(0, 150) + "..." : lines[0] : content.length > 150 ? content.substring(0, 150) + "..." : content;
                  } catch (e) {
                  }
                }
                pathResult.files.push(fileInfo);
              } else if (child instanceof import_obsidian8.TFolder && pathResult.directories) {
                dirCount++;
                const folderInfo = {
                  name: child.name,
                  itemCount: child.children.length,
                  modified: void 0
                };
                pathResult.directories.push(folderInfo);
              }
            }
            const totalItems = allItems.length;
            const itemsShown = Math.min(totalItems, MAX_RESULTS);
            if (totalItems > MAX_RESULTS) {
              pathResult.summary = `Showing ${itemsShown} of ${totalItems} items (${fileCount} files, ${dirCount} folders). Total size: ${formatBytes(totalSize)}. Sorted by: ${sort}${recursive ? " (recursive)" : ""}`;
            } else {
              pathResult.summary = `${totalItems} items (${fileCount} files, ${dirCount} folders). Total size: ${formatBytes(totalSize)}. Sorted by: ${sort}${recursive ? " (recursive)" : ""}`;
            }
            return pathResult;
          } catch (error) {
            return { path, error: error instanceof Error ? error.message : "Unknown error" };
          }
        }));
        return { results };
      }
      async moveItems(params) {
        const { items } = params;
        if (items.length > 5) {
          throw new Error(`Cannot move more than 5 items at a time.`);
        }
        const results = [];
        for (const item of items) {
          const { source, destination } = item;
          try {
            if (!validatePath(source, this.allowedPaths)) {
              throw new Error(`Access denied: ${source}`);
            }
            if (!validatePath(destination, this.allowedPaths)) {
              throw new Error(`Access denied: ${destination}`);
            }
            const sourceFile = this.app.vault.getAbstractFileByPath((0, import_obsidian8.normalizePath)(source));
            if (!sourceFile) {
              throw new Error(`Item not found: ${source}`);
            }
            await this.app.fileManager.renameFile(sourceFile, (0, import_obsidian8.normalizePath)(destination));
            results.push({ source, destination, success: true });
          } catch (error) {
            results.push({ source, destination, success: false, error: error.message });
          }
        }
        return { results };
      }
      async trashFiles(params) {
        const { paths } = params;
        if (paths.length > FILESYSTEM_LIMITS.MAX_OPERATIONS) {
          throw new Error(`Cannot trash more than ${FILESYSTEM_LIMITS.MAX_OPERATIONS} items at once.`);
        }
        const settled = await runWithConcurrency(paths, async (p) => {
          await this.trashFile(p);
          return { path: p, success: true };
        });
        const results = settled.map((res) => {
          var _a, _b, _c, _d;
          if (res && res.success)
            return res;
          const errObj = res;
          return {
            path: (_a = errObj == null ? void 0 : errObj.path) != null ? _a : "<unknown>",
            success: false,
            error: (_d = (_c = (_b = errObj == null ? void 0 : errObj.error) == null ? void 0 : _b.message) != null ? _c : errObj == null ? void 0 : errObj.message) != null ? _d : String(errObj)
          };
        });
        const successfulCount = results.filter((r) => r.success).length;
        if (successfulCount > 0) {
          new import_obsidian8.Notice(`Moved ${successfulCount} item(s) to trash.`);
        }
        return { results };
      }
      async trashFile(path) {
        if (!validatePath(path, this.allowedPaths)) {
          throw new Error(`Access denied: ${path}`);
        }
        const file = this.app.vault.getAbstractFileByPath((0, import_obsidian8.normalizePath)(path));
        if (!file) {
          throw new Error(`File not found: ${path}`);
        }
        const normalizedPath = (0, import_obsidian8.normalizePath)(file.path);
        await this.app.vault.adapter.trashLocal(normalizedPath);
        return { path, success: true };
      }
    };
  }
});

// src/mcp-tools/filesystem/searchScoring.ts
function extractSearchTerms(query) {
  const terms = query.toLowerCase().split(/[\s\-_]+/).filter((term) => term.length > 0);
  const variations = [];
  variations.push(...terms);
  if (terms.length > 1) {
    variations.push(terms.map((t, i) => i === 0 ? t : t.charAt(0).toUpperCase() + t.slice(1)).join(""));
    variations.push(terms.map((t) => t.charAt(0).toUpperCase() + t.slice(1)).join(""));
  }
  if (terms.length > 1) {
    variations.push(terms.join("_"));
  }
  if (terms.length > 1) {
    variations.push(terms.join("-"));
  }
  return [...new Set(variations)];
}
function calculateScore(filePath, content, context) {
  const filename = filePath.split("/").pop() || "";
  const pathParts = filePath.toLowerCase().split("/");
  const lowerContent = (content == null ? void 0 : content.toLowerCase()) || "";
  let score = 0;
  const keywordsFound = [];
  const matchLocations = [];
  const reasons = [];
  for (const term of context.searchTerms) {
    const lowerTerm = term.toLowerCase();
    let termFound = false;
    if (filename.toLowerCase().includes(lowerTerm)) {
      score += 40;
      termFound = true;
      if (!matchLocations.includes("filename")) {
        matchLocations.push("filename");
      }
      reasons.push(`"${term}" in filename (+40)`);
    }
    if (pathParts.some((part) => part.includes(lowerTerm))) {
      score += 20;
      termFound = true;
      if (!matchLocations.includes("path")) {
        matchLocations.push("path");
      }
      reasons.push(`"${term}" in path (+20)`);
    }
    if (lowerContent.includes(lowerTerm)) {
      score += 10;
      termFound = true;
      if (!matchLocations.includes("content")) {
        matchLocations.push("content");
      }
      reasons.push(`"${term}" in content (+10)`);
    }
    if (termFound && !keywordsFound.includes(term)) {
      keywordsFound.push(term);
    }
  }
  const originalTerms = context.originalQuery.toLowerCase().split(/[\s\-_]+/).filter((t) => t.length > 0);
  const foundOriginalTerms = originalTerms.filter((term) => filename.toLowerCase().includes(term) || pathParts.some((part) => part.includes(term)) || lowerContent.includes(term));
  if (foundOriginalTerms.length === originalTerms.length && originalTerms.length > 1) {
    score += 30;
    reasons.push(`All original terms found (+30)`);
  }
  if (content && content.toLowerCase().includes(context.originalQuery.toLowerCase())) {
    score += 20;
    reasons.push(`Exact phrase match (+20)`);
  }
  const relevantPaths = ["email", "campaign", "marketing", "draft", "template", "brand"];
  const pathBonus = relevantPaths.filter((rp) => pathParts.some((part) => part.includes(rp))).length * 5;
  if (pathBonus > 0) {
    score += pathBonus;
    reasons.push(`Relevant directory (+${pathBonus})`);
  }
  const penaltyPaths = ["archive", "backup", "old", "legacy", "deprecated"];
  const pathPenalty = penaltyPaths.filter((pp) => pathParts.some((part) => part.includes(pp))).length * 10;
  if (pathPenalty > 0) {
    score -= pathPenalty;
    reasons.push(`Archive/backup directory (-${pathPenalty})`);
  }
  score = Math.min(100, Math.max(0, score));
  const keywordsMissing = originalTerms.filter((term) => !keywordsFound.map((k) => k.toLowerCase()).includes(term.toLowerCase()));
  return {
    file: filename,
    path: filePath,
    score,
    matchDetails: {
      keywordsFound,
      keywordsMissing,
      matchLocations,
      reasoning: reasons.join(", ")
    }
  };
}
function sortByScore(results) {
  return results.sort((a, b) => b.score - a.score);
}
function formatScoredResults(results, maxResults = 25) {
  var _a, _b, _c;
  const topResults = results.slice(0, maxResults);
  return {
    results: topResults.map((r) => ({
      file: r.file,
      path: r.path,
      score: r.score,
      reasoning: r.matchDetails.reasoning,
      keywordsFound: r.matchDetails.keywordsFound,
      keywordsMissing: r.matchDetails.keywordsMissing,
      contexts: r.contexts,
      created: r.created,
      modified: r.modified,
      fileSize: r.fileSize
    })),
    totalFound: results.length,
    searchSummary: {
      topScore: ((_a = topResults[0]) == null ? void 0 : _a.score) || 0,
      averageScore: topResults.length > 0 ? Math.round(topResults.reduce((sum, r) => sum + r.score, 0) / topResults.length) : 0,
      confidenceLevel: ((_b = topResults[0]) == null ? void 0 : _b.score) >= 70 ? "high" : ((_c = topResults[0]) == null ? void 0 : _c.score) >= 40 ? "medium" : "low"
    }
  };
}
var init_searchScoring = __esm({
  "src/mcp-tools/filesystem/searchScoring.ts"() {
  }
});

// src/utils/searchUtils.ts
var searchUtils_exports = {};
__export(searchUtils_exports, {
  enhanceSearchResults: () => enhanceSearchResults,
  searchSimilarNotes: () => searchSimilarNotes
});
async function searchSimilarNotes(plugin, query, options) {
  try {
    if (!plugin.settings.embeddingsEnabled || !plugin.settings.licenseKey) {
      console.log("[searchUtils] Embeddings disabled or no license key");
      return [];
    }
    const embeddingsManager = plugin.embeddingsManager;
    if (!embeddingsManager) {
      console.log("[searchUtils] No embeddings manager available");
      return [];
    }
    if (!(options == null ? void 0 : options.skipInitialization)) {
      await embeddingsManager.initialize();
    }
    if (await embeddingsManager.isEmpty()) {
      console.log("[searchUtils] No embeddings data available");
      return [];
    }
    const maxResults = (options == null ? void 0 : options.maxResults) || 20;
    const results = await embeddingsManager.searchByQuery(query, maxResults, options == null ? void 0 : options.excludePath);
    return results.map((result) => {
      var _a;
      return {
        path: result.path,
        score: result.score,
        title: result.title,
        content: result.content,
        excerpt: (_a = result.metadata) == null ? void 0 : _a.excerpt
      };
    });
  } catch (error) {
    console.error("[searchUtils] Error in semantic search:", error);
    return [];
  }
}
async function enhanceSearchResults(app, results) {
  const enhanced = await Promise.all(results.map(async (result) => {
    try {
      const file = app.vault.getAbstractFileByPath(result.path);
      if (!(file instanceof import_obsidian9.TFile))
        return result;
      if (!result.content) {
        const content = await app.vault.read(file);
        result.content = content;
      }
      if (!result.excerpt && result.content) {
        const contentWithoutFrontmatter = result.content.replace(/^---[\s\S]*?---\n/, "");
        result.excerpt = contentWithoutFrontmatter.substring(0, 200).trim();
        if (contentWithoutFrontmatter.length > 200) {
          result.excerpt += "...";
        }
      }
      if (!result.title) {
        result.title = file.basename;
      }
      return result;
    } catch (error) {
      console.error("[searchUtils] Error enhancing result:", error);
      return result;
    }
  }));
  return enhanced;
}
var import_obsidian9;
var init_searchUtils = __esm({
  "src/utils/searchUtils.ts"() {
    import_obsidian9 = __toModule(require("obsidian"));
  }
});

// src/mcp-tools/filesystem/tools/SearchOperations.ts
var import_obsidian10, SearchOperations;
var init_SearchOperations = __esm({
  "src/mcp-tools/filesystem/tools/SearchOperations.ts"() {
    import_obsidian10 = __toModule(require("obsidian"));
    init_constants();
    init_utils();
    init_searchScoring();
    SearchOperations = class {
      constructor(app, allowedPaths, plugin) {
        this.app = app;
        this.allowedPaths = allowedPaths;
        this.plugin = plugin;
      }
      async findFiles(params) {
        const { patterns } = params;
        const originalQuery = patterns.join(" ");
        const searchTerms = extractSearchTerms(originalQuery);
        const scoredResults = [];
        const files = this.app.vault.getFiles();
        for (const file of files) {
          if (shouldExcludeFromSearch(file, this.plugin)) {
            continue;
          }
          const scoreResult = calculateScore(file.path, "", {
            searchTerms,
            originalQuery
          });
          scoreResult.created = new Date(file.stat.ctime).toISOString();
          scoreResult.modified = new Date(file.stat.mtime).toISOString();
          scoreResult.fileSize = file.stat.size;
          scoredResults.push(scoreResult);
        }
        const searchFolder = (folder) => {
          var _a, _b;
          for (const child of folder.children) {
            if (child instanceof import_obsidian10.TFolder) {
              const scoreResult = calculateScore(child.path, "", {
                searchTerms,
                originalQuery
              });
              const created = ((_a = child.stat) == null ? void 0 : _a.ctime) ? new Date(child.stat.ctime).toISOString() : void 0;
              const modified = ((_b = child.stat) == null ? void 0 : _b.mtime) ? new Date(child.stat.mtime).toISOString() : void 0;
              if (created)
                scoreResult.created = created;
              if (modified)
                scoreResult.modified = modified;
              scoredResults.push(scoreResult);
              searchFolder(child);
            }
          }
        };
        const rootFolder = this.app.vault.getRoot();
        searchFolder(rootFolder);
        const sortedResults = sortByScore(scoredResults);
        return formatScoredResults(sortedResults, FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS * 3);
      }
      async grepVault(params) {
        const { patterns, searchIn = "content" } = params;
        const originalQuery = patterns.join(" ");
        const searchTerms = extractSearchTerms(originalQuery);
        const metaResults = [];
        const fileHits = [];
        const MAX_CHARS = FILESYSTEM_LIMITS.MAX_RESPONSE_CHARS;
        let currentSize = 0;
        let truncated = false;
        const CONTEXT_CHARS = FILESYSTEM_LIMITS.CONTEXT_CHARS;
        const BATCH_SIZE = FILESYSTEM_LIMITS.BATCH_SIZE;
        const MAX_PROCESSING_TIME = FILESYSTEM_LIMITS.MAX_PROCESSING_TIME;
        const MAX_FILE_SIZE3 = FILESYSTEM_LIMITS.MAX_FILE_SIZE;
        const MAX_MATCHES_PER_FILE = FILESYSTEM_LIMITS.MAX_MATCHES_PER_FILE;
        const metrics = {
          filesProcessed: 0,
          filesSkipped: 0,
          totalMatches: 0,
          processingTime: 0,
          largestFile: 0,
          timeouts: 0
        };
        const startTime = Date.now();
        const getFiles = () => {
          var _a, _b, _c;
          const plugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["systemsculpt-ai"];
          return ((_c = plugin == null ? void 0 : plugin.vaultFileCache) == null ? void 0 : _c.getMarkdownFiles()) || this.app.vault.getMarkdownFiles();
        };
        let filesToSearch = getFiles();
        filesToSearch = filesToSearch.filter((file) => !shouldExcludeFromSearch(file, this.plugin));
        filesToSearch.sort((a, b) => {
          var _a, _b;
          return (((_a = a.stat) == null ? void 0 : _a.size) || 0) - (((_b = b.stat) == null ? void 0 : _b.size) || 0);
        });
        let resultsCount = 0;
        const processFile = async (file) => {
          var _a, _b;
          if (resultsCount >= FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS) {
            return;
          }
          if (Date.now() - startTime > MAX_PROCESSING_TIME) {
            metrics.timeouts++;
            return;
          }
          if (file.stat && file.stat.size > MAX_FILE_SIZE3) {
            metrics.filesSkipped++;
            return;
          }
          if (file.stat && file.stat.size > metrics.largestFile) {
            metrics.largestFile = file.stat.size;
          }
          let hasPathMatch = false;
          for (const pattern of patterns) {
            try {
              const regex = new RegExp(pattern, "i");
              if (regex.test(file.path)) {
                hasPathMatch = true;
                break;
              }
            } catch (e) {
            }
          }
          if (hasPathMatch) {
            const fileResult = {
              file: file.path,
              created: new Date(file.stat.ctime).toISOString(),
              modified: new Date(file.stat.mtime).toISOString(),
              totalMatches: 0,
              contexts: [],
              fileSize: ((_a = file.stat) == null ? void 0 : _a.size) || 0,
              pathMatchOnly: true
            };
            if (!wouldExceedCharLimit(currentSize, fileResult, MAX_CHARS)) {
              fileHits.push(fileResult);
              currentSize += JSON.stringify(fileResult).length;
              resultsCount++;
            } else {
              truncated = true;
            }
            if (resultsCount >= FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS) {
              return;
            }
          }
          try {
            const fullContent = await this.app.vault.cachedRead(file);
            metrics.filesProcessed++;
            if (!fullContent || fullContent.length === 0) {
              return;
            }
            let content = fullContent;
            let contentOffset = 0;
            if (searchIn === "frontmatter" || searchIn === "both") {
              const frontmatterMatch = fullContent.match(/^---\n([\s\S]*?)\n---/);
              if (frontmatterMatch) {
                if (searchIn === "frontmatter") {
                  content = frontmatterMatch[0];
                }
              } else if (searchIn === "frontmatter") {
                return;
              }
            } else if (searchIn === "content") {
              const frontmatterMatch = fullContent.match(/^---\n[\s\S]*?\n---\n/);
              if (frontmatterMatch) {
                content = fullContent.substring(frontmatterMatch[0].length);
                contentOffset = frontmatterMatch[0].length;
              }
            }
            const getLineNumber = createLineCalculator(fullContent);
            const allMatches = [];
            for (const pattern of patterns) {
              const regex = new RegExp(pattern, "gi");
              let match;
              while ((match = regex.exec(content)) !== null && allMatches.length < MAX_MATCHES_PER_FILE) {
                const lineNumber = getLineNumber(match.index + contentOffset);
                allMatches.push({
                  index: match.index + contentOffset,
                  text: match[0],
                  line: lineNumber,
                  pattern
                });
                metrics.totalMatches++;
              }
              regex.lastIndex = 0;
              if (allMatches.length >= MAX_MATCHES_PER_FILE)
                break;
            }
            if (allMatches.length === 0) {
              return;
            }
            if (resultsCount < FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS) {
              const contextWindows = [];
              for (const matchInfo of allMatches) {
                const matchStart = matchInfo.index;
                const matchEnd = matchStart + matchInfo.text.length;
                let contextStart = Math.max(0, matchStart - CONTEXT_CHARS);
                let contextEnd = Math.min(content.length, matchEnd + CONTEXT_CHARS);
                let adjustments = 0;
                while (contextStart > 0 && content[contextStart - 1].match(/\w/) && adjustments < 50) {
                  contextStart--;
                  adjustments++;
                }
                adjustments = 0;
                while (contextEnd < content.length && content[contextEnd].match(/\w/) && adjustments < 50) {
                  contextEnd++;
                  adjustments++;
                }
                let merged = false;
                for (let i = 0; i < contextWindows.length; i++) {
                  const window2 = contextWindows[i];
                  if (contextStart <= window2.end && contextEnd >= window2.start) {
                    window2.start = Math.min(window2.start, contextStart);
                    window2.end = Math.max(window2.end, contextEnd);
                    window2.lines.push(matchInfo.line);
                    window2.matchCount++;
                    merged = true;
                    break;
                  }
                }
                if (!merged) {
                  contextWindows.push({
                    start: contextStart,
                    end: contextEnd,
                    lines: [matchInfo.line],
                    matchCount: 1
                  });
                }
              }
              const fileResults = contextWindows.map((window2) => {
                let contextStr = content.substring(window2.start, window2.end);
                for (const pattern of patterns) {
                  contextStr = contextStr.replace(new RegExp(pattern, "gi"), "\u3010$&\u3011");
                }
                if (window2.start > 0)
                  contextStr = "..." + contextStr;
                if (window2.end < content.length)
                  contextStr = contextStr + "...";
                return {
                  lines: window2.lines,
                  matchCount: window2.matchCount,
                  context: contextStr
                };
              });
              if (fileResults.length > 0) {
                const fileResult = {
                  file: file.path,
                  created: new Date(file.stat.ctime).toISOString(),
                  modified: new Date(file.stat.mtime).toISOString(),
                  totalMatches: allMatches.length,
                  contexts: fileResults,
                  fileSize: ((_b = file.stat) == null ? void 0 : _b.size) || 0
                };
                if (!wouldExceedCharLimit(currentSize, fileResult, MAX_CHARS)) {
                  fileHits.push(fileResult);
                  currentSize += JSON.stringify(fileResult).length;
                  resultsCount++;
                } else {
                  truncated = true;
                }
              }
            }
          } catch (err) {
            metrics.filesSkipped++;
          }
        };
        for (let i = 0; i < filesToSearch.length; i += BATCH_SIZE) {
          if (Date.now() - startTime > MAX_PROCESSING_TIME) {
            metaResults.push({
              file: "_timeout",
              message: `Search timed out after ${MAX_PROCESSING_TIME / 1e3} seconds to prevent UI freeze. Found ${resultsCount} results. Use more specific search terms or paths.`,
              totalMatches: metrics.totalMatches,
              contexts: []
            });
            break;
          }
          if (resultsCount >= FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS) {
            metaResults.push({
              file: "_summary",
              message: `Search stopped after ${FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS} files with matches. More results may exist.`,
              totalMatches: metrics.totalMatches,
              contexts: []
            });
            break;
          }
          const batch = filesToSearch.slice(i, i + BATCH_SIZE);
          await Promise.all(batch.map((file) => processFile(file)));
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
        metrics.processingTime = Date.now() - startTime;
        if (metrics.processingTime > 2e3 || metrics.filesSkipped > 10 || metrics.timeouts > 0) {
          metaResults.push({
            file: "_performance",
            message: `Search completed in ${metrics.processingTime}ms. Processed: ${metrics.filesProcessed} files, Skipped: ${metrics.filesSkipped} files, Total matches: ${metrics.totalMatches}. Largest file: ${Math.round(metrics.largestFile / 1024)}KB.`,
            totalMatches: metrics.totalMatches,
            contexts: []
          });
        }
        if (fileHits.length === 0) {
          metaResults.push({
            file: "_no_matches",
            message: `No matches found for patterns: ${patterns.map((p) => `"${p}"`).join(", ")}. You may want to broaden your patterns, increase context, or specify a narrower search path to speed things up.`,
            totalMatches: 0,
            contexts: []
          });
        }
        const scoredResults = [];
        for (const hit of fileHits) {
          let contentSnippet = "";
          if (hit.contexts && hit.contexts.length > 0) {
            contentSnippet = hit.contexts.map((c) => c.context).join(" ");
          }
          const scoreResult = calculateScore(hit.file, contentSnippet, {
            searchTerms,
            originalQuery
          });
          scoreResult.created = hit.created;
          scoreResult.modified = hit.modified;
          scoreResult.fileSize = hit.fileSize;
          scoreResult.contexts = hit.contexts;
          if (hit.totalMatches > 0) {
            const matchBonus = Math.min(20, hit.totalMatches * 2);
            scoreResult.score = Math.min(100, scoreResult.score + matchBonus);
            scoreResult.matchDetails.reasoning += `, ${hit.totalMatches} content matches (+${matchBonus})`;
          }
          scoredResults.push(scoreResult);
        }
        const sortedResults = sortByScore(scoredResults);
        const formattedResults = formatScoredResults(sortedResults, FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS);
        if (metaResults.length > 0) {
          formattedResults.metaInfo = metaResults;
        }
        if (truncated) {
          formattedResults.truncated = true;
          formattedResults.notice = `Results were truncated to stay within the ${MAX_CHARS} character response cap.`;
        }
        return formattedResults;
      }
      async searchMetadata(params) {
        var _a, _b, _c;
        const { patterns, properties = [], maxResults = 50 } = params;
        const originalQuery = patterns.join(" ");
        const searchTerms = extractSearchTerms(originalQuery);
        const scoredResults = [];
        const files = this.app.vault.getMarkdownFiles();
        for (const file of files) {
          if (shouldExcludeFromSearch(file, this.plugin)) {
            continue;
          }
          try {
            const content = await this.app.vault.cachedRead(file);
            const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
            if (!frontmatterMatch) {
              continue;
            }
            const frontmatterContent = frontmatterMatch[1];
            const lines = frontmatterContent.split("\n");
            const fileProperties = {};
            for (const line of lines) {
              const propertyMatch = line.match(/^(\w+):\s*(.*)$/);
              if (propertyMatch) {
                const [, key, value] = propertyMatch;
                fileProperties[key.toLowerCase()] = value.trim();
              }
            }
            let hasMatch = false;
            let matchedProperties = [];
            let matchedValues = [];
            const propertiesToSearch = properties.length > 0 ? properties.map((p) => p.toLowerCase()) : Object.keys(fileProperties);
            const matchAnyValue = patterns.length === 0 || patterns.length === 1 && patterns[0] === "*";
            if (matchAnyValue && properties.length > 0) {
              for (const prop of propertiesToSearch) {
                if (fileProperties[prop] !== void 0) {
                  hasMatch = true;
                  matchedProperties.push(prop);
                  matchedValues.push(fileProperties[prop]);
                }
              }
            } else {
              for (const prop of propertiesToSearch) {
                const value = fileProperties[prop];
                if (!value)
                  continue;
                for (const pattern of patterns) {
                  try {
                    const regex = new RegExp(pattern, "i");
                    if (regex.test(value) || value.toLowerCase().includes(pattern.toLowerCase())) {
                      hasMatch = true;
                      matchedProperties.push(prop);
                      matchedValues.push(value);
                      break;
                    }
                  } catch (e) {
                    if (value.toLowerCase().includes(pattern.toLowerCase())) {
                      hasMatch = true;
                      matchedProperties.push(prop);
                      matchedValues.push(value);
                    }
                  }
                }
              }
            }
            if (hasMatch) {
              const scoreResult = calculateScore(file.path, "", {
                searchTerms,
                originalQuery
              });
              scoreResult.score = Math.min(100, scoreResult.score + matchedProperties.length * 10);
              scoreResult.created = new Date(file.stat.ctime).toISOString();
              scoreResult.modified = new Date(file.stat.mtime).toISOString();
              scoreResult.fileSize = file.stat.size;
              scoreResult.matchedProperties = matchedProperties;
              scoreResult.matchedValues = matchedValues;
              scoreResult.matchDetails.reasoning += `, ${matchedProperties.length} property matches (+${matchedProperties.length * 10})`;
              scoredResults.push(scoreResult);
            }
          } catch (error) {
            console.error(`Error reading file ${file.path}:`, error);
          }
        }
        const sortedResults = sortByScore(scoredResults);
        const formattedResults = formatScoredResults(sortedResults, maxResults);
        formattedResults.searchSummary = {
          topScore: ((_a = sortedResults[0]) == null ? void 0 : _a.score) || 0,
          averageScore: sortedResults.length > 0 ? Math.round(sortedResults.reduce((sum, r) => sum + r.score, 0) / sortedResults.length) : 0,
          confidenceLevel: ((_b = sortedResults[0]) == null ? void 0 : _b.score) >= 80 ? "high" : ((_c = sortedResults[0]) == null ? void 0 : _c.score) >= 50 ? "medium" : "low",
          propertiesSearched: properties.length > 0 ? properties : "all"
        };
        return formattedResults;
      }
      async searchSimilarNotes(params) {
        var _a, _b, _c;
        const { query } = params;
        if (!this.plugin.settings.embeddingsEnabled) {
          return {
            error: "Embeddings are disabled. Enable embeddings in Settings > SystemSculpt AI > Embeddings to use this tool.",
            results: [],
            searchSummary: {
              topScore: 0,
              averageScore: 0,
              confidenceLevel: "disabled",
              message: "Embeddings feature is disabled"
            }
          };
        }
        if (!this.plugin.settings.licenseKey) {
          return {
            error: "Premium license required. This feature requires a SystemSculpt Pro license.",
            results: [],
            searchSummary: {
              topScore: 0,
              averageScore: 0,
              confidenceLevel: "disabled",
              message: "Premium license required"
            }
          };
        }
        try {
          const { searchSimilarNotes: searchSimilarNotes2 } = await Promise.resolve().then(() => (init_searchUtils(), searchUtils_exports));
          const results = await searchSimilarNotes2(this.plugin, query, { maxResults: 20 });
          const formattedResults = results.map((result) => {
            var _a2;
            return {
              path: result.path,
              score: Math.round(result.score * 100),
              preview: result.excerpt || ((_a2 = result.content) == null ? void 0 : _a2.substring(0, 200)) || "",
              matchDetails: {
                reasoning: `Semantic similarity: ${Math.round(result.score * 100)}%`
              }
            };
          });
          return {
            results: formattedResults,
            searchSummary: {
              topScore: ((_a = formattedResults[0]) == null ? void 0 : _a.score) || 0,
              averageScore: formattedResults.length > 0 ? Math.round(formattedResults.reduce((sum, r) => sum + r.score, 0) / formattedResults.length) : 0,
              confidenceLevel: ((_b = formattedResults[0]) == null ? void 0 : _b.score) >= 80 ? "high" : ((_c = formattedResults[0]) == null ? void 0 : _c.score) >= 50 ? "medium" : "low",
              method: "embeddings"
            }
          };
        } catch (error) {
          return {
            error: `Failed to search similar notes: ${error.message}`,
            results: [],
            searchSummary: {
              topScore: 0,
              averageScore: 0,
              confidenceLevel: "error",
              message: error.message
            }
          };
        }
      }
    };
  }
});

// src/utils/workspaceUtils.ts
function findLeafByPath(app, path) {
  const matchingLeaves = [];
  app.workspace.iterateAllLeaves((leaf) => {
    const view = leaf.view;
    const state = leaf.getViewState();
    const pathFromView = view.file ? (0, import_obsidian11.normalizePath)(view.file.path) : null;
    const pathFromState = state.state && typeof state.state.file === "string" ? (0, import_obsidian11.normalizePath)(state.state.file) : null;
    const leafPath = pathFromView || pathFromState;
    if (leafPath && leafPath === path) {
      matchingLeaves.push(leaf);
    }
  });
  if (matchingLeaves.length === 0) {
    return null;
  }
  const markdownLeaf = matchingLeaves.find((leaf) => leaf.getViewState().type === "markdown");
  if (markdownLeaf) {
    return markdownLeaf;
  }
  return matchingLeaves[0];
}
async function openFileInMainWorkspace(app, filePath) {
  const normalizedPath = (0, import_obsidian11.normalizePath)(filePath);
  const file = app.vault.getAbstractFileByPath(normalizedPath);
  const currentLeaf = app.workspace.activeLeaf;
  if (!file) {
    console.warn(`[SystemSculpt] [Util] File not found at path: ${filePath}`);
    return { leaf: null, action: "error" };
  }
  if (!(file instanceof import_obsidian11.TFile)) {
    console.warn(`[SystemSculpt] [Util] Path is not a file, cannot open: ${filePath}`);
    return { leaf: null, action: "error" };
  }
  const existingFileLeaf = findLeafByPath(app, normalizedPath);
  if (existingFileLeaf && currentLeaf && existingFileLeaf.parent === currentLeaf.parent) {
    app.workspace.setActiveLeaf(existingFileLeaf, { focus: true });
    displayNotice(app, {
      title: "Switched to tab",
      path: normalizedPath
    });
    return { leaf: existingFileLeaf, action: "switched_in_pane" };
  }
  if (existingFileLeaf) {
    app.workspace.setActiveLeaf(existingFileLeaf, { focus: false });
    displayNotice(app, {
      title: "Focused existing tab",
      path: normalizedPath,
      message: "File is in another pane/window."
    });
    return { leaf: existingFileLeaf, action: "focused_other_pane" };
  } else {
    let targetLeaf = null;
    let noticeTitle = "";
    let noticeMessage = "";
    if (import_obsidian11.Platform.isMobile) {
      targetLeaf = app.workspace.getLeaf("tab");
      noticeTitle = "Opened in new tab";
    } else {
      let suitablePane = null;
      app.workspace.iterateAllLeaves((leaf) => {
        if (leaf.getRoot() === app.workspace.rootSplit && leaf !== currentLeaf) {
          if (!suitablePane)
            suitablePane = leaf;
        }
      });
      if (suitablePane) {
        app.workspace.setActiveLeaf(suitablePane, { focus: false });
        targetLeaf = app.workspace.getLeaf("tab");
        noticeTitle = "Opened in new tab";
        noticeMessage = "Added to an existing pane in the main workspace.";
      } else {
        if (currentLeaf && currentLeaf.getRoot() === app.workspace.rootSplit) {
          targetLeaf = app.workspace.createLeafBySplit(currentLeaf, "vertical", true);
          noticeTitle = "Opened in new split";
          noticeMessage = "Created a side-by-side view with the chat.";
        } else {
          targetLeaf = app.workspace.getLeaf(true);
          noticeTitle = "Opened in new pane";
          noticeMessage = "Created a new pane in the main workspace.";
        }
      }
    }
    if (targetLeaf) {
      await targetLeaf.openFile(file);
      displayNotice(app, {
        title: noticeTitle,
        path: normalizedPath,
        message: noticeMessage
      });
      return { leaf: targetLeaf, action: "created_new" };
    }
  }
  return { leaf: null, action: "error" };
}
var import_obsidian11;
var init_workspaceUtils = __esm({
  "src/utils/workspaceUtils.ts"() {
    import_obsidian11 = __toModule(require("obsidian"));
    init_notifications();
  }
});

// src/utils/helpers.ts
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var init_helpers = __esm({
  "src/utils/helpers.ts"() {
  }
});

// src/services/DocumentProcessingService.ts
var import_obsidian12, DocumentProcessingService;
var init_DocumentProcessingService = __esm({
  "src/services/DocumentProcessingService.ts"() {
    import_obsidian12 = __toModule(require("obsidian"));
    init_SystemSculptService();
    init_api();
    init_helpers();
    DocumentProcessingService = class {
      constructor(app, plugin) {
        this.imageMetadataLog = [];
        this.app = app;
        this.plugin = plugin;
        this.sculptService = SystemSculptService.getInstance(plugin);
      }
      static getInstance(app, plugin) {
        if (!DocumentProcessingService.instance) {
          DocumentProcessingService.instance = new DocumentProcessingService(app, plugin);
        }
        return DocumentProcessingService.instance;
      }
      async processDocument(file, options = {}) {
        const { onProgress, addToContext = false, showNotices = true } = options;
        const progressHandler = onProgress || (() => {
        });
        try {
          const hasValidLicense = await this.plugin.getLicenseManager().validateLicenseKey(true, false);
          if (!hasValidLicense) {
            throw new Error("Valid license required for document processing");
          }
          progressHandler(0, "Processing document...", "loader-2");
          console.log(`[DocumentProcessingService] Starting document conversion for: ${file.path}`);
          progressHandler(10, "Uploading document...", "upload");
          let uploadResult;
          try {
            uploadResult = await this.sculptService.uploadDocument(file);
            console.log(`[DocumentProcessingService] Document uploaded, ID: ${uploadResult.documentId}, Status: ${uploadResult.status}, Cached: ${uploadResult.cached}`);
          } catch (uploadError) {
            console.error("[DocumentProcessingService] Document upload error:", uploadError);
            progressHandler(0, `Upload failed: ${uploadError instanceof Error ? uploadError.message : String(uploadError)}`, "x-circle");
            throw uploadError;
          }
          const { documentId, cached } = uploadResult;
          if (cached) {
            progressHandler(50, "Found cached version", "check");
            console.log(`[DocumentProcessingService] Using cached version of document: ${documentId}`);
            try {
              const extractionData = await this.downloadExtraction(documentId);
              const extractionPath = await this.saveExtractionResults(file, extractionData, {
                addToContext,
                progressHandler
              });
              progressHandler(100, "Processing complete!", "check-circle");
              if (showNotices) {
                new import_obsidian12.Notice("Document successfully converted to markdown");
              }
              return extractionPath;
            } catch (cacheError) {
              console.error("[DocumentProcessingService] Error using cached version:", cacheError);
              progressHandler(0, "Error retrieving cached version. Please try again.", "x-circle");
              throw cacheError;
            }
          }
          progressHandler(30, "Processing document...", "loader-2");
          console.log(`[DocumentProcessingService] Polling for document status: ${documentId}`);
          const pollResult = await this.pollUntilComplete(documentId, progressHandler);
          if (!pollResult) {
            console.log(`[DocumentProcessingService] Document processing incomplete: ${documentId}`);
            throw new Error("Document processing failed or timed out");
          }
          progressHandler(80, "Downloading results...", "download");
          console.log(`[DocumentProcessingService] Downloading extraction for document: ${documentId}`);
          try {
            const downloadPromise = this.downloadExtraction(documentId);
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => {
              console.error(`[DocumentProcessingService] Download timed out for document: ${documentId}`);
              reject(new Error("Download timed out"));
            }, 3e4));
            let extractionData = await Promise.race([downloadPromise, timeoutPromise]);
            console.log(`[DocumentProcessingService] Extraction downloaded successfully for document: ${documentId}`);
            if (!extractionData || typeof extractionData === "object" && !extractionData.content && !extractionData.text && !extractionData.markdown && !extractionData.extraction) {
              console.log(`[DocumentProcessingService] Extraction data is empty, trying fallback approach...`);
              try {
                const fallbackUrl = `${this.sculptService.baseUrl}/documents/${documentId}/raw`;
                console.log(`[DocumentProcessingService] Trying fallback URL: ${fallbackUrl}`);
                const fallbackResponse = await fetch(fallbackUrl, {
                  headers: {
                    "x-license-key": this.plugin.settings.licenseKey || ""
                  }
                });
                if (fallbackResponse.ok) {
                  const rawText = await fallbackResponse.text();
                  if (rawText && rawText.length > 0) {
                    console.log(`[DocumentProcessingService] Fallback successful, got ${rawText.length} characters`);
                    extractionData = { content: rawText };
                  }
                }
              } catch (fallbackError) {
                console.error(`[DocumentProcessingService] Fallback approach failed:`, fallbackError);
              }
            }
            const extractionPath = await this.saveExtractionResults(file, extractionData, {
              addToContext,
              progressHandler
            });
            console.log(`[DocumentProcessingService] Extraction saved to: ${extractionPath}`);
            progressHandler(100, "Processing complete!", "check-circle");
            if (showNotices) {
              new import_obsidian12.Notice("Document successfully converted to markdown");
            }
            return extractionPath;
          } catch (downloadError) {
            console.error("[DocumentProcessingService] Error downloading extraction:", downloadError);
            progressHandler(0, "Error downloading results. The server might be experiencing issues.", "x-circle");
            throw downloadError;
          }
        } catch (error) {
          console.error("[DocumentProcessingService] Error processing document:", error);
          progressHandler(0, `Error: ${error instanceof Error ? error.message : String(error)}`, "x-circle");
          if (showNotices) {
            new import_obsidian12.Notice(`Failed to process document: ${error instanceof Error ? error.message : String(error)}`);
          }
          throw error;
        }
      }
      async pollUntilComplete(documentId, progressHandler, maxAttempts = 30) {
        let consecutiveErrors = 0;
        const maxConsecutiveErrors = 5;
        for (let i = 0; i < maxAttempts; i++) {
          try {
            const baseUrl = this.sculptService.baseUrl;
            const endpoint = SYSTEMSCULPT_API_ENDPOINTS.DOCUMENTS.GET(documentId);
            const url = `${baseUrl}${endpoint}`;
            console.log(`[DocumentProcessingService] Polling document status: ${url}`);
            const response = await fetch(url, {
              headers: {
                "Content-Type": "application/json",
                "x-license-key": this.plugin.settings.licenseKey || ""
              }
            });
            if (!response.ok) {
              console.error(`[DocumentProcessingService] Status check failed: ${response.status} ${response.statusText}`);
              consecutiveErrors++;
              try {
                const errorText = await response.text();
                if (errorText) {
                  console.error(`[DocumentProcessingService] Error response: ${errorText}`);
                }
              } catch (e) {
              }
              if (progressHandler) {
                if (response.status === 500) {
                  progressHandler(30 + i / maxAttempts * 20, "Server error, retrying...", "alert-triangle");
                } else {
                  progressHandler(30 + i / maxAttempts * 20, `Error: ${response.status} ${response.statusText}`, "alert-triangle");
                }
              }
              if (consecutiveErrors >= maxConsecutiveErrors) {
                if (progressHandler) {
                  progressHandler(0, "Server is experiencing issues. Please try again later.", "x-circle");
                }
                await sleep(3e3);
                return false;
              }
              await sleep(3e3);
              continue;
            }
            consecutiveErrors = 0;
            const data = await response.json();
            console.log(`[DocumentProcessingService] Document status: ${data.status}`);
            if (data.status === "completed") {
              return true;
            } else if (data.status === "failed") {
              if (progressHandler) {
                progressHandler(0, data.error || "Processing failed", "x-circle");
              }
              await sleep(3e3);
              return false;
            }
            if (progressHandler) {
              const progress = Math.min(30 + i / maxAttempts * 50, 80);
              progressHandler(progress, "Processing document...", "loader-2");
            }
          } catch (error) {
            console.error("[DocumentProcessingService] Error polling document status:", error);
            consecutiveErrors++;
            if (progressHandler) {
              progressHandler(30 + i / maxAttempts * 20, "Connection issue, retrying...", "alert-triangle");
            }
            if (consecutiveErrors >= maxConsecutiveErrors) {
              if (progressHandler) {
                progressHandler(0, "Too many connection errors. Please check your internet connection and try again.", "x-circle");
              }
              await sleep(3e3);
              return false;
            }
          }
          await sleep(2e3);
        }
        if (progressHandler) {
          progressHandler(0, "Document processing is taking longer than expected. Please try again later.", "clock");
        }
        await sleep(3e3);
        return false;
      }
      async downloadExtraction(documentId) {
        try {
          const baseUrl = this.sculptService.baseUrl;
          const endpoint = SYSTEMSCULPT_API_ENDPOINTS.DOCUMENTS.DOWNLOAD(documentId);
          const url = `${baseUrl}${endpoint}`;
          console.log(`[DocumentProcessingService] Downloading extraction: ${url}`);
          const response = await fetch(url, {
            headers: {
              "Content-Type": "application/json",
              "x-license-key": this.plugin.settings.licenseKey || ""
            }
          });
          if (!response.ok) {
            console.error(`[DocumentProcessingService] Download failed: ${response.status} ${response.statusText}`);
            throw new Error(`Failed to download extraction: ${response.statusText}`);
          }
          const data = await response.json();
          console.log(`[DocumentProcessingService] Extraction downloaded successfully`);
          if (!data || typeof data === "object" && !data.content && !data.text) {
            console.error(`[DocumentProcessingService] Empty extraction data received:`, data);
            throw new Error("Empty extraction data received from server");
          }
          return data;
        } catch (error) {
          console.error("[DocumentProcessingService] Error downloading extraction:", error);
          throw error;
        }
      }
      async saveExtractionResults(file, data, options = {}) {
        var _a;
        const { addToContext = false } = options;
        try {
          console.log(`[DocumentProcessingService] Saving extraction results for: ${file.path}`);
          const extractionFolder = this.sculptService.extractionsDirectory;
          const baseName = this.sanitizeFilename(file.basename);
          const parentPath = extractionFolder ? `${extractionFolder}/${baseName}` : `${((_a = file.parent) == null ? void 0 : _a.path) || ""}/${baseName}`;
          console.log(`[DocumentProcessingService] Target extraction folder: ${parentPath}`);
          if (this.plugin.directoryManager) {
            await this.plugin.directoryManager.ensureDirectoryByPath(parentPath);
            console.log(`[DocumentProcessingService] Directory created using DirectoryManager: ${parentPath}`);
          } else {
            await this.plugin.createDirectory(parentPath);
            console.log(`[DocumentProcessingService] Directory created using legacy method: ${parentPath}`);
          }
          let processedContent = data;
          const images = this.extractImagesFromData(data);
          if (images && Object.keys(images).length > 0) {
            processedContent.images = images;
            console.log(`[DocumentProcessingService] Processing ${Object.keys(images).length} images`);
            const documentId = this.sanitizeFilename(baseName).substring(0, 20);
            const imagesPath = `${parentPath}/images-${documentId}`;
            const directoryExists = await this.app.vault.adapter.exists(imagesPath);
            console.log(`[DocumentProcessingService] Images directory ${directoryExists ? "already exists" : "does not exist"}: ${imagesPath}`);
            if (directoryExists) {
              try {
                const files = await this.app.vault.adapter.list(imagesPath);
                if (files && files.files && files.files.length > 0) {
                  console.log(`[DocumentProcessingService] Cleaning up ${files.files.length} existing images in directory`);
                  for (const file2 of files.files) {
                    await this.app.vault.adapter.remove(file2);
                    console.log(`[DocumentProcessingService] Removed existing image: ${file2}`);
                  }
                }
              } catch (error) {
                console.error(`[DocumentProcessingService] Error cleaning up existing images directory:`, error);
              }
            }
            if (this.plugin.directoryManager) {
              await this.plugin.directoryManager.ensureDirectoryByPath(imagesPath);
              console.log(`[DocumentProcessingService] Images directory created: ${imagesPath}`);
            } else {
              await this.plugin.createDirectory(imagesPath);
              console.log(`[DocumentProcessingService] Images directory created using legacy method: ${imagesPath}`);
            }
            const imagePathMap = new Map();
            const processedImages = new Map();
            for (const [imageName, imageBase64] of Object.entries(images)) {
              try {
                const imageHash = this.simpleHash(imageBase64.substring(0, 1e3));
                const existingImage = processedImages.get(imageHash);
                if (existingImage) {
                  console.log(`[DocumentProcessingService] Detected duplicate image: ${imageName} (using ${existingImage})`);
                  imagePathMap.set(imageName, existingImage);
                  continue;
                }
                const uniqueImageName = this.generateUniqueImageName(baseName, imageName, imageBase64);
                const imagePath = this.normalizePath(`${imagesPath}/${uniqueImageName}`);
                console.log(`[DocumentProcessingService] Processing image: ${imageName} -> ${uniqueImageName}`);
                const imageArrayBuffer = this.base64ToArrayBuffer(imageBase64);
                if (imageArrayBuffer.byteLength < 100) {
                  console.warn(`[DocumentProcessingService] Suspicious image data for ${imageName}: size ${imageArrayBuffer.byteLength} bytes`);
                }
                await this.app.vault.createBinary(imagePath, imageArrayBuffer);
                console.log(`[DocumentProcessingService] Saved image: ${imagePath}`);
                const folderName = imagesPath.split("/").pop() || "images";
                const relativeImagePath = `${folderName}/${uniqueImageName}`;
                imagePathMap.set(imageName, relativeImagePath);
                processedImages.set(imageHash, relativeImagePath);
                this.recordImageMetadata({
                  originalName: imageName,
                  newName: uniqueImageName,
                  path: imagePath,
                  size: imageArrayBuffer.byteLength,
                  documentName: file.basename,
                  timestamp: Date.now()
                });
                if (addToContext) {
                }
              } catch (imageError) {
                console.error(`[DocumentProcessingService] Error saving image ${imageName}:`, imageError);
              }
            }
            if (processedContent.content && imagePathMap.size > 0) {
              let updatedContent = processedContent.content;
              imagePathMap.forEach((newPath, originalName) => {
                try {
                  const escapedOriginalName = originalName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                  const imgRegex = new RegExp(`!\\[([^\\]]*)\\]\\(${escapedOriginalName}\\)`, "g");
                  updatedContent = updatedContent.replace(imgRegex, `![$1](${newPath})`);
                  const imgRegexNoAlt = new RegExp(`!\\[\\]\\(${escapedOriginalName}\\)`, "g");
                  updatedContent = updatedContent.replace(imgRegexNoAlt, `![](${newPath})`);
                  const htmlImgRegex = new RegExp(`<img[^>]*src=["']${escapedOriginalName}["'][^>]*>`, "g");
                  updatedContent = updatedContent.replace(htmlImgRegex, (match) => {
                    return match.replace(escapedOriginalName, newPath);
                  });
                  const filenameOnly = escapedOriginalName.split("/").pop();
                  if (filenameOnly && filenameOnly !== escapedOriginalName) {
                    const filenameRegex = new RegExp(`!\\[([^\\]]*)\\]\\(${filenameOnly}\\)`, "g");
                    updatedContent = updatedContent.replace(filenameRegex, `![$1](${newPath})`);
                  }
                  console.log(`[DocumentProcessingService] Replaced image reference: ${originalName} -> ${newPath}`);
                } catch (regexError) {
                  console.error(`[DocumentProcessingService] Error replacing image reference for ${originalName}:`, regexError);
                }
              });
              processedContent.content = updatedContent;
            }
          }
          const extractionPath = this.normalizePath(`${parentPath}/${baseName}-extraction.md`);
          console.log(`[DocumentProcessingService] Extraction file path: ${extractionPath}`);
          if (!processedContent) {
            console.error(`[DocumentProcessingService] Invalid extraction data:`, processedContent);
            throw new Error("Invalid extraction data received");
          }
          const content = this.formatExtractionContent(processedContent);
          console.log(`[DocumentProcessingService] Formatted content length: ${content.length} characters`);
          const existingFile = this.app.vault.getAbstractFileByPath(extractionPath);
          if (existingFile instanceof import_obsidian12.TFile) {
            console.log(`[DocumentProcessingService] Updating existing file: ${extractionPath}`);
            await this.app.vault.modify(existingFile, content);
          } else {
            console.log(`[DocumentProcessingService] Creating new file: ${extractionPath}`);
            await this.app.vault.create(extractionPath, content);
          }
          console.log(`[DocumentProcessingService] Extraction saved successfully to: ${extractionPath}`);
          return extractionPath;
        } catch (error) {
          console.error(`[DocumentProcessingService] Error saving extraction results:`, error);
          throw error;
        }
      }
      formatExtractionContent(data) {
        let title = "Document Extraction";
        let content = "";
        console.log(`[DocumentProcessingService] Formatting extraction content, data:`, data);
        if (data) {
          if (data.title) {
            title = data.title;
          } else if (data.metadata && data.metadata.title) {
            title = data.metadata.title;
          } else if (data.document && data.document.title) {
            title = data.document.title;
          }
          if (data.content) {
            content = data.content;
          } else if (data.text) {
            content = data.text;
          } else if (data.document && data.document.content) {
            content = data.document.content;
          } else if (data.document && data.document.text) {
            content = data.document.text;
          } else if (typeof data === "string") {
            content = data;
          } else if (data.markdown) {
            content = data.markdown;
          } else if (data.extraction) {
            content = data.extraction;
          }
        }
        if (!content && data) {
          try {
            if (typeof data === "object") {
              content = JSON.stringify(data, null, 2);
              console.log(`[DocumentProcessingService] Using stringified data as content`);
            }
          } catch (e) {
            console.error(`[DocumentProcessingService] Error stringifying data:`, e);
          }
        }
        if (!content) {
          content = "No content was extracted from this document. The server may be experiencing issues or the document format is not supported.";
        }
        let imageNote = "";
        if (data && data.images && Object.keys(data.images).length > 0) {
          const imageCount = Object.keys(data.images).length;
          let folderInfo = "the images folder";
          if (this.imageMetadataLog && this.imageMetadataLog.length > 0) {
            const firstImage = this.imageMetadataLog[this.imageMetadataLog.length - imageCount];
            if (firstImage && firstImage.path) {
              const pathParts = firstImage.path.split("/");
              if (pathParts.length >= 2) {
                folderInfo = `the '${pathParts[pathParts.length - 2]}' folder`;
              }
            }
          }
          imageNote = `

> [!note] Images
> ${imageCount} image${imageCount > 1 ? "s were" : " was"} extracted from this document and saved in ${folderInfo}.
`;
        }
        return `# ${title}

${content}${imageNote}

---
Extracted with SystemSculpt
`;
      }
      extractImagesFromData(data) {
        const images = {};
        if (!data)
          return images;
        if (data.images && typeof data.images === "object") {
          Object.entries(data.images).forEach(([key, value]) => {
            if (typeof value === "string") {
              images[key] = value;
            }
          });
        }
        if (data.document && data.document.images && typeof data.document.images === "object") {
          Object.entries(data.document.images).forEach(([key, value]) => {
            if (typeof value === "string") {
              images[key] = value;
            }
          });
        }
        if (data.imageList && Array.isArray(data.imageList)) {
          data.imageList.forEach((img, index) => {
            if (img && typeof img.data === "string") {
              const name = img.name || `image-${index}.png`;
              images[name] = img.data;
            }
          });
        }
        if (data.figures && Array.isArray(data.figures)) {
          data.figures.forEach((fig, index) => {
            if (fig && typeof fig.image === "string") {
              const name = fig.name || `figure-${index}.png`;
              images[name] = fig.image;
            }
          });
        }
        console.log(`[DocumentProcessingService] Extracted ${Object.keys(images).length} images from data`);
        return images;
      }
      generateUniqueImageName(baseName, imageName, imageData) {
        var _a;
        const extension = ((_a = imageName.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "png";
        const sanitizedBaseName = this.sanitizeFilename(baseName);
        let contentHash = "";
        if (imageData) {
          try {
            const sampleData = imageData.substring(0, 1e3);
            contentHash = this.simpleHash(sampleData);
          } catch (e) {
            console.error("[DocumentProcessingService] Error generating content hash:", e);
            contentHash = this.simpleHash(`${baseName}-${imageName}`);
          }
        } else {
          contentHash = this.simpleHash(`${baseName}-${imageName}`);
        }
        const sanitizedImageName = this.sanitizeFilename(imageName.split(".")[0]);
        return `${sanitizedBaseName}-${sanitizedImageName}-${contentHash}.${extension}`;
      }
      simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return (hash >>> 0).toString(16).substring(0, 8);
      }
      base64ToArrayBuffer(base64) {
        const base64Data = base64.replace(/^data:image\/(png|jpeg|jpg|gif);base64,/, "");
        const binaryString = window.atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      }
      recordImageMetadata(metadata) {
        try {
          this.imageMetadataLog.push(metadata);
          console.log(`[DocumentProcessingService] Image metadata recorded: ${metadata.originalName} -> ${metadata.newName}`);
        } catch (e) {
          console.error("[DocumentProcessingService] Error recording image metadata:", e);
        }
      }
      sanitizeFilename(filename) {
        return filename.replace(/[^a-zA-Z0-9-_]/g, "-");
      }
      normalizePath(path) {
        return path.replace(/\\/g, "/").replace(/^\/+|\/+$/g, "");
      }
    };
  }
});

// src/core/ui/components/LoadingIndicator.ts
var init_LoadingIndicator = __esm({
  "src/core/ui/components/LoadingIndicator.ts"() {
  }
});

// src/core/ui/components/Button.ts
var init_Button = __esm({
  "src/core/ui/components/Button.ts"() {
  }
});

// src/core/ui/modals/standard/StandardModal.ts
var import_obsidian13, StandardModal;
var init_StandardModal = __esm({
  "src/core/ui/modals/standard/StandardModal.ts"() {
    import_obsidian13 = __toModule(require("obsidian"));
    StandardModal = class extends import_obsidian13.Modal {
      constructor(app) {
        super(app);
        this.listeners = [];
        this.modalEl.addClass("ss-modal");
      }
      onOpen() {
        this.createModalStructure();
      }
      onClose() {
        this.removeAllListeners();
        this.modalEl.empty();
      }
      registerDomEvent(element, type, listener) {
        element.addEventListener(type, listener);
        this.listeners.push({ element, type, listener });
      }
      removeAllListeners() {
        this.listeners.forEach(({ element, type, listener }) => {
          element.removeEventListener(type, listener);
        });
        this.listeners = [];
      }
      createModalStructure() {
        this.modalEl.empty();
        this.headerEl = this.modalEl.createDiv("ss-modal__header");
        this.contentEl = this.modalEl.createDiv("ss-modal__content");
        this.footerEl = this.modalEl.createDiv("ss-modal__footer");
      }
      setSize(size) {
        this.modalEl.removeClass("ss-modal--small", "ss-modal--medium", "ss-modal--large", "ss-modal--fullwidth");
        this.modalEl.addClass(`ss-modal--${size}`);
      }
      addToHeader(el) {
        this.headerEl.appendChild(el);
      }
      addToContent(el) {
        this.contentEl.appendChild(el);
      }
      addToFooter(el) {
        this.footerEl.appendChild(el);
      }
      addTitle(title, description) {
        const titleContainer = this.headerEl.createDiv({ cls: "ss-modal__title-container" });
        titleContainer.createEl("h2", { text: title, cls: "ss-modal__title" });
        const closeButton = titleContainer.createDiv({ cls: "ss-modal__close-button" });
        (0, import_obsidian13.setIcon)(closeButton, "x");
        this.registerDomEvent(closeButton, "click", () => this.close());
        if (description) {
          this.headerEl.createDiv({ text: description, cls: "ss-modal__description" });
        }
      }
      addActionButton(text, callback, primary = false, icon) {
        const button = this.footerEl.createEl("button", {
          cls: primary ? "ss-button ss-button--primary" : "ss-button ss-button--secondary"
        });
        if (icon) {
          const iconEl = button.createSpan("ss-button__icon");
          (0, import_obsidian13.setIcon)(iconEl, icon);
        }
        button.appendChild(document.createTextNode(text));
        this.registerDomEvent(button, "click", callback);
        return button;
      }
      addSearchBar(placeholder, callback) {
        const searchContainer = this.contentEl.createDiv("ss-modal__search");
        const searchIcon = searchContainer.createDiv("ss-modal__search-icon");
        (0, import_obsidian13.setIcon)(searchIcon, "search");
        const searchInput = searchContainer.createEl("input", {
          type: "text",
          placeholder,
          cls: "ss-modal__search-input"
        });
        const clearButton = searchContainer.createDiv("ss-modal__search-clear");
        (0, import_obsidian13.setIcon)(clearButton, "x");
        clearButton.style.display = "none";
        this.registerDomEvent(searchInput, "input", () => {
          const value = searchInput.value;
          clearButton.style.display = value ? "flex" : "none";
          callback(value);
        });
        this.registerDomEvent(clearButton, "click", () => {
          searchInput.value = "";
          clearButton.style.display = "none";
          callback("");
          searchInput.focus();
        });
        return searchInput;
      }
      addFilterButtons(filters, callback) {
        const filterContainer = this.contentEl.createDiv("ss-modal__filter");
        const filterGroup = filterContainer.createDiv("ss-modal__filter-group");
        filters.forEach((filter) => {
          const button = filterGroup.createEl("button", {
            cls: `ss-button ss-button--small ${filter.active ? "ss-active" : ""}`,
            attr: {
              "data-filter-id": filter.id
            }
          });
          if (filter.icon) {
            const iconContainer = button.createSpan("ss-button__icon");
            (0, import_obsidian13.setIcon)(iconContainer, filter.icon);
          }
          button.appendChild(document.createTextNode(filter.label));
          this.registerDomEvent(button, "click", () => {
            const isActive = button.classList.toggle("ss-active");
            callback(filter.id, isActive);
          });
        });
        return filterContainer;
      }
      createItem(title, description, icon, badge) {
        const item = document.createElement("div");
        item.className = "ss-modal__item";
        if (icon) {
          const iconEl = item.createDiv("ss-modal__item-icon");
          (0, import_obsidian13.setIcon)(iconEl, icon);
        }
        const content = item.createDiv("ss-modal__item-content");
        content.createDiv({ text: title, cls: "ss-modal__item-title" });
        if (description) {
          content.createDiv({ text: description, cls: "ss-modal__item-description" });
        }
        if (badge) {
          const badgeEl = item.createSpan({ text: badge, cls: "ss-modal__item-badge" });
        }
        return item;
      }
    };
  }
});

// src/core/ui/modals/standard/TextEditModal.ts
var init_TextEditModal = __esm({
  "src/core/ui/modals/standard/TextEditModal.ts"() {
    init_StandardModal();
    init_types();
  }
});

// src/core/ui/services/KeyboardNavigationService.ts
var import_obsidian14, KeyboardNavigationService;
var init_KeyboardNavigationService = __esm({
  "src/core/ui/services/KeyboardNavigationService.ts"() {
    import_obsidian14 = __toModule(require("obsidian"));
    KeyboardNavigationService = class extends import_obsidian14.Component {
      constructor(container, options = {}) {
        super();
        this.container = container;
        this.focusedIndex = -1;
        this.itemCount = 0;
        this.options = {
          multiSelect: false,
          closeOnSelect: true,
          allowSpaceToggle: false,
          ...options
        };
        this.registerDomEvent(this.container, "keydown", this.handleKeyDown.bind(this));
      }
      setItemCount(count) {
        this.itemCount = count;
        if (this.focusedIndex >= count) {
          this.focusedIndex = count > 0 ? count - 1 : -1;
        }
      }
      getFocusedIndex() {
        return this.focusedIndex;
      }
      setFocusedIndex(index) {
        if (index >= -1 && index < this.itemCount) {
          this.focusedIndex = index;
          if (this.options.onFocus && index >= 0) {
            this.options.onFocus(index);
          }
        }
      }
      clearFocus() {
        this.focusedIndex = -1;
      }
      handleKeyDown(event) {
        if (this.itemCount === 0)
          return;
        if (event.key === "ArrowDown") {
          event.preventDefault();
          const newIndex = this.focusedIndex < 0 ? 0 : Math.min(this.focusedIndex + 1, this.itemCount - 1);
          this.setFocusedIndex(newIndex);
        } else if (event.key === "ArrowUp") {
          event.preventDefault();
          const newIndex = this.focusedIndex < 0 ? 0 : Math.max(this.focusedIndex - 1, 0);
          this.setFocusedIndex(newIndex);
        } else if (event.key === "Enter" && this.focusedIndex !== -1) {
          event.preventDefault();
          if ((event.metaKey || event.ctrlKey) && this.options.multiSelect) {
            if (this.options.onConfirm) {
              this.options.onConfirm();
            }
          } else {
            if (this.options.onSelect) {
              this.options.onSelect(this.focusedIndex);
            }
            if (this.options.multiSelect && this.options.onToggle) {
              this.options.onToggle(this.focusedIndex);
            }
          }
        } else if (event.code === "Space" && this.focusedIndex !== -1 && this.options.allowSpaceToggle) {
          event.preventDefault();
          if (this.options.onToggle) {
            this.options.onToggle(this.focusedIndex);
          }
        } else if (event.key === "Tab") {
          if (this.itemCount > 0) {
            if (event.shiftKey) {
              const newIndex = this.focusedIndex <= 0 ? this.itemCount - 1 : this.focusedIndex - 1;
              this.setFocusedIndex(newIndex);
            } else {
              const newIndex = this.focusedIndex >= this.itemCount - 1 ? 0 : this.focusedIndex + 1;
              this.setFocusedIndex(newIndex);
            }
          }
        }
      }
    };
  }
});

// src/core/ui/index.ts
var init_ui = __esm({
  "src/core/ui/index.ts"() {
    init_LoadingIndicator();
    init_Button();
    init_TextEditModal();
    init_PopupModal();
    init_notifications();
    init_KeyboardNavigationService();
  }
});

// src/core/license/LicenseChecker.ts
var LicenseChecker;
var init_LicenseChecker = __esm({
  "src/core/license/LicenseChecker.ts"() {
    init_ui();
    init_types();
    LicenseChecker = class {
      static requiresProLicense(extension) {
        return this.PRO_EXTENSIONS.includes(extension.toLowerCase());
      }
      static hasValidLicense(plugin) {
        var _a;
        return ((_a = plugin.settings.licenseKey) == null ? void 0 : _a.trim()) && plugin.settings.licenseValid;
      }
      static async showProFeaturePopup(app) {
        const result = await showPopup(app, "Support SystemSculpt's development and unlock powerful document processing features. Upgrade to Pro to process PDFs, Word documents, and audio files.", {
          title: "Pro Feature Required",
          primaryButton: "Get License",
          secondaryButton: "Maybe Later",
          icon: "sparkles"
        });
        if (result == null ? void 0 : result.confirmed) {
          window.open(LICENSE_URL, "_blank");
        }
        return (result == null ? void 0 : result.confirmed) || false;
      }
      static async checkLicenseForFile(file, app, plugin) {
        if (this.requiresProLicense(file.extension.toLowerCase())) {
          if (!this.hasValidLicense(plugin)) {
            await this.showProFeaturePopup(app);
            return false;
          }
        }
        return true;
      }
    };
    LicenseChecker.PRO_EXTENSIONS = [
      "pdf",
      "doc",
      "docx",
      "ppt",
      "pptx",
      "xls",
      "xlsx",
      "mp3",
      "wav",
      "m4a",
      "ogg",
      "webm"
    ];
  }
});

// src/services/DocumentContextManager.ts
var DocumentContextManager_exports = {};
__export(DocumentContextManager_exports, {
  DocumentContextManager: () => DocumentContextManager
});
var import_obsidian15, DocumentContextManager;
var init_DocumentContextManager = __esm({
  "src/services/DocumentContextManager.ts"() {
    import_obsidian15 = __toModule(require("obsidian"));
    init_DocumentProcessingService();
    init_LicenseChecker();
    DocumentContextManager = class {
      constructor(app, plugin) {
        this.app = app;
        this.plugin = plugin;
        this.documentProcessingService = DocumentProcessingService.getInstance(app, plugin);
      }
      static getInstance(app, plugin) {
        if (!DocumentContextManager.instance) {
          DocumentContextManager.instance = new DocumentContextManager(app, plugin);
        }
        return DocumentContextManager.instance;
      }
      async addFileToContext(file, contextManager, options = {}) {
        const { showNotices = true, updateUI = true, saveChanges = true } = options;
        console.log(`[DocumentContextManager] Adding file to context: ${file.path}`);
        try {
          if (!await LicenseChecker.checkLicenseForFile(file, this.app, this.plugin)) {
            return false;
          }
          const extension = file.extension.toLowerCase();
          const datalabDocExtensions = ["pdf", "doc", "docx", "xls", "xlsx", "ppt", "pptx"];
          const audioExtensions = ["wav", "m4a", "webm", "ogg", "mp3"];
          let contextPath;
          if (datalabDocExtensions.includes(extension)) {
            try {
              console.log(`[DocumentContextManager] Processing document file: ${file.path}`);
              const extractionPath = await this.documentProcessingService.processDocument(file, {
                onProgress: (progress, status, icon) => {
                  contextManager.updateProcessingStatus(file, status, icon);
                },
                showNotices: false,
                addToContext: false
              });
              console.log(`[DocumentContextManager] Document processed, path: ${extractionPath}`);
              contextManager.updateProcessingStatus(file, "Added successfully!", "check-circle", true);
              const mdWikiLink = `[[${extractionPath}]]`;
              contextManager.addToContextFiles(mdWikiLink);
              await this.addExtractedImagesToContext(extractionPath, contextManager);
              contextPath = extractionPath;
            } catch (error) {
              console.error(`[DocumentContextManager] Error processing document: ${error.message}`);
              contextManager.updateProcessingStatus(file, `Error: ${error.message}`, "x-circle");
              if (showNotices) {
                new import_obsidian15.Notice(`Error processing ${file.basename}: ${error.message}`, 5e3);
              }
              return false;
            }
          } else if (audioExtensions.includes(extension)) {
            try {
              console.log(`[DocumentContextManager] Processing audio file: ${file.path}`);
              const transcriptionPath = await contextManager.processAudioFile(file);
              console.log(`[DocumentContextManager] Audio processed, path: ${transcriptionPath}`);
              contextManager.updateProcessingStatus(file, "Added successfully!", "check-circle", true);
              const transcriptionWikiLink = `[[${transcriptionPath}]]`;
              contextManager.addToContextFiles(transcriptionWikiLink);
              contextPath = transcriptionPath;
            } catch (error) {
              console.error(`[DocumentContextManager] Error processing audio: ${error.message}`);
              contextManager.updateProcessingStatus(file, `Error: ${error.message}`, "x-circle");
              if (showNotices) {
                new import_obsidian15.Notice(`Error processing ${file.basename}: ${error.message}`, 5e3);
              }
              return false;
            }
          } else {
            contextPath = file.path;
            const wikiLink = `[[${contextPath}]]`;
            if (contextManager.hasContextFile(wikiLink)) {
              console.log(`[DocumentContextManager] File already in context: ${wikiLink}`);
              if (showNotices) {
                new import_obsidian15.Notice(`${file.basename} is already added to context`, 3e3);
              }
              return false;
            }
            contextManager.addToContextFiles(wikiLink);
            console.log(`[DocumentContextManager] Regular file added to context: ${wikiLink}`);
          }
          if (updateUI) {
            contextManager.updateContextPanel();
          }
          if (saveChanges) {
            await contextManager.triggerContextChange();
          }
          if (showNotices) {
            new import_obsidian15.Notice(`Added ${file.basename} to context`, 3e3);
          }
          return true;
        } catch (error) {
          console.error(`[DocumentContextManager] Unexpected error adding file to context: ${error.message}`);
          if (showNotices) {
            new import_obsidian15.Notice(`Error adding ${file.basename} to context: ${error.message}`, 5e3);
          }
          return false;
        }
      }
      async addExtractedImagesToContext(extractionPath, contextManager) {
        try {
          const extractionFile = this.app.vault.getAbstractFileByPath(extractionPath);
          if (!extractionFile) {
            console.warn(`[DocumentContextManager] Extraction file not found: ${extractionPath}`);
            return;
          }
          const parentFolder = extractionFile.parent;
          if (!parentFolder) {
            console.warn(`[DocumentContextManager] Parent folder not found for: ${extractionPath}`);
            return;
          }
          const allFiles = this.app.vault.getAllLoadedFiles();
          const imageFiles = allFiles.filter((file) => {
            if (!(file instanceof import_obsidian15.TFile))
              return false;
            const filePath = file.path;
            if (!filePath.startsWith(parentFolder.path))
              return false;
            if (!filePath.includes("images-"))
              return false;
            return filePath.endsWith(".png") || filePath.endsWith(".jpg") || filePath.endsWith(".jpeg") || filePath.endsWith(".gif");
          });
          for (const imageFile of imageFiles) {
            const imageWikiLink = `[[${imageFile.path}]]`;
            contextManager.addToContextFiles(imageWikiLink);
            console.log(`[DocumentContextManager] Added image to context: ${imageWikiLink}`);
          }
          console.log(`[DocumentContextManager] Added ${imageFiles.length} images to context`);
        } catch (error) {
          console.error(`[DocumentContextManager] Error adding extracted images to context: ${error.message}`);
        }
      }
      async addFilesToContext(files, contextManager, options = {}) {
        const { showNotices = true, updateUI = true, saveChanges = true, maxFiles = 100 } = options;
        console.log(`[DocumentContextManager] Adding ${files.length} files to context`);
        let successCount = 0;
        let currentContextSize = contextManager.getContextFiles().size;
        for (const file of files) {
          if (currentContextSize >= maxFiles) {
            if (showNotices) {
              new import_obsidian15.Notice(`File limit reached (${maxFiles} total)`, 3e3);
            }
            break;
          }
          const success = await this.addFileToContext(file, contextManager, {
            showNotices: false,
            updateUI: false,
            saveChanges: false
          });
          if (success) {
            successCount++;
            currentContextSize++;
            if (showNotices) {
              new import_obsidian15.Notice(`Added ${file.name} to context (${currentContextSize}/${maxFiles})`, 3e3);
            }
          }
        }
        if (updateUI) {
          contextManager.updateContextPanel();
        }
        if (saveChanges) {
          await contextManager.triggerContextChange();
        }
        console.log(`[DocumentContextManager] Added ${successCount} files to context`);
        return successCount;
      }
    };
  }
});

// src/mcp-tools/filesystem/tools/ManagementOperations.ts
var import_obsidian16, ManagementOperations;
var init_ManagementOperations = __esm({
  "src/mcp-tools/filesystem/tools/ManagementOperations.ts"() {
    import_obsidian16 = __toModule(require("obsidian"));
    init_constants();
    init_utils();
    init_workspaceUtils();
    ManagementOperations = class {
      constructor(app, plugin, allowedPaths) {
        this.app = app;
        this.plugin = plugin;
        this.allowedPaths = allowedPaths;
      }
      async manageWorkspace(params) {
        const { files } = params;
        const opened = [];
        const errors = [];
        const currentLeaf = this.app.workspace.activeLeaf;
        let shouldRestoreFocus = true;
        for (const file of files) {
          const filePath = file.path;
          const { leaf, action } = await openFileInMainWorkspace(this.app, filePath);
          if (leaf) {
            opened.push(filePath);
            if (action === "switched_in_pane") {
              shouldRestoreFocus = false;
            }
          } else {
            errors.push(`Failed to open file: ${filePath}`);
          }
        }
        if (currentLeaf && shouldRestoreFocus) {
          this.app.workspace.setActiveLeaf(currentLeaf, { focus: true });
        }
        return { opened, errors };
      }
      async manageContext(params) {
        const { action, paths } = params;
        if (!Array.isArray(paths) || paths.length === 0) {
          throw new Error("The 'paths' parameter must be a non-empty array of file or directory paths");
        }
        if (paths.length > 10) {
          throw new Error("Maximum 10 paths allowed per request to prevent context overflow");
        }
        const MAX_FILES_PER_REQUEST = FILESYSTEM_LIMITS.MAX_FILES_PER_REQUEST;
        const results = [];
        let totalFilesProcessed = 0;
        const currentChatView = this.getCurrentChatView();
        if (!currentChatView) {
          throw new Error("No active chat view found. This tool can only be used from within a chat conversation.");
        }
        if (action === "add") {
          let filesInCurrentRequest = 0;
          for (const path of paths) {
            try {
              const abstractFile = this.app.vault.getAbstractFileByPath(path);
              if (!abstractFile) {
                results.push({ path, success: false, reason: "File or directory not found" });
                continue;
              }
              if (abstractFile instanceof import_obsidian16.TFolder) {
                const folderFiles = getFilesFromFolder(abstractFile);
                if (folderFiles.length > MAX_FILES_PER_REQUEST) {
                  results.push({
                    path,
                    success: false,
                    reason: `Directory contains ${folderFiles.length} files, which exceeds the limit of ${MAX_FILES_PER_REQUEST} files per request. Please specify individual files instead.`
                  });
                  continue;
                }
                if (filesInCurrentRequest + folderFiles.length > MAX_FILES_PER_REQUEST) {
                  const remainingSlots = MAX_FILES_PER_REQUEST - filesInCurrentRequest;
                  results.push({
                    path,
                    success: false,
                    reason: `Cannot add ${folderFiles.length} files from directory. Only ${remainingSlots} slots remaining in this request.`
                  });
                  continue;
                }
                const { DocumentContextManager: DocumentContextManager2 } = await Promise.resolve().then(() => (init_DocumentContextManager(), DocumentContextManager_exports));
                const documentContextManager = DocumentContextManager2.getInstance(this.app, this.plugin);
                const addedCount = await documentContextManager.addFilesToContext(folderFiles, currentChatView.contextManager, {
                  showNotices: false,
                  updateUI: true,
                  saveChanges: false,
                  maxFiles: 100
                });
                if (addedCount > 0) {
                  results.push({ path, success: true });
                  filesInCurrentRequest += addedCount;
                  totalFilesProcessed += addedCount;
                } else {
                  results.push({ path, success: false, reason: "No files were added from directory" });
                }
              } else if (abstractFile instanceof import_obsidian16.TFile) {
                if (filesInCurrentRequest >= MAX_FILES_PER_REQUEST) {
                  results.push({
                    path,
                    success: false,
                    reason: "Reached maximum of 10 files per request"
                  });
                  continue;
                }
                const { DocumentContextManager: DocumentContextManager2 } = await Promise.resolve().then(() => (init_DocumentContextManager(), DocumentContextManager_exports));
                const documentContextManager = DocumentContextManager2.getInstance(this.app, this.plugin);
                const success = await documentContextManager.addFileToContext(abstractFile, currentChatView.contextManager, {
                  showNotices: false,
                  updateUI: true,
                  saveChanges: false
                });
                if (success) {
                  results.push({ path, success: true });
                  filesInCurrentRequest++;
                  totalFilesProcessed++;
                } else {
                  results.push({ path, success: false, reason: "Failed to add file to context (may already be in context)" });
                }
              }
            } catch (error) {
              results.push({
                path,
                success: false,
                reason: error.message || "Unknown error occurred"
              });
            }
          }
          if (totalFilesProcessed > 0) {
            await currentChatView.contextManager.triggerContextChange();
          }
        } else if (action === "remove") {
          for (const path of paths) {
            try {
              const wikiLink = `[[${path}]]`;
              const hasFile = currentChatView.contextManager.hasContextFile(wikiLink) || currentChatView.contextManager.hasContextFile(path);
              if (hasFile) {
                const removed = await currentChatView.contextManager.removeFromContextFiles(path);
                if (removed) {
                  results.push({ path, success: true });
                  totalFilesProcessed++;
                } else {
                  results.push({
                    path,
                    success: false,
                    reason: "Failed to remove file from context"
                  });
                }
              } else {
                results.push({
                  path,
                  success: false,
                  reason: "File not found in current context"
                });
              }
            } catch (error) {
              results.push({
                path,
                success: false,
                reason: error.message || "Unknown error occurred"
              });
            }
          }
        } else {
          throw new Error("Invalid action. Must be 'add' or 'remove'");
        }
        const successCount = results.filter((r) => r.success).length;
        const failureCount = results.filter((r) => !r.success).length;
        let summary = `Context management completed: ${action} operation processed ${totalFilesProcessed} files. `;
        summary += `${successCount} paths succeeded, ${failureCount} paths failed.`;
        if (action === "add" && totalFilesProcessed > 0) {
          const currentCount = currentChatView.contextManager.getContextFiles().size;
          summary += ` Current context: ${currentCount} files total.`;
        }
        return {
          action,
          processed: totalFilesProcessed,
          results,
          summary
        };
      }
      getCurrentChatView() {
        const leaves = this.app.workspace.getLeavesOfType("systemsculpt-chat-view");
        for (const leaf of leaves) {
          if (leaf === this.app.workspace.activeLeaf) {
            return leaf.view;
          }
        }
        if (leaves.length > 0) {
          return leaves[0].view;
        }
        return null;
      }
    };
  }
});

// src/mcp-tools/filesystem/tools/StorageOperations.ts
var import_obsidian17, StorageOperations;
var init_StorageOperations = __esm({
  "src/mcp-tools/filesystem/tools/StorageOperations.ts"() {
    import_obsidian17 = __toModule(require("obsidian"));
    init_utils();
    StorageOperations = class {
      constructor(app, allowedPaths) {
        this.app = app;
        this.allowedPaths = allowedPaths;
      }
      async analyzeVaultStorage(params) {
        const {
          paths = ["/"],
          minSize = 0,
          extensions,
          groupBy = "extension",
          sortBy = "size",
          limit = 50,
          includeDetails = false
        } = params;
        const filesToAnalyze = [];
        const processedPaths = new Set();
        for (const path of paths) {
          if (!validatePath(path, this.allowedPaths)) {
            continue;
          }
          const normalizedPath = path === "/" ? "" : path;
          const abstractFile = this.app.vault.getAbstractFileByPath(normalizedPath);
          if (!abstractFile && (path === "/" || path === "")) {
            this.collectFiles(this.app.vault.getRoot(), filesToAnalyze, processedPaths);
          } else if (abstractFile instanceof import_obsidian17.TFolder) {
            this.collectFiles(abstractFile, filesToAnalyze, processedPaths);
          } else if (abstractFile instanceof import_obsidian17.TFile) {
            if (!processedPaths.has(abstractFile.path)) {
              filesToAnalyze.push(abstractFile);
              processedPaths.add(abstractFile.path);
            }
          }
        }
        let filteredFiles = filesToAnalyze;
        if (minSize > 0) {
          filteredFiles = filteredFiles.filter((file) => file.stat.size >= minSize);
        }
        if (extensions && extensions.length > 0) {
          const extensionSet = new Set(extensions.map((ext) => ext.toLowerCase()));
          filteredFiles = filteredFiles.filter((file) => {
            const ext = file.extension ? `.${file.extension.toLowerCase()}` : "";
            return extensionSet.has(ext);
          });
        }
        const totalSize = filteredFiles.reduce((sum, file) => sum + file.stat.size, 0);
        const totalFiles = filteredFiles.length;
        const groups = this.groupFiles(filteredFiles, groupBy);
        const sortedGroups = this.sortGroups(groups, sortBy);
        const limitedGroups = sortedGroups.slice(0, limit);
        let fileDetails;
        if (includeDetails) {
          const sortedFiles = [...filteredFiles].sort((a, b) => b.stat.size - a.stat.size);
          fileDetails = sortedFiles.slice(0, limit).map((file) => ({
            path: file.path,
            size: file.stat.size,
            sizeFormatted: this.formatFileSize(file.stat.size),
            extension: file.extension || "none",
            created: new Date(file.stat.ctime).toISOString(),
            modified: new Date(file.stat.mtime).toISOString()
          }));
        }
        const largestFiles = [...filteredFiles].sort((a, b) => b.stat.size - a.stat.size).slice(0, 10).map((file) => ({
          path: file.path,
          size: file.stat.size,
          sizeFormatted: this.formatFileSize(file.stat.size)
        }));
        return {
          totalSize,
          totalSizeFormatted: this.formatFileSize(totalSize),
          totalFiles,
          groups: limitedGroups,
          largestFiles,
          fileDetails,
          summary: this.generateSummary(totalSize, totalFiles, limitedGroups, groupBy)
        };
      }
      collectFiles(folder, files, processedPaths) {
        for (const child of folder.children) {
          if (child instanceof import_obsidian17.TFile && !processedPaths.has(child.path)) {
            files.push(child);
            processedPaths.add(child.path);
          } else if (child instanceof import_obsidian17.TFolder) {
            this.collectFiles(child, files, processedPaths);
          }
        }
      }
      groupFiles(files, groupBy) {
        var _a;
        const groups = new Map();
        for (const file of files) {
          let groupKey;
          switch (groupBy) {
            case "extension":
              groupKey = file.extension || "no-extension";
              break;
            case "directory":
              const dirPath = ((_a = file.parent) == null ? void 0 : _a.path) || "/";
              groupKey = dirPath === "" ? "/" : dirPath;
              break;
            case "month":
              const date = new Date(file.stat.mtime);
              groupKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}`;
              break;
            default:
              groupKey = "all-files";
          }
          const existing = groups.get(groupKey) || {
            name: groupKey,
            size: 0,
            sizeFormatted: "",
            count: 0,
            percentage: 0
          };
          existing.size += file.stat.size;
          existing.count += 1;
          groups.set(groupKey, existing);
        }
        const totalSize = Array.from(groups.values()).reduce((sum, group) => sum + group.size, 0);
        for (const group of groups.values()) {
          group.percentage = totalSize > 0 ? group.size / totalSize * 100 : 0;
          group.sizeFormatted = this.formatFileSize(group.size);
        }
        return groups;
      }
      sortGroups(groups, sortBy) {
        const groupArray = Array.from(groups.values());
        switch (sortBy) {
          case "size":
            return groupArray.sort((a, b) => b.size - a.size);
          case "count":
            return groupArray.sort((a, b) => b.count - a.count);
          case "name":
            return groupArray.sort((a, b) => a.name.localeCompare(b.name));
          default:
            return groupArray.sort((a, b) => b.size - a.size);
        }
      }
      formatFileSize(bytes) {
        const units = ["B", "KB", "MB", "GB", "TB"];
        let size = bytes;
        let unitIndex = 0;
        while (size >= 1024 && unitIndex < units.length - 1) {
          size /= 1024;
          unitIndex++;
        }
        return `${size.toFixed(2)} ${units[unitIndex]}`;
      }
      generateSummary(totalSize, totalFiles, groups, groupBy) {
        const avgSize = totalFiles > 0 ? totalSize / totalFiles : 0;
        const topGroup = groups[0];
        let summary = `Analyzed ${totalFiles} files totaling ${this.formatFileSize(totalSize)}`;
        summary += ` (average ${this.formatFileSize(avgSize)} per file).`;
        if (topGroup && groupBy !== "none") {
          summary += ` The largest ${groupBy} is "${topGroup.name}" with ${topGroup.count} files`;
          summary += ` using ${topGroup.sizeFormatted} (${topGroup.percentage.toFixed(1)}% of total).`;
        }
        return summary;
      }
    };
  }
});

// src/mcp-tools/filesystem/MCPFilesystemServer.ts
var MCPFilesystemServer_exports = {};
__export(MCPFilesystemServer_exports, {
  MCPFilesystemServer: () => MCPFilesystemServer
});
var MCPFilesystemServer;
var init_MCPFilesystemServer = __esm({
  "src/mcp-tools/filesystem/MCPFilesystemServer.ts"() {
    init_constants();
    init_toolDefinitions();
    init_FileOperations();
    init_DirectoryOperations();
    init_SearchOperations();
    init_ManagementOperations();
    init_StorageOperations();
    MCPFilesystemServer = class {
      constructor(plugin, app) {
        this.allowedPaths = [];
        this.plugin = plugin;
        this.app = app;
        this.allowedPaths = ["/"];
        this.fileOps = new FileOperations(this.app, this.allowedPaths);
        this.directoryOps = new DirectoryOperations(this.app, this.allowedPaths, this.plugin);
        this.searchOps = new SearchOperations(this.app, this.allowedPaths, this.plugin);
        this.managementOps = new ManagementOperations(this.app, this.plugin, this.allowedPaths);
        this.storageOps = new StorageOperations(this.app, this.allowedPaths);
      }
      async getTools() {
        return toolDefinitions;
      }
      static getToolDisplayDescription(toolName) {
        return TOOL_DISPLAY_DESCRIPTIONS[toolName] || "No description available";
      }
      async executeTool(toolName, args, chatView) {
        if (chatView && !chatView.agentMode) {
          throw new Error("Filesystem tool execution denied: Agent mode is not enabled for this chat. Enable agent mode in the MCP tools modal to use filesystem tools.");
        }
        switch (toolName) {
          case "read_files":
            return await this.fileOps.readFiles(args);
          case "write_file":
            return await this.fileOps.writeFile(args);
          case "edit_file":
            const diff = await this.fileOps.editFile(args);
            return { path: args.path, success: true, diff };
          case "create_directories":
            return await this.directoryOps.createDirectories(args);
          case "list_directories":
            return await this.directoryOps.listDirectories(args);
          case "move_items":
            return await this.directoryOps.moveItems(args);
          case "trash_files":
            return await this.directoryOps.trashFiles(args);
          case "find_files":
            return await this.searchOps.findFiles(args);
          case "grep_vault":
            return await this.searchOps.grepVault(args);
          case "manage_workspace":
            return await this.managementOps.manageWorkspace(args);
          case "manage_context":
            return await this.managementOps.manageContext(args);
          case "analyze_vault_storage":
            return await this.storageOps.analyzeVaultStorage(args);
          case "search_metadata":
            return await this.searchOps.searchMetadata(args);
          case "search_similar_notes":
            return await this.searchOps.searchSimilarNotes(args);
          default:
            throw new Error(`Unknown tool: ${toolName}`);
        }
      }
      setAllowedPaths(paths) {
        this.allowedPaths = paths.map((p) => p);
        this.fileOps = new FileOperations(this.app, this.allowedPaths);
        this.directoryOps = new DirectoryOperations(this.app, this.allowedPaths, this.plugin);
        this.searchOps = new SearchOperations(this.app, this.allowedPaths, this.plugin);
        this.managementOps = new ManagementOperations(this.app, this.plugin, this.allowedPaths);
        this.storageOps = new StorageOperations(this.app, this.allowedPaths);
      }
    };
  }
});

// src/views/chatview/MCPFilesystemServer.ts
var init_MCPFilesystemServer2 = __esm({
  "src/views/chatview/MCPFilesystemServer.ts"() {
    init_MCPFilesystemServer();
  }
});

// src/views/chatview/MCPService.ts
var MCPService_exports = {};
__export(MCPService_exports, {
  MCPService: () => MCPService
});
var _MCPService, MCPService;
var init_MCPService = __esm({
  "src/views/chatview/MCPService.ts"() {
    init_MCPFilesystemServer2();
    _MCPService = class {
      constructor(plugin, app) {
        this.CACHE_DURATION = 30 * 60 * 1e3;
        this.requestIdCounter = 0;
        this.plugin = plugin;
        this.app = app;
        this.logger = console;
        this.filesystemServer = new MCPFilesystemServer(plugin, app);
      }
      clearCache() {
        _MCPService.connectionTestCache.clear();
        _MCPService.connectionTestPromises.clear();
      }
      async testConnection(server) {
        const cached = _MCPService.connectionTestCache.get(server.id);
        if (cached && Date.now() - cached.result.timestamp < this.CACHE_DURATION) {
          return cached.result;
        }
        const existingPromise = _MCPService.connectionTestPromises.get(server.id);
        if (existingPromise) {
          return existingPromise;
        }
        const testPromise = this.performConnectionTest(server);
        _MCPService.connectionTestPromises.set(server.id, testPromise);
        try {
          const result = await testPromise;
          if (result.success) {
            _MCPService.connectionTestCache.set(server.id, {
              result,
              timestamp: Date.now()
            });
          }
          return result;
        } finally {
          _MCPService.connectionTestPromises.delete(server.id);
        }
      }
      async performConnectionTest(server) {
        try {
          if (server.transport === "internal") {
            const tools2 = await this.discoverTools(server);
            return {
              success: true,
              tools: tools2,
              timestamp: Date.now()
            };
          }
          if (server.transport !== "http") {
            throw new Error("Only HTTP and internal transports are currently supported");
          }
          if (!server.endpoint) {
            throw new Error("HTTP endpoint is required for HTTP transport");
          }
          const tools = await this.discoverTools(server);
          return {
            success: true,
            tools,
            timestamp: Date.now()
          };
        } catch (error) {
          this.logger.error(`MCP connection test failed for ${server.name}:`, error);
          return {
            success: false,
            error: this.getErrorMessage(error),
            timestamp: Date.now()
          };
        }
      }
      async discoverTools(server) {
        var _a;
        if (server.transport === "internal" && server.id === "mcp-filesystem") {
          return await this.filesystemServer.getTools();
        }
        if (server.transport !== "http" || !server.endpoint) {
          throw new Error("Invalid server configuration");
        }
        const request = {
          jsonrpc: "2.0",
          id: ++this.requestIdCounter,
          method: "tools/list",
          params: {}
        };
        const headers = {
          "Content-Type": "application/json"
        };
        if (server.apiKey) {
          headers["Authorization"] = `Bearer ${server.apiKey}`;
        }
        let response;
        try {
          response = await fetch(server.endpoint, {
            method: "POST",
            headers,
            body: JSON.stringify(request),
            signal: AbortSignal.timeout(1e4)
          });
        } catch (error) {
          const message = `\u274C Connection to MCP server '${server.name}' refused:

${server.endpoint}

Please ensure the MCP server is running and accessible at this URL. Verify that any required authentication is correctly configured.

Common issues:
\u2022 Incorrect endpoint URL
\u2022 Server is down or unreachable
\u2022 Missing or invalid authentication
\u2022 Server doesn't support JSON-RPC over HTTP

Check your server status and settings, then try again.`;
          const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
          console.error(`[SystemSculpt] MCP connection error with server '${server.name}':
${message}`, error);
          showNoticeWhenReady2(this.app, message, { type: "error", duration: 15e3 });
          throw error;
        }
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          if (response.status === 401) {
            throw new Error("Invalid authentication. Please check your API key and try again.");
          } else if (response.status === 403) {
            throw new Error("Access denied. Please verify your authentication has the correct permissions.");
          } else if (response.status === 404) {
            throw new Error("MCP endpoint not found. Please check the URL and ensure the server supports JSON-RPC over HTTP.");
          }
          throw new Error(`HTTP error: ${((_a = errorData.error) == null ? void 0 : _a.message) || response.statusText}`);
        }
        const jsonRpcResponse = await response.json();
        if (jsonRpcResponse.error) {
          throw new Error(`MCP server error: ${jsonRpcResponse.error.message}`);
        }
        const toolsResult = jsonRpcResponse.result;
        if (!toolsResult || !Array.isArray(toolsResult.tools)) {
          throw new Error("Invalid tools response format from MCP server");
        }
        return toolsResult.tools.map((tool) => ({
          name: tool.name,
          description: tool.description,
          inputSchema: tool.inputSchema || {}
        }));
      }
      async getAvailableTools() {
        if (!this.plugin.settings.mcpEnabled) {
          return [];
        }
        const enabledServers = this.plugin.settings.mcpServers.filter((server) => server.isEnabled);
        if (enabledServers.length === 0) {
          return [];
        }
        const allTools = [];
        const serverPromises = enabledServers.map(async (server) => {
          try {
            const connectionResult = await this.testConnection(server);
            if (connectionResult.success && connectionResult.tools) {
              const serverTools = [];
              for (const tool of connectionResult.tools) {
                try {
                  const toolKey = `${server.id}:${tool.name}`;
                  if (!this.plugin.settings.mcpEnabledTools.includes(toolKey)) {
                    continue;
                  }
                  const openAITool = this.convertToOpenAITool(tool, server);
                  serverTools.push(openAITool);
                } catch (error) {
                  this.logger.warn(`[SystemSculpt] Failed to convert tool ${tool.name || "unnamed"} from server ${server.name}:`, error);
                }
              }
              return serverTools;
            }
          } catch (error) {
            this.logger.warn(`Failed to get tools from MCP server ${server.name}:`, error);
          }
          return [];
        });
        const serverToolsArrays = await Promise.all(serverPromises);
        for (const serverTools of serverToolsArrays) {
          allTools.push(...serverTools);
        }
        return allTools;
      }
      convertToOpenAITool(tool, server) {
        if (!tool || !tool.name || typeof tool.name !== "string" || tool.name.trim() === "") {
          this.logger.warn(`[SystemSculpt] Skipping tool with invalid name:`, tool);
          throw new Error(`Tool missing required name property`);
        }
        if (!server || !server.id || typeof server.id !== "string") {
          this.logger.warn(`[SystemSculpt] Server missing valid ID:`, server);
          throw new Error(`Server missing required id property`);
        }
        const openAITool = {
          type: "function",
          function: {
            name: `${server.id}_${tool.name}`,
            description: `[${server.name}] ${tool.description || "No description provided"}`,
            parameters: tool.inputSchema || {}
          }
        };
        if (!openAITool.function.name || typeof openAITool.function.name !== "string") {
          this.logger.error(`[SystemSculpt] Generated invalid OpenAI tool:`, openAITool);
          throw new Error(`Failed to generate valid OpenAI tool`);
        }
        return openAITool;
      }
      async executeTool(toolName, args, chatView) {
        if (chatView && !chatView.agentMode) {
          throw new Error("Tool execution denied: Agent mode is not enabled for this chat. Enable agent mode in the MCP tools modal to use tools.");
        }
        const firstUnderscoreIndex = toolName.indexOf("_");
        if (firstUnderscoreIndex === -1) {
          throw new Error(`Invalid tool name format: ${toolName}`);
        }
        const serverId = toolName.substring(0, firstUnderscoreIndex);
        const actualToolName = toolName.substring(firstUnderscoreIndex + 1);
        const server = this.plugin.settings.mcpServers.find((s) => s.id === serverId);
        if (!server) {
          throw new Error(`MCP server not found: ${serverId}`);
        }
        if (!server.isEnabled) {
          throw new Error(`MCP server is disabled: ${server.name}`);
        }
        if (server.transport === "internal" && server.id === "mcp-filesystem") {
          return await this.filesystemServer.executeTool(actualToolName, args, chatView);
        }
        if (server.transport !== "http" || !server.endpoint) {
          throw new Error("Only HTTP and internal transports are currently supported");
        }
        const request = {
          jsonrpc: "2.0",
          id: ++this.requestIdCounter,
          method: "tools/call",
          params: {
            name: actualToolName,
            arguments: args
          }
        };
        const headers = {
          "Content-Type": "application/json"
        };
        if (server.apiKey) {
          headers["Authorization"] = `Bearer ${server.apiKey}`;
        }
        const response = await fetch(server.endpoint, {
          method: "POST",
          headers,
          body: JSON.stringify(request),
          signal: AbortSignal.timeout(3e4)
        });
        if (!response.ok) {
          throw new Error(`Tool execution failed: ${response.statusText}`);
        }
        const jsonRpcResponse = await response.json();
        if (jsonRpcResponse.error) {
          throw new Error(`Tool execution error: ${jsonRpcResponse.error.message}`);
        }
        return jsonRpcResponse.result;
      }
      async testAllServers() {
        const results = {};
        const enabledServers = this.plugin.settings.mcpServers.filter((server) => server.isEnabled);
        const testPromises = enabledServers.map(async (server) => {
          const result = await this.testConnection(server);
          return { serverId: server.id, result };
        });
        const testResults = await Promise.all(testPromises);
        for (const { serverId, result } of testResults) {
          results[serverId] = result;
        }
        return results;
      }
      getErrorMessage(error) {
        if (error instanceof Error) {
          if (error.name === "AbortError") {
            return "Connection timed out. Please check your internet connection and try again.";
          }
          return error.message;
        }
        return "An unexpected error occurred. Please try again or contact support if the issue persists.";
      }
    };
    MCPService = _MCPService;
    MCPService.connectionTestCache = new Map();
    MCPService.connectionTestPromises = new Map();
  }
});

// src/utils/debugLogger.ts
var _DebugLogger, DebugLogger;
var init_debugLogger = __esm({
  "src/utils/debugLogger.ts"() {
    _DebugLogger = class {
      constructor() {
      }
      static initialize(_app) {
      }
      static getInstance() {
        return _DebugLogger.instance;
      }
      log(..._args) {
      }
      logToolCall(..._args) {
      }
      logStreamChunk(..._args) {
      }
      logUserAction(..._args) {
      }
      logAPIRequest(..._args) {
      }
      logAPIResponse(..._args) {
      }
      logToolApproval(..._args) {
      }
      logToolExecution(..._args) {
      }
      logChatViewLoad(..._args) {
      }
      logChatViewRender(..._args) {
      }
      logChatViewStructure(..._args) {
      }
      logChatSave(..._args) {
      }
      logError(..._args) {
      }
      setEnabled(_enabled) {
      }
      clearLog() {
      }
      async exportMobileLogs() {
        return "";
      }
      logMobileError(..._args) {
      }
      logMobilePerformance(..._args) {
      }
      logGlobalUncaughtError(..._args) {
      }
    };
    DebugLogger = _DebugLogger;
    DebugLogger.instance = new _DebugLogger();
  }
});

// src/utils/FileValidator.ts
async function validateFileSize(file, app) {
  const fileSize = file.stat.size;
  if (fileSize > MAX_FILE_SIZE) {
    await showPopup(app, `The file "${file.name}" is too large (${formatFileSize(fileSize)}). The maximum allowed size is 500MB.`, {
      title: "File Size Limit Exceeded",
      description: "Please reduce the file size or choose a smaller file.",
      primaryButton: "OK"
    });
    return false;
  }
  return true;
}
async function validateBrowserFileSize(file, app) {
  if (file.size > MAX_FILE_SIZE) {
    await showPopup(app, `The file "${file.name}" is too large (${formatFileSize(file.size)}). The maximum allowed size is 500MB.`, {
      title: "File Size Limit Exceeded",
      description: "Please reduce the file size or choose a smaller file.",
      primaryButton: "OK"
    });
    return false;
  }
  return true;
}
function formatFileSize(bytes) {
  if (bytes < 1024) {
    return bytes + " bytes";
  } else if (bytes < 1024 * 1024) {
    return (bytes / 1024).toFixed(1) + " KB";
  } else {
    return (bytes / (1024 * 1024)).toFixed(1) + " MB";
  }
}
var MAX_FILE_SIZE;
var init_FileValidator = __esm({
  "src/utils/FileValidator.ts"() {
    init_ui();
    MAX_FILE_SIZE = 500 * 1024 * 1024;
  }
});

// src/constants/models.ts
var OPENAI_REASONING_MODELS, REASONING_MODEL_PATTERN;
var init_models = __esm({
  "src/constants/models.ts"() {
    OPENAI_REASONING_MODELS = [
      "o1",
      "o1-mini",
      "o1-preview",
      "o3",
      "o3-mini",
      "o4",
      "o4-mini"
    ];
    REASONING_MODEL_PATTERN = new RegExp(`(^|@@|/)(${OPENAI_REASONING_MODELS.join("|")})($|-|/)`, "i");
  }
});

// src/utils/modelUtils.ts
var modelUtils_exports = {};
__export(modelUtils_exports, {
  MODEL_ID_SEPARATOR: () => MODEL_ID_SEPARATOR,
  createCanonicalId: () => createCanonicalId,
  ensureCanonicalId: () => ensureCanonicalId,
  filterChatModels: () => filterChatModels,
  filterToolCapableModels: () => filterToolCapableModels,
  findModelById: () => findModelById,
  getCanonicalId: () => getCanonicalId,
  getDisplayName: () => getDisplayName,
  getTemperatureCompatibilityInfo: () => getTemperatureCompatibilityInfo,
  getToolCompatibilityInfo: () => getToolCompatibilityInfo,
  isEmbeddingModel: () => isEmbeddingModel,
  isReasoningModel: () => isReasoningModel,
  migrateFromLegacyId: () => migrateFromLegacyId,
  parseCanonicalId: () => parseCanonicalId,
  supportsTemperature: () => supportsTemperature,
  supportsTools: () => supportsTools
});
function createCanonicalId(providerId, modelId) {
  return `${providerId.toLowerCase()}${MODEL_ID_SEPARATOR}${modelId}`;
}
function parseCanonicalId(canonicalId) {
  if (!(canonicalId == null ? void 0 : canonicalId.includes(MODEL_ID_SEPARATOR))) {
    return null;
  }
  const [providerId, ...modelIdParts] = canonicalId.split(MODEL_ID_SEPARATOR);
  return {
    providerId: providerId.toLowerCase(),
    modelId: modelIdParts.join(MODEL_ID_SEPARATOR)
  };
}
function migrateFromLegacyId(legacyId, defaultProvider = "systemsculpt") {
  if (legacyId == null ? void 0 : legacyId.includes(MODEL_ID_SEPARATOR)) {
    return legacyId;
  }
  const knownProviders = ["openrouter", "together", "fireworks"];
  if (legacyId == null ? void 0 : legacyId.includes("/")) {
    for (const provider of knownProviders) {
      if (legacyId.toLowerCase().startsWith(`${provider}/`)) {
        const providerId = provider;
        const modelId = legacyId.substring(provider.length + 1);
        return createCanonicalId(providerId, modelId);
      }
    }
    const parts = legacyId.split("/");
    if (parts.length >= 2) {
      return createCanonicalId(parts[0].toLowerCase(), parts.slice(1).join("/"));
    }
  }
  return createCanonicalId(defaultProvider, legacyId);
}
function getCanonicalId(model) {
  var _a, _b, _c;
  if ((_a = model.id) == null ? void 0 : _a.includes(MODEL_ID_SEPARATOR)) {
    return model.id;
  }
  if (((_b = model.identifier) == null ? void 0 : _b.providerId) && ((_c = model.identifier) == null ? void 0 : _c.modelId)) {
    return createCanonicalId(model.identifier.providerId, model.identifier.modelId);
  }
  if (model.provider) {
    return createCanonicalId(model.provider, model.id || model.name);
  }
  return createCanonicalId("unknown", model.id || model.name || "unknown-model");
}
function findModelById(models, modelId) {
  const canonicalId = modelId.includes(MODEL_ID_SEPARATOR) ? modelId : migrateFromLegacyId(modelId);
  let model = models.find((m) => m.id === canonicalId);
  if (model) {
    return model;
  }
  const parsed = parseCanonicalId(canonicalId);
  if (!parsed) {
    console.log("[SystemSculpt] Could not parse canonical ID");
    return void 0;
  }
  console.log("[SystemSculpt] Parsed components:", parsed);
  model = models.find((m) => {
    var _a;
    if (m.provider.toLowerCase() !== parsed.providerId) {
      return false;
    }
    return ((_a = m.identifier) == null ? void 0 : _a.modelId) === parsed.modelId || m.name === parsed.modelId;
  });
  if (model) {
    console.log("[SystemSculpt] Found by component matching");
    return model;
  }
  if (parsed.providerId === "openai") {
    const normalizedModelId = parsed.modelId.toLowerCase().replace(/[-\.]/g, "").replace(/\s+/g, "");
    model = models.find((m) => {
      if (m.provider.toLowerCase() !== "openai")
        return false;
      const normalizedName = (m.name || "").toLowerCase().replace(/[-\.]/g, "").replace(/\s+/g, "");
      return normalizedName.includes(normalizedModelId) || normalizedModelId.includes(normalizedName);
    });
    if (model) {
      console.log("[SystemSculpt] Found by OpenAI name normalization");
      return model;
    }
  }
  console.log("[SystemSculpt] No model found for:", modelId);
  return void 0;
}
function getDisplayName(modelId) {
  if (modelId == null ? void 0 : modelId.includes(MODEL_ID_SEPARATOR)) {
    const parsed = parseCanonicalId(modelId);
    if (parsed) {
      return parsed.modelId;
    }
  }
  if (modelId == null ? void 0 : modelId.includes("/")) {
    const parts = modelId.split("/");
    if (parts.length >= 2) {
      return parts[parts.length - 1];
    }
  }
  return modelId;
}
function ensureCanonicalId(modelId, defaultProvider = "systemsculpt") {
  if (!modelId) {
    return "";
  }
  if (modelId.includes(MODEL_ID_SEPARATOR)) {
    return modelId;
  }
  return migrateFromLegacyId(modelId, defaultProvider);
}
function isEmbeddingModel(model) {
  const nameCheck = model.name.toLowerCase().includes("embed");
  const idCheck = model.id.toLowerCase().includes("embed");
  const capabilitiesCheck = model.capabilities && model.capabilities.includes("embeddings") && !model.capabilities.includes("chat");
  return nameCheck || idCheck || capabilitiesCheck;
}
function filterChatModels(models) {
  return models.filter((model) => !isEmbeddingModel(model));
}
function supportsTools(model) {
  if (model.supported_parameters && Array.isArray(model.supported_parameters)) {
    return model.supported_parameters.includes("tools");
  }
  if (model.capabilities && model.capabilities.length > 0) {
    const toolCapabilities = [
      "tools",
      "function_calling",
      "function-calling",
      "tool_use",
      "tool-use"
    ];
    const hasCapability = model.capabilities.some((cap) => toolCapabilities.includes(cap.toLowerCase()));
    if (hasCapability) {
      return true;
    }
  }
  return hasKnownToolSupport(model);
}
function hasKnownToolSupport(model) {
  return true;
}
function filterToolCapableModels(models) {
  return models.filter((model) => supportsTools(model));
}
function getToolCompatibilityInfo(model) {
  if (model.supported_parameters && Array.isArray(model.supported_parameters)) {
    const supportsTools3 = model.supported_parameters.includes("tools");
    return {
      isCompatible: supportsTools3,
      reason: supportsTools3 ? 'OpenRouter confirms model supports "tools" parameter' : 'OpenRouter data shows model does not support "tools" parameter',
      confidence: "high"
    };
  }
  if (model.capabilities && model.capabilities.length > 0) {
    const toolCapabilities = [
      "tools",
      "function_calling",
      "function-calling",
      "tool_use",
      "tool-use"
    ];
    const hasToolCapability = model.capabilities.some((cap) => toolCapabilities.includes(cap.toLowerCase()));
    if (hasToolCapability) {
      return {
        isCompatible: true,
        reason: "Model capabilities indicate tool support",
        confidence: "medium"
      };
    }
  }
  return {
    isCompatible: true,
    reason: "No explicit tool support data - will attempt (OpenRouter safely ignores unsupported params)",
    confidence: "low"
  };
}
function isReasoningModel(model) {
  const modelId = typeof model === "string" ? model : model.id;
  return REASONING_MODEL_PATTERN.test(modelId);
}
function supportsTemperature(model) {
  if (typeof model === "string") {
    return !isReasoningModel(model);
  }
  if (model.supported_parameters && Array.isArray(model.supported_parameters)) {
    return model.supported_parameters.includes("temperature");
  }
  if (isReasoningModel(model)) {
    return false;
  }
  return true;
}
function getTemperatureCompatibilityInfo(model) {
  if (model.supported_parameters && Array.isArray(model.supported_parameters)) {
    const supportsTemp = model.supported_parameters.includes("temperature");
    return {
      isCompatible: supportsTemp,
      reason: supportsTemp ? "Model metadata confirms temperature parameter support" : "Model metadata indicates temperature is not supported",
      confidence: "high"
    };
  }
  if (isReasoningModel(model)) {
    return {
      isCompatible: false,
      reason: "OpenAI reasoning models have fixed temperature at 1.0",
      confidence: "high"
    };
  }
  return {
    isCompatible: true,
    reason: "Traditional model - temperature parameter assumed to be supported",
    confidence: "medium"
  };
}
var MODEL_ID_SEPARATOR;
var init_modelUtils = __esm({
  "src/utils/modelUtils.ts"() {
    init_models();
    MODEL_ID_SEPARATOR = "@@";
  }
});

// src/constants/agent.ts
var agent_exports = {};
__export(agent_exports, {
  AGENT_CONFIG: () => AGENT_CONFIG
});
var AGENT_CONFIG;
var init_agent2 = __esm({
  "src/constants/agent.ts"() {
    AGENT_CONFIG = {
      MODEL_ID: "systemsculpt@@openai/o4-mini",
      MODEL_DISPLAY_NAME: "SystemSculpt AI Agent",
      MODEL_DESCRIPTION: "optimized for fast, multi-step operations"
    };
  }
});

// src/utils/cryptoUtils.ts
function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(16).padStart(8, "0");
}
var init_cryptoUtils = __esm({
  "src/utils/cryptoUtils.ts"() {
  }
});

// src/utils/MobileDetection.ts
var MobileDetection;
var init_MobileDetection = __esm({
  "src/utils/MobileDetection.ts"() {
    MobileDetection = class {
      constructor() {
        this.cachedInfo = null;
        this.lastUpdate = 0;
        this.CACHE_DURATION = 3e4;
      }
      static getInstance() {
        if (!MobileDetection.instance) {
          MobileDetection.instance = new MobileDetection();
        }
        return MobileDetection.instance;
      }
      getDeviceInfo() {
        const now = Date.now();
        if (this.cachedInfo && now - this.lastUpdate < this.CACHE_DURATION) {
          return this.cachedInfo;
        }
        this.cachedInfo = this.detectDeviceInfo();
        this.lastUpdate = now;
        return this.cachedInfo;
      }
      isMobileDevice() {
        return this.getDeviceInfo().isMobile;
      }
      isResourceConstrained() {
        return this.getDeviceInfo().limitations.resourceConstrained;
      }
      hasFunctionalityLimitations() {
        return this.getDeviceInfo().limitations.functionalityLimited;
      }
      detectDeviceInfo() {
        const userAgent = navigator.userAgent;
        const platform = this.detectPlatform(userAgent);
        const device = this.detectDevice(userAgent);
        const capabilities = this.detectCapabilities();
        const network = this.detectNetwork();
        const performance2 = this.detectPerformance();
        const limitations = this.detectLimitations(device, capabilities, network, performance2);
        const npm = this.detectNpmIssues(platform.os, device.type, limitations);
        const isMobile = device.type === "smartphone" || device.type === "tablet" || platform.os === "iOS" || platform.os === "Android" || window.innerWidth <= 768 || /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
        return {
          isMobile,
          platform,
          device,
          capabilities,
          network,
          performance: performance2,
          limitations,
          npm
        };
      }
      detectPlatform(userAgent) {
        let os = "Unknown";
        let name = "Unknown";
        let version = "Unknown";
        if (/iPhone|iPad|iPod/i.test(userAgent)) {
          os = "iOS";
          name = "iOS";
          const match = userAgent.match(/OS (\d+_\d+)/);
          if (match) {
            version = match[1].replace("_", ".");
          }
        } else if (/Android/i.test(userAgent)) {
          os = "Android";
          name = "Android";
          const match = userAgent.match(/Android (\d+\.?\d*)/);
          if (match) {
            version = match[1];
          }
        } else if (/Windows/i.test(userAgent)) {
          os = "Windows";
          name = "Windows";
          if (/Windows NT (\d+\.\d+)/i.test(userAgent)) {
            const match = userAgent.match(/Windows NT (\d+\.\d+)/i);
            if (match)
              version = match[1];
          }
        } else if (/Mac OS X/i.test(userAgent)) {
          os = "macOS";
          name = "macOS";
          const match = userAgent.match(/Mac OS X (\d+[_\d]*)/i);
          if (match) {
            version = match[1].replace(/_/g, ".");
          }
        } else if (/Linux/i.test(userAgent)) {
          os = "Linux";
          name = "Linux";
        }
        return { name, version, os };
      }
      detectDevice(userAgent) {
        let type = "unknown";
        let model = "Unknown";
        let vendor = "Unknown";
        if (/iPhone/i.test(userAgent)) {
          type = "smartphone";
          vendor = "Apple";
          const match = userAgent.match(/iPhone[^;]*/i);
          if (match)
            model = match[0];
        } else if (/iPad/i.test(userAgent)) {
          type = "tablet";
          vendor = "Apple";
          model = "iPad";
        } else if (/Android/i.test(userAgent)) {
          if (/Mobile/i.test(userAgent)) {
            type = "smartphone";
          } else {
            type = "tablet";
          }
          const samsungMatch = userAgent.match(/SM-[A-Z0-9]+/i);
          const pixelMatch = userAgent.match(/Pixel [0-9a-zA-Z ]+/i);
          if (samsungMatch) {
            vendor = "Samsung";
            model = samsungMatch[0];
          } else if (pixelMatch) {
            vendor = "Google";
            model = pixelMatch[0];
          } else if (/Huawei/i.test(userAgent)) {
            vendor = "Huawei";
          } else if (/OnePlus/i.test(userAgent)) {
            vendor = "OnePlus";
          }
        } else {
          type = "desktop";
        }
        const screenSize = `${screen.width}x${screen.height}`;
        return { type, model, vendor, screenSize };
      }
      detectCapabilities() {
        const touchSupport = "ontouchstart" in window || navigator.maxTouchPoints > 0;
        return {
          touchSupport,
          hasCamera: "mediaDevices" in navigator && "getUserMedia" in navigator.mediaDevices,
          hasGeolocation: "geolocation" in navigator,
          hasAccelerometer: "DeviceMotionEvent" in window,
          hasGyroscope: "DeviceOrientationEvent" in window,
          hasVibration: "vibrate" in navigator,
          hasServiceWorker: "serviceWorker" in navigator,
          hasWebGL: this.detectWebGL(),
          hasWebRTC: "RTCPeerConnection" in window,
          hasFileAPI: "File" in window && "FileReader" in window,
          hasClipboardAPI: "clipboard" in navigator,
          hasNotificationAPI: "Notification" in window
        };
      }
      detectWebGL() {
        try {
          const canvas = document.createElement("canvas");
          return !!(window.WebGLRenderingContext && canvas.getContext("webgl"));
        } catch (e) {
          return false;
        }
      }
      detectNetwork() {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        return {
          type: (connection == null ? void 0 : connection.type) || "unknown",
          effectiveType: (connection == null ? void 0 : connection.effectiveType) || "unknown",
          downlink: (connection == null ? void 0 : connection.downlink) || 0,
          rtt: (connection == null ? void 0 : connection.rtt) || 0,
          saveData: (connection == null ? void 0 : connection.saveData) || false
        };
      }
      detectPerformance() {
        const memory = performance.memory;
        return {
          memoryLimit: (memory == null ? void 0 : memory.usedJSHeapSize) ? Math.round(memory.usedJSHeapSize / 1024 / 1024) : 0,
          processorCores: navigator.hardwareConcurrency || 1,
          maxTouchPoints: navigator.maxTouchPoints || 0,
          pixelRatio: window.devicePixelRatio || 1
        };
      }
      detectLimitations(device, capabilities, network, performance2) {
        const reasons = [];
        let resourceConstrained = false;
        let functionalityLimited = false;
        let networkConstrained = false;
        let storageConstrained = false;
        if (performance2.memoryLimit > 0 && performance2.memoryLimit < 100) {
          resourceConstrained = true;
          reasons.push("Low memory available (< 100MB)");
        }
        if (performance2.processorCores <= 2) {
          resourceConstrained = true;
          reasons.push("Limited CPU cores (\u2264 2)");
        }
        if (device.type === "smartphone") {
          resourceConstrained = true;
          reasons.push("Smartphone has inherent resource limitations");
        }
        if (!capabilities.hasFileAPI) {
          functionalityLimited = true;
          reasons.push("File API not available");
        }
        if (!capabilities.hasClipboardAPI) {
          functionalityLimited = true;
          reasons.push("Clipboard API limited or unavailable");
        }
        if (!capabilities.hasServiceWorker) {
          functionalityLimited = true;
          reasons.push("Service Worker not supported");
        }
        if (network.effectiveType === "slow-2g" || network.effectiveType === "2g") {
          networkConstrained = true;
          reasons.push("Slow network connection detected");
        }
        if (network.saveData) {
          networkConstrained = true;
          reasons.push("Data saver mode enabled");
        }
        if (network.downlink > 0 && network.downlink < 1) {
          networkConstrained = true;
          reasons.push("Low bandwidth connection");
        }
        try {
          if ("storage" in navigator && "estimate" in navigator.storage) {
            storageConstrained = true;
            reasons.push("Storage may be limited on mobile device");
          }
        } catch (e) {
        }
        return {
          resourceConstrained,
          functionalityLimited,
          networkConstrained,
          storageConstrained,
          reasons
        };
      }
      detectNpmIssues(os, deviceType, limitations) {
        const problematicPackages = [];
        const unavailableFeatures = [];
        const recommendedAlternatives = {};
        if (os === "iOS") {
          problematicPackages.push("fs-extra", "child_process", "crypto (Node.js)", "path", "os", "node-fetch (older versions)", "jsdom", "puppeteer", "playwright");
          unavailableFeatures.push("File system access", "Process spawning", "Node.js crypto module", "Server-side rendering packages", "Headless browsers");
          recommendedAlternatives["node-fetch"] = "native fetch API";
          recommendedAlternatives["fs-extra"] = "File API / FileSystem Access API";
          recommendedAlternatives["crypto"] = "Web Crypto API";
        }
        if (os === "Android") {
          problematicPackages.push("fs-extra", "child_process", "node-fetch (older versions)", "jsdom", "puppeteer", "playwright", "native modules");
          unavailableFeatures.push("File system access", "Process spawning", "Native module compilation", "Headless browsers", "System-level APIs");
        }
        if (deviceType === "smartphone" || deviceType === "tablet") {
          problematicPackages.push("webpack-dev-server", "nodemon", "pm2", "sharp (native)", "sqlite3 (native)", "bcrypt (native)", "canvas (native)");
          unavailableFeatures.push("Hot module replacement", "File watching", "Process management", "Native image processing", "Native database drivers");
          recommendedAlternatives["sharp"] = "canvas API or browser-compatible image libraries";
          recommendedAlternatives["sqlite3"] = "IndexedDB or WebSQL";
          recommendedAlternatives["bcrypt"] = "Web Crypto API with PBKDF2";
          recommendedAlternatives["canvas"] = "HTML5 Canvas API";
        }
        if (limitations.networkConstrained) {
          problematicPackages.push("large bundled packages", "moment.js (large)", "lodash (full)");
          recommendedAlternatives["moment.js"] = "date-fns or dayjs (smaller)";
          recommendedAlternatives["lodash"] = "lodash-es with tree shaking";
        }
        if (limitations.resourceConstrained) {
          problematicPackages.push("large UI frameworks", "heavy computation libraries", "memory-intensive packages", "large ML/AI libraries");
          unavailableFeatures.push("Heavy computations", "Large data processing", "Memory-intensive operations", "Complex ML models");
        }
        return {
          problematicPackages,
          unavailableFeatures,
          recommendedAlternatives
        };
      }
      getDeviceSummary() {
        const info = this.getDeviceInfo();
        const parts = [];
        if (info.isMobile) {
          parts.push(`\u{1F4F1} ${info.device.type.charAt(0).toUpperCase() + info.device.type.slice(1)}`);
        } else {
          parts.push("\u{1F5A5}\uFE0F Desktop");
        }
        parts.push(`${info.platform.name} ${info.platform.version}`);
        if (info.device.vendor !== "Unknown") {
          parts.push(info.device.vendor);
        }
        if (info.device.model !== "Unknown") {
          parts.push(info.device.model);
        }
        return parts.join(" \u2022 ");
      }
      getCriticalWarnings() {
        const info = this.getDeviceInfo();
        const warnings = [];
        if (info.limitations.resourceConstrained) {
          warnings.push("\u26A0\uFE0F Device has limited resources - some features may be slower");
        }
        if (info.limitations.functionalityLimited) {
          warnings.push("\u26A0\uFE0F Some browser APIs are not available on this device");
        }
        if (info.limitations.networkConstrained) {
          warnings.push("\u26A0\uFE0F Network connection may affect performance");
        }
        if (info.npm.problematicPackages.length > 5) {
          warnings.push("\u26A0\uFE0F Many NPM packages may not work properly on this platform");
        }
        return warnings;
      }
    };
  }
});

// src/utils/urlHelpers.ts
var urlHelpers_exports = {};
__export(urlHelpers_exports, {
  CACHE_BUSTER: () => CACHE_BUSTER,
  normalizeApiUrl: () => normalizeApiUrl
});
function normalizeApiUrl(serverUrl) {
  if (!serverUrl) {
    return serverUrl;
  }
  if (serverUrl.endsWith("/api/v1")) {
    return serverUrl;
  }
  let normalized = serverUrl.replace(/\/$/, "");
  return `${normalized}/api/v1`;
}
var CACHE_BUSTER;
var init_urlHelpers = __esm({
  "src/utils/urlHelpers.ts"() {
    CACHE_BUSTER = {
      shouldApply: (endpoint) => {
        return endpoint.includes("/license/validate");
      },
      generate: () => `_t=${Date.now()}`,
      apply: (url) => {
        if (CACHE_BUSTER.shouldApply(url)) {
          const separator = url.includes("?") ? "&" : "?";
          return `${url}${separator}${CACHE_BUSTER.generate()}`;
        }
        return url;
      }
    };
  }
});

// src/constants/webSearch.ts
var WEB_SEARCH_CONFIG, MOBILE_STREAM_CONFIG;
var init_webSearch = __esm({
  "src/constants/webSearch.ts"() {
    WEB_SEARCH_CONFIG = {
      MAX_RESULTS: 5,
      PLUGIN_ID: "web",
      DEFAULT_CONTEXT_SIZE: "medium"
    };
    MOBILE_STREAM_CONFIG = {
      CHUNK_SIZE: 50,
      CHUNK_DELAY_MS: 10
    };
  }
});

// src/services/SystemSculptService.ts
function deterministicId(input, prefix) {
  const hash = simpleHash(input);
  const extendedHash = simpleHash(hash + input) + simpleHash(input + hash);
  return `${prefix}_${extendedHash.slice(0, 24)}`;
}
var import_obsidian18, import_obsidian19, _SystemSculptService, SystemSculptService;
var init_SystemSculptService = __esm({
  "src/services/SystemSculptService.ts"() {
    import_obsidian18 = __toModule(require("obsidian"));
    init_SystemPromptService();
    init_errors();
    init_licenseUtils();
    init_ImageProcessor();
    init_api();
    init_MCPService();
    init_debugLogger();
    init_FileValidator();
    init_errorHandling();
    init_modelUtils();
    init_agent2();
    import_obsidian19 = __toModule(require("obsidian"));
    init_cryptoUtils();
    init_MobileDetection();
    init_urlHelpers();
    init_modelUtils();
    init_webSearch();
    _SystemSculptService = class {
      constructor(plugin) {
        this.decoder = new TextDecoder();
        this.incompleteChunk = "";
        this.isInsideThinkTags = false;
        this.plugin = plugin;
        this.settings = plugin.settings;
        this.licenseKey = this.settings.licenseKey;
        this.app = plugin.app;
        this.customProviderService = plugin.customProviderService;
        if (!this.customProviderService) {
          throw new Error("SystemSculptService requires CustomProviderService to be initialized first. This is likely a plugin initialization order issue.");
        }
        this.mcpService = new MCPService(plugin, plugin.app);
        this.baseUrl = this.getValidServerUrl();
      }
      generateRequestId() {
        try {
          if (typeof crypto !== "undefined" && crypto.randomUUID) {
            return crypto.randomUUID();
          }
        } catch (e) {
          console.warn("[SystemSculpt] crypto.randomUUID not available, using fallback");
        }
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 15);
        return `${timestamp}-${random}`;
      }
      get extractionsDirectory() {
        var _a;
        return (_a = this.settings.extractionsDirectory) != null ? _a : "";
      }
      static getInstance(plugin) {
        if (!_SystemSculptService.instance) {
          _SystemSculptService.instance = new _SystemSculptService(plugin);
        } else {
          _SystemSculptService.instance.updateSettings(plugin.settings);
        }
        return _SystemSculptService.instance;
      }
      static clearInstance() {
        _SystemSculptService.instance = null;
      }
      updateSettings(settings) {
        this.settings = settings;
        this.licenseKey = settings.licenseKey;
      }
      getValidServerUrl() {
        let serverUrl = this.settings.serverUrl;
        const { API_BASE_URL: API_BASE_URL2 } = (init_api(), api_exports);
        const { normalizeApiUrl: normalizeApiUrl3 } = (init_urlHelpers(), urlHelpers_exports);
        if (!serverUrl || serverUrl.trim() === "") {
          serverUrl = API_BASE_URL2;
        } else if (serverUrl.includes("localhost") && API_BASE_URL2.includes("api.systemsculpt.com")) {
          serverUrl = API_BASE_URL2;
          this.plugin.getSettingsManager().updateSettings({ serverUrl: API_BASE_URL2 }).catch(console.error);
        } else if (serverUrl.includes("api.systemsculpt.com") && API_BASE_URL2.includes("localhost")) {
          serverUrl = API_BASE_URL2;
          this.plugin.getSettingsManager().updateSettings({ serverUrl: API_BASE_URL2 }).catch(console.error);
        }
        return normalizeApiUrl3(serverUrl);
      }
      refreshSettings() {
        this.settings = this.plugin.settings;
        this.baseUrl = this.getValidServerUrl();
        this.licenseKey = this.settings.licenseKey;
      }
      async makeRequest(endpoint, options = {}) {
        if (options.requiresPro && !endpoint.includes("/license/validate")) {
          const isValid = await this.validateLicense(true);
          if (!isValid) {
            throw new SystemSculptError(getErrorMessage(ERROR_CODES.PRO_REQUIRED), ERROR_CODES.PRO_REQUIRED, 403);
          }
        }
        const headers = this.licenseKey ? SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(this.licenseKey) : SYSTEMSCULPT_API_HEADERS.DEFAULT;
        const url = `${this.baseUrl}${endpoint}`;
        let response;
        try {
          response = await (0, import_obsidian18.requestUrl)({
            url,
            method: options.method || "GET",
            headers: {
              ...headers,
              ...options.headers || {}
            },
            body: options.body,
            throw: false
          });
        } catch (requestError) {
          throw requestError;
        }
        let apiResponse;
        try {
          apiResponse = response.json;
        } catch (e) {
          throw new SystemSculptError(getErrorMessage(ERROR_CODES.INVALID_RESPONSE), ERROR_CODES.INVALID_RESPONSE, response.status);
        }
        if (response.status !== 200 || apiResponse.status === "error") {
          this.handleApiError(endpoint, response, apiResponse);
        }
        return apiResponse.data !== void 0 ? apiResponse.data : apiResponse;
      }
      handleApiError(_endpoint, response, apiResponse) {
        if (apiResponse.error) {
          const errorCode = apiResponse.error.code || ERROR_CODES.UNKNOWN_ERROR;
          const statusCode = apiResponse.error.statusCode || response.status;
          const errorMessage = getErrorMessage(errorCode, apiResponse.error.model);
          const metadata = {};
          if (errorCode === ERROR_CODES.MODEL_UNAVAILABLE || errorCode === ERROR_CODES.MODEL_REQUEST_ERROR) {
            metadata.shouldResubmit = true;
            metadata.model = apiResponse.error.model;
          }
          throw new SystemSculptError(errorMessage, errorCode, statusCode, metadata);
        }
        throw new SystemSculptError(getErrorMessage(ERROR_CODES.UNKNOWN_ERROR), ERROR_CODES.UNKNOWN_ERROR, response.status);
      }
      async handleStreamError(response, isCustomProvider = false) {
        var _a, _b, _c, _d;
        try {
          let data;
          try {
            data = await response.json();
          } catch (err) {
            throw new SystemSculptError("Error processing response from API", ERROR_CODES.STREAM_ERROR, response.status, { responseText: await response.text() });
          }
          let errorCode = ERROR_CODES.STREAM_ERROR;
          let errorMessage = "Unknown error";
          let metadata = {};
          if (data.error) {
            if (data.error.code === "unsupported_parameter" && data.error.param === "temperature") {
              console.warn("[SystemSculpt] Temperature parameter not supported for this model:", data.error.message);
              errorCode = ERROR_CODES.MODEL_REQUEST_ERROR;
              errorMessage = TEMPERATURE_UNSUPPORTED_ERROR;
              metadata = {
                modelIssue: true,
                param: "temperature",
                suggestion: "Please report this issue - the model should have been detected as a reasoning model."
              };
            } else if (data.error.code === "unsupported_value" && ((_a = data.error.message) == null ? void 0 : _a.toLowerCase().includes("temperature"))) {
              console.warn("[SystemSculpt] Temperature value not supported for this model:", data.error.message);
              errorCode = ERROR_CODES.MODEL_REQUEST_ERROR;
              errorMessage = TEMPERATURE_VALUE_ERROR;
              metadata = {
                modelIssue: true,
                param: "temperature",
                suggestion: "Model detected as reasoning model - temperature has been handled."
              };
            } else if (isCustomProvider) {
              const status = response.status;
              let model = data.model;
              if (!model && typeof ((_b = data.error) == null ? void 0 : _b.message) === "string") {
                const match = data.error.message.match(/model\s+`?([\\w\\-\\.\/]+)`?/i);
                if (match && match[1]) {
                  model = match[1];
                }
              }
              if (!model) {
                model = "unknown";
              }
              if (status === 404 || ((_c = data.error.message) == null ? void 0 : _c.includes("model")) && ((_d = data.error.message) == null ? void 0 : _d.includes("does not exist"))) {
                errorCode = ERROR_CODES.MODEL_UNAVAILABLE;
                errorMessage = `Model ${model} is unavailable with this provider.`;
                metadata.shouldResubmit = true;
              } else if (status === 429) {
                errorCode = ERROR_CODES.QUOTA_EXCEEDED;
                errorMessage = data.error.message || "Rate limit or quota exceeded. Please try again later.";
              } else if (status === 401) {
                errorCode = ERROR_CODES.INVALID_LICENSE;
                errorMessage = data.error.message || "Invalid API key or authentication error.";
              } else {
                errorCode = data.error.code || ERROR_CODES.STREAM_ERROR;
                errorMessage = data.error.message || "An error occurred with the provider.";
                if (errorMessage.includes("unavailable") || errorMessage.includes("not found")) {
                  metadata.shouldResubmit = true;
                }
              }
              metadata = {
                provider: data.provider || "unknown",
                model,
                statusCode: status,
                rawError: data.error
              };
            } else {
              errorCode = data.error.code || ERROR_CODES.STREAM_ERROR;
              errorMessage = data.error.message || getErrorMessage(errorCode);
              metadata = {
                model: data.model,
                statusCode: response.status,
                rawError: data.error
              };
              if (response.status === 404 || errorCode === ERROR_CODES.MODEL_UNAVAILABLE || errorMessage.includes("unavailable") || errorMessage.includes("not found")) {
                metadata.shouldResubmit = true;
              }
            }
          }
          console.error("[SystemSculpt] Stream error details:", {
            status: response.status,
            errorCode,
            errorMessage,
            rawError: data,
            metadata
          });
          throw new SystemSculptError(errorMessage, errorCode, response.status, metadata);
        } catch (error) {
          if (error instanceof SystemSculptError) {
            throw error;
          }
          throw new SystemSculptError(`Stream error (HTTP ${response.status})`, ERROR_CODES.STREAM_ERROR, response.status);
        }
      }
      async validateLicense(_forceCheck = false) {
        var _a, _b;
        this.refreshSettings();
        if (!((_a = this.licenseKey) == null ? void 0 : _a.trim())) {
          console.warn("[SystemSculpt] No license key provided or key is whitespace.");
          if (this.plugin.settings.licenseValid) {
            await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
          }
          return false;
        }
        const validationEndpoint = SYSTEMSCULPT_API_ENDPOINTS.LICENSE.VALIDATE(this.licenseKey);
        const endpointWithCacheBuster = CACHE_BUSTER.apply(validationEndpoint);
        try {
          const response = await this.makeRequest(endpointWithCacheBuster, {
            method: "GET",
            showNotices: false
          });
          if (response && typeof response.is_pro === "boolean") {
            if (response.is_pro) {
              await this.plugin.getSettingsManager().updateSettings({
                licenseValid: true,
                userEmail: response.email,
                userName: response.user_name || response.email,
                displayName: response.display_name || response.user_name || response.email,
                creditsBalance: response.credits_balance
              });
              return true;
            } else {
              console.warn("[SystemSculpt] License reported as INVALID by API.", response);
              await this.plugin.getSettingsManager().updateSettings({
                licenseValid: false,
                userEmail: void 0,
                userName: void 0,
                displayName: void 0,
                creditsBalance: void 0
              });
              return false;
            }
          } else {
            console.warn("[SystemSculpt] License response malformed or is_pro field missing/invalid.", response);
            await this.plugin.getSettingsManager().updateSettings({
              licenseValid: false,
              userEmail: void 0,
              userName: void 0,
              displayName: void 0,
              creditsBalance: void 0
            });
            return false;
          }
        } catch (error) {
          let errorMessage = "Unknown error during license validation.";
          let errorCode = "UNKNOWN";
          let statusCode = "N/A";
          if (error instanceof SystemSculptError) {
            errorMessage = error.message;
            errorCode = error.code;
            statusCode = ((_b = error.statusCode) == null ? void 0 : _b.toString()) || "N/A";
          } else if (error instanceof Error) {
            errorMessage = error.message;
          }
          console.error(`[SystemSculpt] SystemSculptService.validateLicense: Error during license validation. Key used: '${this.licenseKey}'. ErrorCode: ${errorCode}, StatusCode: ${statusCode}, Message: ${errorMessage}`, error);
          if (this.plugin.settings.licenseValid) {
            await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
          }
          return false;
        }
      }
      async getModels() {
        this.refreshSettings();
        if (!this.settings.enableSystemSculptProvider) {
          return [];
        }
        try {
          const apiResponse = await this.makeRequest(SYSTEMSCULPT_API_ENDPOINTS.MODELS.LIST, {
            method: "GET",
            requiresPro: true
          });
          let apiModels;
          if (Array.isArray(apiResponse)) {
            apiModels = apiResponse;
          } else if (apiResponse && Array.isArray(apiResponse.models)) {
            apiModels = apiResponse.models;
          } else if (apiResponse && Array.isArray(apiResponse.data)) {
            apiModels = apiResponse.data;
          } else {
            console.warn("[SystemSculpt] Unexpected API response format:", apiResponse);
            throw new Error("Invalid API response format");
          }
          const systemSculptModels = apiModels.map((model) => {
            const canonicalId = `systemsculpt${MODEL_ID_SEPARATOR}${model.id}`;
            return {
              ...model,
              id: canonicalId,
              provider: "systemsculpt",
              identifier: {
                providerId: "systemsculpt",
                modelId: model.id,
                displayName: model.name
              }
            };
          });
          const { MODEL_ID, MODEL_DISPLAY_NAME, MODEL_DESCRIPTION } = AGENT_CONFIG;
          const [, baseModelId] = MODEL_ID.split(MODEL_ID_SEPARATOR);
          const databaseAgentModel = systemSculptModels.find((model) => {
            var _a;
            return ((_a = model.identifier) == null ? void 0 : _a.modelId) === baseModelId;
          });
          let agentModel;
          if (databaseAgentModel) {
            agentModel = {
              ...databaseAgentModel,
              id: MODEL_ID,
              name: MODEL_DISPLAY_NAME,
              description: MODEL_DESCRIPTION,
              identifier: {
                ...databaseAgentModel.identifier,
                displayName: MODEL_DISPLAY_NAME
              }
            };
          } else {
            console.warn("[SystemSculpt] Agent base model not found in database, using fallback");
            agentModel = {
              identifier: {
                providerId: "systemsculpt",
                modelId: baseModelId,
                displayName: MODEL_DISPLAY_NAME
              },
              id: MODEL_ID,
              name: MODEL_DISPLAY_NAME,
              description: MODEL_DESCRIPTION,
              context_length: 128e3,
              capabilities: ["tools", "function_calling"],
              supported_parameters: ["temperature", "top_p", "max_tokens", "stream", "tools"],
              architecture: { modality: "", tokenizer: void 0, instruct_type: null },
              pricing: { prompt: "0", completion: "0", image: "0", request: "0" },
              provider: "systemsculpt"
            };
          }
          const otherModels = systemSculptModels.filter((model) => {
            var _a;
            return ((_a = model.identifier) == null ? void 0 : _a.modelId) !== baseModelId;
          });
          return [agentModel, ...otherModels];
        } catch (error) {
          console.warn("[SystemSculpt] Failed to fetch models from API, falling back to agent model only:", error);
          const { MODEL_ID, MODEL_DISPLAY_NAME, MODEL_DESCRIPTION } = AGENT_CONFIG;
          const [, baseModelId] = MODEL_ID.split(MODEL_ID_SEPARATOR);
          const fallbackModel = {
            identifier: {
              providerId: "systemsculpt",
              modelId: baseModelId,
              displayName: MODEL_DISPLAY_NAME
            },
            id: MODEL_ID,
            name: MODEL_DISPLAY_NAME,
            description: MODEL_DESCRIPTION,
            context_length: 128e3,
            capabilities: ["tools", "function_calling"],
            supported_parameters: ["temperature", "top_p", "max_tokens", "stream", "tools"],
            architecture: { modality: "", tokenizer: void 0, instruct_type: null },
            pricing: { prompt: "0", completion: "0", image: "0", request: "0" },
            provider: "systemsculpt"
          };
          return [fallbackModel];
        }
      }
      async getTokenBalance() {
        const isValid = await this.validateLicense(true);
        if (!isValid)
          return 0;
        const licenseInfo = await this.makeRequest(SYSTEMSCULPT_API_ENDPOINTS.LICENSE.VALIDATE(this.licenseKey), {
          method: "GET",
          headers: SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(this.licenseKey)
        });
        return licenseInfo.credits_balance || 0;
      }
      async getCreditBreakdown() {
        const isValid = await this.validateLicense(true);
        if (!isValid) {
          console.log("[SystemSculpt] License invalid, returning null for credit breakdown");
          return null;
        }
        try {
          console.log("[SystemSculpt] Attempting to fetch credit breakdown from:", SYSTEMSCULPT_API_ENDPOINTS.CREDITS.GET);
          const creditInfo = await this.makeRequest(SYSTEMSCULPT_API_ENDPOINTS.CREDITS.GET, {
            method: "GET",
            headers: SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(this.licenseKey)
          });
          console.log("[SystemSculpt] Credit breakdown API response:", creditInfo);
          return creditInfo;
        } catch (error) {
          console.warn("[SystemSculpt] Credit breakdown endpoint not available, falling back to total balance", error);
          const total = await this.getTokenBalance();
          const fallbackBreakdown = {
            monthly: total,
            additional: 0,
            total
          };
          console.log("[SystemSculpt] Using fallback credit breakdown:", fallbackBreakdown);
          return fallbackBreakdown;
        }
      }
      async getContextFileContents(filePath) {
        try {
          const linkText = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
          const cleanPath = linkText.replace(/\$begin:math:display\$\[(.*?)\$end:math:display\$]/g, "$1");
          const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(cleanPath, "");
          if (resolvedFile instanceof import_obsidian18.TFile) {
            if (resolvedFile.extension.match(/^(jpg|jpeg|png|gif|webp)$/i)) {
              const base64 = await ImageProcessor.processImage(resolvedFile, this.app);
              return { type: "image", base64 };
            }
            const content = await this.app.vault.read(resolvedFile);
            return content;
          }
          const fileName = cleanPath.split("/").pop();
          if (fileName) {
            const allFiles = this.app.vault.getFiles();
            const matchingFile = allFiles.find((f) => f.name === fileName);
            if (matchingFile) {
              if (matchingFile.extension.match(/^(jpg|jpeg|png|gif|webp)$/i)) {
                const base64 = await ImageProcessor.processImage(matchingFile, this.app);
                return { type: "image", base64 };
              }
              const content = await this.app.vault.read(matchingFile);
              return content;
            }
          }
          return null;
        } catch (error) {
          return null;
        }
      }
      async buildContextMessageFromFile(filePath) {
        var _a;
        if (filePath === "@@vault-structure@@") {
          const activeView = this.app.workspace.getActiveViewOfType(import_obsidian18.ItemView);
          if (activeView && "contextManager" in activeView) {
            const chatView = activeView;
            const vaultStructure = (_a = chatView.contextManager) == null ? void 0 : _a.getVaultStructureContent();
            if (vaultStructure) {
              return {
                role: "user",
                content: `[VAULT STRUCTURE]
This is the current directory structure of the user's Obsidian vault:

${vaultStructure}

Note: This structure shows only directories to help you understand the vault organization. Use this to provide context-aware suggestions and navigate the user's knowledge base effectively.`,
                message_id: deterministicId("vault-structure", "ctx")
              };
            }
          }
          return null;
        }
        const content = await this.getContextFileContents(filePath);
        const displayName = filePath.replace(/\$begin:math:display\$\[(.*?)\$end:math:display\$]/g, "$1");
        if (content) {
          if (typeof content === "string") {
            return {
              role: "user",
              content: `Context from ${displayName}:

${content}`,
              message_id: deterministicId(filePath, "ctx")
            };
          } else if (content.type === "image") {
            return {
              role: "user",
              content: [
                {
                  type: "text",
                  text: `Context from ${displayName}:

`
                },
                {
                  type: "image_url",
                  image_url: {
                    url: `data:image/png;base64,${content.base64.replace(/^data:.*;base64,/, "")}`
                  }
                }
              ],
              message_id: deterministicId(filePath, "ctx")
            };
          }
        }
        return null;
      }
      async prepareMessagesWithContext(messages, contextFiles, systemPromptType, systemPromptPath, agentMode, toolCallManager) {
        var _a, _b, _c;
        const preparedMessages = [];
        let systemPromptContent;
        const normalizedType = systemPromptType == null ? void 0 : systemPromptType.toLowerCase();
        if (normalizedType === "custom" && systemPromptPath) {
          try {
            const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(systemPromptPath, "");
            if (resolvedFile instanceof import_obsidian18.TFile) {
              systemPromptContent = await this.app.vault.read(resolvedFile);
            } else {
              const fileWithExt = this.app.vault.getAbstractFileByPath(`${systemPromptPath}.md`);
              if (fileWithExt instanceof import_obsidian18.TFile) {
                systemPromptContent = await this.app.vault.read(fileWithExt);
              } else {
                const fileInSystemPromptsDir = this.app.vault.getAbstractFileByPath(`SystemSculpt/System Prompts/${systemPromptPath}.md`);
                if (fileInSystemPromptsDir instanceof import_obsidian18.TFile) {
                  systemPromptContent = await this.app.vault.read(fileInSystemPromptsDir);
                }
              }
            }
          } catch (error) {
            console.error("[SystemSculpt] Error reading custom system prompt:", error);
          }
        } else if (normalizedType === "general-use" || normalizedType === "concise" || normalizedType === "agent") {
          try {
            systemPromptContent = await SystemPromptService.getInstance(this.app, () => ({})).getSystemPromptContent(normalizedType, void 0, agentMode);
          } catch (error) {
            console.error("[SystemSculpt] Error fetching system prompt preset:", error);
          }
        } else {
          try {
            systemPromptContent = await SystemPromptService.getInstance(this.app, () => ({})).getSystemPromptContent("general-use", void 0, agentMode);
          } catch (error) {
            console.error("[SystemSculpt] Error fetching default system prompt:", error);
          }
        }
        if (systemPromptContent) {
          preparedMessages.push({
            role: "system",
            content: systemPromptContent,
            message_id: deterministicId(systemPromptContent, "sys")
          });
        } else {
          const fallbackPrompt = "You are a helpful AI assistant. Provide clear, accurate, and relevant information.";
          preparedMessages.push({
            role: "system",
            content: fallbackPrompt,
            message_id: deterministicId(fallbackPrompt, "sys")
          });
        }
        const documentIds = [];
        for (const filePath of contextFiles) {
          if (filePath.startsWith("doc:")) {
            const documentId = filePath.substring(4);
            documentIds.push(documentId);
          } else {
            const contextMessage = await this.buildContextMessageFromFile(filePath);
            if (contextMessage) {
              if (filePath === "@@vault-structure@@") {
                console.log("[SystemSculpt] Adding vault structure to context");
              }
              preparedMessages.push(contextMessage);
            }
          }
        }
        if (documentIds.length > 0) {
          const firstMessage = messages[0];
          if (firstMessage) {
            firstMessage.documentContext = { documentIds };
          }
        }
        for (const msg of messages) {
          if (msg.role === "assistant" && Array.isArray(msg.tool_calls) && msg.tool_calls.length > 0) {
            if (agentMode) {
              const toolCallsForApi = msg.tool_calls.map((toolCall) => {
                if (toolCall.request) {
                  return toolCall.request;
                } else if (toolCall.type === "function" && toolCall.function) {
                  return toolCall;
                } else {
                  console.error("[SystemSculpt] Invalid tool call format:", toolCall);
                  return null;
                }
              }).filter((tc) => tc !== null);
              const assistantApiMessage = {
                role: "assistant",
                message_id: msg.message_id
              };
              if (toolCallsForApi.length > 0) {
                assistantApiMessage.tool_calls = toolCallsForApi;
              }
              assistantApiMessage.content = msg.content || "";
              preparedMessages.push(assistantApiMessage);
              for (const toolCall of msg.tool_calls) {
                let toolContent;
                if (toolCall.state === "completed" && ((_a = toolCall.result) == null ? void 0 : _a.success)) {
                  toolContent = typeof toolCall.result.data === "string" ? toolCall.result.data : JSON.stringify(toolCall.result.data);
                } else if (toolCall.state === "failed" || toolCall.state === "completed" && !((_b = toolCall.result) == null ? void 0 : _b.success)) {
                  toolContent = JSON.stringify({ error: ((_c = toolCall.result) == null ? void 0 : _c.error) || { code: "EXECUTION_FAILED", message: "Tool execution failed without a specific error." } });
                } else if (toolCall.state === "denied") {
                  toolContent = JSON.stringify({ error: { code: "USER_DENIED", message: "The user has explicitly denied this tool call request." } });
                } else {
                  continue;
                }
                preparedMessages.push({
                  role: "tool",
                  tool_call_id: toolCall.id,
                  content: toolContent,
                  message_id: deterministicId(toolContent, "tool")
                });
              }
            } else {
              console.log(`[SystemSculpt] Agent mode OFF - stripping ${msg.tool_calls.length} tool calls from assistant message`);
              const assistantMessageWithoutTools = {
                role: "assistant",
                message_id: msg.message_id,
                content: msg.content || ""
              };
              preparedMessages.push(assistantMessageWithoutTools);
            }
          } else if (msg.role !== "tool") {
            const messageToPush = {
              role: msg.role,
              message_id: msg.message_id,
              documentContext: msg.documentContext,
              systemPromptType: msg.systemPromptType,
              systemPromptPath: msg.systemPromptPath,
              ...msg.tool_calls && msg.tool_calls.length > 0 && { tool_calls: msg.tool_calls }
            };
            if (msg.content) {
              messageToPush.content = msg.content;
            }
            preparedMessages.push(messageToPush);
          }
        }
        if (toolCallManager && agentMode) {
          this.optimizeToolResultsContext(preparedMessages, toolCallManager);
        }
        return preparedMessages;
      }
      optimizeToolResultsContext(preparedMessages, toolCallManager) {
        const recentToolResults = toolCallManager.getToolResultsForContext();
        const archivedSummary = toolCallManager.getArchivedToolResultsSummary();
        const toolMessageCount = preparedMessages.filter((msg) => msg.role === "tool").length;
        if (toolMessageCount > 15) {
          const recentToolCallIds = new Set(recentToolResults.map((tc) => tc.id));
          const filteredMessages = preparedMessages.filter((msg) => {
            if (msg.role !== "tool")
              return true;
            return recentToolCallIds.has(msg.tool_call_id || "");
          });
          if (archivedSummary && filteredMessages.length < preparedMessages.length) {
            const summaryMessage = {
              role: "system",
              content: `Context Note: ${archivedSummary}`,
              message_id: deterministicId(archivedSummary, "context")
            };
            const firstUserIndex = filteredMessages.findIndex((msg) => msg.role === "user");
            if (firstUserIndex > 0) {
              filteredMessages.splice(firstUserIndex, 0, summaryMessage);
            } else {
              filteredMessages.unshift(summaryMessage);
            }
          }
          preparedMessages.length = 0;
          preparedMessages.push(...filteredMessages);
        }
      }
      normalizeDataPrefix(line) {
        if (!(line == null ? void 0 : line.trim()))
          return "";
        const trimmed = line.trim();
        if (trimmed === "data:" || trimmed === "data: " || trimmed === "[DONE]" || trimmed.startsWith(": OPENROUTER")) {
          return "";
        }
        return trimmed.replace(/^(?:data:\s*)+/, "");
      }
      isValidStreamEvent(data, _isCustomProvider = false) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
        if (!data)
          return false;
        try {
          const parsed = JSON.parse(data);
          return !!(parsed && (((_c = (_b = (_a = parsed.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content) || ((_f = (_e = (_d = parsed.choices) == null ? void 0 : _d[0]) == null ? void 0 : _e.delta) == null ? void 0 : _f.reasoning) || ((_i = (_h = (_g = parsed.choices) == null ? void 0 : _g[0]) == null ? void 0 : _h.delta) == null ? void 0 : _i.function_call) || ((_l = (_k = (_j = parsed.choices) == null ? void 0 : _j[0]) == null ? void 0 : _k.delta) == null ? void 0 : _l.tool_calls) || ((_o = (_n = (_m = parsed.choices) == null ? void 0 : _m[0]) == null ? void 0 : _n.message) == null ? void 0 : _o.tool_calls) || ((_q = (_p = parsed.choices) == null ? void 0 : _p[0]) == null ? void 0 : _q.finish_reason) === "tool_calls" || parsed.error));
        } catch (e) {
          return false;
        }
      }
      processStreamLine(line, isCustomProvider = false) {
        if (!line.trim().startsWith("data:")) {
          return null;
        }
        const normalized = this.normalizeDataPrefix(line);
        return this.isValidStreamEvent(normalized, isCustomProvider) ? normalized : null;
      }
      async handleStreamEvent(event, model, _isCustomProvider = false) {
        var _a, _b, _c, _d, _e;
        if (!event)
          return null;
        try {
          let parsed;
          try {
            parsed = JSON.parse(event);
          } catch (parseError) {
            console.error(`[SystemSculpt] \u{1F527} Failed to parse stream event:`, event, parseError);
            return null;
          }
          if (!parsed)
            return null;
          if (parsed.webSearchEnabled !== void 0) {
            return { content: null, reasoning: null, webSearchEnabled: parsed.webSearchEnabled };
          }
          if (parsed.error) {
            console.error(`[SystemSculpt] \u{1F527} Error in stream:`, parsed.error);
            const errorCode = parsed.error.code || ERROR_CODES.STREAM_ERROR;
            let errorMessage = parsed.error.message || getErrorMessage(errorCode, model);
            const metadata = {
              model,
              shouldResubmit: false,
              rawError: parsed.error,
              originalEvent: event
            };
            if (errorCode === ERROR_CODES.MODEL_UNAVAILABLE || errorCode === ERROR_CODES.MODEL_REQUEST_ERROR) {
              metadata.shouldResubmit = true;
            }
            throw new SystemSculptError(errorMessage, errorCode, parsed.error.statusCode || 500, metadata);
          }
          const choice = (_a = parsed.choices) == null ? void 0 : _a[0];
          const content = ((_b = choice == null ? void 0 : choice.delta) == null ? void 0 : _b.content) || null;
          const reasoning = ((_c = choice == null ? void 0 : choice.delta) == null ? void 0 : _c.reasoning) || null;
          const toolCalls = ((_d = choice == null ? void 0 : choice.delta) == null ? void 0 : _d.tool_calls) || ((_e = choice == null ? void 0 : choice.message) == null ? void 0 : _e.tool_calls) || null;
          const logger = DebugLogger.getInstance();
          if (logger && (toolCalls || (choice == null ? void 0 : choice.finish_reason) === "tool_calls")) {
            await logger.log("STREAM_EVENT", "Tool calls in stream", { toolCalls, finishReason: choice == null ? void 0 : choice.finish_reason });
          }
          if (this.isInsideThinkTags) {
            let combinedText = "";
            if (reasoning)
              combinedText += reasoning;
            if (content)
              combinedText += content;
            const thinkEndMatch = combinedText.match(/(.*?)\s*<\/think>\s*(.*)/);
            if (thinkEndMatch) {
              this.isInsideThinkTags = false;
              return {
                reasoning: thinkEndMatch[1] || "",
                content: thinkEndMatch[2] || ""
              };
            }
            return {
              content: null,
              reasoning: combinedText || null
            };
          } else {
            if (content) {
              const thinkStartMatch = content.match(/<think>\s*(.*)/);
              if (thinkStartMatch) {
                this.isInsideThinkTags = true;
                return {
                  content: null,
                  reasoning: thinkStartMatch[1] || ""
                };
              }
            }
          }
          return {
            content,
            reasoning,
            ...toolCalls && { toolCalls }
          };
        } catch (e) {
          if (e instanceof SystemSculptError) {
            throw e;
          }
          return null;
        }
      }
      async processStreamChunk(chunk, buffer, model, isCustomProvider = false, accumulatedToolCalls) {
        var _a, _b, _c, _d, _e;
        let decoded;
        try {
          decoded = this.decoder.decode(chunk, { stream: true });
        } catch (decodeError) {
          console.error("[SystemSculpt] processStreamChunk decode error:", {
            error: decodeError,
            message: decodeError.message,
            chunkType: typeof chunk,
            chunkLength: chunk == null ? void 0 : chunk.length
          });
          throw new SystemSculptError(`Failed to decode stream chunk: ${decodeError.message}`, ERROR_CODES.STREAM_ERROR, 500);
        }
        const fullChunk = buffer + decoded;
        const lines = fullChunk.split("\n");
        const contents = [];
        const reasonings = [];
        const toolCalls = [];
        const completedToolCalls = [];
        let webSearchEnabled;
        for (let i = 0; i < lines.length - 1; i++) {
          const line = lines[i];
          const event = this.processStreamLine(line, isCustomProvider);
          if (event) {
            const result = await this.handleStreamEvent(event, model, isCustomProvider);
            if (result) {
              if (result.content)
                contents.push(result.content);
              if (result.reasoning)
                reasonings.push(result.reasoning);
              if (result.webSearchEnabled !== void 0)
                webSearchEnabled = result.webSearchEnabled;
              if (result.toolCalls && accumulatedToolCalls) {
                for (const toolCall of result.toolCalls) {
                  const index = (_a = toolCall.index) != null ? _a : 0;
                  const isCompleteCall = ((_b = toolCall.function) == null ? void 0 : _b.name) && ((_c = toolCall.function) == null ? void 0 : _c.arguments) && toolCall.function.arguments.length > 2;
                  if (isCompleteCall) {
                    const logger = DebugLogger.getInstance();
                    await (logger == null ? void 0 : logger.logToolCall("COMPLETE_TOOL_CALL_RECEIVED", {
                      index,
                      toolCall,
                      isCompleteCall: true
                    }));
                    accumulatedToolCalls.set(index, toolCall);
                    completedToolCalls.push(toolCall);
                  } else {
                    if (!accumulatedToolCalls.has(index)) {
                      let toolCallId = toolCall.id;
                      if (!toolCallId || !toolCallId.startsWith("call_")) {
                        toolCallId = `call_${crypto.randomUUID().replace(/-/g, "").substring(0, 24)}`;
                      }
                      accumulatedToolCalls.set(index, {
                        id: toolCallId,
                        type: toolCall.type || "function",
                        function: {
                          name: "",
                          arguments: ""
                        }
                      });
                    }
                    const accumulated = accumulatedToolCalls.get(index);
                    if ((_d = toolCall.function) == null ? void 0 : _d.name) {
                      accumulated.function.name += toolCall.function.name;
                    }
                    if ((_e = toolCall.function) == null ? void 0 : _e.arguments) {
                      accumulated.function.arguments += toolCall.function.arguments;
                    }
                  }
                }
              } else if (result.toolCalls) {
                toolCalls.push(...result.toolCalls);
              }
            }
          }
        }
        const newBuffer = lines[lines.length - 1].trim() ? lines[lines.length - 1] : "";
        return { newBuffer, contents, reasonings, toolCalls, completedToolCalls, webSearchEnabled };
      }
      stripProviderPrefixes(modelId) {
        return modelId.replace(/^openrouter\//, "");
      }
      async getModelInfo(modelId) {
        this.refreshSettings();
        console.log("[SystemSculpt] getModelInfo - looking up model:", modelId);
        const model = await this.plugin.modelService.getModelById(modelId);
        console.log("[SystemSculpt] getModelInfo - found model:", model);
        if (!model) {
          throw new SystemSculptError(`Model ${modelId} not found`, ERROR_CODES.MODEL_UNAVAILABLE, 404);
        }
        const parsed = parseCanonicalId(model.id);
        if (!parsed) {
          throw new SystemSculptError(`Invalid model ID format: ${model.id}`, ERROR_CODES.MODEL_UNAVAILABLE, 400);
        }
        const { providerId, modelId: actualModelId } = parsed;
        if (providerId === "systemsculpt") {
          return {
            isCustom: false,
            actualModelId: this.stripProviderPrefixes(actualModelId)
          };
        }
        const customProvider = this.settings.customProviders.find((p) => p.isEnabled && (p.id === providerId || p.name.toLowerCase() === providerId));
        if (!customProvider) {
          throw new SystemSculptError(`Custom provider ${providerId} not found or disabled`, ERROR_CODES.MODEL_UNAVAILABLE, 404);
        }
        return {
          isCustom: true,
          provider: customProvider,
          actualModelId
        };
      }
      async handleCustomProviderCompletion(provider, messages, temperature, modelId, mcpTools = [], signal, plugins, web_search_options) {
        try {
          const adapter = this.customProviderService.getProviderAdapter(provider);
          const headers = adapter.getHeaders();
          const fullEndpoint = adapter.getChatEndpoint();
          const mobileDetection = MobileDetection.getInstance();
          const isMobile = mobileDetection.isMobileDevice();
          const requestBody = adapter.buildRequestBody(messages, modelId, temperature, mcpTools, !isMobile);
          if (provider.name.toLowerCase().includes("openrouter")) {
            if (plugins && plugins.length > 0) {
              requestBody.plugins = plugins;
            }
            if (web_search_options) {
              requestBody.web_search_options = web_search_options;
            }
          }
          const logger = DebugLogger.getInstance();
          logger == null ? void 0 : logger.logAPIRequest(fullEndpoint, "POST", requestBody);
          let response;
          let canUseFetch = !isMobile && !fullEndpoint.includes("anthropic.com");
          if (canUseFetch) {
            try {
              response = await fetch(fullEndpoint, {
                method: "POST",
                headers,
                body: JSON.stringify(requestBody),
                signal
              });
            } catch (fetchError) {
              console.warn("[SystemSculpt] Fetch failed, falling back to requestUrl:", fetchError.message);
              canUseFetch = false;
            }
          }
          if (!canUseFetch || !response) {
            try {
              const isAnthropicEndpoint2 = fullEndpoint.includes("anthropic.com");
              const finalRequestBody = isAnthropicEndpoint2 || isMobile ? { ...requestBody, stream: false } : requestBody;
              const result = await (0, import_obsidian18.requestUrl)({
                url: fullEndpoint,
                method: "POST",
                headers,
                body: JSON.stringify(finalRequestBody),
                throw: false
              });
              if (!result.status || result.status >= 400) {
                const errorData = result.json || {};
                response = new Response(JSON.stringify(errorData), {
                  status: result.status || 500,
                  statusText: "Error",
                  headers: { "Content-Type": "application/json" }
                });
              } else {
                const responseBody = JSON.stringify(result.json || result.text);
                response = new Response(responseBody, {
                  status: 200,
                  statusText: "OK",
                  headers: {
                    "Content-Type": result.json ? "application/json" : "text/plain"
                  }
                });
              }
            } catch (requestError) {
              const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
              const message = `\u274C Connection to API endpoint failed:

${fullEndpoint}

${isMobile ? "Mobile network error. Please check your connection." : "Please ensure the API server is running and accessible."}

Common issues:
\u2022 Invalid API key
\u2022 Rate limits
\u2022 Network connectivity

Check your settings and try again.`;
              console.error("[SystemSculpt] Connection error:", requestError);
              showNoticeWhenReady2(this.app, message, { type: "error", duration: 15e3 });
              throw requestError;
            }
          }
          if (!response.ok) {
            await this.handleStreamError(response, true);
          }
          const { stream, headers: transformHeaders } = await adapter.transformStreamResponse(response, isMobile);
          return new Response(stream, {
            status: response.status,
            statusText: response.statusText,
            headers: transformHeaders || response.headers
          });
        } catch (error) {
          console.error("[SystemSculpt] Custom provider completion error:", error);
          throw error;
        }
      }
      async *streamMessage({
        messages,
        model,
        temperature = 0.7,
        onError,
        contextFiles,
        systemPromptType,
        systemPromptPath,
        agentMode,
        signal,
        toolCallManager,
        plugins,
        web_search_options
      }) {
        var _a;
        const { DEVELOPMENT_MODE: DEVELOPMENT_MODE2 } = await Promise.resolve().then(() => (init_api(), api_exports));
        this.refreshSettings();
        const isSystemSculptModel = (model.includes("systemsculpt") || model.startsWith("claude-") && !model.includes("@@")) && !model.startsWith("anthropic@@");
        if (isSystemSculptModel && !verifyPremiumAccess(this.plugin.settings, 1, true)) {
          throw new SystemSculptError("Insufficient credits or invalid license", ERROR_CODES.INVALID_LICENSE, 403);
        }
        try {
          this.isInsideThinkTags = false;
          const accumulatedToolCalls = new Map();
          const preparedMessages = await this.prepareMessagesWithContext(messages, contextFiles || new Set(), systemPromptType, systemPromptPath, agentMode, toolCallManager);
          console.log("[SystemSculpt] Getting model info for:", model);
          const { isCustom, provider, actualModelId } = await this.getModelInfo(model);
          console.log("[SystemSculpt] Model info result:", { isCustom, provider: provider == null ? void 0 : provider.name, actualModelId });
          let mcpTools = [];
          let compatibleTools = [];
          let toolCompatibilityWarning = null;
          if (agentMode) {
            mcpTools = await this.mcpService.getAvailableTools();
            if (mcpTools.length > 0 && preparedMessages.length > 0 && preparedMessages[0].role === "system") {
              preparedMessages[0].content += "\n\nYou have access to filesystem tools to interact with the user's vault. Use them when asked about files or directories.";
            }
          }
          if (mcpTools.length > 0) {
            let modelToCheck;
            try {
              const allModels = await this.plugin.modelService.getModels();
              modelToCheck = allModels.find((m) => m.id === model || m.id === actualModelId);
            } catch (error) {
              console.warn("[SystemSculpt] Could not load models for tool compatibility check:", error);
            }
            if (modelToCheck) {
              const compatibility = getToolCompatibilityInfo(modelToCheck);
              compatibleTools = mcpTools;
              if (compatibility.isCompatible) {
              } else {
                if (compatibility.confidence === "high") {
                  new import_obsidian19.Notice(`\u2139\uFE0F Model "${modelToCheck.name}" doesn't support tools, but will try anyway`, 5e3);
                }
              }
            } else {
              compatibleTools = mcpTools;
            }
          } else {
          }
          let response;
          if (isCustom && provider) {
            response = await this.handleCustomProviderCompletion(provider, preparedMessages, temperature, actualModelId, compatibleTools, signal, plugins, web_search_options);
          } else {
            const requestBody = {
              model: actualModelId,
              messages: preparedMessages,
              stream: true,
              include_reasoning: true
            };
            if (!isReasoningModel(actualModelId)) {
              requestBody.temperature = temperature;
            } else {
              const debugLogger = DebugLogger.getInstance();
              debugLogger == null ? void 0 : debugLogger.log(`[SystemSculpt] Excluding temperature parameter for reasoning model: ${actualModelId}`);
            }
            if (plugins && plugins.length > 0) {
              requestBody.plugins = plugins;
            }
            if (web_search_options) {
              requestBody.web_search_options = web_search_options;
            }
            if (compatibleTools.length > 0) {
              const validTools = compatibleTools.filter((tool) => {
                if (!tool || typeof tool !== "object") {
                  console.warn("[SystemSculpt] Invalid tool object:", tool);
                  return false;
                }
                if (!tool.function || typeof tool.function !== "object") {
                  console.warn("[SystemSculpt] Tool missing function property:", tool);
                  return false;
                }
                if (!tool.function.name || typeof tool.function.name !== "string") {
                  console.warn("[SystemSculpt] Tool missing or invalid function.name:", tool);
                  return false;
                }
                if (tool.function.name === null || tool.function.name === void 0) {
                  console.error("[SystemSculpt] Tool function.name is null/undefined after type check:", tool);
                  return false;
                }
                return true;
              });
              if (validTools.length > 0) {
                const isO4Mini = actualModelId.toLowerCase().includes("o4-mini") || actualModelId.toLowerCase().includes("o4 mini");
                if (isO4Mini) {
                  requestBody.tools = validTools.map((tool) => {
                    var _a2;
                    if (!((_a2 = tool == null ? void 0 : tool.function) == null ? void 0 : _a2.name)) {
                      console.error("[SystemSculpt] Tool passed validation but has no function.name:", tool);
                      return null;
                    }
                    const parameters = tool.function.parameters || {};
                    return {
                      type: tool.type || "function",
                      name: tool.function.name,
                      description: tool.function.description || "",
                      parameters
                    };
                  }).filter((tool) => tool !== null);
                } else {
                  requestBody.tools = validTools;
                }
                requestBody.tool_choice = "auto";
              } else {
                console.warn("[SystemSculpt] All tools were filtered out due to validation errors");
              }
            }
            const logger2 = DebugLogger.getInstance();
            const endpoint2 = `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS.CHAT.COMPLETIONS}`;
            if (requestBody.tools && requestBody.tools.length > 0) {
              requestBody.tools.forEach((tool, index) => {
                var _a2;
                const hasValidName = ((_a2 = tool == null ? void 0 : tool.function) == null ? void 0 : _a2.name) || (tool == null ? void 0 : tool.name);
                if (!hasValidName) {
                  console.error(`[SystemSculpt] Tool at index ${index} is missing name:`, tool);
                }
              });
            }
            logger2 == null ? void 0 : logger2.logAPIRequest(endpoint2, "POST", requestBody);
            const requestHeaders = {
              "Content-Type": "application/json",
              Accept: "text/event-stream",
              "Cache-Control": "no-cache",
              "X-Request-ID": this.generateRequestId(),
              "x-license-key": this.licenseKey
            };
            const mobileDetection = MobileDetection.getInstance();
            const isMobile = mobileDetection.isMobileDevice();
            console.log("[SystemSculpt] Is mobile device:", isMobile);
            if (isMobile) {
              const mobileRequestBody = {
                ...requestBody,
                stream: false
              };
              try {
                const mobileResponse = await (0, import_obsidian18.requestUrl)({
                  url: endpoint2,
                  method: "POST",
                  headers: requestHeaders,
                  body: JSON.stringify(mobileRequestBody),
                  throw: false
                });
                if (!mobileResponse.status || mobileResponse.status >= 400) {
                  response = new Response(JSON.stringify(mobileResponse.json || {}), {
                    status: mobileResponse.status || 500,
                    statusText: "Error"
                  });
                } else {
                  const responseData = mobileResponse.json;
                  const enqueueSSE = (controller, data) => {
                    const sseData = typeof data === "string" ? data : `data: ${JSON.stringify(data)}

`;
                    controller.enqueue(new TextEncoder().encode(sseData));
                  };
                  const mockStream = new ReadableStream({
                    async start(controller) {
                      var _a2, _b, _c, _d, _e, _f;
                      let content = "";
                      let reasoning = null;
                      let toolCalls = null;
                      let annotations = null;
                      let webSearchEnabled = null;
                      if (responseData.choices && responseData.choices[0]) {
                        const choice = responseData.choices[0];
                        content = ((_a2 = choice.message) == null ? void 0 : _a2.content) || "";
                        reasoning = ((_b = choice.message) == null ? void 0 : _b.reasoning) || null;
                        toolCalls = ((_c = choice.message) == null ? void 0 : _c.tool_calls) || null;
                        annotations = ((_d = choice.message) == null ? void 0 : _d.annotations) || null;
                      } else if (responseData.text) {
                        content = responseData.text;
                        reasoning = responseData.reasoning || null;
                        annotations = responseData.annotations || null;
                        webSearchEnabled = responseData.webSearchEnabled || null;
                      } else if (typeof responseData === "string") {
                        content = responseData;
                      }
                      if (webSearchEnabled) {
                        enqueueSSE(controller, { webSearchEnabled: true });
                        await new Promise((resolve) => setTimeout(resolve, MOBILE_STREAM_CONFIG.CHUNK_DELAY_MS));
                      }
                      if (reasoning) {
                        const reasoningChunk = {
                          choices: [{
                            delta: {
                              reasoning
                            },
                            finish_reason: null
                          }],
                          model: responseData.model,
                          id: responseData.id
                        };
                        enqueueSSE(controller, reasoningChunk);
                        await new Promise((resolve) => setTimeout(resolve, MOBILE_STREAM_CONFIG.CHUNK_DELAY_MS));
                      }
                      const chunkSize = MOBILE_STREAM_CONFIG.CHUNK_SIZE;
                      let chunksEnqueued = 0;
                      for (let i = 0; i < content.length; i += chunkSize) {
                        const contentChunk = content.slice(i, i + chunkSize);
                        const chunk = {
                          choices: [{
                            delta: {
                              content: contentChunk
                            },
                            finish_reason: null
                          }],
                          model: responseData.model,
                          id: responseData.id
                        };
                        enqueueSSE(controller, chunk);
                        chunksEnqueued++;
                        await new Promise((resolve) => setTimeout(resolve, MOBILE_STREAM_CONFIG.CHUNK_DELAY_MS));
                      }
                      console.log("[SystemSculpt] Content chunks enqueued:", chunksEnqueued);
                      if (annotations && annotations.length > 0) {
                        const annotationsChunk = {
                          choices: [{
                            delta: {
                              annotations
                            },
                            finish_reason: null
                          }],
                          model: responseData.model,
                          id: responseData.id
                        };
                        enqueueSSE(controller, annotationsChunk);
                        await new Promise((resolve) => setTimeout(resolve, MOBILE_STREAM_CONFIG.CHUNK_DELAY_MS));
                      }
                      if (toolCalls && toolCalls.length > 0) {
                        const toolCallChunk = {
                          choices: [{
                            delta: {
                              tool_calls: toolCalls
                            },
                            finish_reason: "tool_calls"
                          }],
                          model: responseData.model,
                          id: responseData.id
                        };
                        enqueueSSE(controller, toolCallChunk);
                      }
                      const finishReason = ((_f = (_e = responseData.choices) == null ? void 0 : _e[0]) == null ? void 0 : _f.finish_reason) || "stop";
                      const finalChunk = {
                        choices: [{
                          delta: {},
                          finish_reason: finishReason
                        }],
                        model: responseData.model || "unknown",
                        id: responseData.id || "mobile-response"
                      };
                      enqueueSSE(controller, finalChunk);
                      enqueueSSE(controller, "data: [DONE]\n\n");
                      controller.close();
                    }
                  });
                  response = new Response(mockStream, {
                    status: 200,
                    statusText: "OK",
                    headers: {
                      "Content-Type": "text/event-stream"
                    }
                  });
                }
              } catch (requestError) {
                console.error("[SystemSculpt] Mobile requestUrl failed:", {
                  error: requestError,
                  message: requestError.message
                });
                throw new SystemSculptError("Network request failed on mobile. Please check your internet connection and try again.", ERROR_CODES.STREAM_ERROR, 0);
              }
            } else {
              console.log("[SystemSculpt] Using fetch for desktop streaming");
              try {
                const fetchOptions = {
                  method: "POST",
                  headers: requestHeaders,
                  body: JSON.stringify(requestBody),
                  signal,
                  mode: "cors",
                  credentials: "omit"
                };
                response = await fetch(endpoint2, fetchOptions);
              } catch (fetchError) {
                const errorDetails = {
                  message: fetchError.message || "Unknown fetch error",
                  name: fetchError.name || "FetchError",
                  stack: fetchError.stack || "No stack trace",
                  code: fetchError.code,
                  cause: fetchError.cause,
                  toString: fetchError.toString(),
                  isMobile: MobileDetection.getInstance().isMobileDevice(),
                  endpoint: endpoint2,
                  baseUrl: this.baseUrl,
                  isOnline: navigator.onLine,
                  connection: navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    type: navigator.connection.type,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt
                  } : "Not available"
                };
                console.error("[SystemSculpt] Fetch failed with detailed info:", JSON.stringify(errorDetails, null, 2));
                if (fetchError.message === "Load failed" && errorDetails.isMobile) {
                  console.error("[SystemSculpt] Mobile network error detected. Possible causes:");
                  console.error("- CORS policy blocking the request");
                  console.error("- SSL/TLS certificate issues");
                  console.error("- Network restrictions on iOS/Android");
                  console.error("- Missing or invalid API headers");
                  throw new SystemSculptError("Network request failed on mobile. This may be due to network restrictions or CORS policy. Please check your internet connection and try again.", ERROR_CODES.STREAM_ERROR, 0);
                }
                throw fetchError;
              }
            }
          }
          const logger = DebugLogger.getInstance();
          const endpoint = isCustom && provider ? provider.endpoint : `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS.CHAT.COMPLETIONS}`;
          logger == null ? void 0 : logger.logAPIResponse(endpoint, response.status);
          if (!response.ok) {
            logger == null ? void 0 : logger.logAPIResponse(endpoint, response.status, null, { message: `HTTP ${response.status}` });
            await this.handleStreamError(response, !!provider);
          }
          if (!response.body) {
            throw new SystemSculptError(getErrorMessage(ERROR_CODES.STREAM_ERROR), ERROR_CODES.STREAM_ERROR, response.status);
          }
          const reader = response.body.getReader();
          let buffer = "";
          const isMobileStream = MobileDetection.getInstance().isMobileDevice();
          let totalYieldedContent = "";
          try {
            let chunkCount = 0;
            let totalContent = "";
            console.log("[SystemSculpt] Starting to read stream");
            while (true) {
              let done, value;
              try {
                const result = await reader.read();
                done = result.done;
                value = result.value;
              } catch (readError) {
                console.error("[SystemSculpt] Stream read error:", {
                  error: readError,
                  message: readError.message,
                  name: readError.name,
                  chunkCount
                });
                throw new SystemSculptError(`Failed to read stream: ${readError.message}`, ERROR_CODES.STREAM_ERROR, 500);
              }
              if (done) {
                const finalChunk = this.decoder.decode();
                if (finalChunk) {
                  const event = this.processStreamLine(finalChunk);
                  if (event) {
                    const result = await this.handleStreamEvent(event, model, !!provider);
                    if (result) {
                      if (result.content || result.reasoning) {
                        yield {
                          content: result.content || void 0,
                          reasoning: result.reasoning || void 0
                        };
                      }
                      if (result.toolCalls && result.toolCalls.length > 0) {
                        for (const toolCall of result.toolCalls) {
                          const index = (_a = toolCall.index) != null ? _a : 0;
                          accumulatedToolCalls.set(index, toolCall);
                        }
                        yield {
                          toolCalls: result.toolCalls
                        };
                      }
                    }
                  }
                }
                break;
              }
              try {
                const decodedChunk = this.decoder.decode(value, { stream: false });
                if (decodedChunk.trim()) {
                  if (decodedChunk.includes("tool_calls") || decodedChunk.includes("error") || decodedChunk.includes("finish_reason") && !decodedChunk.includes('"finish_reason":null')) {
                  }
                }
              } catch (e) {
                console.error("[SystemSculpt] Chunk decode error:", {
                  error: e,
                  message: e.message,
                  chunkCount,
                  valueType: value ? typeof value : "undefined",
                  valueLength: value ? value.length : 0
                });
              }
              chunkCount++;
              if (!value) {
                console.error("[SystemSculpt] Unexpected undefined value in stream");
                continue;
              }
              const isMobileDebug = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
              if (isMobileDebug) {
                console.log("[SystemSculpt] Processing chunk:", {
                  chunkCount,
                  chunkSize: value.length,
                  bufferSize: buffer.length
                });
              }
              const { newBuffer, contents, reasonings, toolCalls, completedToolCalls, webSearchEnabled } = await this.processStreamChunk(value, buffer, model, !!provider, accumulatedToolCalls);
              buffer = newBuffer;
              if (contents.length > 0) {
                totalContent += contents.join("");
              }
              if (isMobileDebug && (contents.length > 0 || reasonings.length > 0)) {
                console.log("[SystemSculpt] Yielding content:", {
                  contentCount: contents.length,
                  reasoningCount: reasonings.length,
                  contentPreview: contents.length > 0 ? contents[0].substring(0, 100) : null
                });
              }
              for (const reasoning of reasonings) {
                if (reasoning) {
                  yield { reasoning };
                }
              }
              for (const content of contents) {
                if (content) {
                  if (isMobileStream) {
                    totalYieldedContent += content;
                    console.log("[SystemSculpt] Yielding content chunk:", {
                      chunkLength: content.length,
                      totalYielded: totalYieldedContent.length
                    });
                  }
                  yield { content };
                }
              }
              if (completedToolCalls.length > 0) {
                const logger2 = DebugLogger.getInstance();
                await (logger2 == null ? void 0 : logger2.logToolCall("YIELDING_TOOL_CALLS", {
                  count: completedToolCalls.length,
                  toolCalls: completedToolCalls
                }));
                yield {
                  toolCalls: completedToolCalls
                };
              }
            }
          } finally {
            reader.releaseLock();
            if (isMobileStream) {
              console.log("[SystemSculpt] Stream completed:", {
                totalYieldedContent: totalYieldedContent.length,
                contentPreview: totalYieldedContent.substring(0, 200),
                hadContent: totalYieldedContent.length > 0
              });
            }
            if (accumulatedToolCalls.size > 0) {
              const completedCalls = Array.from(accumulatedToolCalls.values());
              const validToolCalls = completedCalls.filter((call) => {
                var _a2, _b;
                const isValid = ((_a2 = call.function) == null ? void 0 : _a2.name) && ((_b = call.function) == null ? void 0 : _b.arguments);
                if (!isValid) {
                }
                return isValid;
              });
              if (validToolCalls.length > 0) {
                yield {
                  toolCalls: validToolCalls
                };
              }
            }
          }
        } catch (error) {
          if (error instanceof DOMException && error.name === "AbortError") {
            return;
          }
          if (onError) {
            let errorMessage = error instanceof Error ? error.message : getErrorMessage(ERROR_CODES.UNKNOWN_ERROR);
            if (error instanceof SystemSculptError && error.code === ERROR_CODES.STREAM_ERROR && error.statusCode === 400) {
              errorMessage += "\nPlease try again in a few moments. If the issue persists, try selecting a different model.";
            }
            onError(errorMessage);
          }
          throw error;
        }
      }
      async uploadDocument(file) {
        var _a;
        try {
          if (!((_a = this.licenseKey) == null ? void 0 : _a.trim())) {
            throw new SystemSculptError("A valid license key is required for document processing", ERROR_CODES.PRO_REQUIRED, 403);
          }
          const isValidSize = await validateFileSize(file, this.app);
          if (!isValidSize) {
            throw new SystemSculptError("File size exceeds the maximum limit of 25MB", ERROR_CODES.FILE_TOO_LARGE, 413);
          }
          const data = await this.app.vault.readBinary(file);
          const blob = new Blob([data], { type: "application/octet-stream" });
          const boundary = "WebKitFormBoundary" + Math.random().toString(36).substring(2, 15);
          const encoder = new TextEncoder();
          const parts = [];
          parts.push(encoder.encode(`--${boundary}\r
`));
          parts.push(encoder.encode(`Content-Disposition: form-data; name="file"; filename="${file.name}"\r
`));
          parts.push(encoder.encode(`Content-Type: application/octet-stream\r
`));
          parts.push(encoder.encode("\r\n"));
          parts.push(new Uint8Array(await blob.arrayBuffer()));
          parts.push(encoder.encode("\r\n"));
          parts.push(encoder.encode(`--${boundary}--\r
`));
          const totalSize = parts.reduce((sum, part) => sum + part.length, 0);
          const formDataArray = new Uint8Array(totalSize);
          let offset = 0;
          for (const part of parts) {
            formDataArray.set(part, offset);
            offset += part.length;
          }
          const url = `${this.baseUrl}/documents/process`;
          const response = await (0, import_obsidian18.requestUrl)({
            url,
            method: "POST",
            headers: {
              "Content-Type": `multipart/form-data; boundary=${boundary}`,
              "x-license-key": this.licenseKey
            },
            body: formDataArray.buffer,
            throw: false
          });
          if (response.status !== 200) {
            let errorText = "";
            try {
              errorText = response.text;
            } catch (textError) {
            }
            if (response.status === 403) {
              throw new SystemSculptError("Invalid or expired license key", ERROR_CODES.INVALID_LICENSE, 403);
            }
            throw new SystemSculptError(`Upload failed: ${response.status} ${errorText ? `- ${errorText}` : ""}`, ERROR_CODES.PROCESSING_ERROR, response.status);
          }
          try {
            const responseData = JSON.parse(response.text);
            return responseData;
          } catch (jsonError) {
            throw new SystemSculptError("Invalid response format from server", ERROR_CODES.INVALID_RESPONSE, 500);
          }
        } catch (error) {
          if (error instanceof SystemSculptError) {
            throw error;
          }
          throw new SystemSculptError(error instanceof Error ? error.message : String(error), ERROR_CODES.PROCESSING_ERROR, 500);
        }
      }
      async uploadAudio(file) {
        try {
          const isValidSize = await validateFileSize(file, this.app);
          if (!isValidSize) {
            throw new Error("File size exceeds the maximum limit of 25MB");
          }
          const data = await this.app.vault.readBinary(file);
          const blob = new Blob([data], { type: "application/octet-stream" });
          const boundary = "WebKitFormBoundary" + Math.random().toString(36).substring(2, 15);
          const encoder = new TextEncoder();
          const parts = [];
          parts.push(encoder.encode(`--${boundary}\r
`));
          parts.push(encoder.encode(`Content-Disposition: form-data; name="file"; filename="${file.name}"\r
`));
          parts.push(encoder.encode(`Content-Type: application/octet-stream\r
`));
          parts.push(encoder.encode("\r\n"));
          parts.push(new Uint8Array(await blob.arrayBuffer()));
          parts.push(encoder.encode("\r\n"));
          parts.push(encoder.encode(`--${boundary}--\r
`));
          const totalSize = parts.reduce((sum, part) => sum + part.length, 0);
          const formDataArray = new Uint8Array(totalSize);
          let offset = 0;
          for (const part of parts) {
            formDataArray.set(part, offset);
            offset += part.length;
          }
          const response = await (0, import_obsidian18.requestUrl)({
            url: `${this.baseUrl}/audio/transcriptions`,
            method: "POST",
            headers: {
              "Content-Type": `multipart/form-data; boundary=${boundary}`
            },
            body: formDataArray.buffer,
            throw: false
          });
          if (response.status !== 200) {
            throw new Error(`Audio upload failed: ${response.status}`);
          }
          const result = JSON.parse(response.text);
          return result;
        } catch (error) {
          logMobileError("SystemSculptService", "Audio upload failed", error, {
            filename: file.name,
            fileSize: file.stat.size,
            endpoint: `${this.baseUrl}/audio/transcriptions`
          });
          throw error;
        }
      }
      async preloadModels() {
        return Promise.resolve();
      }
      async getApiStatus() {
        this.refreshSettings();
        const endpoint = `${this.baseUrl}/status`;
        try {
          const response = await fetch(endpoint, {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              ...this.licenseKey && { "Authorization": `Bearer ${this.licenseKey}` }
            }
          });
          if (!response.ok) {
            console.warn(`[SystemSculpt] API status check failed with status ${response.status} for ${endpoint}`);
            return { status: "error", message: `API request failed with status ${response.status}` };
          }
          return await response.json();
        } catch (error) {
          console.error("[SystemSculpt] Error fetching API status:", error);
          return { status: "error", message: "Failed to connect to SystemSculpt API. Please check your network connection and server URL." };
        }
      }
    };
    SystemSculptService = _SystemSculptService;
    SystemSculptService.instance = null;
  }
});

// src/components/FolderSuggester.ts
function getFolderSuggestions(app) {
  const folders = app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian22.TFolder);
  return new Set(folders.map((folder) => folder.path));
}
function attachFolderSuggester(inputEl, onSelect, app) {
  const suggester = new FolderSuggester(inputEl, onSelect, app);
  inputEl.addEventListener("focus", () => {
    suggester.refreshSuggestions();
  });
  return suggester;
}
var import_obsidian22, FolderSuggester, InternalSuggester;
var init_FolderSuggester = __esm({
  "src/components/FolderSuggester.ts"() {
    import_obsidian22 = __toModule(require("obsidian"));
    FolderSuggester = class {
      constructor(inputEl, onSelectCb, app) {
        this.onSelectCb = onSelectCb;
        this.app = app;
        this.suggestEl = inputEl;
        this.content = getFolderSuggestions(app);
        this.suggest = new InternalSuggester(app, inputEl);
        this.suggest.onSelect((value) => {
          this.onSelectCb(value);
        });
      }
      refreshSuggestions() {
        this.content = getFolderSuggestions(this.app);
      }
      close() {
        this.suggest.close();
      }
    };
    InternalSuggester = class extends import_obsidian22.AbstractInputSuggest {
      constructor(app, inputEl) {
        super(app, inputEl);
        this.inputEl = inputEl;
      }
      getSuggestions(inputStr) {
        const folders = getFolderSuggestions(this.app);
        const lowerCaseInputStr = inputStr.toLowerCase();
        return [...folders].filter((content) => content.toLowerCase().includes(lowerCaseInputStr));
      }
      renderSuggestion(content, el) {
        el.setText(content);
      }
      selectSuggestion(content, evt) {
        this.inputEl.value = content;
        this.inputEl.blur();
        this.close();
        super.selectSuggestion(content, evt);
      }
    };
  }
});

// src/services/FavoritesService.ts
var _FavoritesService, FavoritesService;
var init_FavoritesService = __esm({
  "src/services/FavoritesService.ts"() {
    init_modelUtils();
    _FavoritesService = class {
      constructor(plugin) {
        this.plugin = plugin;
      }
      static getInstance(plugin) {
        if (!_FavoritesService.instance) {
          _FavoritesService.instance = new _FavoritesService(plugin);
        }
        return _FavoritesService.instance;
      }
      static clearInstance() {
        _FavoritesService.instance = null;
      }
      async addFavorite(model) {
        if (model.isFavorite === true) {
          return;
        }
        model.isFavorite = true;
        const favorite = {
          provider: model.provider,
          modelId: model.id,
          addedAt: Date.now()
        };
        const updatedFavorites = [...this.plugin.settings.favoriteModels, favorite];
        await this.plugin.getSettingsManager().updateSettings({ favoriteModels: updatedFavorites });
        this.emitFavoritesChanged();
      }
      async removeFavorite(model) {
        if (model.isFavorite !== true) {
          return;
        }
        model.isFavorite = false;
        const updatedFavorites = this.plugin.settings.favoriteModels.filter((fav) => !(fav.modelId === model.id && fav.provider === model.provider));
        await this.plugin.getSettingsManager().updateSettings({ favoriteModels: updatedFavorites });
        this.emitFavoritesChanged();
      }
      async toggleFavorite(model) {
        if (model.isFavorite === true) {
          await this.removeFavorite(model);
        } else {
          await this.addFavorite(model);
        }
        await this.forceSaveSettings();
      }
      isFavorite(model) {
        return model.isFavorite === true;
      }
      getFavorites(models) {
        return models.filter((model) => model.isFavorite === true);
      }
      async clearAllFavorites(models) {
        models.forEach((model) => {
          model.isFavorite = false;
        });
        await this.plugin.getSettingsManager().updateSettings({ favoriteModels: [] });
        this.emitFavoritesChanged();
      }
      processFavorites(models) {
        const favoriteModels = this.plugin.settings.favoriteModels || [];
        models.forEach((model) => {
          model.isFavorite = false;
        });
        const updatedFavorites = [];
        for (const favorite of favoriteModels) {
          const matchingModel = models.find((m) => {
            var _a;
            const legacyID = `${m.provider}/${(_a = m.identifier) == null ? void 0 : _a.modelId}`;
            const favoriteIDCanonical = ensureCanonicalId(favorite.modelId);
            return m.id === favorite.modelId || m.id === favoriteIDCanonical || legacyID === favorite.modelId;
          });
          if (matchingModel) {
            updatedFavorites.push({
              provider: matchingModel.provider,
              modelId: matchingModel.id,
              addedAt: favorite.addedAt || Date.now()
            });
            matchingModel.isFavorite = true;
          } else {
            const canonicalID = ensureCanonicalId(favorite.modelId, favorite.provider);
            updatedFavorites.push({
              provider: favorite.provider,
              modelId: canonicalID,
              addedAt: favorite.addedAt || Date.now()
            });
          }
        }
        this.plugin.getSettingsManager().updateSettings({ favoriteModels: updatedFavorites }).catch((error) => {
          console.error("[SystemSculpt] Error updating favorites:", error);
        });
      }
      sortModelsByFavorites(models) {
        const favoritesFirst = this.plugin.settings.favoritesFilterSettings.favoritesFirst;
        const sortOrder = this.plugin.settings.favoritesFilterSettings.modelSortOrder;
        if (!favoritesFirst && sortOrder === "default") {
          return models;
        }
        return [...models].sort((a, b) => {
          if (favoritesFirst) {
            const aIsFav = a.isFavorite === true;
            const bIsFav = b.isFavorite === true;
            if (aIsFav && !bIsFav)
              return -1;
            if (!aIsFav && bIsFav)
              return 1;
          }
          if (sortOrder === "alphabetical") {
            const providerCompare = a.provider.localeCompare(b.provider);
            if (providerCompare !== 0) {
              return providerCompare;
            }
            return a.name.localeCompare(b.name);
          } else {
            return 0;
          }
        });
      }
      filterModelsByFavorites(models) {
        if (!this.plugin.settings.favoritesFilterSettings.showFavoritesOnly) {
          return models;
        }
        return models.filter((model) => model.isFavorite === true);
      }
      async toggleShowFavoritesOnly() {
        const currentValue = this.plugin.settings.favoritesFilterSettings.showFavoritesOnly;
        await this.plugin.getSettingsManager().updateSettings({
          favoritesFilterSettings: {
            ...this.plugin.settings.favoritesFilterSettings,
            showFavoritesOnly: !currentValue
          }
        });
        this.emitFavoritesFilterChanged();
        return !currentValue;
      }
      getShowFavoritesOnly() {
        return this.plugin.settings.favoritesFilterSettings.showFavoritesOnly;
      }
      async setFavoritesFirst(value) {
        await this.plugin.getSettingsManager().updateSettings({
          favoritesFilterSettings: {
            ...this.plugin.settings.favoritesFilterSettings,
            favoritesFirst: value
          }
        });
        this.emitFavoritesFilterChanged();
      }
      getFavoritesFirst() {
        return this.plugin.settings.favoritesFilterSettings.favoritesFirst;
      }
      emitFavoritesChanged() {
        document.dispatchEvent(new CustomEvent("systemsculpt:favorites-changed", {
          detail: {
            favorites: this.plugin.settings.favoriteModels
          }
        }));
      }
      emitFavoritesFilterChanged() {
        document.dispatchEvent(new CustomEvent("systemsculpt:favorites-filter-changed", {
          detail: {
            showFavoritesOnly: this.plugin.settings.favoritesFilterSettings.showFavoritesOnly,
            favoritesFirst: this.plugin.settings.favoritesFilterSettings.favoritesFirst
          }
        }));
      }
      async forceSaveSettings() {
        try {
          await this.plugin.getSettingsManager().saveSettings();
        } catch (error) {
          console.error("[SystemSculpt] Error forcibly saving favorites:", error);
        }
      }
    };
    FavoritesService = _FavoritesService;
    FavoritesService.instance = null;
  }
});

// src/components/FavoriteToggle.ts
var import_obsidian26, FavoriteToggle;
var init_FavoriteToggle = __esm({
  "src/components/FavoriteToggle.ts"() {
    import_obsidian26 = __toModule(require("obsidian"));
    FavoriteToggle = class {
      constructor(container, model, favoritesService, callback) {
        this.isAnimating = false;
        this.model = model;
        this.favoritesService = favoritesService;
        this.callback = callback;
        this.element = container.createDiv({
          cls: "systemsculpt-favorite-toggle",
          attr: {
            "aria-label": this.getAriaLabel(),
            "role": "button",
            "tabindex": "0",
            "aria-pressed": this.model.isFavorite === true ? "true" : "false"
          }
        });
        this.updateAppearance();
        this.addEventListeners();
      }
      updateAppearance() {
        this.element.empty();
        const isFavorite = this.model.isFavorite === true;
        if (isFavorite) {
          this.element.addClass("is-favorite");
          this.element.removeClass("not-favorite");
        } else {
          this.element.addClass("not-favorite");
          this.element.removeClass("is-favorite");
        }
        const iconWrapper = this.element.createDiv({
          cls: "systemsculpt-favorite-icon-wrapper"
        });
        const iconEl = iconWrapper.createSpan({
          cls: "systemsculpt-favorite-icon"
        });
        (0, import_obsidian26.setIcon)(iconEl, "star");
        this.element.setAttribute("aria-label", this.getAriaLabel());
        this.element.setAttribute("aria-pressed", isFavorite ? "true" : "false");
        this.element.setAttribute("data-tooltip", this.getAriaLabel());
        if (!this.element.querySelector(".systemsculpt-favorite-feedback")) {
          const feedbackEl = this.element.createDiv({
            cls: "systemsculpt-favorite-feedback"
          });
        }
      }
      getAriaLabel() {
        return this.model.isFavorite === true ? `Remove ${this.model.name} from favorites` : `Add ${this.model.name} to favorites`;
      }
      addEventListeners() {
        this.element.addEventListener("click", this.handleClick.bind(this));
        this.element.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            this.handleClick(e);
          }
        });
        this.element.addEventListener("focus", () => {
          this.element.addClass("is-focused");
        });
        this.element.addEventListener("blur", () => {
          this.element.removeClass("is-focused");
        });
        this.element.addEventListener("mouseenter", () => {
          this.element.addClass("is-hovered");
        });
        this.element.addEventListener("mouseleave", () => {
          this.element.removeClass("is-hovered");
        });
      }
      playStatusChangeAnimation(newState) {
        if (this.isAnimating)
          return;
        this.isAnimating = true;
        const feedbackEl = this.element.querySelector(".systemsculpt-favorite-feedback");
        if (!feedbackEl)
          return;
        if (newState) {
          feedbackEl.addClass("animate-favorite");
        } else {
          feedbackEl.addClass("animate-unfavorite");
        }
        setTimeout(() => {
          feedbackEl.removeClass("animate-favorite");
          feedbackEl.removeClass("animate-unfavorite");
          this.isAnimating = false;
        }, 100);
      }
      handleClick(e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.isAnimating)
          return;
        this.element.addClass("is-active");
        setTimeout(() => {
          this.element.removeClass("is-active");
        }, 50);
        this.favoritesService.toggleFavorite(this.model).then(() => {
          this.updateAppearance();
          this.playStatusChangeAnimation(this.model.isFavorite === true);
          if (this.callback) {
            this.callback(this.model, this.model.isFavorite === true);
          }
        }).catch((error) => {
          console.error("[SystemSculpt] Failed to toggle favorite status:", error);
        });
      }
      updateModel(model) {
        this.model = model;
        this.updateAppearance();
      }
    };
  }
});

// src/core/ui/modals/standard/ListSelectionModal.ts
var import_obsidian27, ListSelectionModal;
var init_ListSelectionModal = __esm({
  "src/core/ui/modals/standard/ListSelectionModal.ts"() {
    import_obsidian27 = __toModule(require("obsidian"));
    init_StandardModal();
    init_KeyboardNavigationService();
    init_FavoriteToggle();
    init_MobileDetection();
    ListSelectionModal = class extends StandardModal {
      constructor(app, items, options) {
        super(app);
        this.items = [];
        this.filteredItems = [];
        this.selectedIds = new Set();
        this.searchInput = null;
        this.listContainer = null;
        this.emptyStateEl = null;
        this.resolvePromise = null;
        this.focusedItemIndex = -1;
        this.itemElements = [];
        this.customSearchHandler = null;
        this.favoritesService = null;
        this.items = items;
        this.filteredItems = [...items];
        this.options = {
          emptyText: "No items found",
          placeholder: "Search...",
          withSearch: true,
          withFilters: false,
          closeOnSelect: !options.multiSelect,
          multiSelect: false,
          size: "medium",
          ...options
        };
        this.favoritesService = options.favoritesService || null;
        this.items.forEach((item) => {
          if (item.selected) {
            this.selectedIds.add(item.id);
          }
        });
        if (this.options.size) {
          this.setSize(this.options.size);
        }
      }
      onOpen() {
        super.onOpen();
        this.addTitle(this.options.title, this.options.description);
        if (this.options.customContent) {
          const customContentEl = this.contentEl.createDiv("ss-modal__custom-content");
          this.options.customContent(customContentEl);
        }
        if (this.options.withSearch) {
          const debouncedSearchHandler = (0, import_obsidian27.debounce)((query) => {
            this.handleSearch(query);
          }, 300, true);
          this.searchInput = this.addSearchBar(this.options.placeholder || "Search...", debouncedSearchHandler);
        }
        if (this.options.withFilters && this.options.filters && this.options.filters.length > 0) {
          this.addFilterButtons(this.options.filters, this.handleFilterToggle.bind(this));
        }
        this.listContainer = this.contentEl.createDiv("ss-modal__list");
        this.emptyStateEl = this.contentEl.createDiv({
          cls: "ss-modal__empty-state",
          text: this.options.emptyText
        });
        this.emptyStateEl.style.display = "none";
        this.renderItems();
        if (this.options.multiSelect) {
          this.addActionButton("Cancel", () => this.close(), false);
          this.addActionButton("Select", this.handleConfirmSelection.bind(this), true);
        }
        if (this.searchInput) {
          setTimeout(() => {
            var _a;
            return (_a = this.searchInput) == null ? void 0 : _a.focus();
          }, 50);
        }
        this.keyboardNavService = new KeyboardNavigationService(this.modalEl, {
          multiSelect: this.options.multiSelect,
          closeOnSelect: this.options.closeOnSelect,
          onSelect: (index) => {
            if (index >= 0 && index < this.itemElements.length) {
              this.itemElements[index].click();
            }
          },
          onToggle: (index) => {
            if (index >= 0 && index < this.itemElements.length) {
              this.itemElements[index].click();
            }
          },
          onConfirm: () => {
            if (this.options.multiSelect) {
              this.handleConfirmSelection();
            }
          },
          onFocus: (index) => {
            this.focusItem(index);
          }
        });
        this.keyboardNavService.setItemCount(this.itemElements.length);
      }
      handleSearch(query) {
        if (this.customSearchHandler) {
          this.customSearchHandler(query).then((items) => {
            if (!items || !Array.isArray(items)) {
              console.error("Custom search handler did not return an array of items");
              this.filteredItems = [];
            } else {
              this.filteredItems = items;
            }
            this.renderItems();
            this.keyboardNavService.setItemCount(this.itemElements.length);
            this.keyboardNavService.clearFocus();
          }).catch((error) => {
            console.error("Error in custom search handler:", error);
            this.filteredItems = [];
            this.renderItems();
            if (this.emptyStateEl) {
              this.emptyStateEl.textContent = "Error searching files. Please try again.";
              this.emptyStateEl.style.display = "flex";
            }
            this.keyboardNavService.setItemCount(0);
            this.keyboardNavService.clearFocus();
          });
        } else {
          if (!query) {
            this.filteredItems = [...this.items];
          } else {
            const lowerQuery = query.toLowerCase();
            this.filteredItems = this.items.filter((item) => item.title.toLowerCase().includes(lowerQuery) || item.description && item.description.toLowerCase().includes(lowerQuery));
          }
          this.renderItems();
          this.keyboardNavService.setItemCount(this.itemElements.length);
          this.keyboardNavService.clearFocus();
        }
      }
      handleFilterToggle(filterId, active) {
        this.renderItems();
        this.keyboardNavService.setItemCount(this.itemElements.length);
        this.keyboardNavService.clearFocus();
      }
      focusItem(index) {
        if (index === -1 || index >= this.itemElements.length)
          return;
        const item = this.itemElements[index];
        if (!item)
          return;
        this.itemElements.forEach((el) => {
          if (el) {
            el.classList.remove("ss-focused");
          }
        });
        item.classList.add("ss-focused");
        try {
          item.scrollIntoView({ block: "nearest" });
        } catch (e) {
        }
      }
      handleConfirmSelection() {
        const selectedItems = this.items.filter((item) => this.selectedIds.has(item.id));
        if (this.resolvePromise) {
          this.resolvePromise(selectedItems);
        }
        this.close();
      }
      renderItems() {
        if (!this.listContainer)
          return;
        this.listContainer.empty();
        this.itemElements = [];
        if (this.filteredItems.length === 0) {
          if (this.emptyStateEl) {
            this.emptyStateEl.style.display = "flex";
          }
          return;
        }
        if (this.emptyStateEl) {
          this.emptyStateEl.style.display = "none";
        }
        this.removePreviewContainer();
        this.filteredItems.forEach((item, index) => {
          const itemEl = this.createListItem(item, index);
          if (this.selectedIds.has(item.id)) {
            itemEl.classList.add("ss-active");
          }
          itemEl.setAttribute("data-item-id", item.id);
          itemEl.setAttribute("tabindex", "0");
          this.itemElements.push(itemEl);
          this.registerDomEvent(itemEl, "click", () => {
            if (this.options.multiSelect) {
              if (this.selectedIds.has(item.id)) {
                this.selectedIds.delete(item.id);
                itemEl.classList.remove("ss-active");
              } else {
                this.selectedIds.add(item.id);
                itemEl.classList.add("ss-active");
              }
            } else {
              this.selectedIds.clear();
              this.selectedIds.add(item.id);
              if (this.resolvePromise) {
                this.resolvePromise([item]);
              }
              if (this.options.closeOnSelect) {
                this.close();
              } else {
                this.itemElements.forEach((el) => {
                  if (el) {
                    el.classList.remove("ss-active");
                  }
                });
                itemEl.classList.add("ss-active");
              }
            }
          });
          if (this.listContainer) {
            this.listContainer.appendChild(itemEl);
          }
        });
        if (this.listContainer) {
          this.listContainer.dispatchEvent(new CustomEvent("ss-items-rendered"));
        }
        if (this.keyboardNavService) {
          this.keyboardNavService.setItemCount(this.itemElements.length);
        }
      }
      createListItem(itemData, index) {
        const itemEl = document.createElement("div");
        itemEl.className = "ss-modal__item";
        if (itemData._ssModel) {
          itemEl.setAttribute("data-provider", itemData._ssModel.provider);
          if (itemData._ssModel.isFavorite) {
            itemEl.classList.add("has-favorite");
          }
        }
        if (itemData.additionalClasses) {
          itemEl.classList.add(itemData.additionalClasses);
        }
        const { title, description, icon, badge, thumbnail, fileType } = itemData;
        if (icon) {
          const iconEl = itemEl.createDiv("ss-modal__item-icon");
          (0, import_obsidian27.setIcon)(iconEl, icon);
        }
        const content = itemEl.createDiv("ss-modal__item-content");
        content.createDiv({ text: title, cls: "ss-modal__item-title" });
        if (description) {
          content.createDiv({ text: description, cls: "ss-modal__item-description" });
        }
        if (badge) {
          const badgeEl = itemEl.createSpan({ text: badge, cls: "ss-modal__item-badge" });
        }
        if (this.favoritesService && itemData._ssModel) {
          const model = itemData._ssModel;
          const buttonContainer = itemEl.createDiv("systemsculpt-favorite-button-container");
          const favoriteToggle = new FavoriteToggle(buttonContainer, model, this.favoritesService, (updatedModel, isFavorite) => {
            if (isFavorite) {
              itemEl.classList.add("has-favorite");
            } else {
              itemEl.classList.remove("has-favorite");
            }
            itemEl.dispatchEvent(new CustomEvent("ss-list-item-favorite-toggled", {
              bubbles: true,
              detail: { modelId: updatedModel.id, isFavorite, index }
            }));
          });
        }
        if (thumbnail && fileType && this.isImageType(fileType)) {
          const thumbnailContainer = itemEl.createDiv("ss-modal__item-thumbnail");
          const img = document.createElement("img");
          img.src = thumbnail;
          img.alt = title;
          img.loading = "lazy";
          thumbnailContainer.appendChild(img);
          const showPreviewHandler = (e) => {
            this.showPreview(thumbnail, title, e);
            e.stopPropagation();
          };
          if (!this.isMobileDevice()) {
            this.registerDomEvent(thumbnailContainer, "mouseenter", showPreviewHandler);
            this.registerDomEvent(thumbnailContainer, "mouseleave", () => this.hidePreview());
            this.registerDomEvent(thumbnailContainer, "click", showPreviewHandler);
          } else {
            this.registerDomEvent(thumbnailContainer, "click", (e) => {
              e.stopPropagation();
              this.toggleExpandedPreview(itemEl, thumbnail, title);
            });
          }
        }
        return itemEl;
      }
      isImageType(fileType) {
        const imageTypes = ["png", "jpg", "jpeg", "gif", "svg", "webp"];
        return imageTypes.includes(fileType.toLowerCase());
      }
      isMobileDevice() {
        return MobileDetection.getInstance().isMobileDevice();
      }
      showPreview(imageUrl, title, event) {
        this.removePreviewContainer();
        const previewContainer = document.createElement("div");
        previewContainer.className = "ss-preview-container";
        const titleEl = document.createElement("div");
        titleEl.className = "ss-preview-title";
        titleEl.textContent = title;
        previewContainer.appendChild(titleEl);
        const previewImg = document.createElement("img");
        previewImg.src = imageUrl;
        previewImg.alt = title;
        previewImg.onload = () => {
          const aspectRatio = previewImg.naturalWidth / previewImg.naturalHeight;
          if (aspectRatio > 1.5) {
            previewContainer.style.width = "350px";
            previewContainer.style.height = "auto";
          } else if (aspectRatio < 0.7) {
            previewContainer.style.width = "auto";
            previewContainer.style.height = "350px";
          } else {
            previewContainer.style.width = "300px";
            previewContainer.style.height = "300px";
          }
        };
        previewContainer.appendChild(previewImg);
        document.body.appendChild(previewContainer);
        const offset = 20;
        const containerWidth = 300;
        const containerHeight = 300;
        let left = event.clientX + offset;
        let top = event.clientY + offset;
        if (left + containerWidth > window.innerWidth) {
          left = Math.max(0, window.innerWidth - containerWidth - offset);
        }
        if (top + containerHeight > window.innerHeight) {
          top = Math.max(0, window.innerHeight - containerHeight - offset);
        }
        previewContainer.style.left = `${left}px`;
        previewContainer.style.top = `${top}px`;
      }
      hidePreview() {
        this.removePreviewContainer();
      }
      toggleExpandedPreview(itemEl, imageUrl, title) {
        if (itemEl.classList.contains("expanded")) {
          itemEl.classList.remove("expanded");
          const previewEl = itemEl.querySelector(".ss-modal__item-preview");
          if (previewEl) {
            previewEl.remove();
          }
        } else {
          itemEl.classList.add("expanded");
          const previewContainer = document.createElement("div");
          previewContainer.className = "ss-modal__item-preview";
          const previewImg = document.createElement("img");
          previewImg.src = imageUrl;
          previewImg.alt = title;
          previewContainer.appendChild(previewImg);
          itemEl.appendChild(previewContainer);
        }
      }
      removePreviewContainer() {
        const existingPreview = document.querySelector(".ss-preview-container");
        if (existingPreview) {
          existingPreview.remove();
        }
      }
      onClose() {
        this.removePreviewContainer();
        if (this.keyboardNavService) {
          this.keyboardNavService.unload();
        }
        if (this.options.multiSelect && this.resolvePromise) {
          const selectedItems = this.items.filter((item) => this.selectedIds.has(item.id));
          this.resolvePromise(selectedItems);
        }
        super.onClose();
      }
      setCustomSearchHandler(handler) {
        this.customSearchHandler = handler;
      }
      setItems(items) {
        if (!items || !Array.isArray(items)) {
          console.error("setItems called with invalid items. Expected array, got:", items);
          return;
        }
        this.items = items;
        if (this.searchInput && this.searchInput.value) {
          if (this.customSearchHandler) {
            this.customSearchHandler(this.searchInput.value).then((filteredItems) => {
              if (!filteredItems || !Array.isArray(filteredItems)) {
                console.error("Custom search handler did not return an array of items");
                this.filteredItems = [];
              } else {
                this.filteredItems = filteredItems;
              }
              this.renderItems();
              if (this.keyboardNavService) {
                this.keyboardNavService.setItemCount(this.itemElements.length);
                this.keyboardNavService.clearFocus();
              }
            }).catch((error) => {
              var _a;
              console.error("Error in custom search handler:", error);
              const query = ((_a = this.searchInput) == null ? void 0 : _a.value.toLowerCase()) || "";
              this.filteredItems = this.items.filter((item) => item.title.toLowerCase().includes(query) || item.description && item.description.toLowerCase().includes(query));
              this.renderItems();
              if (this.keyboardNavService) {
                this.keyboardNavService.setItemCount(this.itemElements.length);
                this.keyboardNavService.clearFocus();
              }
            });
          } else {
            const query = this.searchInput.value.toLowerCase();
            this.filteredItems = this.items.filter((item) => item.title.toLowerCase().includes(query) || item.description && item.description.toLowerCase().includes(query));
            this.renderItems();
            if (this.keyboardNavService) {
              this.keyboardNavService.setItemCount(this.itemElements.length);
              this.keyboardNavService.clearFocus();
            }
          }
        } else {
          this.filteredItems = [...this.items];
          this.renderItems();
          if (this.keyboardNavService) {
            this.keyboardNavService.setItemCount(this.itemElements.length);
            this.keyboardNavService.clearFocus();
          }
        }
      }
      openAndGetSelection() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
          this.open();
        });
      }
    };
  }
});

// src/core/ui/modals/standard/index.ts
var init_standard = __esm({
  "src/core/ui/modals/standard/index.ts"() {
    init_StandardModal();
    init_ListSelectionModal();
  }
});

// src/services/SearchService.ts
var SearchService;
var init_SearchService = __esm({
  "src/services/SearchService.ts"() {
    SearchService = class {
      constructor() {
        this.DEFAULT_INITIAL_RESULTS_LIMIT = 25;
        this.DEFAULT_MAX_FILTERED_RESULTS = 50;
      }
      static getInstance() {
        if (!SearchService.instance) {
          SearchService.instance = new SearchService();
        }
        return SearchService.instance;
      }
      search(items, query, getSearchableFields, options) {
        var _a, _b;
        const initialLimit = (_a = options == null ? void 0 : options.initialResultsLimit) != null ? _a : this.DEFAULT_INITIAL_RESULTS_LIMIT;
        const maxFiltered = (_b = options == null ? void 0 : options.maxFilteredResults) != null ? _b : this.DEFAULT_MAX_FILTERED_RESULTS;
        if (!query.trim()) {
          return items.slice(0, initialLimit).map((item) => ({
            item,
            matches: [],
            score: 0
          }));
        }
        const searchTerms = query.toLowerCase().split(/\s+/).filter(Boolean);
        const results = items.map((item) => {
          const fields = getSearchableFields(item);
          const matches = [];
          let totalScore = 0;
          const searchText = fields.map((f) => {
            var _a2;
            return ((_a2 = f.text) == null ? void 0 : _a2.toLowerCase()) || "";
          }).join(" ");
          const allTermsExist = searchTerms.every((term) => searchText.includes(term));
          if (!allTermsExist) {
            return { item, matches: [], score: 0 };
          }
          searchTerms.forEach((term) => {
            var _a2;
            let pos = 0;
            const termMatches = new Set();
            while ((pos = searchText.indexOf(term, pos)) !== -1) {
              let currentPos = 0;
              for (const field of fields) {
                const fieldText = ((_a2 = field.text) == null ? void 0 : _a2.toLowerCase()) || "";
                const fieldEnd = currentPos + fieldText.length;
                if (pos >= currentPos && pos < fieldEnd) {
                  const relativePos = pos - currentPos;
                  const quality = this.getMatchQuality(fieldText, term, relativePos);
                  matches.push({
                    field: field.field,
                    text: field.text || "",
                    indices: Array.from({ length: term.length }, (_, i) => relativePos + i),
                    matchQuality: quality
                  });
                  totalScore += field.weight * quality;
                  break;
                }
                currentPos = fieldEnd + 1;
              }
              pos += 1;
            }
          });
          if (searchTerms.length > 1 && matches.length > 0) {
            const positions = matches.flatMap((m) => m.indices[0]);
            const maxDistance = Math.max(...positions) - Math.min(...positions);
            if (maxDistance < 50) {
              totalScore *= 1.5;
            }
          }
          return {
            item,
            matches,
            score: totalScore
          };
        });
        return results.filter((result) => result.score > 0).sort((a, b) => b.score - a.score).slice(0, maxFiltered);
      }
      getMatchQuality(text, term, position) {
        const beforeChar = position > 0 ? text[position - 1] : " ";
        const afterChar = position + term.length < text.length ? text[position + term.length] : " ";
        if ((/\s/.test(beforeChar) || /\W/.test(beforeChar)) && (/\s/.test(afterChar) || /\W/.test(afterChar))) {
          return 1;
        }
        return 0.8;
      }
      highlightText(text, matches = [], searchQuery) {
        if (!matches || matches.length === 0 || !searchQuery) {
          const fragment2 = document.createDocumentFragment();
          fragment2.textContent = text;
          return fragment2;
        }
        const fragment = document.createDocumentFragment();
        const searchTerms = searchQuery.toLowerCase().trim().split(/\s+/).filter(Boolean);
        const regex = new RegExp(`(${searchTerms.map((term) => this.escapeRegExp(term)).join("|")})`, "gi");
        let lastIndex = 0;
        let match;
        while ((match = regex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
          }
          const span = document.createElement("span");
          span.className = "systemsculpt-search-highlight";
          span.textContent = match[0];
          fragment.appendChild(span);
          lastIndex = match.index + match[0].length;
        }
        if (lastIndex < text.length) {
          fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
        }
        return fragment;
      }
      escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
    };
  }
});

// src/components/FavoritesFilter.ts
var import_obsidian28, FavoritesFilter;
var init_FavoritesFilter = __esm({
  "src/components/FavoritesFilter.ts"() {
    import_obsidian28 = __toModule(require("obsidian"));
    FavoritesFilter = class {
      constructor(container, favoritesService, callback) {
        this.favoritesService = favoritesService;
        this.callback = callback;
        this.element = container.createDiv({
          cls: "systemsculpt-favorites-filter",
          attr: {
            "aria-label": "Show favorites only",
            "role": "button",
            "tabindex": "0"
          }
        });
        this.iconEl = this.element.createSpan({
          cls: "systemsculpt-favorites-icon"
        });
        (0, import_obsidian28.setIcon)(this.iconEl, "star");
        this.textEl = this.element.createSpan({
          text: "Favorites only",
          cls: "systemsculpt-favorites-label"
        });
        this.updateAppearance();
        this.addEventListeners();
        document.addEventListener("systemsculpt:favorites-filter-changed", () => {
          this.updateAppearance();
        });
      }
      updateAppearance() {
        const showFavoritesOnly = this.favoritesService.getShowFavoritesOnly();
        if (showFavoritesOnly) {
          this.element.addClass("is-active");
          this.textEl.setText("Favorites only");
        } else {
          this.element.removeClass("is-active");
          this.textEl.setText("Show favorites");
        }
        this.element.setAttribute("aria-pressed", showFavoritesOnly ? "true" : "false");
        this.element.setAttribute("aria-label", showFavoritesOnly ? "Click to show all models" : "Click to show favorites only");
        this.element.setAttribute("data-tooltip", showFavoritesOnly ? "Click to show all models" : "Click to show favorites only");
      }
      addEventListeners() {
        this.element.addEventListener("click", this.handleClick.bind(this));
        this.element.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            this.handleClick(e);
          }
        });
        this.element.addEventListener("focus", () => {
          this.element.addClass("is-focused");
        });
        this.element.addEventListener("blur", () => {
          this.element.removeClass("is-focused");
        });
      }
      handleClick(e) {
        e.preventDefault();
        e.stopPropagation();
        this.element.addClass("is-clicking");
        setTimeout(() => {
          this.element.removeClass("is-clicking");
        }, 200);
        this.favoritesService.toggleShowFavoritesOnly().then((newState) => {
          this.updateAppearance();
          if (this.callback) {
            this.callback(newState);
          }
        }).catch((error) => {
          console.error("[SystemSculpt] Failed to toggle favorites filter:", error);
        });
      }
      async setFilterState(showFavoritesOnly) {
        if (this.favoritesService.getShowFavoritesOnly() !== showFavoritesOnly) {
          await this.favoritesService.toggleShowFavoritesOnly();
          this.updateAppearance();
        }
      }
    };
  }
});

// src/components/EmptyFavoritesState.ts
var import_obsidian29, EmptyFavoritesState;
var init_EmptyFavoritesState = __esm({
  "src/components/EmptyFavoritesState.ts"() {
    import_obsidian29 = __toModule(require("obsidian"));
    EmptyFavoritesState = class {
      constructor(container, showingFavoritesOnly = false) {
        this.element = container.createDiv({
          cls: "systemsculpt-favorites-empty-state"
        });
        const iconEl = this.element.createSpan();
        (0, import_obsidian29.setIcon)(iconEl, "star");
        const heading = this.element.createEl("h4");
        const message = this.element.createEl("p");
        if (showingFavoritesOnly) {
          heading.setText("No favorite models");
          message.setText("You haven't favorited any models yet. Try turning off the favorites filter and mark some models as favorites.");
        } else {
          heading.setText("Mark models as favorites");
          message.setText("Click the star icon next to any model to add it to your favorites. Favorite models will appear at the top of the list.");
        }
      }
      updateForFilterState(showingFavoritesOnly) {
        const heading = this.element.querySelector("h4");
        const message = this.element.querySelector("p");
        if (!heading || !message)
          return;
        if (showingFavoritesOnly) {
          heading.setText("No favorite models");
          message.setText("You haven't favorited any models yet. Try turning off the favorites filter and mark some models as favorites.");
        } else {
          heading.setText("Mark models as favorites");
          message.setText("Click the star icon next to any model to add it to your favorites. Favorite models will appear at the top of the list.");
        }
      }
    };
  }
});

// src/modals/ProviderSelectionModal.ts
var import_obsidian30, ProviderSelectionModal;
var init_ProviderSelectionModal = __esm({
  "src/modals/ProviderSelectionModal.ts"() {
    import_obsidian30 = __toModule(require("obsidian"));
    ProviderSelectionModal = class extends import_obsidian30.Modal {
      constructor(options) {
        super(options.app);
        this.providerButtons = new Map();
        this.plugin = options.plugin;
        this.onSelect = options.onSelect;
        this.onUpdate = options.onUpdate;
        this.originalSelectedProviders = new Set(options.currentSelectedProviders);
        this.selectedProviders = new Set(options.currentSelectedProviders);
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        this.titleEl.setText("Select Providers");
        contentEl.createEl("p", {
          text: "Choose which AI providers to include in your model list. At least one provider must be selected.",
          cls: "systemsculpt-provider-selection-description"
        });
        const providerContainer = contentEl.createDiv("systemsculpt-provider-selection-list");
        if (this.plugin.settings.enableSystemSculptProvider) {
          this.createProviderToggle("systemsculpt", "SystemSculpt", providerContainer);
        }
        this.plugin.settings.customProviders.filter((provider) => provider.isEnabled).forEach((provider) => {
          this.createProviderToggle(provider.id, provider.name, providerContainer);
        });
      }
      createProviderToggle(providerId, displayName, container) {
        const providerItem = container.createDiv("systemsculpt-provider-toggle-item");
        this.providerButtons.set(providerId, providerItem);
        const iconWrapper = providerItem.createDiv("systemsculpt-provider-toggle-icon");
        const icon = iconWrapper.createSpan();
        if (providerId === "systemsculpt") {
          (0, import_obsidian30.setIcon)(icon, "bot");
        } else {
          (0, import_obsidian30.setIcon)(icon, "server");
        }
        const details = providerItem.createDiv("systemsculpt-provider-toggle-details");
        const name = details.createEl("span", { text: displayName, cls: "systemsculpt-provider-toggle-name" });
        const countText = details.createEl("span", {
          text: "Loading...",
          cls: "systemsculpt-provider-toggle-count"
        });
        this.getProviderModelCount(providerId).then((modelCount) => {
          countText.textContent = `${modelCount} models`;
        });
        const toggleWrapper = providerItem.createDiv("systemsculpt-provider-toggle-control");
        const toggleButton = toggleWrapper.createEl("button", {
          cls: "systemsculpt-provider-toggle-button"
        });
        this.updateToggleState(providerId, toggleButton);
        providerItem.addEventListener("click", () => {
          this.toggleProvider(providerId, toggleButton);
          this.notifyUpdate();
        });
      }
      toggleProvider(providerId, toggleButton) {
        if (this.selectedProviders.has(providerId)) {
          if (this.selectedProviders.size <= 1) {
            return;
          }
          this.selectedProviders.delete(providerId);
        } else {
          this.selectedProviders.add(providerId);
        }
        this.updateToggleState(providerId, toggleButton);
      }
      updateToggleState(providerId, toggleButton) {
        const isSelected = this.selectedProviders.has(providerId);
        if (isSelected) {
          toggleButton.addClass("is-active");
          toggleButton.textContent = "\u2713";
        } else {
          toggleButton.removeClass("is-active");
          toggleButton.textContent = "";
        }
        const parentItem = this.providerButtons.get(providerId);
        if (parentItem) {
          if (isSelected) {
            parentItem.addClass("is-selected");
          } else {
            parentItem.removeClass("is-selected");
          }
        }
      }
      async getProviderModelCount(providerId) {
        try {
          const allModels = await this.plugin.modelService.getModels();
          return allModels.filter((model) => {
            if (providerId === "systemsculpt") {
              return model.provider === "systemsculpt";
            } else {
              const provider = this.plugin.settings.customProviders.find((p) => p.id === providerId);
              return provider && model.provider.toLowerCase() === provider.name.toLowerCase();
            }
          }).length;
        } catch (error) {
          console.error("[SystemSculpt] Error getting model count for provider:", providerId, error);
          return 0;
        }
      }
      notifyUpdate() {
        console.log("[ProviderSelectionModal] Notifying update. Current selectedProviders:", Array.from(this.selectedProviders));
        if (this.selectedProviders.size === 0) {
          console.log("[ProviderSelectionModal] No providers selected, adding default");
          if (this.plugin.settings.enableSystemSculptProvider) {
            this.selectedProviders.add("systemsculpt");
            this.updateAllToggleStates();
          } else {
            const firstCustomProvider = this.plugin.settings.customProviders.find((p) => p.isEnabled);
            if (firstCustomProvider) {
              this.selectedProviders.add(firstCustomProvider.id);
              this.updateAllToggleStates();
            }
          }
        }
        const result = {
          selectedProviders: new Set(this.selectedProviders)
        };
        console.log("[ProviderSelectionModal] Sending update to callback:", Array.from(result.selectedProviders));
        if (this.onUpdate) {
          this.onUpdate(result);
        } else {
          this.onSelect(result);
        }
      }
      applyFinalSelection() {
        const result = {
          selectedProviders: new Set(this.selectedProviders)
        };
        console.log("[ProviderSelectionModal] Applying final selection:", Array.from(result.selectedProviders));
        this.onSelect(result);
      }
      updateAllToggleStates() {
        this.providerButtons.forEach((buttonEl, providerId) => {
          const toggleButton = buttonEl.querySelector(".systemsculpt-provider-toggle-button");
          if (toggleButton) {
            this.updateToggleState(providerId, toggleButton);
          }
        });
      }
      onClose() {
        this.applyFinalSelection();
        const { contentEl } = this;
        contentEl.empty();
        this.providerButtons.clear();
      }
    };
  }
});

// src/modals/StandardModelSelectionModal.ts
var StandardModelSelectionModal_exports = {};
__export(StandardModelSelectionModal_exports, {
  StandardModelSelectionModal: () => StandardModelSelectionModal
});
var import_obsidian31, _StandardModelSelectionModal, StandardModelSelectionModal;
var init_StandardModelSelectionModal = __esm({
  "src/modals/StandardModelSelectionModal.ts"() {
    import_obsidian31 = __toModule(require("obsidian"));
    init_standard();
    init_SearchService();
    init_modelUtils();
    init_FavoritesService();
    init_FavoritesFilter();
    init_EmptyFavoritesState();
    init_ProviderSelectionModal();
    _StandardModelSelectionModal = class {
      constructor(options) {
        this.allModels = [];
        this.filteredModels = [];
        this.selectedProviders = new Set(["systemsculpt"]);
        this.modalInstance = null;
        this.listeners = [];
        this.favoritesFilter = null;
        this.emptyState = null;
        this.app = options.app;
        this.plugin = options.plugin;
        this.selectedModelId = options.currentModelId;
        this.onSelect = options.onSelect;
        this.modalTitle = options.title || "Select AI Model";
        this.modalDescription = options.description || "Choose a model for your conversation";
        this.searchService = SearchService.getInstance();
        this.favoritesService = FavoritesService.getInstance(this.plugin);
        this.initializeSelectedProviders();
        this.plugin.modelService.getModels().then((models) => {
          this.allModels = filterChatModels(models);
          this.favoritesService.processFavorites(this.allModels);
          this.filteredModels = this.applyAllFilters(this.allModels);
        }).catch((error) => {
          console.error("[SystemSculpt] Error loading models:", error);
          this.allModels = [];
          this.filteredModels = [];
        });
        console.log("[SystemSculpt] ModelSelectionModal initialized with model ID:", this.selectedModelId);
      }
      initializeSelectedProviders() {
        this.selectedProviders.clear();
        const savedProviders = this.plugin.settings.selectedModelProviders || [];
        console.log("[SystemSculpt] Initializing providers. Saved preferences:", savedProviders);
        if (savedProviders.length > 0) {
          const availableProviders = this.getAvailableProviders();
          console.log("[SystemSculpt] Available providers:", availableProviders);
          savedProviders.forEach((providerId) => {
            if (availableProviders.includes(providerId)) {
              this.selectedProviders.add(providerId);
              console.log("[SystemSculpt] Added saved provider:", providerId);
            } else {
              console.log("[SystemSculpt] Skipped unavailable provider:", providerId);
            }
          });
          if (this.selectedProviders.size === 0) {
            console.log("[SystemSculpt] No saved providers available, using defaults");
            this.useDefaultProviders();
          } else {
            console.log("[SystemSculpt] Using saved provider preferences:", Array.from(this.selectedProviders));
          }
        } else {
          console.log("[SystemSculpt] No saved preferences, using default logic");
          this.useDefaultProviders();
        }
      }
      getAvailableProviders() {
        const availableProviders = [];
        if (this.plugin.settings.enableSystemSculptProvider) {
          availableProviders.push("systemsculpt");
        }
        this.plugin.settings.customProviders.forEach((provider) => {
          if (provider.isEnabled) {
            availableProviders.push(provider.id);
          }
        });
        return availableProviders;
      }
      useDefaultProviders() {
        if (this.plugin.settings.enableSystemSculptProvider) {
          this.selectedProviders.add("systemsculpt");
        }
        this.plugin.settings.customProviders.forEach((provider) => {
          if (provider.isEnabled) {
            this.selectedProviders.add(provider.id);
          }
        });
      }
      registerListener(element, type, listener) {
        element.addEventListener(type, listener);
        this.listeners.push({ element, type, listener });
      }
      removeAllListeners() {
        this.listeners.forEach(({ element, type, listener }) => {
          element.removeEventListener(type, listener);
        });
        this.listeners = [];
      }
      filterModelsByProviders(models) {
        if (this.selectedProviders.size === 0) {
          return [];
        }
        if (this.plugin.settings.debugMode) {
          console.log("[SystemSculpt] Filtering models by providers:", {
            selectedProviders: Array.from(this.selectedProviders),
            totalModels: models.length,
            modelProviders: models.map((m) => m.provider).filter((v, i, a) => a.indexOf(v) === i)
          });
        }
        const providerCache = {};
        this.plugin.settings.customProviders.forEach((p) => {
          providerCache[p.name.toLowerCase()] = p.id;
        });
        return models.filter((model) => {
          if (model.provider !== "systemsculpt") {
            const providerName = model.provider.toLowerCase();
            const providerId = providerCache[providerName];
            if (providerId) {
              return this.selectedProviders.has(providerId);
            }
            return false;
          }
          return this.selectedProviders.has(model.provider);
        });
      }
      applyAllFilters(models) {
        let filteredModels = models;
        filteredModels = this.filterModelsByProviders(models);
        filteredModels = this.favoritesService.filterModelsByFavorites(filteredModels);
        const currentModel = models.find((m) => this.isModelSelected(m.id));
        if (currentModel && !filteredModels.some((m) => this.isModelSelected(m.id))) {
          filteredModels.unshift(currentModel);
        }
        filteredModels = this.favoritesService.sortModelsByFavorites(filteredModels);
        this.filteredModels = filteredModels;
        return filteredModels;
      }
      searchModels(models, query) {
        if (!query || query.trim() === "") {
          return this.convertModelsToListItems(models);
        }
        const results = this.searchService.search(models, query, (model) => this.getSearchableFields(model), {
          initialResultsLimit: 25,
          maxFilteredResults: 50
        });
        let filteredResults = results.filter((result) => result.matches.length > 0 && result.score > 0).sort((a, b) => b.score - a.score).map((result) => result.item);
        const currentModel = models.find((m) => this.isModelSelected(m.id));
        if (currentModel && !filteredResults.some((m) => this.isModelSelected(m.id))) {
          filteredResults.unshift(currentModel);
        }
        return this.convertModelsToListItems(filteredResults);
      }
      createFilters(containerEl) {
        const filterBar = containerEl.createDiv("ss-model-filter-bar");
        const providerSection = filterBar.createDiv("ss-model-filter-section");
        const providerButtonContainer = providerSection.createDiv("ss-model-filter-buttons");
        this.createProviderButton(providerButtonContainer);
        const controlsSection = filterBar.createDiv("ss-model-filter-controls");
        const favoritesButton = controlsSection.createDiv("ss-favorites-button");
        this.favoritesFilter = new FavoritesFilter(favoritesButton, this.favoritesService, () => {
          this.updateModelList();
          this.updateFavoritesButtonCount();
          this.updateEmptyState();
        });
        this.updateFavoritesButtonCount();
        const refreshButton = controlsSection.createEl("button", {
          cls: "ss-model-refresh-button"
        });
        const refreshIcon = refreshButton.createSpan();
        (0, import_obsidian31.setIcon)(refreshIcon, "refresh-cw");
        const refreshText = refreshButton.createSpan();
        refreshText.textContent = "Refresh";
        refreshButton.addEventListener("click", async () => {
          refreshIcon.addClass("ss-spin");
          refreshText.textContent = "...";
          try {
            this.allModels = await this.plugin.modelService.refreshModels();
            this.favoritesService.processFavorites(this.allModels);
            this.updateModelList();
            this.updateFavoritesButtonCount();
            this.updateEmptyState();
            new import_obsidian31.Notice("Models refreshed");
          } catch (error) {
            console.error("[SystemSculpt] Error refreshing models:", error);
            new import_obsidian31.Notice("Failed to refresh models");
          } finally {
            refreshIcon.removeClass("ss-spin");
            refreshText.textContent = "Refresh";
          }
        });
      }
      createProviderButton(container) {
        const providerButton = container.createDiv("ss-provider-selection-button");
        const iconWrapper = providerButton.createDiv("ss-provider-selection-icon");
        const icon = iconWrapper.createSpan();
        (0, import_obsidian31.setIcon)(icon, "server");
        const textWrapper = providerButton.createDiv("ss-provider-selection-text");
        const label = textWrapper.createSpan("ss-provider-selection-label");
        label.textContent = "Providers";
        const count = textWrapper.createSpan("ss-provider-selection-count");
        this.updateProviderButtonCount(count);
        const arrowWrapper = providerButton.createDiv("ss-provider-selection-arrow");
        const arrow = arrowWrapper.createSpan();
        (0, import_obsidian31.setIcon)(arrow, "chevron-right");
        providerButton.addEventListener("click", () => {
          this.openProviderSelectionModal();
        });
      }
      updateProviderButtonCount(countEl) {
        const selectedCount = this.selectedProviders.size;
        const totalCount = this.getTotalAvailableProviders();
        countEl.textContent = `${selectedCount}/${totalCount}`;
      }
      getTotalAvailableProviders() {
        let count = 0;
        if (this.plugin.settings.enableSystemSculptProvider) {
          count++;
        }
        count += this.plugin.settings.customProviders.filter((p) => p.isEnabled).length;
        return count;
      }
      openProviderSelectionModal() {
        const modal = new ProviderSelectionModal({
          app: this.app,
          plugin: this.plugin,
          currentSelectedProviders: this.selectedProviders,
          onUpdate: async (result) => {
            var _a;
            console.log("[SystemSculpt] Provider selection update:", Array.from(result.selectedProviders));
            this.selectedProviders = result.selectedProviders;
            await this.saveProviderPreferences();
            this.updateModelList();
            this.updateEmptyState();
            const countEl = (_a = this.modalInstance) == null ? void 0 : _a.contentEl.querySelector(".ss-provider-selection-count");
            if (countEl && countEl instanceof HTMLElement) {
              this.updateProviderButtonCount(countEl);
            }
          },
          onSelect: async (result) => {
            var _a;
            console.log("[SystemSculpt] Provider selection final result:", Array.from(result.selectedProviders));
            this.selectedProviders = result.selectedProviders;
            await this.saveProviderPreferences();
            this.updateModelList();
            this.updateEmptyState();
            const countEl = (_a = this.modalInstance) == null ? void 0 : _a.contentEl.querySelector(".ss-provider-selection-count");
            if (countEl && countEl instanceof HTMLElement) {
              this.updateProviderButtonCount(countEl);
            }
          }
        });
        modal.open();
      }
      async saveProviderPreferences() {
        try {
          console.log("[SystemSculpt] Saving provider preferences. Current selectedProviders:", Array.from(this.selectedProviders));
          if (this.selectedProviders.size === 0) {
            console.warn("[SystemSculpt] No providers selected, applying default providers");
            this.useDefaultProviders();
          }
          const providersArray = Array.from(this.selectedProviders);
          this.plugin.settings.selectedModelProviders = providersArray;
          console.log("[SystemSculpt] About to save to settings:", providersArray);
          await this.plugin.saveSettings();
          console.log("[SystemSculpt] Saved provider preferences to settings:", this.plugin.settings.selectedModelProviders);
        } catch (error) {
          console.error("[SystemSculpt] Error saving provider preferences:", error);
        }
      }
      static cleanupProviderPreferences(plugin) {
        try {
          const savedProviders = plugin.settings.selectedModelProviders || [];
          const availableProviders = [];
          if (plugin.settings.enableSystemSculptProvider) {
            availableProviders.push("systemsculpt");
          }
          plugin.settings.customProviders.forEach((provider) => {
            if (provider.isEnabled) {
              availableProviders.push(provider.id);
            }
          });
          const validProviders = savedProviders.filter((providerId) => availableProviders.includes(providerId));
          if (validProviders.length === 0 && savedProviders.length > 0) {
            plugin.settings.selectedModelProviders = [];
            plugin.saveSettings();
            if (plugin.settings.debugMode) {
              console.log("[SystemSculpt] Cleaned up invalid provider preferences");
            }
          } else if (validProviders.length !== savedProviders.length) {
            plugin.settings.selectedModelProviders = validProviders;
            plugin.saveSettings();
            if (plugin.settings.debugMode) {
              console.log("[SystemSculpt] Removed invalid providers from preferences:", savedProviders.filter((p) => !validProviders.includes(p)));
            }
          }
        } catch (error) {
          console.error("[SystemSculpt] Error cleaning up provider preferences:", error);
        }
      }
      updateFavoritesButtonCount() {
        var _a;
        if (!this.favoritesFilter)
          return;
        const favorites = this.filteredModels.filter((m) => m.isFavorite).length;
        const favoritesEl = (_a = this.modalInstance) == null ? void 0 : _a.contentEl.querySelector(".systemsculpt-favorites-filter");
        if (favoritesEl) {
          const existingCount = favoritesEl.querySelector(".ss-favorites-count");
          if (existingCount) {
            existingCount.remove();
          }
          if (favorites > 0) {
            const countSpan = favoritesEl.createSpan("ss-favorites-count");
            countSpan.textContent = favorites.toString();
          }
        }
      }
      updateModelList() {
        if (!this.modalInstance) {
          console.error("Modal instance not found");
          return;
        }
        try {
          this.filteredModels = this.applyAllFilters(this.allModels);
          const items = this.convertModelsToListItems(this.filteredModels);
          this.modalInstance.setItems(items);
          this.updateEmptyState();
        } catch (error) {
          console.error("Error updating model list:", error);
        }
      }
      updateEmptyState() {
        if (!this.modalInstance)
          return;
        const modalContent = this.modalInstance.contentEl;
        if (this.filteredModels.length === 0) {
          if (!this.emptyState) {
            this.emptyState = new EmptyFavoritesState(modalContent, this.favoritesService.getShowFavoritesOnly());
          } else {
            this.emptyState.updateForFilterState(this.favoritesService.getShowFavoritesOnly());
            modalContent.appendChild(this.emptyState.element);
          }
          const listEl = modalContent.querySelector(".ss-modal__list");
          if (listEl) {
            listEl.addClass("systemsculpt-hidden");
          }
        } else {
          if (this.emptyState && this.emptyState.element.parentNode) {
            this.emptyState.element.detach();
          }
          const listEl = modalContent.querySelector(".ss-modal__list");
          if (listEl) {
            listEl.removeClass("systemsculpt-hidden");
          }
        }
      }
      getSearchableFields(model) {
        return [
          { field: "name", text: model.name || "", weight: 2 },
          { field: "description", text: model.description || "", weight: 0.5 },
          { field: "provider", text: model.provider || "", weight: 0.8 },
          { field: "id", text: model.id || "", weight: 0.6 }
        ];
      }
      convertModelsToListItems(models) {
        const sortedModels = models.sort((a, b) => {
          const aSelected = this.isModelSelected(a.id) ? 1 : 0;
          const bSelected = this.isModelSelected(b.id) ? 1 : 0;
          const aFavorite = a.isFavorite ? 1 : 0;
          const bFavorite = b.isFavorite ? 1 : 0;
          if (aSelected !== bSelected) {
            return bSelected - aSelected;
          }
          if (aFavorite !== bFavorite) {
            return bFavorite - aFavorite;
          }
          return a.name.localeCompare(b.name);
        });
        return sortedModels.map((model) => {
          const isCurrentModel = this.isModelSelected(model.id);
          const item = {
            id: model.id,
            title: model.name,
            description: this.getModelDescription(model),
            icon: this.getModelIcon(model),
            selected: isCurrentModel,
            badge: this.getModelBadge(model),
            metadata: {
              provider: model.provider,
              contextLength: model.context_length,
              isFavorite: model.isFavorite || false,
              isNew: model.is_new || false,
              isBeta: model.is_beta || false,
              isDeprecated: model.is_deprecated || false,
              capabilities: this.getModelCapabilities(model),
              isCurrentModel
            }
          };
          item._ssModel = model;
          if (model.provider === "systemsculpt") {
            item.providerClass = "provider-systemsculpt";
          } else {
            item.providerClass = "provider-custom";
          }
          if (isCurrentModel) {
            item.additionalClasses = "ss-current-model";
          }
          return item;
        });
      }
      getModelCapabilities(model) {
        const capabilities = [];
        if (model.supports_vision)
          capabilities.push("Vision");
        if (model.supports_functions)
          capabilities.push("Functions");
        if (model.supports_streaming !== false)
          capabilities.push("Streaming");
        if (model.context_length && model.context_length >= 1e5)
          capabilities.push("Long Context");
        return capabilities;
      }
      isModelSelected(modelId) {
        if (this.selectedModelId === modelId) {
          return true;
        }
        const normalizedSelected = ensureCanonicalId(this.selectedModelId);
        const normalizedCandidate = ensureCanonicalId(modelId);
        return normalizedSelected === normalizedCandidate;
      }
      getModelDescription(model) {
        const parts = [];
        if (model.context_length) {
          const tokens = model.context_length;
          let formattedTokens;
          if (tokens >= 1e6) {
            formattedTokens = `${(tokens / 1e6).toFixed(1)}M tokens`;
          } else if (tokens >= 1e3) {
            formattedTokens = `${(tokens / 1e3).toFixed(0)}K tokens`;
          } else {
            formattedTokens = `${tokens} tokens`;
          }
          parts.push(formattedTokens);
        }
        if (model.pricing) {
          const pricing = model.pricing;
          if (pricing.input && pricing.output) {
            parts.push(`$${pricing.input}/$${pricing.output} per 1K`);
          }
        }
        const capabilities = [];
        if (model.supports_vision)
          capabilities.push("Vision");
        if (model.supports_functions)
          capabilities.push("Functions");
        if (model.supports_streaming)
          capabilities.push("Streaming");
        if (capabilities.length > 0) {
          parts.push(capabilities.join(" \xB7 "));
        }
        if (model.description && model.description.length > 0 && model.description.length < 100) {
          parts.push(model.description);
        }
        return parts.join(" \u2022 ");
      }
      getModelIcon(model) {
        const canonicalId = getCanonicalId(model);
        if (canonicalId === "systemsculpt@@vault-agent") {
          return "folder-open";
        }
        if (model.provider === "systemsculpt") {
          return "bot";
        } else {
          return "server";
        }
      }
      getModelBadge(model) {
        const canonicalId = getCanonicalId(model);
        if (canonicalId === "systemsculpt@@vault-agent") {
          return "Agent";
        }
        if (model.is_new) {
          return "New";
        }
        if (model.is_beta) {
          return "Beta";
        }
        if (model.is_deprecated) {
          return "Legacy";
        }
        if (model.provider !== "systemsculpt") {
          const providerName = model.provider.toLowerCase();
          if (!_StandardModelSelectionModal.providerNameCache[providerName]) {
            const matchingProvider = this.plugin.settings.customProviders.find((p) => p.name.toLowerCase() === providerName);
            _StandardModelSelectionModal.providerNameCache[providerName] = matchingProvider ? matchingProvider.name : "Custom";
          }
          return _StandardModelSelectionModal.providerNameCache[providerName];
        }
        return "";
      }
      registerEventsForUpdates() {
        const favChangedListener = () => this.updateModelList();
        const favFilterChangedListener = () => this.updateModelList();
        const favToggledListener = (event) => {
          const { modelId, isFavorite } = event.detail;
          const modelIndex = this.filteredModels.findIndex((m) => m.id === modelId);
          if (modelIndex !== -1) {
            this.filteredModels[modelIndex].isFavorite = isFavorite;
          }
        };
        this.registerListener(document.body, "systemsculpt:favorites-changed", favChangedListener);
        this.registerListener(document.body, "systemsculpt:favorites-filter-changed", favFilterChangedListener);
        this.registerListener(document.body, "ss-list-item-favorite-toggled", favToggledListener);
      }
      async open() {
        try {
          this.removeAllListeners();
          const models = await this.plugin.getInitialModels();
          this.allModels = filterChatModels(models);
          this.favoritesService.processFavorites(this.allModels);
          this.filteredModels = this.applyAllFilters(this.allModels);
          const items = this.convertModelsToListItems(this.filteredModels);
          const modal = new ListSelectionModal(this.app, items, {
            title: this.modalTitle,
            description: this.modalDescription,
            emptyText: "No models found matching your criteria",
            placeholder: "Search by name, provider, or capabilities...",
            withSearch: true,
            size: "large",
            closeOnSelect: true,
            favoritesService: this.favoritesService,
            customContent: (containerEl) => {
              this.createFilters(containerEl);
            }
          });
          this.modalInstance = modal;
          modal.contentEl.addClass("systemsculpt-model-selection-modal");
          modal.setCustomSearchHandler((query) => {
            return this.searchModelsAsync(this.filteredModels, query);
          });
          modal.contentEl.addEventListener("ss-list-item-favorite-toggled", (event) => {
            const customEvent = event;
            console.log("Favorite toggled event received in modal:", customEvent.detail);
          });
          this.registerEventsForUpdates();
          this.updateEmptyState();
          const selectedItems = await modal.openAndGetSelection();
          this.removeAllListeners();
          if (selectedItems && selectedItems.length > 0) {
            const selectedItem = selectedItems[0];
            const result = {
              modelId: selectedItem.id
            };
            this.onSelect(result);
          } else {
            console.log("[SystemSculpt] Model selection cancelled.");
          }
        } catch (error) {
          console.error("[SystemSculpt] Error opening or handling model selection modal:", error);
        }
      }
      async searchModelsAsync(models, query) {
        return Promise.resolve(this.searchModels(models, query));
      }
    };
    StandardModelSelectionModal = _StandardModelSelectionModal;
    StandardModelSelectionModal.providerNameCache = {};
  }
});

// src/modals/SystemPromptCreatorModal.ts
var import_obsidian32, SystemPromptCreatorModal;
var init_SystemPromptCreatorModal = __esm({
  "src/modals/SystemPromptCreatorModal.ts"() {
    import_obsidian32 = __toModule(require("obsidian"));
    SystemPromptCreatorModal = class extends import_obsidian32.Modal {
      constructor(options) {
        super(options.app);
        this.fileNameInput = null;
        this.contentTextArea = null;
        this.saveLocationEl = null;
        this.createButton = null;
        this.presets = [
          {
            id: "creative-writing",
            name: "Creative Writing Assistant",
            description: "For creative writing, storytelling, and content creation",
            content: `You are a creative writing assistant with expertise in storytelling, character development, and narrative structure. Your role is to help users craft compelling stories, develop interesting characters, and improve their writing style.

Key areas of assistance:
- Plot development and story structure
- Character creation and development
- Dialogue writing and improvement
- Setting and world-building
- Writing style and voice development
- Grammar and clarity suggestions

Always encourage creativity while providing constructive feedback. Ask clarifying questions to better understand the user's vision and goals.`
          },
          {
            id: "code-assistant",
            name: "Code Review Assistant",
            description: "For code review, debugging, and programming guidance",
            content: `You are a senior software engineer specializing in code review and development best practices. Your role is to help users write better code, debug issues, and follow industry standards.

Key areas of assistance:
- Code review and quality assessment
- Bug identification and debugging strategies
- Performance optimization suggestions
- Security best practices
- Clean code principles and refactoring
- Documentation and commenting standards
- Testing strategies and implementation

Provide specific, actionable feedback with examples when possible. Consider readability, maintainability, and scalability in your recommendations.`
          },
          {
            id: "research-helper",
            name: "Research Assistant",
            description: "For research, analysis, and information gathering",
            content: `You are a research assistant with expertise in information analysis, source evaluation, and academic writing. Your role is to help users conduct thorough research and present findings clearly.

Key areas of assistance:
- Research methodology and planning
- Source evaluation and credibility assessment
- Data analysis and interpretation
- Literature review and synthesis
- Citation and referencing guidance
- Academic writing structure and style
- Fact-checking and verification

Always emphasize the importance of multiple sources and critical thinking. Help users develop strong analytical skills and present well-supported arguments.`
          },
          {
            id: "meeting-notes",
            name: "Meeting Notes Assistant",
            description: "For organizing meetings, taking notes, and action items",
            content: `You are a professional meeting assistant focused on organization, clarity, and actionable outcomes. Your role is to help users prepare for meetings, take effective notes, and follow up on commitments.

Key areas of assistance:
- Meeting agenda preparation and structure
- Note-taking strategies and templates
- Action item identification and tracking
- Decision documentation and clarity
- Follow-up task organization
- Meeting summary creation
- Stakeholder communication templates

Focus on clear, concise documentation that enables effective follow-through and accountability.`
          },
          {
            id: "blank",
            name: "Blank Template",
            description: "Start with a clean slate",
            content: `You are a helpful assistant. Please provide clear, accurate, and helpful responses to user questions and requests.

Key guidelines:
- Be concise but thorough in your responses
- Ask clarifying questions when needed
- Provide examples when helpful
- Maintain a professional and friendly tone

Customize this prompt based on your specific needs and use case.`
          }
        ];
        this.plugin = options.plugin;
        this.onCreated = options.onCreated;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("systemsculpt-prompt-creator-modal");
        contentEl.createEl("h2", { text: "Create New System Prompt" });
        contentEl.createEl("p", {
          text: "Create a custom system prompt file that will be saved to your vault and available for use in chats.",
          cls: "systemsculpt-prompt-creator-description"
        });
        const fileNameSection = contentEl.createDiv("systemsculpt-prompt-creator-section");
        fileNameSection.createEl("h3", { text: "File Name" });
        new import_obsidian32.Setting(fileNameSection).setName("Prompt Name").setDesc("Enter a name for your system prompt file").addText((text) => {
          this.fileNameInput = text;
          text.setPlaceholder("My Custom Prompt").setValue("").onChange((value) => {
            this.updateSaveLocation();
            this.validateForm();
          });
          text.inputEl.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              this.createPrompt();
            }
          });
        });
        this.saveLocationEl = fileNameSection.createDiv("systemsculpt-save-location");
        this.updateSaveLocation();
        const presetsSection = contentEl.createDiv("systemsculpt-prompt-creator-section");
        presetsSection.createEl("h3", { text: "Quick Start Templates" });
        presetsSection.createEl("p", {
          text: "Choose a template to get started, then customize as needed.",
          cls: "systemsculpt-section-description"
        });
        const presetsGrid = presetsSection.createDiv("systemsculpt-presets-grid");
        this.presets.forEach((preset) => {
          const presetCard = presetsGrid.createDiv("systemsculpt-preset-card systemsculpt-preset-card-clickable");
          presetCard.createEl("h4", { text: preset.name, cls: "systemsculpt-preset-card-title" });
          presetCard.createEl("p", { text: preset.description, cls: "systemsculpt-preset-card-description" });
          presetCard.addEventListener("click", () => {
            if (this.contentTextArea) {
              this.contentTextArea.setValue(preset.content);
            }
            if (this.fileNameInput && !this.fileNameInput.getValue().trim()) {
              this.fileNameInput.setValue(preset.name);
              this.updateSaveLocation();
              this.validateForm();
            }
            this.highlightSelectedPreset(presetCard);
          });
        });
        const contentSection = contentEl.createDiv("systemsculpt-prompt-creator-section");
        contentSection.createEl("h3", { text: "System Prompt Content" });
        contentSection.createEl("p", {
          text: "Write your system prompt here. This text will guide the AI's behavior and responses.",
          cls: "systemsculpt-section-description"
        });
        const textAreaContainer = contentSection.createDiv("systemsculpt-prompt-textarea-container");
        const textArea = textAreaContainer.createEl("textarea", {
          cls: "systemsculpt-prompt-textarea",
          placeholder: "Enter your system prompt here..."
        });
        this.contentTextArea = {
          getValue: () => textArea.value,
          setValue: (value) => {
            textArea.value = value;
            this.validateForm();
          },
          onChange: (callback) => {
            textArea.addEventListener("input", () => {
              callback(textArea.value);
            });
          },
          inputEl: textArea
        };
        textArea.rows = 12;
        textArea.addEventListener("input", () => {
          this.validateForm();
        });
        const actionsSection = contentEl.createDiv("systemsculpt-prompt-creator-actions");
        const cancelButton = new import_obsidian32.ButtonComponent(actionsSection);
        cancelButton.setButtonText("Cancel").onClick(() => {
          this.close();
        });
        this.createButton = new import_obsidian32.ButtonComponent(actionsSection);
        this.createButton.setButtonText("Create System Prompt").setCta().setDisabled(true).onClick(() => {
          this.createPrompt();
        });
        this.validateForm();
      }
      highlightSelectedPreset(selectedCard) {
        var _a;
        const allCards = (_a = selectedCard.parentElement) == null ? void 0 : _a.querySelectorAll(".systemsculpt-preset-card");
        allCards == null ? void 0 : allCards.forEach((card) => card.removeClass("systemsculpt-preset-card-selected"));
        selectedCard.addClass("systemsculpt-preset-card-selected");
        setTimeout(() => {
          selectedCard.removeClass("systemsculpt-preset-card-selected");
        }, 1e3);
      }
      updateSaveLocation() {
        if (!this.saveLocationEl || !this.fileNameInput)
          return;
        const fileName = this.fileNameInput.getValue().trim();
        const systemPromptsFolder = "SystemSculpt/System Prompts";
        if (fileName) {
          const sanitizedFileName = this.sanitizeFileName(fileName);
          const fullPath = `${systemPromptsFolder}/${sanitizedFileName}.md`;
          this.saveLocationEl.innerHTML = `
        <div class="systemsculpt-save-location-label">Will be saved to:</div>
        <div class="systemsculpt-save-location-path">${fullPath}</div>
      `;
        } else {
          this.saveLocationEl.innerHTML = `
        <div class="systemsculpt-save-location-label">Will be saved to:</div>
        <div class="systemsculpt-save-location-path systemsculpt-save-location-placeholder">${systemPromptsFolder}/[enter name].md</div>
      `;
        }
      }
      sanitizeFileName(fileName) {
        return fileName.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim();
      }
      validateForm() {
        if (!this.fileNameInput || !this.contentTextArea || !this.createButton)
          return;
        const fileName = this.fileNameInput.getValue().trim();
        const content = this.contentTextArea.getValue().trim();
        const isValid = fileName.length > 0 && content.length > 0;
        this.createButton.setDisabled(!isValid);
      }
      async createPrompt() {
        if (!this.fileNameInput || !this.contentTextArea) {
          new import_obsidian32.Notice("Missing required fields", 5e3);
          return;
        }
        const fileName = this.fileNameInput.getValue().trim();
        const content = this.contentTextArea.getValue().trim();
        if (!fileName || !content) {
          new import_obsidian32.Notice("Please fill in both the name and content fields", 5e3);
          return;
        }
        try {
          const systemPromptsFolder = "SystemSculpt/System Prompts";
          await this.ensureFolderExists(systemPromptsFolder);
          const sanitizedFileName = this.sanitizeFileName(fileName);
          const filePath = `${systemPromptsFolder}/${sanitizedFileName}.md`;
          const existingFile = this.app.vault.getAbstractFileByPath(filePath);
          if (existingFile) {
            new import_obsidian32.Notice(`A system prompt with the name "${sanitizedFileName}" already exists. Please choose a different name.`, 8e3);
            return;
          }
          const fileContent = `---
type: system-prompt
created: ${new Date().toISOString()}
tags: [system-prompt, custom]
---

${content}`;
          await this.app.vault.create(filePath, fileContent);
          new import_obsidian32.Notice(`System prompt "${sanitizedFileName}" created successfully!`, 5e3);
          if (this.onCreated) {
            this.onCreated(filePath);
          }
          this.close();
        } catch (error) {
          console.error("Error creating system prompt:", error);
          new import_obsidian32.Notice("Failed to create system prompt. Please try again.", 8e3);
        }
      }
      async ensureFolderExists(folderPath) {
        const pathParts = folderPath.split("/");
        let currentPath = "";
        for (const part of pathParts) {
          currentPath = currentPath ? `${currentPath}/${part}` : part;
          const existingFolder = this.app.vault.getAbstractFileByPath(currentPath);
          if (!existingFolder) {
            await this.app.vault.createFolder(currentPath);
          }
        }
      }
      onClose() {
      }
    };
  }
});

// src/modals/StandardSystemPromptSelectionModal.ts
var StandardSystemPromptSelectionModal_exports = {};
__export(StandardSystemPromptSelectionModal_exports, {
  StandardSystemPromptSelectionModal: () => StandardSystemPromptSelectionModal
});
var import_obsidian33, StandardSystemPromptSelectionModal;
var init_StandardSystemPromptSelectionModal = __esm({
  "src/modals/StandardSystemPromptSelectionModal.ts"() {
    import_obsidian33 = __toModule(require("obsidian"));
    init_standard();
    init_SystemPromptService();
    init_prompts2();
    init_SearchService();
    init_SystemPromptCreatorModal();
    StandardSystemPromptSelectionModal = class {
      constructor(options) {
        this.modalInstance = null;
        this.allItems = [];
        this.filteredItems = [];
        this.app = options.app;
        this.plugin = options.plugin;
        this.currentType = options.currentType;
        this.currentPath = options.currentPath;
        this.onSelect = options.onSelect;
        this.modalTitle = options.title || "Select System Prompt";
        this.modalDescription = options.description || "Choose a system prompt for this conversation";
        this.systemPromptService = SystemPromptService.getInstance(this.app, () => this.plugin.settings);
        this.searchService = SearchService.getInstance();
      }
      async loadSystemPromptItems() {
        const items = [];
        items.push({
          id: "general-use",
          name: "General Use",
          description: "A comprehensive prompt for general conversations",
          type: "general-use",
          prompt: GENERAL_USE_PRESET.systemPrompt
        });
        items.push({
          id: "concise",
          name: "Concise",
          description: "A focused prompt for brief, direct responses",
          type: "concise",
          prompt: CONCISE_PRESET.systemPrompt
        });
        try {
          const customFiles = await this.systemPromptService.getCustomPromptFiles();
          for (const file of customFiles) {
            items.push({
              id: `custom-${file.path}`,
              name: file.name,
              description: `Custom prompt from: ${file.path}`,
              type: "custom",
              path: file.path
            });
          }
        } catch (error) {
          console.error("[SystemSculpt] Error loading custom prompt files:", error);
        }
        return items;
      }
      convertToListItems(items) {
        return items.map((item) => {
          const isSelected = this.isItemSelected(item);
          return {
            id: item.id,
            title: item.name,
            description: item.description,
            icon: this.getItemIcon(item),
            selected: isSelected,
            badge: item.type === "custom" ? "Custom" : ""
          };
        });
      }
      isItemSelected(item) {
        if (item.type === "custom" && this.currentType === "custom") {
          return item.path === this.currentPath;
        }
        return item.type === this.currentType;
      }
      getItemIcon(item) {
        switch (item.type) {
          case "general-use":
            return "message-square";
          case "concise":
            return "zap";
          case "agent":
            return "cpu";
          case "custom":
            return "file-text";
          default:
            return "file-text";
        }
      }
      searchItems(items, query) {
        if (!query || query.trim() === "") {
          return this.convertToListItems(items);
        }
        const results = this.searchService.search(items, query, (item) => this.getSearchableFields(item), {
          initialResultsLimit: 25,
          maxFilteredResults: 50
        });
        const filteredResults = results.filter((result) => result.matches.length > 0 && result.score > 0).sort((a, b) => b.score - a.score).map((result) => result.item);
        return this.convertToListItems(filteredResults);
      }
      getSearchableFields(item) {
        return [
          { field: "name", text: item.name || "", weight: 2 },
          { field: "description", text: item.description || "", weight: 1 },
          { field: "type", text: item.type || "", weight: 0.5 }
        ];
      }
      createFilters(containerEl) {
        const filtersContainer = containerEl.createDiv({ cls: "ss-modal-filters-container" });
        const actionsContainer = containerEl.createDiv({ cls: "ss-modal-actions-container" });
        const createButton2 = actionsContainer.createEl("button", {
          text: "Create New System Prompt",
          cls: "mod-cta ss-modal-create-button"
        });
        const createIconSpan = createButton2.createSpan({ cls: "ss-modal-create-icon" });
        (0, import_obsidian33.setIcon)(createIconSpan, "plus-circle");
        createButton2.addEventListener("click", () => {
          this.openSystemPromptCreator();
        });
        const refreshButton = actionsContainer.createEl("button", {
          text: "Refresh Custom Prompts",
          cls: "ss-modal-refresh-button"
        });
        const refreshIconSpan = refreshButton.createSpan({ cls: "ss-modal-refresh-icon" });
        (0, import_obsidian33.setIcon)(refreshIconSpan, "refresh-cw");
        refreshButton.addEventListener("click", async () => {
          const originalText = refreshButton.textContent || "Refresh Custom Prompts";
          refreshButton.textContent = "Refreshing...";
          refreshButton.classList.add("is-loading");
          refreshIconSpan.addClass("ss-modal-refresh-icon--spinning");
          try {
            this.allItems = await this.loadSystemPromptItems();
            this.updateItemList();
          } catch (error) {
            console.error("[SystemSculpt] Error refreshing custom prompts:", error);
          } finally {
            refreshButton.textContent = originalText;
            refreshButton.classList.remove("is-loading");
            refreshIconSpan.removeClass("ss-modal-refresh-icon--spinning");
          }
        });
      }
      openSystemPromptCreator() {
        const creatorModal = new SystemPromptCreatorModal({
          app: this.app,
          plugin: this.plugin,
          onCreated: async (filePath) => {
            try {
              this.allItems = await this.loadSystemPromptItems();
              this.updateItemList();
              const newItem = this.allItems.find((item) => item.path === filePath);
              if (newItem && this.modalInstance) {
                setTimeout(() => {
                  var _a;
                  const listItems = (_a = this.modalInstance) == null ? void 0 : _a.contentEl.querySelectorAll(".ss-modal__list-item");
                  const targetItem = Array.from(listItems || []).find((el) => el.getAttribute("data-id") === newItem.id);
                  if (targetItem) {
                    targetItem.click();
                  }
                }, 100);
              }
              new import_obsidian33.Notice("System prompt list updated with your new prompt!", 3e3);
            } catch (error) {
              console.error("[SystemSculpt] Error refreshing system prompts after creation:", error);
              new import_obsidian33.Notice("Created prompt successfully, but failed to refresh list. Please refresh manually.", 5e3);
            }
          }
        });
        creatorModal.open();
      }
      updateItemList() {
        if (!this.modalInstance) {
          console.error("Modal instance not found");
          return;
        }
        const items = this.convertToListItems(this.allItems);
        this.modalInstance.setItems(items);
      }
      async showAgentModeWarning() {
        return new Promise((resolve) => {
          const modal = new import_obsidian33.Modal(this.app);
          modal.titleEl.textContent = "Agent Mode Required";
          const content = modal.contentEl;
          content.empty();
          content.createEl("p", {
            text: "The Agent prompt requires Agent Mode to be enabled for full functionality. Agent Mode provides the AI with vault exploration and file operation capabilities."
          });
          content.createEl("p", {
            text: "Would you like to enable Agent Mode now?"
          });
          const buttonContainer = content.createDiv({ cls: "ss-modal-button-container ss-modal-margin-top-16" });
          new import_obsidian33.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
            modal.close();
            resolve(false);
          });
          new import_obsidian33.ButtonComponent(buttonContainer).setButtonText("Enable Agent Mode").setCta().onClick(() => {
            modal.close();
            resolve(true);
          });
          modal.open();
        });
      }
      async open() {
        try {
          this.allItems = await this.loadSystemPromptItems();
          const items = this.convertToListItems(this.allItems);
          const modal = new ListSelectionModal(this.app, items, {
            title: this.modalTitle,
            description: this.modalDescription,
            emptyText: "No system prompts found.",
            placeholder: "Search prompts...",
            withSearch: true,
            size: "medium",
            closeOnSelect: true,
            customContent: (containerEl) => {
              this.createFilters(containerEl);
            }
          });
          this.modalInstance = modal;
          modal.contentEl.addClass("systemsculpt-system-prompt-selection-modal");
          modal.setCustomSearchHandler(async (query) => {
            return this.searchItems(this.allItems, query);
          });
          const selectedItems = await modal.openAndGetSelection();
          if (selectedItems && selectedItems.length > 0) {
            const selectedItem = selectedItems[0];
            const item = this.allItems.find((i) => i.id === selectedItem.id);
            if (item) {
              let result;
              if (item.type === "custom" && item.path) {
                const customPrompt = await this.systemPromptService.getSystemPromptContent("custom", item.path);
                result = {
                  type: "custom",
                  prompt: customPrompt,
                  path: item.path
                };
              } else {
                result = {
                  type: item.type,
                  prompt: item.prompt || ""
                };
              }
              this.onSelect(result);
            }
          } else {
            console.log("[SystemSculpt] System prompt selection cancelled.");
          }
        } catch (error) {
          console.error("[SystemSculpt] Error opening system prompt selection modal:", error);
        }
      }
    };
  }
});

// src/utils/titleUtils.ts
function generateDefaultChatTitle() {
  const now = new Date();
  return `Chat ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
}
function sanitizeChatTitle(title) {
  return title.replace(/[\\/:*?"<>|]/g, "");
}
var init_titleUtils = __esm({
  "src/utils/titleUtils.ts"() {
  }
});

// src/views/chatview/MCPManagerModal.ts
var MCPManagerModal_exports = {};
__export(MCPManagerModal_exports, {
  MCPManagerModal: () => MCPManagerModal,
  showMCPManagerModal: () => showMCPManagerModal
});
function showMCPManagerModal(app, plugin) {
  return new Promise((resolve) => {
    const modal = new MCPManagerModal(app, plugin, {
      onSave: () => {
        resolve();
      },
      onCancel: () => {
        resolve();
      }
    });
    const originalClose = modal.close.bind(modal);
    modal.close = () => {
      resolve();
      originalClose();
    };
    modal.open();
  });
}
var import_obsidian74, MCPManagerModal;
var init_MCPManagerModal = __esm({
  "src/views/chatview/MCPManagerModal.ts"() {
    import_obsidian74 = __toModule(require("obsidian"));
    init_MCPService();
    init_MCPFilesystemServer2();
    init_agent2();
    MCPManagerModal = class extends import_obsidian74.Modal {
      constructor(app, plugin, options) {
        super(app);
        this.toolItems = [];
        this.isLoading = true;
        this.hasUnsavedChanges = false;
        this.plugin = plugin;
        this.options = options;
        this.enabledTools = new Set(plugin.settings.mcpEnabledTools || []);
        this.autoAcceptTools = new Set(plugin.settings.mcpAutoAcceptTools || []);
        this.modalEl.addClass("systemsculpt-mcp-manager-modal");
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.createEl("h2", { text: "Agent Settings & MCP Tools" });
        this.showLoadingState();
        await this.loadAllTools();
        this.createContent();
      }
      showLoadingState() {
        this.contentEl.empty();
        this.contentEl.createEl("h2", { text: "Agent Settings & MCP Tools" });
        new import_obsidian74.Setting(this.contentEl).setName("Loading...").setDesc("Discovering available MCP tools...");
      }
      async loadAllTools() {
        try {
          this.toolItems = [];
          if (!this.plugin.settings.mcpEnabled) {
            this.isLoading = false;
            return;
          }
          const mcpService = new MCPService(this.plugin, this.app);
          const servers = this.plugin.settings.mcpServers || [];
          for (const server of servers) {
            if (!server.isEnabled)
              continue;
            try {
              let tools = [];
              if (server.id === "mcp-filesystem") {
                const filesystemServer = new MCPFilesystemServer(this.plugin, this.app);
                tools = await filesystemServer.getTools();
              } else {
                const result = await mcpService.testConnection(server);
                if (result.success && result.tools) {
                  tools = result.tools;
                }
              }
              for (const tool of tools) {
                const toolKey = `${server.id}:${tool.name}`;
                const category = this.categorizeTool(tool.name);
                this.toolItems.push({
                  serverId: server.id,
                  serverName: server.name,
                  tool,
                  toolKey,
                  isEnabled: this.enabledTools.has(toolKey),
                  isAutoAccept: this.autoAcceptTools.has(toolKey),
                  category
                });
              }
            } catch (error) {
              console.error(`Failed to load tools from server ${server.name}:`, error);
            }
          }
          this.isLoading = false;
        } catch (error) {
          console.error("Failed to load MCP tools:", error);
          this.isLoading = false;
          this.showError("Failed to load MCP tools. Please check your server connections.");
        }
      }
      categorizeTool(toolName) {
        const readTools = [
          "read_files",
          "list_directories",
          "find_files",
          "grep_vault",
          "manage_workspace",
          "manage_context",
          "search_similar_notes",
          "search_graph",
          "refine_search",
          "search_metadata",
          "analyze_vault_storage"
        ];
        return readTools.includes(toolName) ? "read" : "write";
      }
      showError(message) {
        this.contentEl.empty();
        this.contentEl.createEl("h2", { text: "Agent Settings & MCP Tools" });
        new import_obsidian74.Setting(this.contentEl).setName("Error").setDesc(message).addButton((button) => button.setButtonText("Retry").setCta().onClick(async () => {
          this.showLoadingState();
          await this.loadAllTools();
          this.createContent();
        }));
      }
      createContent() {
        this.contentEl.empty();
        this.contentEl.createEl("h2", { text: "Agent Settings & MCP Tools" });
        this.createAgentModeToggle();
        if (!this.plugin.settings.mcpEnabled) {
          new import_obsidian74.Setting(this.contentEl).setName("MCP Disabled").setDesc("MCP tools are not enabled. Enable them in chat settings to access tools.");
          return;
        }
        if (this.toolItems.length === 0) {
          new import_obsidian74.Setting(this.contentEl).setName("No Tools Available").setDesc("No MCP tools available. Configure servers in chat settings to add tools.");
          return;
        }
        this.createBulkActions();
        const toolsContainer = this.contentEl.createDiv("systemsculpt-tools-container");
        this.createToolsList(toolsContainer);
      }
      createAgentModeToggle() {
        const activeChatView = this.app.workspace.getLeavesOfType("systemsculpt-chat-view").map((leaf) => leaf.view).find((view) => view && view.leaf === this.app.workspace.activeLeaf);
        if (!activeChatView) {
          new import_obsidian74.Setting(this.contentEl).setName("No Active Chat").setDesc("Open a chat to configure Agent Mode").setClass("systemsculpt-no-active-chat");
          return;
        }
        const agentModeSetting = new import_obsidian74.Setting(this.contentEl).setName("Agent Mode").setDesc("Enable autonomous vault exploration and file operations for this chat");
        agentModeSetting.addToggle((toggle) => {
          toggle.setValue(activeChatView.agentMode || false).onChange(async (value) => {
            if (value) {
              await this.enableAgentMode(activeChatView, toggle);
            } else {
              await this.disableAgentMode(activeChatView);
            }
          });
        });
        const statusText = activeChatView.agentMode ? "Agent can browse vault and access files" : "Agent works with limited capabilities";
        const statusDesc = agentModeSetting.descEl;
        statusDesc.createDiv({
          text: statusText,
          cls: "setting-item-description systemsculpt-agent-status"
        });
      }
      async enableAgentMode(activeChatView, toggle) {
        const models = await this.plugin.modelService.getModels();
        const agentModelAvailable = models.some((model) => model.id === AGENT_CONFIG.MODEL_ID);
        if (!agentModelAvailable) {
          new import_obsidian74.Notice("Cannot enable Agent Mode: SystemSculpt Agent Model not available", 1e4);
          this.close();
          return;
        }
        activeChatView.agentMode = true;
        activeChatView.systemPromptType = "agent";
        activeChatView.systemPromptPath = void 0;
        const agentModelId = AGENT_CONFIG.MODEL_ID;
        activeChatView.selectedModelId = agentModelId;
        await activeChatView.setSelectedModelId(agentModelId);
        const SystemPromptService2 = await Promise.resolve().then(() => (init_SystemPromptService(), SystemPromptService_exports));
        const service = SystemPromptService2.SystemPromptService.getInstance(this.app, () => this.plugin.settings);
        activeChatView.currentPrompt = await service.getSystemPromptContent("agent", void 0, true);
        await activeChatView.saveChat();
        if (activeChatView.updateSystemPromptIndicator) {
          await activeChatView.updateSystemPromptIndicator();
        }
        if (activeChatView.updateModelIndicator) {
          await activeChatView.updateModelIndicator();
        }
        if (activeChatView.inputHandler && activeChatView.inputHandler.updateAgentModeButtonState) {
          activeChatView.inputHandler.updateAgentModeButtonState();
        }
        this.refreshToolToggles();
        this.updateBulkActionStates();
        this.updateAgentModeStatus(activeChatView);
      }
      async disableAgentMode(activeChatView) {
        var _a, _b;
        activeChatView.agentMode = false;
        const defaultType = ((_a = this.plugin.settings) == null ? void 0 : _a.systemPromptType) || "general-use";
        const defaultPath = ((_b = this.plugin.settings) == null ? void 0 : _b.systemPromptPath) || void 0;
        if (activeChatView.systemPromptType === "agent") {
          activeChatView.systemPromptType = defaultType === "agent" ? "general-use" : defaultType;
          activeChatView.systemPromptPath = activeChatView.systemPromptType === "custom" ? defaultPath : void 0;
        }
        await activeChatView.saveChat();
        await activeChatView.updateModelIndicator();
        await activeChatView.updateSystemPromptIndicator();
        if (activeChatView.inputHandler && activeChatView.inputHandler.updateAgentModeButtonState) {
          activeChatView.inputHandler.updateAgentModeButtonState();
        }
        this.refreshToolToggles();
        this.updateBulkActionStates();
        this.updateAgentModeStatus(activeChatView);
      }
      updateAgentModeStatus(activeChatView) {
        const agentModeSettings = this.contentEl.querySelectorAll(".setting-item");
        for (let i = 0; i < agentModeSettings.length; i++) {
          const setting = agentModeSettings[i];
          const nameEl = setting.querySelector(".setting-item-name");
          if (nameEl && nameEl.textContent === "Agent Mode") {
            const statusEl = setting.querySelector(".systemsculpt-agent-status");
            if (statusEl) {
              const statusText = activeChatView.agentMode ? "Agent can browse vault and access files" : "Agent works with limited capabilities";
              statusEl.textContent = statusText;
            }
            break;
          }
        }
      }
      createBulkActions() {
        const bulkSetting = new import_obsidian74.Setting(this.contentEl).setName("Quick Actions").setDesc("Apply changes to all tools at once").setClass("systemsculpt-bulk-actions");
        let enableAllButton;
        let disableAllButton;
        let autoApproveAllButton;
        bulkSetting.addButton((button) => {
          disableAllButton = button;
          button.setButtonText("Disable All").onClick(() => {
            this.toolItems.forEach((item) => {
              this.enabledTools.delete(item.toolKey);
              this.autoAcceptTools.delete(item.toolKey);
              item.isEnabled = false;
              item.isAutoAccept = false;
            });
            this.refreshToolToggles();
            this.hasUnsavedChanges = true;
          });
        });
        bulkSetting.addButton((button) => {
          enableAllButton = button;
          button.setButtonText("Enable All").onClick(() => {
            this.toolItems.forEach((item) => {
              this.enabledTools.add(item.toolKey);
              item.isEnabled = true;
            });
            this.refreshToolToggles();
            this.hasUnsavedChanges = true;
          });
        });
        bulkSetting.addButton((button) => {
          autoApproveAllButton = button;
          button.setButtonText("Enable & Auto-approve Read Tools").onClick(() => {
            let updatedCount = 0;
            this.toolItems.forEach((item) => {
              if (item.category === "read") {
                this.enabledTools.add(item.toolKey);
                item.isEnabled = true;
                this.autoAcceptTools.add(item.toolKey);
                item.isAutoAccept = true;
                updatedCount++;
              }
            });
            console.log(`Enabled and auto-approved ${updatedCount} read tools`);
            this.refreshToolToggles();
            this.hasUnsavedChanges = true;
          });
        });
        bulkSetting.settingEl._enableAllButton = enableAllButton;
        bulkSetting.settingEl._disableAllButton = disableAllButton;
        bulkSetting.settingEl._autoApproveAllButton = autoApproveAllButton;
        this.updateBulkActionStates();
      }
      createToolsList(container) {
        const readTools = this.toolItems.filter((item) => item.category === "read");
        const writeTools = this.toolItems.filter((item) => item.category === "write");
        if (readTools.length > 0) {
          this.createToolCategorySection(container, "read", "Read Tools", "Safe tools for viewing and searching vault content", readTools);
        }
        if (writeTools.length > 0) {
          this.createToolCategorySection(container, "write", "Write Tools", "Dangerous & experimental tools that modify your vault. Use with extreme caution, especially auto-approve.", writeTools);
        }
      }
      createToolCategorySection(container, category, title, description, tools) {
        const categorySection = container.createDiv("systemsculpt-tool-category");
        const headerEl = categorySection.createDiv("systemsculpt-category-header");
        const titleEl = headerEl.createEl("h3", {
          text: title,
          cls: `systemsculpt-category-title ${category === "write" ? "systemsculpt-write-category" : ""}`
        });
        if (category === "write") {
          const warningIcon = titleEl.createSpan("systemsculpt-warning-icon");
          (0, import_obsidian74.setIcon)(warningIcon, "alert-triangle");
        }
        headerEl.createEl("p", {
          text: description,
          cls: `systemsculpt-category-description ${category === "write" ? "systemsculpt-write-warning" : ""}`
        });
        const toolsByServer = new Map();
        tools.forEach((item) => {
          if (!toolsByServer.has(item.serverId)) {
            toolsByServer.set(item.serverId, []);
          }
          toolsByServer.get(item.serverId).push(item);
        });
        toolsByServer.forEach((serverTools, serverId) => {
          const serverName = serverTools[0].serverName;
          if (toolsByServer.size > 1) {
            const serverHeaderEl = categorySection.createDiv("systemsculpt-server-section");
            serverHeaderEl.createEl("h4", {
              text: serverName,
              cls: "systemsculpt-server-title"
            });
          }
          serverTools.forEach((item) => {
            this.createToolSetting(item, categorySection);
          });
        });
      }
      createToolSetting(item, container) {
        const displayDescription = item.serverId === "mcp-filesystem" ? MCPFilesystemServer.getToolDisplayDescription(item.tool.name) : item.tool.description.split("\n")[0].substring(0, 120);
        const toolSetting = new import_obsidian74.Setting(container).setName(this.formatToolName(item.tool.name)).setDesc(displayDescription).setClass("systemsculpt-tool-setting");
        if (item.category === "write") {
          toolSetting.settingEl.addClass("systemsculpt-write-tool");
        }
        const activeChatView = this.app.workspace.getLeavesOfType("systemsculpt-chat-view").map((leaf) => leaf.view).find((view) => view && view.leaf === this.app.workspace.activeLeaf);
        const isAgentModeActive = (activeChatView == null ? void 0 : activeChatView.agentMode) || false;
        let enabledToggle;
        let autoAcceptToggle;
        toolSetting.addToggle((toggle) => {
          enabledToggle = toggle;
          toggle.setValue(item.isEnabled).setTooltip("Enable this tool").setDisabled(!isAgentModeActive).onChange((value) => {
            if (value) {
              this.enabledTools.add(item.toolKey);
            } else {
              this.enabledTools.delete(item.toolKey);
              this.autoAcceptTools.delete(item.toolKey);
              item.isAutoAccept = false;
              if (autoAcceptToggle) {
                autoAcceptToggle.setValue(false);
              }
            }
            item.isEnabled = value;
            if (autoAcceptToggle) {
              autoAcceptToggle.setDisabled(!value || !isAgentModeActive);
            }
            this.hasUnsavedChanges = true;
          });
        });
        toolSetting.addToggle((toggle) => {
          autoAcceptToggle = toggle;
          const tooltip = item.category === "write" ? "\u26A0\uFE0F DANGER: Auto-approve will allow the agent to modify your vault without asking!" : "Auto-approve requests for this tool";
          toggle.setValue(item.isAutoAccept).setDisabled(!item.isEnabled || !isAgentModeActive).setTooltip(tooltip).onChange((value) => {
            if (value && item.category === "write") {
              const confirmed = confirm(`\u26A0\uFE0F WARNING: You are about to enable auto-approve for "${this.formatToolName(item.tool.name)}", a write tool that can modify your vault.

This means the agent can use this tool WITHOUT asking for permission, potentially making destructive changes to your files.

Are you absolutely sure you want to enable auto-approve for this dangerous tool?`);
              if (!confirmed) {
                toggle.setValue(false);
                return;
              }
            }
            if (value) {
              if (!item.isEnabled) {
                this.enabledTools.add(item.toolKey);
                item.isEnabled = true;
                if (enabledToggle) {
                  enabledToggle.setValue(true);
                }
              }
              this.autoAcceptTools.add(item.toolKey);
            } else {
              this.autoAcceptTools.delete(item.toolKey);
            }
            item.isAutoAccept = value;
            this.hasUnsavedChanges = true;
          });
        });
        if (!isAgentModeActive) {
          toolSetting.settingEl.addClass("mod-disabled");
        }
        toolSetting.settingEl._item = item;
        toolSetting.settingEl._enabledToggle = enabledToggle;
        toolSetting.settingEl._autoAcceptToggle = autoAcceptToggle;
      }
      refreshToolToggles() {
        const settingElements = this.contentEl.querySelectorAll(".setting-item.systemsculpt-tool-setting");
        const activeChatView = this.app.workspace.getLeavesOfType("systemsculpt-chat-view").map((leaf) => leaf.view).find((view) => view && view.leaf === this.app.workspace.activeLeaf);
        const isAgentModeActive = (activeChatView == null ? void 0 : activeChatView.agentMode) || false;
        settingElements.forEach((settingEl) => {
          const item = settingEl._item;
          const enabledToggle = settingEl._enabledToggle;
          const autoAcceptToggle = settingEl._autoAcceptToggle;
          if (!item || !enabledToggle || !autoAcceptToggle)
            return;
          enabledToggle.setValue(item.isEnabled);
          autoAcceptToggle.setValue(item.isAutoAccept);
          if (!isAgentModeActive) {
            settingEl.addClass("mod-disabled");
            enabledToggle.setDisabled(true);
            autoAcceptToggle.setDisabled(true);
          } else {
            settingEl.removeClass("mod-disabled");
            enabledToggle.setDisabled(false);
            autoAcceptToggle.setDisabled(!item.isEnabled);
          }
        });
      }
      updateBulkActionStates() {
        const activeChatView = this.app.workspace.getLeavesOfType("systemsculpt-chat-view").map((leaf) => leaf.view).find((view) => view && view.leaf === this.app.workspace.activeLeaf);
        const isAgentModeActive = (activeChatView == null ? void 0 : activeChatView.agentMode) || false;
        const bulkSetting = this.contentEl.querySelector(".systemsculpt-bulk-actions");
        if (!bulkSetting)
          return;
        const enableAllButton = bulkSetting._enableAllButton;
        const disableAllButton = bulkSetting._disableAllButton;
        const autoApproveAllButton = bulkSetting._autoApproveAllButton;
        if (!isAgentModeActive) {
          bulkSetting.addClass("mod-disabled");
          if (enableAllButton)
            enableAllButton.setDisabled(true);
          if (disableAllButton)
            disableAllButton.setDisabled(true);
          if (autoApproveAllButton)
            autoApproveAllButton.setDisabled(true);
        } else {
          bulkSetting.removeClass("mod-disabled");
          if (enableAllButton)
            enableAllButton.setDisabled(false);
          if (disableAllButton)
            disableAllButton.setDisabled(false);
          if (autoApproveAllButton)
            autoApproveAllButton.setDisabled(false);
        }
      }
      formatToolName(toolName) {
        return toolName.replace(/[_-]/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
      }
      async saveChanges() {
        if (!this.hasUnsavedChanges) {
          this.close();
          return;
        }
        try {
          const enabledToolsArray = Array.from(this.enabledTools);
          const autoAcceptToolsArray = Array.from(this.autoAcceptTools);
          await this.plugin.getSettingsManager().updateSettings({
            mcpEnabledTools: enabledToolsArray,
            mcpAutoAcceptTools: autoAcceptToolsArray
          });
          new import_obsidian74.Notice("MCP tool settings saved");
          this.hasUnsavedChanges = false;
        } catch (error) {
          console.error("Failed to save MCP settings:", error);
          new import_obsidian74.Notice("Failed to save MCP settings");
        }
        this.close();
      }
      async onClose() {
        if (this.hasUnsavedChanges) {
          await this.saveChanges();
        }
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/services/TitleGenerationService.ts
var import_obsidian77, TitleGenerationService;
var init_TitleGenerationService = __esm({
  "src/services/TitleGenerationService.ts"() {
    init_SystemSculptService();
    init_types();
    import_obsidian77 = __toModule(require("obsidian"));
    init_titleUtils();
    init_modelUtils();
    init_errors();
    init_PopupModal();
    init_StandardModelSelectionModal();
    TitleGenerationService = class {
      constructor(plugin) {
        this.plugin = plugin;
        this.defaultModelId = null;
        this.sculptService = SystemSculptService.getInstance(plugin);
      }
      static getInstance(plugin) {
        if (!TitleGenerationService.instance) {
          TitleGenerationService.instance = new TitleGenerationService(plugin);
        }
        return TitleGenerationService.instance;
      }
      sanitizeTitle(title) {
        return sanitizeChatTitle(title);
      }
      isNoteContext(messages) {
        return messages instanceof import_obsidian77.TFile;
      }
      async getTitleGenerationPrompt(isNoteContext = false) {
        const { titleGenerationPromptType, titleGenerationPrompt, titleGenerationPromptPath } = this.plugin.settings;
        if (titleGenerationPrompt) {
          return this.adaptPromptToContext(titleGenerationPrompt, isNoteContext);
        }
        if (titleGenerationPromptType === "precise") {
          return this.adaptPromptToContext(DEFAULT_TITLE_GENERATION_PROMPT, isNoteContext);
        }
        if (titleGenerationPromptType === "movie-style") {
          const movieStylePrompt = `You are a creative title generation assistant focused on creating engaging, movie-style titles.

Your task is to analyze the provided ${isNoteContext ? "note" : "conversation"} and generate a single, attention-grabbing title that:
- Has a cinematic, dramatic quality similar to movie titles
- Uses creative, evocative language that captures the essence of the ${isNoteContext ? "note" : "conversation"}
- Is between 2-6 words long
- May use metaphors, wordplay, or allusions when appropriate
- Maintains proper capitalization (typically capitalize all major words)
- NEVER includes characters that are invalid in filenames: \\ / : * ? " < > |
- Uses proper spacing between all words

The title should be memorable and distinctive while still reflecting the actual content of the ${isNoteContext ? "note" : "conversation"}.
Respond with ONLY the title, nothing else.`;
          return movieStylePrompt;
        }
        if (titleGenerationPromptType === "custom" && titleGenerationPromptPath) {
          try {
            const file = this.plugin.app.vault.getAbstractFileByPath(titleGenerationPromptPath);
            if (file instanceof import_obsidian77.TFile) {
              const promptContent = await this.plugin.app.vault.read(file);
              return this.adaptPromptToContext(promptContent, isNoteContext);
            }
          } catch (error) {
            console.error("Error reading custom title generation prompt file:", error);
          }
        }
        return this.adaptPromptToContext(DEFAULT_TITLE_GENERATION_PROMPT, isNoteContext);
      }
      adaptPromptToContext(prompt, isNoteContext) {
        if (isNoteContext) {
          return prompt.replace(/conversation/gi, "note").replace(/chat/gi, "note").replace(/messages/gi, "content");
        }
        return prompt;
      }
      async generateTitle(messages, onProgress, onStatusUpdate, additionalContext, retryCount = 0) {
        let modelId = "";
        let providerId = "";
        try {
          modelId = this.plugin.settings.titleGenerationModelId;
          providerId = this.plugin.settings.titleGenerationProviderId;
          let usedFallback = false;
          if (!modelId || !providerId) {
            console.warn("[SystemSculpt] Title generation model or provider not explicitly set, using defaults.");
            if (this.plugin.settings.titleGenerationModelId) {
              const parsed = parseCanonicalId(this.plugin.settings.titleGenerationModelId);
              if (parsed) {
                modelId = parsed.modelId;
                providerId = parsed.providerId;
              }
            } else {
              const globalDefault = this.plugin.settings.selectedModelId;
              if (globalDefault) {
                const parsedGlobal = parseCanonicalId(globalDefault);
                if (parsedGlobal) {
                  modelId = parsedGlobal.modelId;
                  providerId = parsedGlobal.providerId;
                }
              }
            }
          }
          modelId = ensureCanonicalId(modelId);
          if (!modelId) {
            throw new Error("Failed to determine a valid model for title generation.");
          }
          let contentXml = "";
          if (messages instanceof import_obsidian77.TFile) {
            onStatusUpdate == null ? void 0 : onStatusUpdate(20, "Reading note content...");
            const content = await this.plugin.app.vault.read(messages);
            contentXml = `<content_to_generate_title_from>
<note_title>${messages.basename}</note_title>
<note_content>
${content}
</note_content>
${additionalContext ? `<user_provided_context>
${additionalContext}
</user_provided_context>` : ""}
</content_to_generate_title_from>`;
          } else {
            onStatusUpdate == null ? void 0 : onStatusUpdate(20, "Processing chat messages...");
            if (!messages.length) {
              throw new Error("No chat messages to generate a title from.");
            }
            const messagesToUse = messages.slice(0, 25);
            contentXml = `<content_to_generate_title_from>
${messagesToUse.map((msg) => {
              let contentStr = "";
              if (typeof msg.content === "string") {
                contentStr = msg.content;
              } else if (Array.isArray(msg.content)) {
                contentStr = msg.content.filter((part) => part.type === "text").map((part) => part.text).join("\n");
              }
              return `[${msg.role}]: ${contentStr}`;
            }).join("\n")}
${additionalContext ? `
<user_provided_context>
${additionalContext}
</user_provided_context>` : ""}
</content_to_generate_title_from>`;
          }
          onStatusUpdate == null ? void 0 : onStatusUpdate(40, "Analyzing content...");
          const isNoteContext = messages instanceof import_obsidian77.TFile;
          const systemPromptContent = await this.getTitleGenerationPrompt(isNoteContext);
          const promptMessages = [
            {
              role: "system",
              content: systemPromptContent,
              message_id: crypto.randomUUID()
            },
            {
              role: "user",
              content: contentXml,
              message_id: crypto.randomUUID()
            }
          ];
          let generatedTitle = "";
          const statusModelId = modelId.split("@@").pop() || modelId;
          onStatusUpdate == null ? void 0 : onStatusUpdate(60, `Generating title using ${statusModelId}${usedFallback ? " (fallback)" : ""}...`);
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error("Title generation timed out after 30 seconds")), 3e4);
          });
          const streamingPromise = (async () => {
            for await (const chunk of this.sculptService.streamMessage({
              messages: promptMessages,
              model: modelId,
              temperature: 0.7
            })) {
              if (chunk.content) {
                generatedTitle += chunk.content;
                if (onProgress) {
                  onProgress(generatedTitle.trim());
                }
              }
            }
            return generatedTitle;
          })();
          generatedTitle = await Promise.race([streamingPromise, timeoutPromise]);
          onStatusUpdate == null ? void 0 : onStatusUpdate(80, "Finalizing title...");
          const finalTitle = this.sanitizeTitle(generatedTitle.trim());
          if (!finalTitle) {
            console.warn("Title generation resulted in an empty title after sanitization.");
            return "Untitled Chat";
          }
          return finalTitle;
        } catch (error) {
          console.error("Error generating title:", error);
          if (error instanceof SystemSculptError && (error.code === ERROR_CODES.MODEL_UNAVAILABLE || error.code === ERROR_CODES.MODEL_REQUEST_ERROR)) {
            if (retryCount >= 2) {
              console.warn("[SystemSculpt] Max retries reached for title generation, falling back to default");
              new import_obsidian77.Notice("Unable to generate title after multiple attempts. Using default title.", 5e3);
              return this.isNoteContext(messages) ? "Untitled Note" : "Untitled Chat";
            }
            try {
              const parsedModel = parseCanonicalId(modelId);
              const modelDisplayName = (parsedModel == null ? void 0 : parsedModel.modelId) || modelId;
              const errorMessage = `The model "${modelDisplayName}" is not available for title generation. This could be because the model is not found, the provider is unavailable, or the model requires different configuration.`;
              const wantToSelectModel = await showPopup(this.plugin.app, errorMessage + "\n\nWould you like to select a different model for title generation?", {
                title: "Title Generation Failed",
                primaryButton: "Select Model",
                secondaryButton: "Cancel",
                icon: "alert-circle"
              });
              if (wantToSelectModel == null ? void 0 : wantToSelectModel.confirmed) {
                const modelSelectionResult = await new Promise((resolve) => {
                  const modelSelectionModal = new StandardModelSelectionModal({
                    app: this.plugin.app,
                    plugin: this.plugin,
                    currentModelId: this.plugin.settings.titleGenerationModelId,
                    onSelect: async (result) => {
                      if (result && result.modelId) {
                        const parsed = parseCanonicalId(result.modelId);
                        if (parsed) {
                          await this.plugin.getSettingsManager().updateSettings({
                            titleGenerationProviderId: parsed.providerId,
                            titleGenerationModelId: result.modelId
                          });
                          new import_obsidian77.Notice(`Title generation model set to: ${parsed.providerId} / ${parsed.modelId}`);
                        }
                        resolve(result);
                      } else {
                        resolve(null);
                      }
                    }
                  });
                  modelSelectionModal.open();
                });
                if (modelSelectionResult && modelSelectionResult.modelId) {
                  console.log("[SystemSculpt] User selected new title generation model:", modelSelectionResult.modelId);
                  return await this.generateTitle(messages, onProgress, onStatusUpdate, additionalContext, retryCount + 1);
                } else {
                  new import_obsidian77.Notice("Title generation cancelled. Using default title.", 3e3);
                  return this.isNoteContext(messages) ? "Untitled Note" : "Untitled Chat";
                }
              } else {
                new import_obsidian77.Notice("Title generation cancelled. Using default title.", 3e3);
                return this.isNoteContext(messages) ? "Untitled Note" : "Untitled Chat";
              }
            } catch (modalError) {
              console.error("[SystemSculpt] Error showing title generation error modal:", modalError);
              new import_obsidian77.Notice(`Title generation failed: ${error.message}`, 5e3);
              throw error;
            }
          } else {
            const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
            new import_obsidian77.Notice(`Title generation failed: ${errorMessage}`, 5e3);
            throw error;
          }
        }
      }
    };
  }
});

// src/modals/DefaultChatPresetsModal.ts
var DefaultChatPresetsModal_exports = {};
__export(DefaultChatPresetsModal_exports, {
  DefaultChatPresetsModal: () => DefaultChatPresetsModal
});
var import_obsidian78, CustomPromptFileSuggestModal, DefaultChatPresetsModal;
var init_DefaultChatPresetsModal = __esm({
  "src/modals/DefaultChatPresetsModal.ts"() {
    import_obsidian78 = __toModule(require("obsidian"));
    init_modelUtils();
    init_StandardModelSelectionModal();
    init_SystemPromptService();
    CustomPromptFileSuggestModal = class extends import_obsidian78.SuggestModal {
      constructor(app, systemPromptService, onSelect) {
        super(app);
        this.systemPromptService = systemPromptService;
        this.onSelectCallback = onSelect;
        this.setPlaceholder("Select a custom system prompt file...");
      }
      async getSuggestions(query) {
        const files = await this.systemPromptService.getCustomPromptFiles();
        if (!query) {
          return files;
        }
        return files.filter((file) => file.name.toLowerCase().includes(query.toLowerCase()));
      }
      renderSuggestion(file, el) {
        el.createEl("div", { text: file.name });
        el.createEl("small", { text: file.path, cls: "ss-suggestion-path" });
      }
      onChooseSuggestion(file, evt) {
        this.onSelectCallback(file);
      }
    };
    DefaultChatPresetsModal = class extends import_obsidian78.Modal {
      constructor(app, plugin) {
        super(app);
        this.promptTypeBtns = {};
        this.plugin = plugin;
        this.systemPromptService = SystemPromptService.getInstance(this.app, () => this.plugin.settings);
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Default Chat Presets" });
        contentEl.createEl("p", {
          text: "Set your default AI model and system prompt type for new chats. These presets will be used every time you start a new, fresh chat."
        });
        const modelSection = contentEl.createDiv("modal-section");
        modelSection.createEl("h3", { text: "Default AI Model" });
        new import_obsidian78.Setting(modelSection).setName("AI Model").setDesc("Select the default model for new chats").addText((text) => {
          text.setPlaceholder("Model").setValue(this.plugin.settings.selectedModelId ? getDisplayName(this.plugin.settings.selectedModelId) : "No model selected").setDisabled(true);
        }).addButton((button) => {
          button.setButtonText("Change Model").setCta().onClick(() => this.openModelSelectModal());
        });
        const titleGenModelSection = contentEl.createDiv("modal-section");
        titleGenModelSection.createEl("h3", { text: "Default Title Generation Model" });
        new import_obsidian78.Setting(titleGenModelSection).setName("Title Generation Model").setDesc("Select the default model for generating chat titles").addText((text) => {
          text.setPlaceholder("Model").setValue(this.plugin.settings.titleGenerationModelId ? getDisplayName(this.plugin.settings.titleGenerationModelId) : "Same as chat model").setDisabled(true);
        }).addButton((button) => {
          button.setButtonText("Change Model").setCta().onClick(() => this.openTitleGenModelSelectModal());
        });
        const promptSection = contentEl.createDiv("modal-section");
        promptSection.createEl("h3", { text: "Default System Prompt Type" });
        this.defaultInfoEl = promptSection.createEl("div", {
          cls: "setting-item-description"
        });
        await this.updateDefaultInfo();
        const promptSetting = new import_obsidian78.Setting(promptSection).setName("System Prompt").setDesc("Choose the default system prompt type for new chats");
        const buttonContainer = promptSetting.controlEl.createDiv({ cls: "ss-modal-button-container--grid" });
        ["general-use", "concise", "custom"].forEach((type) => {
          const displayText = type === "general-use" ? "General Use" : type.charAt(0).toUpperCase() + type.slice(1);
          const button = buttonContainer.createEl("button", {
            text: displayText,
            cls: this.plugin.settings.systemPromptType === type ? "mod-cta" : ""
          });
          this.promptTypeBtns[type] = button;
          button.onclick = async () => {
            if (type !== "custom") {
              await this.plugin.getSettingsManager().updateSettings({
                systemPromptType: type,
                systemPromptPath: ""
              });
              await this.saveAndNotify(displayText);
            } else {
              await this.plugin.getSettingsManager().updateSettings({
                systemPromptType: type
              });
              this.updateButtonStyles();
              this.openCustomPromptPicker();
            }
          };
        });
        this.customPromptInfo = promptSection.createDiv("custom-prompt-info ss-modal-custom-prompt-info");
        this.updateCustomPromptInfo();
      }
      async saveAndNotify(promptName) {
        var _a, _b;
        await this.plugin.getSettingsManager().saveSettings();
        (_b = (_a = this.plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
        new import_obsidian78.Notice(`Default system prompt set to ${promptName}`, 2e3);
        this.updateButtonStyles();
        this.updateCustomPromptInfo();
        await this.updateDefaultInfo();
      }
      async updateDefaultInfo() {
        const type = this.plugin.settings.systemPromptType;
        let displayText = "";
        if (type === "agent") {
          console.warn(`Agent Mode cannot be used as a default system prompt. Agent Mode is now per-chat only. Falling back to General Use.`);
          await this.plugin.getSettingsManager().updateSettings({
            systemPromptType: "general-use",
            systemPromptPath: ""
          });
          displayText = "General Use (auto-switched from Agent Mode - now per-chat only)";
        } else if (type === "general-use") {
          displayText = "General Use";
        } else if (type === "concise") {
          displayText = "Concise";
        } else if (type === "custom") {
          if (this.plugin.settings.systemPromptPath) {
            const file = this.app.vault.getAbstractFileByPath(this.plugin.settings.systemPromptPath);
            if (!file) {
              console.warn(`Custom system prompt file not found: ${this.plugin.settings.systemPromptPath}. Falling back to General Use.`);
              await this.plugin.getSettingsManager().updateSettings({
                systemPromptType: "general-use",
                systemPromptPath: ""
              });
              displayText = "General Use (auto-switched from missing custom file)";
            } else {
              const pathParts = this.plugin.settings.systemPromptPath.split("/");
              const fileName = pathParts[pathParts.length - 1];
              displayText = `Custom: ${fileName}`;
            }
          } else {
            displayText = "Custom (no file selected)";
          }
        } else {
          const validDefaultTypes = ["general-use", "concise", "custom"];
          if (!validDefaultTypes.includes(type)) {
            console.warn(`Invalid system prompt type: ${type}. Falling back to General Use.`);
            await this.plugin.getSettingsManager().updateSettings({
              systemPromptType: "general-use",
              systemPromptPath: ""
            });
            displayText = "General Use (auto-switched from invalid type)";
          } else {
            displayText = "General Use";
          }
        }
        this.defaultInfoEl.setText(`Current default for new chats: ${displayText}`);
      }
      updateButtonStyles() {
        Object.values(this.promptTypeBtns).forEach((btn) => {
          btn.removeClass("mod-cta");
          btn.removeClass("mod-primary");
        });
        const currentType = this.plugin.settings.systemPromptType;
        if (this.promptTypeBtns[currentType]) {
          this.promptTypeBtns[currentType].addClass("mod-cta");
        }
      }
      updateCustomPromptInfo() {
        this.customPromptInfo.empty();
        if (this.plugin.settings.systemPromptType === "custom") {
          this.customPromptInfo.addClass("ss-modal-custom-prompt-info--visible");
          if (this.plugin.settings.systemPromptPath) {
            const pathParts = this.plugin.settings.systemPromptPath.split("/");
            const fileName = pathParts[pathParts.length - 1];
            this.customPromptInfo.createEl("div", {
              text: `Selected custom prompt: ${fileName}`,
              cls: "setting-item-description"
            });
            const changeBtn = this.customPromptInfo.createEl("button", {
              text: "Change Custom Prompt",
              cls: "mod-warning ss-modal-button--small"
            });
            changeBtn.onclick = () => this.openCustomPromptPicker();
          } else {
            this.customPromptInfo.createEl("div", {
              text: "No custom prompt selected. Please choose one.",
              cls: "setting-item-description mod-warning"
            });
            const selectBtn = this.customPromptInfo.createEl("button", {
              text: "Select Custom Prompt",
              cls: "mod-cta ss-modal-button--small"
            });
            selectBtn.onclick = () => this.openCustomPromptPicker();
          }
        } else {
          this.customPromptInfo.removeClass("ss-modal-custom-prompt-info--visible");
        }
      }
      openCustomPromptPicker() {
        new CustomPromptFileSuggestModal(this.app, this.systemPromptService, async (file) => {
          await this.plugin.getSettingsManager().updateSettings({
            systemPromptPath: file.path
          });
          await this.saveAndNotify(`Custom: ${file.name}`);
        }).open();
      }
      openModelSelectModal() {
        const modal = new StandardModelSelectionModal({
          app: this.app,
          plugin: this.plugin,
          currentModelId: this.plugin.settings.selectedModelId || "",
          onSelect: async (result) => {
            var _a, _b;
            try {
              const canonicalId = ensureCanonicalId(result.modelId);
              await this.plugin.getSettingsManager().updateSettings({
                selectedModelId: canonicalId
              });
              (_b = (_a = this.plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
              new import_obsidian78.Notice("Default model updated successfully.", 3e3);
              const input = this.contentEl.querySelector("input[type='text']");
              if (input) {
                input.value = getDisplayName(canonicalId);
              }
            } catch (error) {
              console.error("Error updating default model:", error);
              new import_obsidian78.Notice("Failed to update default model", 1e4);
            }
          }
        });
        modal.open();
      }
      openTitleGenModelSelectModal() {
        const modal = new StandardModelSelectionModal({
          app: this.app,
          plugin: this.plugin,
          currentModelId: this.plugin.settings.titleGenerationModelId || this.plugin.settings.selectedModelId || "",
          onSelect: async (result) => {
            var _a, _b;
            try {
              const canonicalId = ensureCanonicalId(result.modelId);
              await this.plugin.getSettingsManager().updateSettings({
                titleGenerationModelId: canonicalId
              });
              (_b = (_a = this.plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
              new import_obsidian78.Notice("Title generation model updated successfully.", 3e3);
              const titleGenModelInput = this.contentEl.querySelectorAll("input[type='text']")[1];
              if (titleGenModelInput) {
                titleGenModelInput.value = getDisplayName(canonicalId);
              }
            } catch (error) {
              console.error("Error updating title generation model:", error);
              new import_obsidian78.Notice("Failed to update title generation model", 1e4);
            }
          }
        });
        modal.open();
      }
    };
  }
});

// src/modals/TitleGenerationModal.ts
var TitleGenerationModal_exports = {};
__export(TitleGenerationModal_exports, {
  TitleGenerationModal: () => TitleGenerationModal,
  TitleGenerationNotice: () => TitleGenerationNotice,
  showTitleGenerationModal: () => showTitleGenerationModal
});
async function showTitleGenerationModal(app, plugin, initialValue, content) {
  const modal = new TitleGenerationModal(app, plugin, initialValue, content);
  return await modal.openAndGetTitle();
}
var import_obsidian91, import_obsidian92, TitleGenerationNotice, TitleGenerationModal;
var init_TitleGenerationModal = __esm({
  "src/modals/TitleGenerationModal.ts"() {
    import_obsidian91 = __toModule(require("obsidian"));
    init_TitleGenerationService();
    import_obsidian92 = __toModule(require("obsidian"));
    TitleGenerationNotice = class {
      constructor() {
        this.autoCloseTimer = null;
        this.countdownEl = null;
        this.countdownInterval = null;
        this.countdownSeconds = 5;
        this.noticeEl = document.createElement("div");
        this.noticeEl.addClass("systemsculpt-title-notice");
        const header = this.noticeEl.createDiv({ cls: "systemsculpt-title-notice-header" });
        const title = header.createDiv({ text: "Generating Title", cls: "systemsculpt-title-notice-title" });
        this.closeButton = header.createDiv({ cls: "systemsculpt-title-notice-close" });
        this.closeButton.addEventListener("click", () => {
          this.hide();
        });
        (0, import_obsidian92.setIcon)(this.closeButton, "x");
        const progressContainer = this.noticeEl.createDiv();
        this.textEl = progressContainer.createDiv({ cls: "systemsculpt-title-notice-progress-text" });
        this.textEl.textContent = "Analyzing content...";
        const progressBarBg = progressContainer.createDiv({ cls: "systemsculpt-title-notice-progress-bg" });
        this.progressEl = progressBarBg.createDiv({ cls: "systemsculpt-title-notice-progress-bar" });
        this.countdownEl = this.noticeEl.createDiv({ cls: "systemsculpt-title-notice-countdown" });
        document.body.appendChild(this.noticeEl);
        setTimeout(() => {
          this.noticeEl.addClass("systemsculpt-title-notice--visible");
        }, 10);
      }
      updateProgress(progress, text) {
        this.progressEl.style.setProperty("width", `${progress}%`);
        if (text) {
          this.textEl.textContent = text;
        }
      }
      showCompletion(message = "Title generated successfully!") {
        this.progressEl.style.setProperty("width", "100%");
        this.textEl.textContent = message;
        if (this.countdownEl) {
          this.countdownEl.addClass("systemsculpt-title-notice-countdown--visible");
          this.countdownEl.textContent = `Closing in ${this.countdownSeconds} seconds...`;
          this.countdownInterval = window.setInterval(() => {
            this.countdownSeconds--;
            if (this.countdownEl) {
              this.countdownEl.textContent = `Closing in ${this.countdownSeconds} seconds...`;
            }
            if (this.countdownSeconds <= 0) {
              this.hide();
            }
          }, 1e3);
        }
        this.autoCloseTimer = window.setTimeout(() => {
          this.hide();
        }, this.countdownSeconds * 1e3);
      }
      showError(errorMessage) {
        this.progressEl.style.setProperty("width", "100%");
        this.progressEl.addClass("systemsculpt-title-notice-progress-bar--error");
        this.textEl.textContent = errorMessage;
        this.autoCloseTimer = window.setTimeout(() => {
          this.hide();
        }, 5e3);
      }
      hide() {
        if (this.autoCloseTimer) {
          clearTimeout(this.autoCloseTimer);
          this.autoCloseTimer = null;
        }
        if (this.countdownInterval) {
          clearInterval(this.countdownInterval);
          this.countdownInterval = null;
        }
        this.noticeEl.removeClass("systemsculpt-title-notice--visible");
        setTimeout(() => {
          this.noticeEl.remove();
        }, 300);
      }
    };
    TitleGenerationModal = class extends import_obsidian91.Modal {
      constructor(app, plugin, initialValue, content) {
        super(app);
        this.plugin = plugin;
        this.initialValue = initialValue;
        this.content = content;
        this.result = null;
        this.resolvePromise = null;
        this.isGenerating = false;
        this.progressAnimation = null;
        this.titleGenerationService = TitleGenerationService.getInstance(plugin);
        this.isNoteContext = this.content instanceof import_obsidian91.TFile;
      }
      onOpen() {
        const { contentEl, modalEl } = this;
        modalEl.addClass("systemsculpt-title-modal");
        const headerEl = contentEl.createDiv({ cls: "systemsculpt-title-modal-header" });
        const titleEl = headerEl.createEl("h2", {
          text: this.isNoteContext ? "Note Title" : "Chat Title",
          cls: "systemsculpt-title-modal-title"
        });
        contentEl.createEl("p", {
          text: this.isNoteContext ? "Enter a title manually or generate one based on your note content." : "Enter a title manually or generate one based on your chat content.",
          cls: "systemsculpt-title-modal-description"
        });
        const contextContainer = contentEl.createDiv({ cls: "systemsculpt-title-modal-context-container" });
        const contextLabelContainer = contextContainer.createDiv({ cls: "systemsculpt-title-modal-context-label-container" });
        const contextLabel = contextLabelContainer.createEl("label", {
          text: "What is this note about?",
          cls: "systemsculpt-title-modal-context-label"
        });
        const infoIcon = contextLabelContainer.createEl("span", {
          cls: "systemsculpt-title-modal-info-icon"
        });
        (0, import_obsidian92.setIcon)(infoIcon, "help-circle");
        infoIcon.setAttribute("aria-label", "This helps the AI understand your content better and generate more accurate titles");
        infoIcon.setAttribute("data-tooltip-position", "top");
        infoIcon.setAttribute("data-tooltip-delay", "300");
        this.contextInput = contextContainer.createEl("textarea", {
          placeholder: "Briefly describe the main topic or purpose of this " + (this.isNoteContext ? "note" : "chat") + "...",
          cls: "systemsculpt-title-modal-context-input"
        });
        this.contextInput.rows = 3;
        const inputContainer = contentEl.createDiv({ cls: "systemsculpt-title-modal-input-container" });
        inputContainer.createEl("label", {
          text: "Title",
          cls: "systemsculpt-title-modal-input-label"
        });
        this.titleInput = inputContainer.createEl("input", {
          type: "text",
          placeholder: "Enter title...",
          value: this.initialValue,
          cls: "systemsculpt-title-modal-input"
        });
        this.progressContainer = contentEl.createDiv({ cls: "systemsculpt-title-modal-progress" });
        this.progressText = this.progressContainer.createDiv({
          text: "Generating title...",
          cls: "systemsculpt-title-modal-progress-text"
        });
        const progressBarContainer = this.progressContainer.createDiv({
          cls: "systemsculpt-title-modal-progress-bar-container"
        });
        this.progressBar = progressBarContainer.createDiv({
          cls: "systemsculpt-title-modal-progress-bar"
        });
        const buttonsContainer = contentEl.createDiv({ cls: "systemsculpt-title-modal-buttons" });
        const cancelButton = buttonsContainer.createEl("button", {
          text: "Cancel",
          cls: "systemsculpt-title-modal-button systemsculpt-title-modal-button-secondary"
        });
        cancelButton.addEventListener("click", () => {
          this.cancel();
        });
        this.generateButton = buttonsContainer.createEl("button", {
          text: "Generate Title",
          cls: "systemsculpt-title-modal-button systemsculpt-title-modal-button-secondary"
        });
        const shortcutHint = this.generateButton.createSpan({
          text: import_obsidian91.Platform.isMacOS ? " (\u2318+G)" : " (Ctrl+G)",
          cls: "systemsculpt-title-modal-shortcut"
        });
        this.generateButton.addEventListener("click", () => {
          if (!this.isGenerating) {
            this.generateTitle();
          }
        });
        const saveButton = buttonsContainer.createEl("button", {
          text: "Save",
          cls: "systemsculpt-title-modal-button systemsculpt-title-modal-button-primary"
        });
        saveButton.addEventListener("click", () => {
          this.save();
        });
        this.registerDocumentKeydown();
        setTimeout(() => {
          this.contextInput.focus();
        }, 10);
        this.initializeStyles();
      }
      initializeStyles() {
        const { modalEl } = this;
        modalEl.addClass("systemsculpt-title-modal");
      }
      registerDocumentKeydown() {
        this.scope.register([], "Enter", (evt) => {
          if (!evt.isComposing && !evt.shiftKey && !evt.altKey && !evt.ctrlKey && !evt.metaKey) {
            evt.preventDefault();
            this.save();
            return false;
          }
          return true;
        });
        this.scope.register([], "Escape", (evt) => {
          evt.preventDefault();
          this.cancel();
          return false;
        });
        this.scope.register([import_obsidian91.Platform.isMacOS ? "Meta" : "Ctrl"], "g", (evt) => {
          evt.preventDefault();
          if (!this.isGenerating) {
            this.generateTitle();
          }
          return false;
        });
      }
      updateGenerateButton() {
        if (!this.generateButton)
          return;
        if (this.isGenerating) {
          this.generateButton.textContent = "Generating...";
          this.generateButton.setAttribute("disabled", "true");
        } else {
          this.generateButton.textContent = "Generate Title";
          this.generateButton.removeAttribute("disabled");
          const shortcutHint = document.createElement("span");
          shortcutHint.textContent = import_obsidian91.Platform.isMacOS ? " (\u2318+G)" : " (Ctrl+G)";
          shortcutHint.className = "systemsculpt-title-modal-shortcut";
          const existingHints = this.generateButton.querySelectorAll(".systemsculpt-title-modal-shortcut");
          existingHints.forEach((hint) => hint.remove());
          this.generateButton.appendChild(shortcutHint);
        }
      }
      startProgressAnimation() {
        this.progressContainer.addClass("systemsculpt-title-modal-progress--visible");
        let width = 0;
        const frame = () => {
          if (width >= 90) {
            return;
          }
          width += (90 - width) / 100;
          this.progressBar.style.setProperty("width", `${width}%`);
          this.progressAnimation = requestAnimationFrame(frame);
        };
        this.progressAnimation = requestAnimationFrame(frame);
      }
      stopProgressAnimation() {
        if (this.progressAnimation) {
          cancelAnimationFrame(this.progressAnimation);
          this.progressAnimation = null;
        }
      }
      sanitizeTitle(title) {
        const trimmedTitle = title.trim();
        if (trimmedTitle)
          return trimmedTitle;
        return this.isNoteContext ? "Untitled Note" : "Untitled Chat";
      }
      async generateTitle() {
        if (Array.isArray(this.content) && this.content.length === 0) {
          new import_obsidian91.Notice("No chat messages to generate a title from.");
          return;
        }
        this.isGenerating = true;
        this.updateGenerateButton();
        this.startProgressAnimation();
        try {
          const additionalContext = this.contextInput.value.trim();
          await this.titleGenerationService.generateTitle(this.content, (title) => {
            this.titleInput.value = title;
          }, (progress, status) => {
            if (progress > 0) {
              this.progressBar.style.setProperty("width", `${progress}%`);
              this.progressText.textContent = status || "Generating title...";
            }
          }, additionalContext || void 0);
          this.progressBar.style.setProperty("width", "100%");
          this.progressText.textContent = "Title generated!";
          setTimeout(() => {
            this.progressContainer.style.setProperty("opacity", "0");
            setTimeout(() => {
              this.progressContainer.removeClass("systemsculpt-title-modal-progress--visible");
              this.progressContainer.style.removeProperty("opacity");
            }, 300);
          }, 1500);
          this.titleInput.focus();
          this.titleInput.select();
        } catch (error) {
          console.error("Error generating title:", error);
          this.progressBar.style.setProperty("width", "100%");
          this.progressBar.addClass("systemsculpt-title-modal-progress-bar--error");
          this.progressText.textContent = "Failed to generate title";
          new import_obsidian91.Notice("Failed to generate title", 5e3);
        } finally {
          this.isGenerating = false;
          this.updateGenerateButton();
          this.stopProgressAnimation();
        }
      }
      save() {
        this.result = this.sanitizeTitle(this.titleInput.value);
        this.close();
      }
      cancel() {
        this.result = null;
        this.close();
      }
      onClose() {
        this.stopProgressAnimation();
        if (this.resolvePromise) {
          this.resolvePromise(this.result);
          this.resolvePromise = null;
        }
      }
      async openAndGetTitle() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
          this.open();
        });
      }
    };
  }
});

// src/modals/ImproveResponseModal.ts
var import_obsidian95, ImproveResponseModal;
var init_ImproveResponseModal = __esm({
  "src/modals/ImproveResponseModal.ts"() {
    import_obsidian95 = __toModule(require("obsidian"));
    ImproveResponseModal = class extends import_obsidian95.Modal {
      constructor(app, promptText, defaultValue, onSubmit) {
        super(app);
        this.promptText = promptText;
        this.defaultValue = defaultValue;
        this.onSubmit = onSubmit;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Improve Response" });
        contentEl.createEl("p", { text: this.promptText });
        const presetContainer = contentEl.createDiv();
        presetContainer.style.display = "flex";
        presetContainer.style.flexWrap = "wrap";
        presetContainer.style.gap = "8px";
        presetContainer.style.marginTop = "8px";
        const presets = ["Shorter", "Longer", "Simpler", "More professional", "More creative"];
        presets.forEach((preset) => {
          const btn = presetContainer.createEl("button", { text: preset });
          btn.onclick = () => {
            this.inputEl.value = preset;
            this.inputEl.focus();
          };
        });
        this.inputEl = contentEl.createEl("input", {
          type: "text",
          placeholder: "E.g., shorter, longer, simpler, professional, creative, or custom instruction",
          value: this.defaultValue
        });
        this.inputEl.style.width = "100%";
        this.inputEl.style.marginTop = "10px";
        this.inputEl.style.marginBottom = "20px";
        const buttonContainer = contentEl.createDiv();
        buttonContainer.style.display = "flex";
        buttonContainer.style.justifyContent = "flex-end";
        buttonContainer.style.gap = "10px";
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.addClass("mod-muted");
        cancelButton.style.flex = "0 0 auto";
        cancelButton.onclick = () => {
          this.close();
        };
        const confirmButton = buttonContainer.createEl("button", { text: "Improve" });
        confirmButton.addClass("mod-cta");
        confirmButton.style.flex = "0 0 auto";
        confirmButton.onclick = () => {
          const value = this.inputEl.value.trim();
          if (!value) {
            this.inputEl.focus();
            return;
          }
          this.onSubmit(value);
          this.close();
        };
        this.inputEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && !e.isComposing) {
            confirmButton.click();
          }
        });
        this._globalKeyHandler = (e) => {
          if (e.metaKey && e.key === "Enter") {
            e.preventDefault();
            confirmButton.click();
          }
        };
        document.addEventListener("keydown", this._globalKeyHandler);
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
        if (this._globalKeyHandler) {
          document.removeEventListener("keydown", this._globalKeyHandler);
        }
      }
    };
  }
});

// src/modals/SaveAsNoteModal.ts
var import_obsidian96, SaveAsNoteModal;
var init_SaveAsNoteModal = __esm({
  "src/modals/SaveAsNoteModal.ts"() {
    import_obsidian96 = __toModule(require("obsidian"));
    init_FolderSuggester();
    SaveAsNoteModal = class extends import_obsidian96.Modal {
      constructor(app, plugin, defaultFolder, defaultFileName, content, onSaveSuccess) {
        super(app);
        this.plugin = plugin;
        this.defaultFolder = defaultFolder;
        this.defaultFileName = defaultFileName;
        this.content = content;
        this.onSaveSuccess = onSaveSuccess;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Save as Note" });
        contentEl.createEl("p", { text: "Choose a location and name for your note" });
        const folderLabel = contentEl.createEl("label", { text: "Folder" });
        folderLabel.style.marginBottom = "12px";
        this.folderInput = contentEl.createEl("input", {
          type: "text",
          value: this.defaultFolder,
          placeholder: "Folder path"
        });
        this.folderInput.style.width = "100%";
        this.folderInput.style.marginBottom = "12px";
        attachFolderSuggester(this.folderInput, (folder) => {
          this.folderInput.value = folder;
        }, this.app);
        const fileNameLabel = contentEl.createEl("label", { text: "File name" });
        this.fileNameInput = contentEl.createEl("input", {
          type: "text",
          value: this.defaultFileName,
          placeholder: "File name (without extension)"
        });
        this.fileNameInput.style.width = "100%";
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
        buttonContainer.style.display = "flex";
        buttonContainer.style.justifyContent = "flex-end";
        buttonContainer.style.gap = "10px";
        buttonContainer.style.marginTop = "20px";
        this.cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        this.saveButton = buttonContainer.createEl("button", { text: "Save" });
        this.saveButton.addClass("mod-cta");
        this.cancelButton.addEventListener("click", () => this.close());
        this.saveButton.addEventListener("click", () => this.handleSave());
      }
      async handleSave() {
        const folderPath = this.folderInput.value.trim();
        const fileName = this.fileNameInput.value.trim();
        if (!folderPath) {
          new import_obsidian96.Notice("Please enter a folder path.");
          return;
        }
        if (!fileName) {
          new import_obsidian96.Notice("Please enter a file name.");
          return;
        }
        const sanitizedFileName = fileName.replace(/[/\\?%*:|"<>]/g, "").trim();
        if (!sanitizedFileName) {
          new import_obsidian96.Notice("Invalid file name.");
          return;
        }
        const fullPath = `${folderPath}/${sanitizedFileName}.md`;
        try {
          if (this.plugin.directoryManager) {
            await this.plugin.directoryManager.ensureDirectoryByPath(folderPath);
          } else {
            await this.plugin.app.vault.createFolder(folderPath).catch(() => {
            });
          }
          const existingFile = this.plugin.app.vault.getAbstractFileByPath(fullPath);
          if (existingFile instanceof import_obsidian96.TFile) {
            new import_obsidian96.Notice("File already exists. Please choose a different name.");
            return;
          }
          await this.plugin.app.vault.create(fullPath, this.content);
          new import_obsidian96.Notice(`Note saved to "${fullPath}"`);
          const file = this.plugin.app.vault.getAbstractFileByPath(fullPath);
          if (file) {
            await this.plugin.app.workspace.openLinkText(file.path, "", true);
          }
          if (this.onSaveSuccess) {
            this.onSaveSuccess(fullPath);
          }
          await this.plugin.updateLastSaveAsNoteFolder(folderPath);
          this.close();
        } catch (error) {
          console.error("[SystemSculpt] Error saving note:", error);
          new import_obsidian96.Notice("Failed to save note. Please try again.");
        }
      }
    };
  }
});

// src/modals/StandardAIResponseModal.ts
async function showAIResponseModal(app, options) {
  const modal = new StandardAIResponseModal(app, options);
  modal.open();
}
var import_obsidian97, StandardAIResponseModal;
var init_StandardAIResponseModal = __esm({
  "src/modals/StandardAIResponseModal.ts"() {
    import_obsidian97 = __toModule(require("obsidian"));
    init_ImproveResponseModal();
    init_StandardModal();
    init_SaveAsNoteModal();
    StandardAIResponseModal = class extends StandardModal {
      constructor(app, options) {
        super(app);
        this.fullResponse = "";
        this.isGenerating = false;
        this.setSize("large");
        this.plugin = options.plugin;
        this.modelId = options.modelId;
        this.messages = options.messages;
        this.onInsert = options.onInsert || (() => {
        });
        this.commandText = options.commandText;
        this.parentModal = options.parentModal;
      }
      onOpen() {
        super.onOpen();
        this.addTitle("AI Response");
        this.responseContainer = this.contentEl.createDiv("ss-modal__response-container");
        this.responseContainer.style.padding = "20px";
        this.responseContainer.style.backgroundColor = "var(--background-secondary)";
        this.responseContainer.style.borderRadius = "8px";
        this.responseContainer.style.whiteSpace = "pre-wrap";
        this.responseContainer.style.maxHeight = "60vh";
        this.responseContainer.style.minHeight = "250px";
        this.responseContainer.style.overflow = "auto";
        this.responseContainer.style.marginBottom = "20px";
        this.responseContainer.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.1)";
        this.responseContainer.style.display = "flex";
        this.responseContainer.style.flexDirection = "column";
        this.responseContainer.style.justifyContent = "center";
        this.responseContainer.style.fontSize = "15px";
        this.responseContainer.style.lineHeight = "1.5";
        this.buttonContainer = this.footerEl.createDiv("ss-button-container");
        this.buttonContainer.style.display = "flex";
        this.buttonContainer.style.flexWrap = "wrap";
        this.buttonContainer.style.gap = "10px";
        this.buttonContainer.style.justifyContent = "center";
        this.buttonContainer.style.alignItems = "center";
        this.buttonContainer.style.marginTop = "12px";
        if (!document.getElementById("ss-airesponse-redesign-styles")) {
          const styleEl = document.createElement("style");
          styleEl.id = "ss-airesponse-redesign-styles";
          styleEl.textContent = `
        .ss-button {
          min-width: 120px;
          max-width: 200px;
          flex: 1 1 auto;
        }
      `;
          document.head.appendChild(styleEl);
        }
        this.generateResponse();
      }
      createLoadingIndicator() {
        if (this.loadingEl) {
          this.loadingEl.remove();
        }
        this.loadingEl = this.responseContainer.createDiv("ss-modal__loading");
        this.loadingEl.style.display = "flex";
        this.loadingEl.style.alignItems = "center";
        this.loadingEl.style.justifyContent = "center";
        this.loadingEl.style.height = "100%";
        this.loadingEl.style.width = "100%";
        this.loadingEl.style.minHeight = "200px";
        this.loadingEl.style.boxSizing = "border-box";
        const loadingTextEl = this.loadingEl.createDiv("ss-modal__loading-text");
        loadingTextEl.setText("Processing with AI...");
        loadingTextEl.style.fontWeight = "600";
        loadingTextEl.style.color = "var(--text-accent)";
        loadingTextEl.style.fontSize = "20px";
        loadingTextEl.style.letterSpacing = "0.5px";
        loadingTextEl.style.textAlign = "center";
        if (!document.getElementById("systemsculpt-pulse-keyframes")) {
          const styleEl = document.createElement("style");
          styleEl.id = "systemsculpt-pulse-keyframes";
          styleEl.textContent = `
        @keyframes pulse {
          0% { opacity: 0.4; }
          50% { opacity: 1; }
          100% { opacity: 0.4; }
        }
        .ss-modal__loading-text {
          animation: pulse 2.5s infinite ease-in-out;
        }
      `;
          document.head.appendChild(styleEl);
        }
      }
      async generateResponse() {
        if (this.isGenerating)
          return;
        this.isGenerating = true;
        try {
          this.responseContainer.empty();
          this.buttonContainer.empty();
          this.fullResponse = "";
          this.createLoadingIndicator();
          try {
            const streamGenerator = this.plugin.aiService.streamMessage({
              messages: this.messages,
              model: this.modelId,
              temperature: 0.7
            });
            for await (const chunk of streamGenerator) {
              if (chunk.content) {
                if (this.loadingEl && this.fullResponse === "") {
                  this.loadingEl.remove();
                  this.loadingEl = void 0;
                  this.responseContainer.style.display = "block";
                  this.responseContainer.style.justifyContent = "initial";
                }
                this.fullResponse += chunk.content;
                this.responseContainer.setText(this.fullResponse);
                this.responseContainer.scrollTop = this.responseContainer.scrollHeight;
              }
            }
            this.createButtons();
          } catch (error) {
            if (this.loadingEl) {
              this.loadingEl.remove();
              this.responseContainer.style.display = "block";
              this.responseContainer.style.justifyContent = "initial";
            }
            this.responseContainer.setText(`Error: ${error.message || "Failed to get response from AI"}`);
            console.error("[SystemSculpt] Error streaming response:", error);
            this.createButtons();
          }
        } catch (error) {
          console.error("[SystemSculpt] Error processing with AI:", error);
          new import_obsidian97.Notice("Failed to process with AI. Please try again.");
        } finally {
          this.isGenerating = false;
        }
      }
      closeAllModals() {
        if (this.commandText) {
          const activeView2 = this.app.workspace.getActiveViewOfType(import_obsidian97.MarkdownView);
          if (activeView2) {
            const editor = activeView2.editor;
            const content = editor.getValue();
            const commandIndex = content.indexOf(this.commandText);
            if (commandIndex >= 0) {
              const startPos = editor.offsetToPos(commandIndex);
              const endPos = editor.offsetToPos(commandIndex + this.commandText.length);
              editor.replaceRange("", startPos, endPos);
            }
          }
        }
        this.close();
        if (this.parentModal) {
          this.parentModal.close();
        }
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian97.MarkdownView);
        if (activeView) {
          activeView.editor.focus();
        }
      }
      createButtons() {
        this.buttonContainer.empty();
        const createButtonWithIcon = (text, iconName, buttonClass = "ss-button") => {
          const button = this.buttonContainer.createEl("button", { cls: buttonClass });
          const icon = button.createSpan("ss-button__icon");
          (0, import_obsidian97.setIcon)(icon, iconName);
          button.appendChild(document.createTextNode(text));
          return button;
        };
        const regenerateButton = createButtonWithIcon("Regenerate", "refresh-ccw", "ss-button mod-warning");
        this.registerDomEvent(regenerateButton, "click", () => this.generateResponse());
        const copyButton = createButtonWithIcon("Copy", "copy");
        this.registerDomEvent(copyButton, "click", async () => {
          await navigator.clipboard.writeText(this.fullResponse);
          new import_obsidian97.Notice("Response copied to clipboard");
          copyButton.textContent = "Copied!";
          setTimeout(() => {
            copyButton.innerHTML = "";
            const text = document.createTextNode("Copy");
            copyButton.appendChild(text);
            const newIcon = copyButton.createSpan("ss-button__icon");
            (0, import_obsidian97.setIcon)(newIcon, "copy");
          }, 2e3);
        });
        const insertButton = createButtonWithIcon("Insert", "text-cursor-input", "ss-button ss-button--primary");
        insertButton.addClass("mod-cta");
        this.registerDomEvent(insertButton, "click", () => {
          this.onInsert(this.fullResponse);
          this.closeAllModals();
        });
        const saveAsNoteButton = createButtonWithIcon("Save as Note", "file-plus");
        this.registerDomEvent(saveAsNoteButton, "click", () => {
          const now = new Date();
          const defaultFileName = `AI Response ${now.toLocaleDateString()} ${now.toLocaleTimeString().replace(/:/g, ".")}`;
          const modal = new SaveAsNoteModal(this.app, this.plugin, this.plugin.settings.lastSaveAsNoteFolder || "SystemSculpt/AI Responses", defaultFileName, this.fullResponse, () => this.closeAllModals());
          modal.open();
        });
        const improveButton = createButtonWithIcon("Improve", "sparkles");
        this.registerDomEvent(improveButton, "click", () => {
          const promptText = "Choose how to improve the response:";
          const improveModal = new ImproveResponseModal(this.app, promptText, "shorter", (inputValue) => {
            const improvementPrompt = "The user has requested that this text should be improved upon, and they provided these improvement details / requirements: " + inputValue;
            const assistantMsg = {
              role: "assistant",
              content: this.fullResponse,
              message_id: `assistant_${Date.now()}`
            };
            const userMsg = {
              role: "user",
              content: improvementPrompt,
              message_id: `user_${Date.now()}`
            };
            const modal = new StandardAIResponseModal(this.app, {
              plugin: this.plugin,
              modelId: this.modelId,
              messages: [...this.messages, assistantMsg, userMsg],
              onInsert: this.onInsert,
              commandText: this.commandText,
              parentModal: this.parentModal
            });
            this.close();
            modal.open();
          });
          improveModal.open();
        });
        const closeButton = createButtonWithIcon("Close", "x");
        this.registerDomEvent(closeButton, "click", () => this.closeAllModals());
      }
    };
  }
});

// src/modals/StandardTemplateModal.ts
var StandardTemplateModal_exports = {};
__export(StandardTemplateModal_exports, {
  StandardTemplateModal: () => StandardTemplateModal,
  showStandardTemplateModal: () => showStandardTemplateModal
});
async function showStandardTemplateModal(app, title, content, options = {}) {
  const modal = new StandardTemplateModal(app, title, content, options);
  return await modal.openAndGetValue();
}
var import_obsidian98, StandardTemplateModal;
var init_StandardTemplateModal = __esm({
  "src/modals/StandardTemplateModal.ts"() {
    import_obsidian98 = __toModule(require("obsidian"));
    init_StandardModelSelectionModal();
    init_StandardAIResponseModal();
    init_StandardModal();
    init_modelUtils();
    StandardTemplateModal = class extends StandardModal {
      constructor(app, title, initialContent, options = {}) {
        super(app);
        this.result = null;
        this.originalFile = null;
        this.selectedModelId = "";
        this.currentNoteContent = "";
        this.commandText = "";
        this.isPreviewMode = true;
        this.modelDropdown = null;
        this.templateTextArea = null;
        this.previewContainer = null;
        this.finalPromptTextArea = null;
        this.setSize("large");
        this.title = title;
        this.templateContent = initialContent;
        this.plugin = options.plugin;
        this.commandText = options.commandText || "";
        if (this.plugin) {
          this.selectedModelId = this.plugin.settings.selectedModelId || "";
        }
        this.loadCurrentNoteContent();
        if (this.plugin) {
          const systemPromptsDir = this.plugin.settings.systemPromptsDirectory;
          const possiblePath = `${systemPromptsDir}/${this.title}.md`;
          this.originalFile = this.app.vault.getAbstractFileByPath(possiblePath);
        }
      }
      async loadCurrentNoteContent() {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian98.MarkdownView);
        if (activeView) {
          this.currentNoteContent = activeView.getViewData();
          if (this.commandText && this.currentNoteContent.includes(this.commandText)) {
            this.currentNoteContent = this.currentNoteContent.replace(this.commandText, "");
          }
        }
      }
      async onOpen() {
        super.onOpen();
        this.registerDomEvent(this.modalEl, "keydown", (event) => {
          if (event.key === "Enter" && !event.isComposing && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            if (this.plugin) {
              this.processWithAI();
            } else {
              console.warn("[SystemSculpt] Plugin reference missing in Command+Enter handler");
            }
          }
        });
        if (this.plugin) {
          try {
            await this.plugin.modelService.validateSelectedModel();
            this.selectedModelId = this.plugin.settings.selectedModelId || "";
          } catch (e) {
            console.warn("[SystemSculpt] Failed to validate selected model on modal open:", e);
          }
        }
        this.addTitle(`System Prompt: ${this.title}`, "Preview and edit template for processing notes");
        this.createModelSection();
        this.createNotePreviewSection();
        const titleEl = document.createElement("h3");
        titleEl.textContent = "Final System Prompt Preview & Edit";
        titleEl.addClass("ss-modal-title--large");
        this.contentEl.appendChild(titleEl);
        const labelEl = document.createElement("div");
        labelEl.textContent = "Review and edit the final system prompt before sending to AI";
        labelEl.addClass("ss-modal-label--small");
        this.contentEl.appendChild(labelEl);
        const textarea = document.createElement("textarea");
        textarea.value = this.templateContent;
        textarea.addClass("ss-modal-textarea");
        textarea.rows = 12;
        this.contentEl.appendChild(textarea);
        this.registerDomEvent(textarea, "keydown", (event) => {
          if (event.key === "Enter" && !event.isComposing && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            event.stopPropagation();
            if (this.plugin) {
              this.processWithAI();
            }
          }
        });
        this.finalPromptTextArea = textarea;
        this.addActionButton("Cancel", () => {
          this.result = null;
          this.close();
        }, false);
        if (this.plugin) {
          const processButton = this.addActionButton("Process with AI", async () => {
            await this.processWithAI();
          }, true, "send");
          processButton.addClass("mod-cta");
          this.registerDomEvent(processButton, "click", async () => {
            if (this.plugin) {
              await this.processWithAI();
            }
          });
          const shortcutEl = processButton.createSpan({
            cls: "systemsculpt-shortcut-hint",
            text: import_obsidian98.Platform.isMacOS ? " (\u2318+Enter)" : " (Ctrl+Enter)"
          });
        }
      }
      createModelSection() {
        const setting = new import_obsidian98.Setting(this.contentEl).setName("AI Model To Be Used");
        setting.addDropdown(async (dropdown) => {
          dropdown.selectEl.disabled = true;
          dropdown.addOption("", "Loading...");
          if (!this.plugin)
            return;
          try {
            const models = await this.plugin.modelService.getModels();
            dropdown.selectEl.innerHTML = "";
            for (const model of models) {
              const prefix = model.provider === "systemsculpt" ? "[SS AI] " : `[${model.provider.toUpperCase()}] `;
              dropdown.addOption(model.id, `${prefix}${model.name}`);
            }
            dropdown.setValue(this.selectedModelId);
            dropdown.selectEl.disabled = false;
          } catch (e) {
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "Failed to load models");
          }
          dropdown.onChange((value) => {
            this.selectedModelId = value;
          });
          this.modelDropdown = dropdown.selectEl;
        });
        const changeDefaultTemplateModelButton = this.contentEl.createEl("button", {
          text: "Change Default Template Model...",
          cls: "ss-template-modal__model-change-default-btn ss-modal-button--small"
        });
        changeDefaultTemplateModelButton.addEventListener("click", async () => {
          if (!this.plugin) {
            new import_obsidian98.Notice("Cannot change default template model: plugin instance not available", 1e4);
            return;
          }
          const modelSelectionOptions = {
            app: this.app,
            plugin: this.plugin,
            currentModelId: this.plugin.settings.defaultTemplateModelId || "",
            onSelect: async (result) => {
              try {
                const canonicalId = ensureCanonicalId(result.modelId);
                this.plugin.settings.defaultTemplateModelId = canonicalId;
                this.plugin.settings.selectedModelId = canonicalId;
                await this.plugin.saveSettings();
                this.selectedModelId = canonicalId;
                if (this.modelDropdown) {
                  this.modelDropdown.value = canonicalId;
                }
                new import_obsidian98.Notice("Default template model updated and set as active model.", 3e3);
              } catch (error) {
                console.error("Error updating default template model:", error);
                new import_obsidian98.Notice("Failed to update default template model", 1e4);
              }
            }
          };
          const modal = new StandardModelSelectionModal(modelSelectionOptions);
          modal.open();
        });
      }
      createNotePreviewSection() {
        if (!this.currentNoteContent)
          return;
        const maxPreviewLength = 500;
        const displayContent = this.currentNoteContent.length > maxPreviewLength ? this.currentNoteContent.substring(0, maxPreviewLength) + "..." : this.currentNoteContent;
        new import_obsidian98.Setting(this.contentEl).setName("Current Note Content").setDesc(displayContent);
      }
      async processWithAI() {
        var _a;
        if (!this.plugin)
          return;
        try {
          const finalPrompt = ((_a = this.finalPromptTextArea) == null ? void 0 : _a.value) || this.templateContent;
          if (!finalPrompt.trim()) {
            new import_obsidian98.Notice("System prompt cannot be empty", 1e4);
            return;
          }
          if (!this.currentNoteContent.trim()) {
            try {
              const skipWarning = this.plugin.settings.skipEmptyNoteWarning;
              if (!skipWarning) {
                const result = await new Promise((resolve) => {
                  const modal = new class extends import_obsidian98.Modal {
                    constructor(app) {
                      super(app);
                      this.confirmed = false;
                      this.checkboxChecked = false;
                    }
                    onOpen() {
                      const { contentEl } = this;
                      contentEl.empty();
                      contentEl.createEl("h3", { text: "Empty Note Detected" });
                      contentEl.createEl("p", { text: "The current note is empty. Are you sure you want to proceed?" });
                      const checkboxContainer = contentEl.createDiv({ cls: "empty-note-checkbox-container" });
                      const checkbox = document.createElement("input");
                      checkbox.type = "checkbox";
                      checkbox.id = "skip-empty-note-warning-checkbox";
                      const label = document.createElement("label");
                      label.htmlFor = "skip-empty-note-warning-checkbox";
                      label.textContent = "Do not show this notice again";
                      checkboxContainer.appendChild(checkbox);
                      checkboxContainer.appendChild(label);
                      const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
                      const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
                      cancelButton.addEventListener("click", () => {
                        this.close();
                      });
                      const proceedButton = buttonContainer.createEl("button", { text: "Proceed" });
                      proceedButton.addClass("mod-cta");
                      proceedButton.addEventListener("click", () => {
                        this.confirmed = true;
                        this.checkboxChecked = checkbox.checked;
                        this.close();
                      });
                      this.onClose = () => {
                        resolve({ confirmed: this.confirmed, checkboxChecked: this.checkboxChecked });
                      };
                    }
                  }(this.app);
                  modal.open();
                });
                if (!result || !result.confirmed) {
                  return;
                }
                if (result.checkboxChecked) {
                  try {
                    await this.plugin.getSettingsManager().updateSettings({ skipEmptyNoteWarning: true });
                  } catch (e) {
                    console.error("Failed to save skipEmptyNoteWarning preference", e);
                  }
                }
              }
            } catch (e) {
              console.error("Failed to show empty note confirmation modal", e);
              new import_obsidian98.Notice("Note content is empty", 1e4);
              return;
            }
          }
          if (!this.selectedModelId) {
            new import_obsidian98.Notice("Please select a model first", 1e4);
            return;
          }
          this.close();
          const messages = [
            {
              role: "system",
              content: finalPrompt,
              message_id: this.generateMessageId()
            },
            {
              role: "user",
              content: this.currentNoteContent,
              message_id: this.generateMessageId()
            }
          ];
          showAIResponseModal(this.app, {
            plugin: this.plugin,
            modelId: this.selectedModelId,
            messages,
            commandText: this.commandText,
            onInsert: (response) => {
              const activeView = this.app.workspace.getActiveViewOfType(import_obsidian98.MarkdownView);
              if (activeView) {
                const editor = activeView.editor;
                editor.replaceRange(response, editor.getCursor());
              } else {
                new import_obsidian98.Notice("No active editor to insert AI response");
              }
              this.result = response;
              this.close();
            }
          });
        } catch (error) {
          console.error("[SystemSculpt] Error processing with AI:", error);
          new import_obsidian98.Notice("Failed to process note with AI. Please try again.", 1e4);
        }
      }
      generateMessageId() {
        return Date.now().toString() + Math.random().toString().substring(2, 8);
      }
      onClose() {
        if (this.resolvePromise) {
          this.resolvePromise(this.result);
        }
        super.onClose();
      }
      async openAndGetValue() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
          this.open();
        });
      }
    };
  }
});

// src/services/AdaptivePerformanceManager.ts
var AdaptivePerformanceManager_exports = {};
__export(AdaptivePerformanceManager_exports, {
  AdaptivePerformanceManager: () => AdaptivePerformanceManager
});
var _AdaptivePerformanceManager, AdaptivePerformanceManager;
var init_AdaptivePerformanceManager = __esm({
  "src/services/AdaptivePerformanceManager.ts"() {
    _AdaptivePerformanceManager = class {
      constructor() {
        this.eventLoopStart = 0;
        this.memoryStart = 0;
        this.operationStart = 0;
        this.enabled = true;
        const deviceProfile = this.detectDeviceProfile();
        this.config = {
          initialBatchSize: deviceProfile.type === "mobile" ? 1 : deviceProfile.type === "tablet" ? 2 : deviceProfile.type === "desktop-constrained" ? 2 : 4,
          maxBatchSize: deviceProfile.maxBatchSize,
          minBatchSize: 1,
          scaleUpThreshold: 0.7,
          scaleDownThreshold: 1.2,
          historySize: 10
        };
        this.state = {
          currentBatchSize: this.config.initialBatchSize,
          consecutiveGoodSamples: 0,
          lastPerformanceLevel: "good",
          history: [],
          deviceProfile
        };
      }
      static getInstance() {
        if (!this.instance) {
          this.instance = new _AdaptivePerformanceManager();
        }
        return this.instance;
      }
      detectDeviceProfile() {
        var _a, _b, _c;
        const isMobile = typeof window !== "undefined" && (((_a = window.app) == null ? void 0 : _a.isMobile) || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
        const estimatedMemoryMB = this.estimateDeviceMemory();
        const cpuCores = navigator.hardwareConcurrency || 2;
        if (isMobile) {
          const screenWidth = ((_b = window.screen) == null ? void 0 : _b.width) || 0;
          const screenHeight = ((_c = window.screen) == null ? void 0 : _c.height) || 0;
          const maxDimension = Math.max(screenWidth, screenHeight);
          if (maxDimension >= 1e3) {
            return _AdaptivePerformanceManager.DEVICE_PROFILES.tablet;
          } else {
            return _AdaptivePerformanceManager.DEVICE_PROFILES.mobile;
          }
        } else {
          if (estimatedMemoryMB < 4e3 || cpuCores <= 4) {
            return _AdaptivePerformanceManager.DEVICE_PROFILES["desktop-constrained"];
          } else {
            return _AdaptivePerformanceManager.DEVICE_PROFILES["desktop-high-end"];
          }
        }
      }
      estimateDeviceMemory() {
        const memory = performance.memory;
        if ((memory == null ? void 0 : memory.usedJSHeapSize) && (memory == null ? void 0 : memory.totalJSHeapSize)) {
          return Math.round(memory.totalJSHeapSize * 8 / 1024 / 1024);
        }
        const ua = navigator.userAgent.toLowerCase();
        if (ua.includes("mobile") || ua.includes("android")) {
          return 2e3;
        }
        if (ua.includes("ipad") || ua.includes("tablet")) {
          return 4e3;
        }
        return 8e3;
      }
      startOperation() {
        if (!this.enabled)
          return;
        this.eventLoopStart = performance.now();
        this.operationStart = performance.now();
        const memory = performance.memory;
        this.memoryStart = (memory == null ? void 0 : memory.usedJSHeapSize) ? memory.usedJSHeapSize / 1024 / 1024 : 0;
        this.measureEventLoopLag();
      }
      endOperation(itemsProcessed) {
        if (!this.enabled) {
          return {
            eventLoopLag: 0,
            memoryUsedMB: 0,
            memoryDeltaMB: 0,
            operationTimeMs: 0,
            timestamp: Date.now()
          };
        }
        const now = performance.now();
        const operationTime = now - this.operationStart;
        const memory = performance.memory;
        const memoryEnd = (memory == null ? void 0 : memory.usedJSHeapSize) ? memory.usedJSHeapSize / 1024 / 1024 : 0;
        const memoryDelta = memoryEnd - this.memoryStart;
        const eventLoopLag = now - this.eventLoopStart;
        const metrics = {
          eventLoopLag,
          memoryUsedMB: memoryEnd,
          memoryDeltaMB: memoryDelta,
          operationTimeMs: operationTime,
          timestamp: Date.now()
        };
        this.recordMetrics(metrics);
        this.adaptBatchSize(metrics);
        return metrics;
      }
      measureEventLoopLag() {
        const start = performance.now();
        setTimeout(() => {
          this.eventLoopStart = performance.now() - start;
        }, 0);
      }
      recordMetrics(metrics) {
        this.state.history.push(metrics);
        if (this.state.history.length > this.config.historySize) {
          this.state.history.shift();
        }
      }
      adaptBatchSize(metrics) {
        const profile = this.state.deviceProfile;
        const targetLag = profile.targetEventLoopLag;
        const memoryThreshold = profile.memoryThresholdMB;
        const performanceLevel = this.classifyPerformance(metrics, targetLag, memoryThreshold);
        this.state.lastPerformanceLevel = performanceLevel;
        if (performanceLevel === "poor" || performanceLevel === "critical") {
          this.scaleDown();
          this.state.consecutiveGoodSamples = 0;
          return;
        }
        if (performanceLevel === "excellent" || performanceLevel === "good") {
          this.state.consecutiveGoodSamples++;
          if (this.state.consecutiveGoodSamples >= profile.stabilityRequired && this.state.currentBatchSize < this.config.maxBatchSize) {
            this.scaleUp();
            this.state.consecutiveGoodSamples = 0;
          }
        } else {
          this.state.consecutiveGoodSamples = 0;
        }
      }
      classifyPerformance(metrics, targetLag, memoryThreshold) {
        const lagRatio = metrics.eventLoopLag / targetLag;
        const memoryRatio = metrics.memoryDeltaMB / memoryThreshold;
        if (lagRatio > 2 || memoryRatio > 2) {
          return "critical";
        }
        if (lagRatio > this.config.scaleDownThreshold || memoryRatio > this.config.scaleDownThreshold) {
          return "poor";
        }
        if (lagRatio < this.config.scaleUpThreshold && memoryRatio < this.config.scaleUpThreshold) {
          return "excellent";
        }
        return "good";
      }
      scaleUp() {
        const oldSize = this.state.currentBatchSize;
        this.state.currentBatchSize = Math.min(this.state.currentBatchSize * 2, this.config.maxBatchSize);
        if (this.state.currentBatchSize !== oldSize) {
        }
      }
      scaleDown() {
        const oldSize = this.state.currentBatchSize;
        this.state.currentBatchSize = Math.max(Math.floor(this.state.currentBatchSize / 2), this.config.minBatchSize);
        if (this.state.currentBatchSize !== oldSize) {
        }
      }
      getCurrentBatchSize() {
        return this.state.currentBatchSize;
      }
      getYieldDelay() {
        const baseDelay = this.state.deviceProfile.yieldDelayMs;
        switch (this.state.lastPerformanceLevel) {
          case "excellent":
            return 0;
          case "good":
            return Math.max(1, baseDelay / 2);
          case "poor":
            return baseDelay * 2;
          case "critical":
            return baseDelay * 4;
          default:
            return baseDelay;
        }
      }
      async yieldControl() {
        const delay = this.getYieldDelay();
        if (delay > 0) {
          await new Promise((resolve) => setTimeout(resolve, delay));
        } else {
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
      }
      getPerformanceState() {
        return { ...this.state };
      }
      getPerformanceSummary() {
        const recent = this.state.history.slice(-3);
        if (recent.length === 0)
          return "No performance data available";
        const avgLag = recent.reduce((sum, m) => sum + m.eventLoopLag, 0) / recent.length;
        const avgMemory = recent.reduce((sum, m) => sum + m.memoryDeltaMB, 0) / recent.length;
        return `Performance: ${this.state.lastPerformanceLevel} | Batch: ${this.state.currentBatchSize} | Lag: ${avgLag.toFixed(1)}ms | Memory: ${avgMemory.toFixed(1)}MB | Device: ${this.state.deviceProfile.type}`;
      }
      reset() {
        this.state.currentBatchSize = this.config.initialBatchSize;
        this.state.consecutiveGoodSamples = 0;
        this.state.lastPerformanceLevel = "good";
        this.state.history = [];
      }
      setEnabled(enabled) {
        this.enabled = enabled;
        if (enabled) {
        } else {
        }
      }
      shouldContinueProcessing(itemsRemaining) {
        if (!this.enabled || itemsRemaining === 0)
          return false;
        if (this.state.currentBatchSize <= this.config.minBatchSize)
          return true;
        if (this.state.lastPerformanceLevel === "critical")
          return false;
        return true;
      }
    };
    AdaptivePerformanceManager = _AdaptivePerformanceManager;
    AdaptivePerformanceManager.instance = null;
    AdaptivePerformanceManager.DEVICE_PROFILES = {
      mobile: {
        type: "mobile",
        targetEventLoopLag: 24,
        maxBatchSize: 8,
        memoryThresholdMB: 50,
        stabilityRequired: 3,
        yieldDelayMs: 10
      },
      tablet: {
        type: "tablet",
        targetEventLoopLag: 20,
        maxBatchSize: 12,
        memoryThresholdMB: 100,
        stabilityRequired: 2,
        yieldDelayMs: 5
      },
      "desktop-constrained": {
        type: "desktop-constrained",
        targetEventLoopLag: 16,
        maxBatchSize: 16,
        memoryThresholdMB: 200,
        stabilityRequired: 2,
        yieldDelayMs: 2
      },
      "desktop-high-end": {
        type: "desktop-high-end",
        targetEventLoopLag: 16,
        maxBatchSize: 32,
        memoryThresholdMB: 500,
        stabilityRequired: 2,
        yieldDelayMs: 0
      }
    };
  }
});

// src/services/MemoryPressureMonitor.ts
var MemoryPressureMonitor_exports = {};
__export(MemoryPressureMonitor_exports, {
  MemoryPressureMonitor: () => MemoryPressureMonitor
});
var _MemoryPressureMonitor, MemoryPressureMonitor;
var init_MemoryPressureMonitor = __esm({
  "src/services/MemoryPressureMonitor.ts"() {
    _MemoryPressureMonitor = class {
      constructor() {
        this.cacheManagers = new Map();
        this.enabled = true;
        this.monitoringInterval = null;
        this.lastCleanupTime = 0;
        this.cleanupCooldown = 3e4;
        this.memoryHistory = [];
        this.maxHistorySize = 20;
        this.thresholds = {
          mediumPressure: 60,
          highPressure: 75,
          criticalPressure: 85,
          gcThreshold: 80
        };
        this.startMonitoring();
      }
      static getInstance() {
        if (!this.instance) {
          this.instance = new _MemoryPressureMonitor();
        }
        return this.instance;
      }
      registerCache(type, manager) {
        if (!this.cacheManagers.has(type)) {
          this.cacheManagers.set(type, []);
        }
        this.cacheManagers.get(type).push(manager);
      }
      startMonitoring() {
        if (this.monitoringInterval)
          return;
        this.monitoringInterval = window.setInterval(() => {
          if (this.enabled) {
            this.checkMemoryPressure();
          }
        }, 5e3);
      }
      stopMonitoring() {
        if (this.monitoringInterval) {
          clearInterval(this.monitoringInterval);
          this.monitoringInterval = null;
        }
      }
      getMemoryStats() {
        try {
          const memory = performance.memory;
          if (!memory || typeof memory.usedJSHeapSize !== "number") {
            return null;
          }
          const usagePercent = memory.usedJSHeapSize / memory.jsHeapSizeLimit * 100;
          const stats = {
            usedJSHeapSize: memory.usedJSHeapSize,
            totalJSHeapSize: memory.totalJSHeapSize,
            jsHeapSizeLimit: memory.jsHeapSizeLimit,
            usagePercent,
            pressureLevel: this.calculatePressureLevel(usagePercent),
            timestamp: Date.now()
          };
          return stats;
        } catch (error) {
          console.warn("[MemoryPressureMonitor] Unable to get memory stats:", error);
          return null;
        }
      }
      calculatePressureLevel(usagePercent) {
        if (usagePercent >= this.thresholds.criticalPressure)
          return "critical";
        if (usagePercent >= this.thresholds.highPressure)
          return "high";
        if (usagePercent >= this.thresholds.mediumPressure)
          return "medium";
        return "low";
      }
      async checkMemoryPressure() {
        const stats = this.getMemoryStats();
        if (!stats)
          return;
        this.recordMemoryStats(stats);
        const timeSinceLastCleanup = Date.now() - this.lastCleanupTime;
        if (timeSinceLastCleanup < this.cleanupCooldown && stats.pressureLevel !== "critical") {
          return;
        }
        switch (stats.pressureLevel) {
          case "medium":
            await this.handleMediumPressure(stats);
            break;
          case "high":
            await this.handleHighPressure(stats);
            break;
          case "critical":
            await this.handleCriticalPressure(stats);
            break;
          default:
            break;
        }
      }
      recordMemoryStats(stats) {
        this.memoryHistory.push(stats);
        if (this.memoryHistory.length > this.maxHistorySize) {
          this.memoryHistory.shift();
        }
      }
      async handleMediumPressure(stats) {
        console.log(`[MemoryPressureMonitor] Medium pressure detected (${stats.usagePercent.toFixed(1)}%) - clearing low priority caches`);
        const bytesFreed = await this.clearCaches("low");
        if (bytesFreed > 0) {
          this.lastCleanupTime = Date.now();
          console.log(`[MemoryPressureMonitor] Freed ${(bytesFreed / 1024 / 1024).toFixed(1)}MB from low priority caches`);
        }
      }
      async handleHighPressure(stats) {
        console.log(`[MemoryPressureMonitor] High pressure detected (${stats.usagePercent.toFixed(1)}%) - aggressive cleanup`);
        const bytesFreed = await this.clearCaches("medium");
        if (stats.usagePercent >= this.thresholds.gcThreshold) {
          this.triggerGarbageCollection();
        }
        this.notifyPerformanceManager("high-memory-pressure");
        if (bytesFreed > 0) {
          this.lastCleanupTime = Date.now();
          console.log(`[MemoryPressureMonitor] Freed ${(bytesFreed / 1024 / 1024).toFixed(1)}MB from medium priority caches`);
        }
      }
      async handleCriticalPressure(stats) {
        console.log(`[MemoryPressureMonitor] CRITICAL pressure detected (${stats.usagePercent.toFixed(1)}%) - emergency cleanup`);
        const bytesFreed = await this.clearCaches("high");
        this.triggerGarbageCollection();
        this.notifyPerformanceManager("critical-memory-pressure");
        await this.emergencyCleanup();
        this.lastCleanupTime = Date.now();
        console.log(`[MemoryPressureMonitor] Emergency cleanup completed - freed ${(bytesFreed / 1024 / 1024).toFixed(1)}MB`);
      }
      async clearCaches(priority) {
        let totalFreed = 0;
        const cacheOrder = priority === "high" ? ["temporary", "ui", "files", "search", "chat", "embeddings"] : priority === "medium" ? ["temporary", "ui", "files", "search"] : ["temporary", "ui"];
        for (const cacheType of cacheOrder) {
          const managers = this.cacheManagers.get(cacheType);
          if (managers) {
            for (const manager of managers) {
              try {
                const freed = await manager.clearCache(priority);
                totalFreed += freed;
              } catch (error) {
                console.warn(`[MemoryPressureMonitor] Error clearing ${cacheType} cache:`, error);
              }
            }
          }
        }
        return totalFreed;
      }
      triggerGarbageCollection() {
        try {
          if (typeof window.gc === "function") {
            window.gc();
            console.log("[MemoryPressureMonitor] Manual garbage collection triggered");
            return;
          }
          if (typeof performance.webkitClearResourceTimings === "function") {
            performance.webkitClearResourceTimings();
          }
          const forceGC = () => {
            const arrays = [];
            for (let i = 0; i < 100; i++) {
              arrays.push(new Array(1e3).fill(Math.random()));
            }
            arrays.length = 0;
          };
          forceGC();
          console.log("[MemoryPressureMonitor] Attempted to encourage garbage collection");
        } catch (error) {
          console.warn("[MemoryPressureMonitor] Unable to trigger garbage collection:", error);
        }
      }
      notifyPerformanceManager(event) {
        try {
          Promise.resolve().then(() => (init_AdaptivePerformanceManager(), AdaptivePerformanceManager_exports)).then(({ AdaptivePerformanceManager: AdaptivePerformanceManager2 }) => {
            const manager = AdaptivePerformanceManager2.getInstance();
            if (event === "critical-memory-pressure") {
              manager.reset();
              console.log("[MemoryPressureMonitor] Forced AdaptivePerformanceManager to minimum settings");
            }
          }).catch((error) => {
            console.warn("[MemoryPressureMonitor] Unable to notify AdaptivePerformanceManager:", error);
          });
        } catch (error) {
          console.warn("[MemoryPressureMonitor] Error notifying performance manager:", error);
        }
      }
      async emergencyCleanup() {
        try {
          if (typeof document !== "undefined") {
            const tempElements = document.querySelectorAll("[data-temp-cache]");
            tempElements.forEach((el) => el.remove());
          }
          if (typeof window !== "undefined") {
            const commonCaches = ["_cache", "_tempCache", "cache", "tempData"];
            commonCaches.forEach((cacheName) => {
              if (window[cacheName]) {
                delete window[cacheName];
              }
            });
          }
          if (typeof document !== "undefined") {
            const elements = document.querySelectorAll("[data-cleanup-listeners]");
            elements.forEach((el) => {
              var _a;
              const newEl = el.cloneNode(true);
              (_a = el.parentNode) == null ? void 0 : _a.replaceChild(newEl, el);
            });
          }
          console.log("[MemoryPressureMonitor] Emergency cleanup measures completed");
        } catch (error) {
          console.warn("[MemoryPressureMonitor] Error during emergency cleanup:", error);
        }
      }
      getMemoryPressureSummary() {
        const stats = this.getMemoryStats();
        if (!stats)
          return "Memory monitoring unavailable";
        const memoryMB = (stats.usedJSHeapSize / 1024 / 1024).toFixed(1);
        const limitMB = (stats.jsHeapSizeLimit / 1024 / 1024).toFixed(1);
        return `Memory: ${memoryMB}MB / ${limitMB}MB (${stats.usagePercent.toFixed(1)}%) - ${stats.pressureLevel} pressure`;
      }
      getMemoryHistory() {
        return [...this.memoryHistory];
      }
      isMemoryConstrained() {
        const stats = this.getMemoryStats();
        return stats ? stats.pressureLevel === "high" || stats.pressureLevel === "critical" : false;
      }
      getRecommendedBatchSize(baseBatchSize) {
        const stats = this.getMemoryStats();
        if (!stats)
          return baseBatchSize;
        switch (stats.pressureLevel) {
          case "critical":
            return Math.max(1, Math.floor(baseBatchSize * 0.25));
          case "high":
            return Math.max(1, Math.floor(baseBatchSize * 0.5));
          case "medium":
            return Math.max(1, Math.floor(baseBatchSize * 0.75));
          default:
            return baseBatchSize;
        }
      }
      setThresholds(thresholds) {
        this.thresholds = { ...this.thresholds, ...thresholds };
        console.log("[MemoryPressureMonitor] Updated thresholds:", this.thresholds);
      }
      setEnabled(enabled) {
        this.enabled = enabled;
        if (enabled) {
          this.startMonitoring();
          console.log("[MemoryPressureMonitor] Memory monitoring enabled");
        } else {
          this.stopMonitoring();
          console.log("[MemoryPressureMonitor] Memory monitoring disabled");
        }
      }
      async checkNow() {
        if (!this.enabled)
          return;
        console.log("[MemoryPressureMonitor] Performing immediate memory check...");
        await this.checkMemoryPressure();
      }
      destroy() {
        this.stopMonitoring();
        this.cacheManagers.clear();
        this.memoryHistory.length = 0;
        _MemoryPressureMonitor.instance = null;
        console.log("[MemoryPressureMonitor] Destroyed");
      }
    };
    MemoryPressureMonitor = _MemoryPressureMonitor;
    MemoryPressureMonitor.instance = null;
  }
});

// src/commands/RunAudioAnalysis.ts
var RunAudioAnalysis_exports = {};
__export(RunAudioAnalysis_exports, {
  runAudioAnalysis: () => runAudioAnalysis
});
async function runAudioAnalysis(plugin) {
  try {
    new import_obsidian108.Notice(`Running audio chunking analysis...`);
    const report = "Audio chunking analysis functionality is disabled (test files not available)";
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const filePath = `AudioChunkingAnalysis-${timestamp}.md`;
    await plugin.app.vault.create(filePath, report);
    new import_obsidian108.Notice(`Analysis complete. Results saved to ${filePath}`);
    const file = plugin.app.vault.getAbstractFileByPath(filePath);
    if (file && file instanceof import_obsidian108.TFile) {
      plugin.app.workspace.getLeaf().openFile(file);
    }
  } catch (error) {
    console.error(`[RunAudioAnalysis] Error:`, error);
    new import_obsidian108.Notice(`Error running analysis: ${error instanceof Error ? error.message : String(error)}`);
  }
}
var import_obsidian108;
var init_RunAudioAnalysis = __esm({
  "src/commands/RunAudioAnalysis.ts"() {
    import_obsidian108 = __toModule(require("obsidian"));
  }
});

// src/modals/SystemSearchModal.ts
var SystemSearchModal_exports = {};
__export(SystemSearchModal_exports, {
  SystemSearchModal: () => SystemSearchModal
});
var import_obsidian109, SystemSearchModal;
var init_SystemSearchModal = __esm({
  "src/modals/SystemSearchModal.ts"() {
    import_obsidian109 = __toModule(require("obsidian"));
    init_StandardModal();
    init_searchUtils();
    SystemSearchModal = class extends StandardModal {
      constructor(app, plugin) {
        super(app);
        this.query = "";
        this.history = [];
        this.historyIndex = -1;
        this.isClosing = false;
        this.searchAbortController = null;
        this.recentFiles = [];
        this.plugin = plugin;
      }
      shouldExcludeFile(file) {
        if (this.plugin.embeddingsManager) {
          return this.plugin.embeddingsManager.shouldExcludeFile(file);
        }
        const settings = this.plugin.settings;
        const exclusions = settings.embeddingsExclusions || {
          folders: [],
          patterns: [],
          ignoreChatHistory: true,
          respectObsidianExclusions: true
        };
        if (exclusions.ignoreChatHistory !== false) {
          const chatsDirectory = settings.chatsDirectory || "SystemSculpt/Chats";
          if (file.path.startsWith(chatsDirectory + "/")) {
            return true;
          }
        }
        if (file.path.startsWith(".obsidian/") || file.path.includes("node_modules/")) {
          return true;
        }
        return false;
      }
      onOpen() {
        super.onOpen();
        this.setSize("large");
        const subtitle = this.plugin.settings.embeddingsEnabled && this.plugin.settings.licenseKey ? "Search your vault with lexical and semantic matching" : "Search your vault with lexical matching";
        this.addTitle("System Search", subtitle);
        this.searchInputEl = this.addSearchBar("Search files, content, and ideas\u2026", (query) => {
          this.query = query;
          this.historyIndex = this.history.length;
          if (query.trim().length >= 2) {
            if (this.searchAbortController) {
              this.searchAbortController.abort();
            }
            setTimeout(() => this.performSearch(), 300);
          } else if (query.trim().length === 0) {
            this.renderRecentFiles();
          }
        });
        this.searchInputEl.focus();
        this.registerDomEvent(this.searchInputEl, "keydown", (e) => {
          if (e.key === "ArrowUp") {
            if (this.history.length > 0) {
              if (this.historyIndex < 0 || this.historyIndex > this.history.length) {
                this.historyIndex = this.history.length;
              }
              this.historyIndex += -1;
              if (this.historyIndex < 0)
                this.historyIndex = this.history.length - 1;
              if (this.historyIndex > this.history.length - 1)
                this.historyIndex = 0;
              this.query = this.history[this.historyIndex];
              this.searchInputEl.value = this.query;
              this.searchInputEl.dispatchEvent(new Event("input"));
            }
            e.preventDefault();
            return;
          }
          if (e.key === "Enter") {
            e.preventDefault();
            this.performSearch();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            this.close();
          }
        });
        if (!this.plugin.settings.embeddingsEnabled || !this.plugin.settings.licenseKey) {
          const noticeEl = this.contentEl.createEl("div", {
            cls: "ss-notice ss-notice--info"
          });
          const noticeContent = noticeEl.createEl("div", { cls: "ss-notice__content" });
          if (!this.plugin.settings.licenseKey) {
            noticeContent.createEl("span", {
              text: "Semantic search requires a SystemSculpt premium license. Only lexical search is available. "
            });
            const linkEl = noticeContent.createEl("a", {
              text: "Get a license",
              href: "#",
              cls: "ss-link"
            });
            this.registerDomEvent(linkEl, "click", (e) => {
              e.preventDefault();
              window.open("https://systemsculpt.com", "_blank");
            });
          } else {
            noticeContent.createEl("span", {
              text: "Embeddings are currently disabled. Only lexical search is available. "
            });
            const linkEl = noticeContent.createEl("a", {
              text: "Enable embeddings",
              href: "#",
              cls: "ss-link"
            });
            this.registerDomEvent(linkEl, "click", (e) => {
              e.preventDefault();
              this.app.setting.open();
              this.app.setting.openTabById(this.plugin.manifest.id);
              setTimeout(() => {
                const embedTab = document.querySelector('.systemsculpt-settings-tabs button[data-tab="embeddings"]');
                if (embedTab)
                  embedTab.click();
              }, 100);
              this.close();
            });
            noticeContent.createEl("span", { text: " for semantic search capabilities." });
          }
        }
        this.resultsListEl = this.contentEl.createEl("div", { cls: "ss-modal__list" });
        this.loadRecentFiles();
        this.renderRecentFiles();
      }
      loadRecentFiles() {
        const files = this.app.vault.getMarkdownFiles();
        const currentFile = this.app.workspace.getActiveFile();
        const currentFilePath = currentFile == null ? void 0 : currentFile.path;
        const sortedFiles = files.filter((file) => {
          if (file.path === currentFilePath)
            return false;
          return !this.shouldExcludeFile(file);
        }).map((file) => ({ path: file.path, mtime: file.stat.mtime })).sort((a, b) => b.mtime - a.mtime).slice(0, 25);
        this.recentFiles = sortedFiles;
      }
      renderRecentFiles() {
        this.resultsListEl.empty();
        if (this.recentFiles.length === 0) {
          const emptyState = this.resultsListEl.createEl("div", { cls: "ss-modal__empty-state" });
          const iconEl = emptyState.createEl("div", { cls: "ss-modal__empty-state-icon" });
          (0, import_obsidian109.setIcon)(iconEl, "file-text");
          emptyState.createEl("div", { text: "No recent files found." });
          return;
        }
        const headerEl = this.resultsListEl.createEl("div", { cls: "ss-modal__list-header" });
        headerEl.createEl("h4", { text: "Recent Files" });
        headerEl.createEl("span", { text: "25 most recently modified files", cls: "ss-modal__list-subtitle" });
        for (const file of this.recentFiles) {
          this.createRecentFileItem(this.resultsListEl, file);
        }
      }
      createRecentFileItem(containerEl, file) {
        const lastSlashIndex = file.path.lastIndexOf("/");
        const name = file.path.substring(lastSlashIndex + 1).replace(/\.md$/, "");
        const folder = lastSlashIndex > 0 ? file.path.substring(0, lastSlashIndex) : "";
        const modifiedDate = new Date(file.mtime);
        const dateStr = modifiedDate.toLocaleDateString();
        const timeStr = modifiedDate.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        const modifiedStr = `${dateStr} ${timeStr}`;
        const item = this.createItem(name, `${folder || "Root"} \u2022 ${modifiedStr}`, "file-text");
        item.classList.add("ss-modal__item--clickable");
        this.registerDomEvent(item, "click", () => {
          this.openNote(file.path);
          this.close();
        });
        containerEl.appendChild(item);
      }
      async performSearch() {
        var _a, _b, _c, _d;
        const q = this.query.trim();
        if (!q) {
          new import_obsidian109.Notice("Please enter a search query.");
          return;
        }
        if (this.searchAbortController) {
          this.searchAbortController.abort();
        }
        if (this.isClosing) {
          return;
        }
        this.searchAbortController = new AbortController();
        if (!this.history.length || this.history[this.history.length - 1] !== q) {
          this.history.push(q);
          if (this.history.length > 50)
            this.history.shift();
        }
        this.historyIndex = this.history.length;
        this.resultsListEl.empty();
        const loadingEl = this.resultsListEl.createEl("div", { cls: "ss-modal__loading" });
        loadingEl.createEl("div", { text: `Searching for "${q}"...` });
        const keywordResults = [];
        const files = this.app.vault.getMarkdownFiles().filter((file) => !this.shouldExcludeFile(file));
        for (const file of files) {
          if (((_a = this.searchAbortController) == null ? void 0 : _a.signal.aborted) || this.isClosing) {
            return;
          }
          try {
            const filename = file.basename.toLowerCase();
            const queryLower = q.toLowerCase();
            const queryNormalized = queryLower.replace(/\s+/g, "[_\\s-]?");
            const queryRegex = new RegExp(queryNormalized, "i");
            if (filename.includes(queryLower) || queryRegex.test(filename)) {
              const filenameScore = 1;
              const content2 = await this.app.vault.read(file);
              const preview = content2.substring(0, 200) + (content2.length > 200 ? "..." : "");
              keywordResults.push({
                path: file.path,
                score: filenameScore,
                content: content2,
                preview: `Filename match: ${file.basename}

${preview}`
              });
              continue;
            }
            const content = await this.app.vault.read(file);
            const lower = content.toLowerCase();
            const idx = lower.indexOf(queryLower);
            if (idx >= 0) {
              const score = 1 - idx / lower.length;
              let preview = "";
              const previewStart = Math.max(0, idx - 100);
              const previewEnd = Math.min(content.length, idx + q.length + 100);
              preview = content.substring(previewStart, previewEnd);
              if (previewStart > 0)
                preview = "..." + preview;
              if (previewEnd < content.length)
                preview += "...";
              keywordResults.push({ path: file.path, score, content, preview });
            }
          } catch (error) {
            console.error("[SystemSculpt] Error reading file for keyword search:", error);
          }
        }
        keywordResults.sort((a, b) => b.score - a.score);
        if (((_b = this.searchAbortController) == null ? void 0 : _b.signal.aborted) || this.isClosing) {
          return;
        }
        let semanticResults = [];
        if (this.plugin.settings.embeddingsEnabled && this.plugin.settings.licenseKey) {
          try {
            const results = await searchSimilarNotes(this.plugin, q, {
              maxResults: 20,
              skipInitialization: true
            });
            if (((_c = this.searchAbortController) == null ? void 0 : _c.signal.aborted) || this.isClosing) {
              return;
            }
            const enhancedResults = await enhanceSearchResults(this.app, results);
            for (const result of enhancedResults) {
              const preview = result.excerpt || (result.content && result.content.length > 200 ? result.content.substring(0, 200) + "..." : result.content);
              semanticResults.push({
                path: result.path,
                score: result.score,
                content: result.content,
                preview
              });
            }
          } catch (error) {
            console.error("[SystemSculpt] Error in semantic search:", error);
            if (!((_d = error.message) == null ? void 0 : _d.includes("No embeddings"))) {
              new import_obsidian109.Notice("Error performing semantic search.");
            }
          }
        }
        this.renderFusedResults(q, keywordResults, semanticResults);
      }
      renderFusedResults(query, keywordResults, semanticResults) {
        this.resultsListEl.empty();
        const map = {};
        for (const r of keywordResults) {
          map[r.path] = map[r.path] || { path: r.path, types: [], content: r.content, preview: r.preview };
          map[r.path].lexicalScore = r.score;
          if (!map[r.path].types.includes("lexical"))
            map[r.path].types.push("lexical");
        }
        for (const r of semanticResults) {
          map[r.path] = map[r.path] || { path: r.path, types: [], content: r.content, preview: r.preview };
          map[r.path].semanticScore = r.score;
          if (!map[r.path].types.includes("semantic"))
            map[r.path].types.push("semantic");
          if (!map[r.path].preview && r.preview) {
            map[r.path].preview = r.preview;
          }
        }
        const fused = Object.values(map).map((item) => {
          var _a;
          let combinedScore;
          const isFilenameMatch = item.lexicalScore === 1;
          if (isFilenameMatch) {
            combinedScore = 1.5;
          } else if (item.semanticScore !== void 0 && item.lexicalScore !== void 0) {
            combinedScore = item.semanticScore * 0.7 + item.lexicalScore * 0.3;
          } else if (item.semanticScore !== void 0) {
            combinedScore = item.semanticScore;
          } else {
            combinedScore = ((_a = item.lexicalScore) != null ? _a : 0) * 0.5;
          }
          return {
            ...item,
            combinedScore,
            highlightedPreview: this.highlightQueryInText(item.preview || "", query)
          };
        }).sort((a, b) => b.combinedScore - a.combinedScore);
        if (!fused.length) {
          const emptyState = this.resultsListEl.createEl("div", { cls: "ss-modal__empty-state" });
          const iconEl = emptyState.createEl("div", { cls: "ss-modal__empty-state-icon" });
          (0, import_obsidian109.setIcon)(iconEl, "search");
          emptyState.createEl("div", { text: "No matches found." });
          return;
        }
        const headerEl = this.resultsListEl.createEl("div", { cls: "ss-modal__list-header" });
        headerEl.createEl("h4", { text: "Search Results" });
        headerEl.createEl("span", { text: `${fused.length} ${fused.length === 1 ? "result" : "results"} for "${query}"`, cls: "ss-modal__list-subtitle" });
        for (const item of fused)
          this.createFusedResultItem(this.resultsListEl, item, query);
      }
      highlightQueryInText(text, query) {
        if (!text || !query)
          return text;
        const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
        return text.replace(regex, (match) => `<mark class="ss-highlight">${match}</mark>`);
      }
      async createFusedResultItem(containerEl, item, query) {
        const lastSlashIndex = item.path.lastIndexOf("/");
        const name = item.path.substring(lastSlashIndex + 1).replace(/\.md$/, "");
        const folder = lastSlashIndex > 0 ? item.path.substring(0, lastSlashIndex) : "";
        const normalizedScore = Math.min(100, Math.round(item.combinedScore * 100));
        const description = `${folder || "Root"} \u2022 ${normalizedScore}% match`;
        const itemEl = this.createItem(name, description, "file-text");
        itemEl.classList.add("ss-modal__item--clickable");
        this.registerDomEvent(itemEl, "click", () => {
          this.openNote(item.path);
          this.close();
        });
        containerEl.appendChild(itemEl);
      }
      async openNote(path) {
        try {
          await this.app.workspace.openLinkText(path, "");
        } catch (error) {
          console.error(`[SystemSculpt] Error opening note ${path}:`, error);
          new import_obsidian109.Notice(`Error opening note: ${path}`);
        }
      }
      onClose() {
        this.isClosing = true;
        if (this.searchAbortController) {
          this.searchAbortController.abort();
          this.searchAbortController = null;
        }
        super.onClose();
      }
    };
  }
});

// src/main.ts
__export(exports, {
  default: () => SystemSculptPlugin
});

// src/services/ErrorCollectorService.ts
var _ErrorCollectorService = class {
  constructor(maxLogs = 50) {
    this.logs = [];
    this.captureAllLogs = false;
    this.maxLogs = maxLogs;
    this.originalConsoleLog = console.log;
    this.originalConsoleInfo = console.info;
    this.originalConsoleWarn = console.warn;
    this.originalConsoleError = console.error;
    this.originalConsoleDebug = console.debug;
    this.importEarlyLogs();
    console.log = (...args) => {
      this.originalConsoleLog.apply(console, args);
      this.captureIfSystemSculpt("log", args);
    };
    console.info = (...args) => {
      this.originalConsoleInfo.apply(console, args);
      this.captureIfSystemSculpt("info", args);
    };
    console.warn = (...args) => {
      this.originalConsoleWarn.apply(console, args);
      this.captureIfSystemSculpt("warn", args);
    };
    console.error = (...args) => {
      this.originalConsoleError.apply(console, args);
      this.captureIfSystemSculpt("error", args);
    };
    console.debug = (...args) => {
      this.originalConsoleDebug.apply(console, args);
      this.captureIfSystemSculpt("debug", args);
    };
  }
  static initializeEarlyLogsCapture() {
    const originalLog = console.log;
    const originalInfo = console.info;
    const originalWarn = console.warn;
    const originalError = console.error;
    const isSystemSculptLog = (args) => {
      return args.some((arg) => {
        if (typeof arg !== "string")
          return false;
        const str = arg.toString();
        return str.includes("SystemSculpt") || str.includes("systemsculpt") || str.includes("plugin:systemsculpt-ai") || str.includes("systemsculpt-ai") || str.includes("[SS]") || str.includes("Directory") && str.includes("SystemSculpt") || str.includes("Starting directory initialization") || str.includes("directory structure initialized") || str.includes("Directory marked as available:") || str.includes("Template manager initialized") || str.includes("Preloading models") || str.includes("template preload");
      });
    };
    console.log = (...args) => {
      originalLog.apply(console, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: new Date(),
        level: "log",
        args
      });
    };
    console.info = (...args) => {
      originalInfo.apply(console, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: new Date(),
        level: "info",
        args
      });
    };
    console.warn = (...args) => {
      originalWarn.apply(console, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: new Date(),
        level: "warn",
        args
      });
    };
    console.error = (...args) => {
      originalError.apply(console, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: new Date(),
        level: "error",
        args
      });
    };
    const originalDebug = console.debug;
    console.debug = (...args) => {
      originalDebug.apply(console, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: new Date(),
        level: "debug",
        args
      });
    };
  }
  enableCaptureAllLogs() {
    this.captureAllLogs = true;
  }
  importEarlyLogs() {
    _ErrorCollectorService.earlyLogs.forEach((earlyLog) => {
      const { timestamp, level, args } = earlyLog;
      const message = args.map((arg) => {
        if (arg instanceof Error) {
          return `Error: ${arg.message}`;
        }
        if (typeof arg === "object" && arg !== null) {
          try {
            return JSON.stringify(arg, null, 2);
          } catch (e) {
            return String(arg);
          }
        }
        return String(arg);
      }).join(" ");
      const errorArg = args.find((arg) => arg instanceof Error);
      const stack = errorArg instanceof Error ? errorArg.stack : void 0;
      this.logs.push({
        timestamp,
        level,
        context: "console." + level + " (early)",
        message,
        stack
      });
    });
    _ErrorCollectorService.earlyLogs = [];
  }
  captureIfSystemSculpt(level, args) {
    const isSystemSculptLog = (args2) => {
      if (this.captureAllLogs)
        return true;
      return args2.some((arg) => {
        if (typeof arg !== "string")
          return false;
        const str = arg.toString();
        return str.includes("SystemSculpt") || str.includes("systemsculpt") || str.includes("plugin:systemsculpt-ai") || str.includes("systemsculpt-ai") || str.includes("[SS]") || str.includes("Directory") && str.includes("SystemSculpt") || str.includes("Starting directory initialization") || str.includes("directory structure initialized") || str.includes("Directory marked as available:") || str.includes("Template manager initialized") || str.includes("Preloading models") || str.includes("template preload");
      });
    };
    if (isSystemSculptLog(args)) {
      const message = args.map((arg) => {
        if (arg instanceof Error) {
          return `Error: ${arg.message}`;
        }
        if (typeof arg === "object" && arg !== null) {
          try {
            return JSON.stringify(arg, null, 2);
          } catch (e) {
            return String(arg);
          }
        }
        return String(arg);
      }).join(" ");
      const errorArg = args.find((arg) => arg instanceof Error);
      const stack = errorArg instanceof Error ? errorArg.stack : void 0;
      this.captureLog(level, "console." + level, message, stack);
    }
  }
  captureLog(level, context, message, stack) {
    this.logs.push({
      timestamp: new Date(),
      level,
      context,
      message,
      stack
    });
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
  }
  captureError(context, error, stack) {
    const message = error instanceof Error ? error.message : error;
    const errorStack = error instanceof Error ? error.stack : stack;
    this.captureLog("error", context, message, errorStack);
  }
  getAllLogs() {
    return this.logs.map((log) => {
      const time = log.timestamp.toISOString();
      const base = `[${time}] [${log.level.toUpperCase()}] [${log.context}] ${log.message}`;
      if (log.stack) {
        const stackLines = log.stack.split("\n").slice(0, 3);
        return `${base}
    ${stackLines.join("\n    ")}`;
      }
      return base;
    });
  }
  getErrorLogs() {
    return this.logs.filter((log) => log.level === "error").map((log) => {
      const time = log.timestamp.toISOString();
      const base = `[${time}] [${log.context}] ${log.message}`;
      if (log.stack) {
        const stackLines = log.stack.split("\n").slice(0, 3);
        return `${base}
    ${stackLines.join("\n    ")}`;
      }
      return base;
    });
  }
  clearLogs() {
    this.logs = [];
  }
  unload() {
    console.log = this.originalConsoleLog;
    console.info = this.originalConsoleInfo;
    console.warn = this.originalConsoleWarn;
    console.error = this.originalConsoleError;
  }
};
var ErrorCollectorService = _ErrorCollectorService;
ErrorCollectorService.earlyLogs = [];

// src/main.ts
var import_obsidian110 = __toModule(require("obsidian"));
init_notifications();
init_types();
init_SystemSculptService();

// src/settings/SystemSculptSettingTab.ts
var import_obsidian48 = __toModule(require("obsidian"));
init_SystemSculptService();

// src/settings/SetupTabContent.ts
var import_obsidian21 = __toModule(require("obsidian"));

// src/modals/CustomProviderModal.ts
var import_obsidian20 = __toModule(require("obsidian"));
init_StandardModal();
var CustomProviderModal = class extends StandardModal {
  constructor(app, plugin, options) {
    super(app);
    this.plugin = plugin;
    this.options = options;
    this.isToggleEnabled = options.isEnabled !== void 0 ? options.isEnabled : true;
    this.modalEl.addClass("systemsculpt-custom-provider-modal");
  }
  onOpen() {
    super.onOpen();
    this.setSize("small");
    const isEditing = !!this.options.existingId;
    this.addTitle(isEditing ? "Edit Provider" : "Add Provider", isEditing ? "Update your API provider connection" : "Connect to a new API provider");
    this.createForm();
    this.addActionButton("Cancel", () => {
      if (this.options.onCancel) {
        this.options.onCancel();
      }
      this.close();
    }, false);
    this.addActionButton(isEditing ? "Update" : "Add Provider", () => {
      this.saveProvider();
    }, true);
  }
  createForm() {
    const formContainer = this.contentEl.createDiv("systemsculpt-custom-provider-form");
    if (!this.options.existingId) {
      this.createPresetSection(formContainer);
    }
    const nameGroup = formContainer.createDiv("systemsculpt-custom-provider-form-group");
    nameGroup.createEl("label", { text: "Provider Name" });
    this.nameInput = nameGroup.createEl("input", {
      type: "text",
      placeholder: "e.g., OpenAI, Anthropic, etc.",
      value: this.options.name || ""
    });
    const endpointGroup = formContainer.createDiv("systemsculpt-custom-provider-form-group");
    endpointGroup.createEl("label", { text: "API Endpoint" });
    this.endpointInput = endpointGroup.createEl("input", {
      type: "text",
      placeholder: "https://api.example.com/v1",
      value: this.options.endpoint || ""
    });
    const apiKeyGroup = formContainer.createDiv("systemsculpt-custom-provider-form-group");
    const apiKeyLabel = apiKeyGroup.createEl("label");
    apiKeyLabel.setText("API Key");
    const apiKeyContainer = apiKeyGroup.createDiv("systemsculpt-api-key-input-container");
    this.apiKeyInput = apiKeyContainer.createEl("input", {
      type: "password",
      placeholder: "Enter your API key",
      value: this.options.apiKey || ""
    });
    const showHideButton = apiKeyContainer.createEl("button", {
      cls: "mod-small systemsculpt-api-key-toggle-visibility",
      attr: { "aria-label": "Show/Hide API Key" }
    });
    (0, import_obsidian20.setIcon)(showHideButton, "eye-off");
    showHideButton.addEventListener("click", (e) => {
      e.preventDefault();
      if (this.apiKeyInput.type === "password") {
        this.apiKeyInput.type = "text";
        (0, import_obsidian20.setIcon)(showHideButton, "eye");
      } else {
        this.apiKeyInput.type = "password";
        (0, import_obsidian20.setIcon)(showHideButton, "eye-off");
      }
    });
    const updateApiKeyAppearance = () => {
      const name = this.nameInput.value.trim();
      const endpoint = this.endpointInput.value.trim().toLowerCase();
      const isLocal = endpoint.includes("localhost") || endpoint.includes("127.0.0.1");
      const isOptionalPreset = name === "Ollama" || name === "LM Studio";
      const isGenericCustom = name === "Custom Provider";
      const isEffectivelyOptional = isLocal || isOptionalPreset || isGenericCustom && !this.apiKeyInput.value;
      this.apiKeyInput.placeholder = isEffectivelyOptional ? "Enter your API key (optional)" : "Enter your API key";
      const currentOptionalSpan = apiKeyLabel.querySelector(".systemsculpt-optional-field-text");
      if (isEffectivelyOptional && !currentOptionalSpan) {
        apiKeyLabel.createSpan({
          text: " (optional)",
          cls: "systemsculpt-optional-field-text"
        });
      } else if (!isEffectivelyOptional && currentOptionalSpan) {
        currentOptionalSpan.remove();
      }
    };
    this.registerDomEvent(this.nameInput, "input", updateApiKeyAppearance);
    this.registerDomEvent(this.endpointInput, "input", updateApiKeyAppearance);
    updateApiKeyAppearance();
    const enabledGroup = formContainer.createDiv("systemsculpt-custom-provider-form-group systemsculpt-setting-item");
    const settingItemInfo = enabledGroup.createDiv("setting-item-info");
    settingItemInfo.createDiv({ text: "Enable Provider", cls: "setting-item-name" });
    settingItemInfo.createDiv({ text: "Make this provider available for use in the plugin.", cls: "setting-item-description" });
    const controlContainer = enabledGroup.createDiv("setting-item-control");
    this.providerToggleComponent = new import_obsidian20.ToggleComponent(controlContainer).setValue(this.isToggleEnabled).onChange((value) => {
      this.isToggleEnabled = value;
    });
  }
  createPresetSection(container) {
    const presetsSection = container.createDiv("systemsculpt-custom-provider-presets");
    presetsSection.createEl("label", { text: "Quick Setup" });
    const presetButtons = presetsSection.createDiv("systemsculpt-custom-provider-preset-buttons");
    this.createPresetButton(presetButtons, "OpenAI", "https://api.openai.com/v1", "sparkles");
    this.createPresetButton(presetButtons, "Anthropic", "https://api.anthropic.com/v1", "bot");
    this.createPresetButton(presetButtons, "OpenRouter", "https://openrouter.ai/api/v1", "network");
    this.createPresetButton(presetButtons, "Ollama", "http://localhost:11434/v1", "layers");
    this.createPresetButton(presetButtons, "LM Studio", "http://localhost:1234/v1", "cpu");
  }
  createPresetButton(container, name, endpoint, icon) {
    const buttonEl = container.createEl("button", {
      text: name,
      cls: "mod-small systemsculpt-preset-button"
    });
    const iconSpan = buttonEl.createSpan({ cls: "systemsculpt-preset-icon" });
    (0, import_obsidian20.setIcon)(iconSpan, icon);
    buttonEl.prepend(iconSpan);
    buttonEl.addEventListener("click", (e) => {
      e.preventDefault();
      this.nameInput.value = name;
      this.endpointInput.value = endpoint;
      this.nameInput.dispatchEvent(new Event("input"));
      this.endpointInput.dispatchEvent(new Event("input"));
      this.apiKeyInput.focus();
    });
  }
  saveProvider() {
    const name = this.nameInput.value.trim();
    const endpoint = this.endpointInput.value.trim();
    const apiKey = this.apiKeyInput.value.trim();
    if (!name) {
      this.showValidationError(this.nameInput, "Provider name is required");
      return;
    }
    if (!endpoint) {
      this.showValidationError(this.endpointInput, "API endpoint is required");
      return;
    }
    const isLocal = endpoint.toLowerCase().includes("localhost") || endpoint.toLowerCase().includes("127.0.0.1");
    const isOptionalPreset = name === "Ollama" || name === "LM Studio";
    const isGenericCustom = name === "Custom Provider";
    const isApiKeyEffectivelyOptional = isLocal || isOptionalPreset || isGenericCustom;
    if (!apiKey && !isApiKeyEffectivelyOptional) {
      this.showValidationError(this.apiKeyInput, "API key is required for this provider/endpoint");
      return;
    }
    const existingProviders = this.plugin.settings.customProviders || [];
    const otherProviders = this.options.existingId ? existingProviders.filter((p) => p.id !== this.options.existingId) : existingProviders;
    const duplicateName = otherProviders.find((p) => p.name.toLowerCase() === name.toLowerCase());
    if (duplicateName) {
      this.showValidationError(this.nameInput, `A provider with the name "${name}" already exists`);
      return;
    }
    const commonLocalEndpoints = ["http://localhost:11434/v1", "http://localhost:1234/v1"];
    if (!commonLocalEndpoints.includes(endpoint.toLowerCase())) {
      const duplicateEndpoint = otherProviders.find((p) => p.endpoint.toLowerCase() === endpoint.toLowerCase());
      if (duplicateEndpoint) {
        this.showValidationError(this.endpointInput, `A provider with this endpoint already exists`);
        return;
      }
    }
    const provider = {
      id: this.options.existingId || `custom-${name.toLowerCase().replace(/\s+/g, "-")}-${Date.now()}`,
      name,
      endpoint,
      apiKey,
      isEnabled: this.isToggleEnabled
    };
    this.options.onSave(provider);
    this.close();
  }
  showValidationError(inputEl, message) {
    const formGroup = inputEl.closest(".systemsculpt-custom-provider-form-group");
    if (!formGroup)
      return;
    formGroup.addClass("error");
    let validationEl = formGroup.querySelector(".systemsculpt-custom-provider-form-validation");
    if (!validationEl) {
      validationEl = formGroup.createDiv({ cls: "systemsculpt-custom-provider-form-validation" });
    }
    validationEl.textContent = message;
    inputEl.focus();
    const clearError = () => {
      formGroup.removeClass("error");
      if (validationEl) {
        validationEl.remove();
      }
      inputEl.removeEventListener("input", clearError);
    };
    this.registerDomEvent(inputEl, "input", clearError);
  }
};
function showCustomProviderModal(app, plugin, options) {
  return new Promise((resolve) => {
    const modal = new CustomProviderModal(app, plugin, {
      ...options,
      onSave: (provider) => {
        resolve(provider);
      },
      onCancel: () => {
        resolve(null);
      }
    });
    modal.open();
  });
}

// src/settings/SetupTabContent.ts
init_licenseUtils();

// src/constants/credits.ts
var SYSTEMSCULPT_URLS = {
  CREDITS: "https://systemsculpt.com/credits",
  LIFETIME: "https://systemsculpt.com/lifetime",
  MONTHLY: "https://systemsculpt.com/resources/a05a7abf-b8bb-41cf-9190-8b795d117fda"
};
var CREDIT_MESSAGES = {
  ADDITIONAL_CREDITS_TOOLTIP: "Additional credits are purchased credits that never expire and roll over indefinitely. Unlike monthly credits that reset each month, additional credits persist until used.",
  LOADING: "Loading credits...",
  UNAVAILABLE: "No credit information available",
  FETCH_ERROR: "Unable to fetch credit balance"
};

// src/settings/SetupTabContent.ts
async function openCustomProviderSetup(tabInstance, name, endpoint, existingId, apiKey, isEnabled) {
  const { app, plugin } = tabInstance;
  const provider = await showCustomProviderModal(app, plugin, {
    name,
    endpoint,
    existingId,
    apiKey,
    isEnabled: existingId ? isEnabled : true
  });
  if (provider) {
    let updatedProviders = [...plugin.settings.customProviders];
    if (existingId) {
      updatedProviders = updatedProviders.map((p) => p.id === existingId ? provider : p);
    } else {
      updatedProviders.push(provider);
    }
    await plugin.getSettingsManager().updateSettings({ customProviders: updatedProviders });
    new import_obsidian21.Notice(`${existingId ? "Updated" : "Added"} ${provider.name} provider.`, 3e3);
    if (provider.isEnabled) {
      try {
        plugin.customProviderService.clearCache();
        await plugin.modelService.refreshModels();
        new import_obsidian21.Notice(`\u2705 ${provider.name} provider is ready and models have been loaded.`, 5e3);
      } catch (error) {
        console.error(`Failed to refresh models for ${provider.name}:`, error);
        new import_obsidian21.Notice(`\u26A0\uFE0F ${provider.name} provider added but model refresh failed. Check your credentials and connection.`, 8e3);
      }
    }
    tabInstance.display();
  }
}
function displayCreditBreakdown(containerEl, tabInstance) {
  console.log("[SystemSculpt] displayCreditBreakdown called - NEW FUNCTION!");
  try {
    containerEl.setText(CREDIT_MESSAGES.LOADING);
    tabInstance.systemSculptService.getCreditBreakdown().then((breakdown) => {
      console.log("[SystemSculpt] Credit breakdown received:", breakdown);
      if (breakdown) {
        containerEl.empty();
        const creditContainer = containerEl.createDiv("systemsculpt-credit-display-container");
        creditContainer.createSpan({
          text: `Credits: ${formatCreditsDisplay(breakdown.total)} (${formatCreditsDisplay(breakdown.monthly)} monthly, ${formatCreditsDisplay(breakdown.additional)} additional)`,
          cls: "systemsculpt-credit-breakdown-text"
        });
      } else {
        containerEl.setText(CREDIT_MESSAGES.UNAVAILABLE);
      }
    }).catch((error) => {
      tabInstance.systemSculptService.getTokenBalance().then((balance) => {
        containerEl.setText(`Available Credits: ${formatCreditsDisplay(balance)}`);
      }).catch((fallbackError) => {
        containerEl.setText(CREDIT_MESSAGES.FETCH_ERROR);
        console.error("Failed to fetch credit breakdown and balance:", error, fallbackError);
      });
    });
  } catch (error) {
    containerEl.setText(CREDIT_MESSAGES.FETCH_ERROR);
    console.error("Failed to fetch credit breakdown:", error);
  }
}
function createProStatusSection(licenseSection, tabInstance) {
  const { plugin } = tabInstance;
  const userStatus = checkPremiumUserStatus(plugin.settings);
  const statusSetting = new import_obsidian21.Setting(licenseSection).setName("Pro Status").setDesc(userStatus.greeting || "Active subscription \u2022 Premium features enabled");
  statusSetting.nameEl.createSpan({
    cls: "systemsculpt-pro-badge",
    text: "ACTIVE"
  });
  const balanceEl = createSpan({
    cls: "systemsculpt-token-balance-value",
    text: "Loading..."
  });
  statusSetting.addExtraButton((button) => {
    button.setIcon("sparkles").setTooltip("Available credits").setDisabled(true);
    statusSetting.controlEl.appendChild(balanceEl);
  });
  displayCreditBreakdown(balanceEl, tabInstance);
}
function displayProPromotionSection(containerEl, isProActive) {
  if (!isProActive) {
    const proPromotionEl = containerEl.createEl("div", {
      cls: "systemsculpt-pro-promotion-redesigned"
    });
    const headerSection = proPromotionEl.createEl("div", {
      cls: "systemsculpt-pro-header-section"
    });
    const headerContent = headerSection.createEl("div", {
      cls: "systemsculpt-pro-header-content"
    });
    const titleRow = headerContent.createEl("div", {
      cls: "systemsculpt-pro-title-row"
    });
    const proBadge = titleRow.createEl("div", {
      cls: "systemsculpt-pro-badge-large"
    });
    proBadge.createEl("span", { text: "\u2728" });
    proBadge.createEl("span", { text: "PRO", cls: "pro-badge-text" });
    titleRow.createEl("h2", {
      text: "Unlock the Full Power of SystemSculpt",
      cls: "systemsculpt-pro-title"
    });
    headerContent.createEl("p", {
      text: "Transform your Obsidian workflow with advanced AI capabilities, premium features, and dedicated support.",
      cls: "systemsculpt-pro-subtitle"
    });
    const contentSection = proPromotionEl.createEl("div", {
      cls: "systemsculpt-pro-content-section"
    });
    const featuresGrid = contentSection.createEl("div", {
      cls: "systemsculpt-pro-features-grid"
    });
    const features = [
      { icon: "\u{1F399}\uFE0F", title: "Audio Recording", desc: "Record and transcribe audio instantly" },
      { icon: "\u{1F4C4}", title: "Document Processing", desc: "Extract text from PDFs and images" },
      { icon: "\u{1F5E3}\uFE0F", title: "Voice-to-Text", desc: "Real-time transcription in notes & chat" },
      { icon: "\u{1F916}", title: "AI Templates", desc: "Custom prompts and personalities" },
      { icon: "\u{1F680}", title: "Early Access", desc: "Priority access to new features" },
      { icon: "\u{1F4AC}", title: "1-on-1 Support", desc: "Personal session with Mike" }
    ];
    features.forEach((feature) => {
      const featureCard = featuresGrid.createEl("div", {
        cls: "systemsculpt-pro-feature-card"
      });
      featureCard.createEl("div", {
        text: feature.icon,
        cls: "systemsculpt-pro-feature-icon"
      });
      featureCard.createEl("h4", {
        text: feature.title,
        cls: "systemsculpt-pro-feature-title"
      });
      featureCard.createEl("p", {
        text: feature.desc,
        cls: "systemsculpt-pro-feature-desc"
      });
    });
    const pricingSection = contentSection.createEl("div", {
      cls: "systemsculpt-pro-pricing-section"
    });
    pricingSection.createEl("h3", {
      text: "Choose Your Plan",
      cls: "systemsculpt-pro-pricing-title"
    });
    const pricingCards = pricingSection.createEl("div", {
      cls: "systemsculpt-pro-pricing-cards"
    });
    const monthlyCard = pricingCards.createEl("div", {
      cls: "systemsculpt-pro-pricing-card"
    });
    monthlyCard.createEl("h4", {
      text: "Monthly",
      cls: "systemsculpt-pro-plan-name"
    });
    const monthlyPrice = monthlyCard.createEl("div", {
      cls: "systemsculpt-pro-price"
    });
    monthlyPrice.createEl("span", { text: "$", cls: "currency" });
    monthlyPrice.createEl("span", { text: "19", cls: "amount" });
    monthlyPrice.createEl("span", { text: "/month", cls: "period" });
    monthlyCard.createEl("p", {
      text: "Flexible monthly subscription",
      cls: "systemsculpt-pro-plan-desc"
    });
    const monthlyButton = monthlyCard.createEl("button", {
      text: "Get Monthly",
      cls: "systemsculpt-pro-cta-button"
    });
    monthlyButton.addEventListener("click", () => {
      window.open(SYSTEMSCULPT_URLS.MONTHLY, "_blank");
    });
    const lifetimeCard = pricingCards.createEl("div", {
      cls: "systemsculpt-pro-pricing-card featured"
    });
    const popularBadge = lifetimeCard.createEl("div", {
      text: "MOST POPULAR",
      cls: "systemsculpt-pro-popular-badge"
    });
    lifetimeCard.createEl("h4", {
      text: "Lifetime",
      cls: "systemsculpt-pro-plan-name"
    });
    const lifetimePrice = lifetimeCard.createEl("div", {
      cls: "systemsculpt-pro-price"
    });
    lifetimePrice.createEl("span", { text: "$", cls: "currency" });
    lifetimePrice.createEl("span", { text: "249", cls: "amount" });
    lifetimePrice.createEl("span", { text: " one-time", cls: "period" });
    lifetimeCard.createEl("p", {
      text: "Best value + 1:1 session with Mike",
      cls: "systemsculpt-pro-plan-desc"
    });
    const lifetimeButton = lifetimeCard.createEl("button", {
      text: "Get Lifetime Access",
      cls: "systemsculpt-pro-cta-button featured"
    });
    lifetimeButton.addEventListener("click", () => {
      window.open(SYSTEMSCULPT_URLS.LIFETIME, "_blank");
    });
    const trustSection = contentSection.createEl("div", {
      cls: "systemsculpt-pro-trust-section"
    });
    const trustIndicators = trustSection.createEl("div", {
      cls: "systemsculpt-pro-trust-indicators"
    });
    const indicators = [
      "\u{1F512} Secure payment via Stripe",
      "\u2705 30-day money-back guarantee",
      "\u{1F31F} Join 1000+ pro users"
    ];
    indicators.forEach((indicator) => {
      trustIndicators.createEl("span", {
        text: indicator,
        cls: "systemsculpt-pro-trust-item"
      });
    });
  }
}
function createLicenseKeyField(licenseSection, tabInstance, isProActive) {
  const { plugin } = tabInstance;
  let licenseKeyTextComponent = null;
  new import_obsidian21.Setting(licenseSection).setName("License Key").setDesc("Support development and unlock premium features").addText((text) => {
    licenseKeyTextComponent = text;
    text.setPlaceholder("Paste license key").setValue(plugin.settings.licenseKey).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ licenseKey: value });
    }).inputEl.addClass("systemsculpt-license-input");
    text.inputEl.type = "password";
    text.inputEl.style.fontFamily = "monospace";
    tabInstance.registerListener(text.inputEl, "focus", () => {
      text.inputEl.type = "text";
      text.inputEl.style.fontFamily = "inherit";
    });
    tabInstance.registerListener(text.inputEl, "blur", () => {
      text.inputEl.type = "password";
      text.inputEl.style.fontFamily = "monospace";
    });
    return text;
  }).addToggle((toggle) => {
    toggle.setValue(isProActive).setTooltip(isProActive ? "Disable Pro features" : "Enable Pro features").onChange(async (value) => {
      toggle.setDisabled(true);
      let noticeMessage = "";
      const noticeDuration = 4e3;
      let validationSuccessful = false;
      try {
        if (value) {
          let keyFromInput = "";
          if (licenseKeyTextComponent) {
            keyFromInput = licenseKeyTextComponent.getValue().trim();
          }
          if (!keyFromInput) {
            noticeMessage = "Please enter a license key first.";
            if (plugin.settings.licenseValid) {
              await plugin.getSettingsManager().updateSettings({ licenseValid: false });
            }
            validationSuccessful = false;
          } else {
            await plugin.getSettingsManager().updateSettings({ licenseKey: keyFromInput });
            console.log(`[SystemSculpt] SetupTabContent: Validating key from settings: '${plugin.settings.licenseKey}' (should match input: '${keyFromInput}')`);
            const validatingNotice = new import_obsidian21.Notice("Validating license key...", 0);
            try {
              validationSuccessful = await plugin.getLicenseManager().validateLicenseKey(true, false);
              validatingNotice.hide();
              if (validationSuccessful) {
                noticeMessage = "\u2705 License key validated successfully! Pro features activated.";
              } else {
                noticeMessage = "Invalid license key. Please check your key and try again.";
              }
            } catch (error) {
              validatingNotice.hide();
              console.error("License validation error:", error);
              noticeMessage = `Failed to validate license: ${error.message || "Unknown error"}`;
              if (plugin.settings.licenseValid) {
                await plugin.getSettingsManager().updateSettings({ licenseValid: false });
              }
              validationSuccessful = false;
            }
          }
        } else {
          await plugin.getSettingsManager().updateSettings({ licenseValid: false });
          noticeMessage = "Pro features deactivated.";
          validationSuccessful = false;
        }
      } finally {
        tabInstance.display();
        if (noticeMessage) {
          new import_obsidian21.Notice(noticeMessage, noticeDuration);
        }
      }
    });
    if (isProActive) {
      toggle.toggleEl.addClass("mod-cta");
    }
  });
}
function displaySetupTabContent(containerEl, tabInstance, isProActive) {
  containerEl.empty();
  containerEl.dataset.tab = "setup";
  const { plugin } = tabInstance;
  const setupContainer = containerEl.createDiv("systemsculpt-setup-settings");
  const apiConnectionSection = setupContainer.createDiv("systemsculpt-api-connection-section");
  apiConnectionSection.createEl("h3", {
    text: "Connect with your API Keys"
  });
  apiConnectionSection.createEl("p", {
    text: "The SystemSculpt provider (shown first) is automatically enabled with a valid license key, giving you direct access to SystemSculpt's cloud models. You can also add and manage other custom model providers below.",
    cls: "systemsculpt-setup-section-description"
  });
  const activeProvidersContainer = apiConnectionSection.createDiv("systemsculpt-active-providers");
  activeProvidersContainer.createEl("h4", {
    text: "Your Active Providers",
    cls: "systemsculpt-active-providers-heading"
  });
  const systemSculptProviderClasses = isProActive ? "systemsculpt-provider-card systemsculpt-native-provider-card systemsculpt-primary-provider-active systemsculpt-compact-provider" : "systemsculpt-provider-card systemsculpt-native-provider-card systemsculpt-compact-provider";
  const systemSculptProviderSection = activeProvidersContainer.createDiv(systemSculptProviderClasses);
  if (isProActive) {
    const primaryHeader = systemSculptProviderSection.createDiv("systemsculpt-primary-provider-header-compact");
    primaryHeader.createSpan({
      cls: "systemsculpt-primary-provider-badge-compact",
      text: "\u2B50 PRIMARY"
    });
  }
  if (isProActive) {
    const settingsGrid = systemSculptProviderSection.createDiv("systemsculpt-provider-settings-grid");
    const enableToggleSetting = new import_obsidian21.Setting(settingsGrid).setName("SystemSculpt Models").setDesc("Enable SystemSculpt models in dropdown").addToggle((toggle) => {
      toggle.setValue(plugin.settings.enableSystemSculptProvider).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ enableSystemSculptProvider: value });
        plugin.customProviderService.clearCache();
        await plugin.modelService.refreshModels();
        new import_obsidian21.Notice(`SystemSculpt models ${value ? "enabled" : "disabled"}`);
      });
    });
    if (plugin.settings.enableSystemSculptProvider) {
      const toggleElement = enableToggleSetting.controlEl.querySelector(".checkbox-container");
      if (toggleElement) {
        toggleElement.addClass("systemsculpt-primary-toggle");
      }
    }
    new import_obsidian21.Setting(settingsGrid).setName("Use as Fallback").setDesc("Use SystemSculpt when other providers fail").addToggle((toggle) => {
      toggle.setValue(plugin.settings.useSystemSculptAsFallback === true).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ useSystemSculptAsFallback: value });
        new import_obsidian21.Notice(`SystemSculpt as fallback provider ${value ? "enabled" : "disabled"}`);
      });
    });
  }
  if (!isProActive) {
    const guidance = systemSculptProviderSection.createEl("div", {
      cls: "systemsculpt-license-guidance"
    });
    guidance.createEl("div", {
      text: "Choose one option to get started:",
      cls: "systemsculpt-guidance-header"
    });
    const option1 = guidance.createEl("div", { cls: "systemsculpt-guidance-option" });
    option1.createSpan({ text: "Option A: ", cls: "systemsculpt-option-label" });
    option1.createSpan({ text: "Get a SystemSculpt license (premium models, no API keys needed)" });
    const divider = guidance.createEl("div", { cls: "systemsculpt-option-divider" });
    divider.createSpan({ text: "\u2014 OR \u2014" });
    const option2 = guidance.createEl("div", { cls: "systemsculpt-guidance-option" });
    option2.createSpan({ text: "Option B: ", cls: "systemsculpt-option-label" });
    option2.createSpan({ text: "Use your own API keys with providers below" });
  }
  const oneClickContainer = apiConnectionSection.createDiv("systemsculpt-one-click-container");
  oneClickContainer.createEl("h4", {
    text: "Quick Model Provider Setup",
    cls: "systemsculpt-one-click-heading"
  });
  const buttonsContainer = oneClickContainer.createDiv("systemsculpt-one-click-buttons");
  const openaiButtonContainer = buttonsContainer.createDiv();
  new import_obsidian21.ButtonComponent(openaiButtonContainer).setIcon("sparkles").setButtonText("OpenAI").onClick(() => {
    openCustomProviderSetup(tabInstance, "OpenAI", "https://api.openai.com/v1");
  });
  const anthropicButtonContainer = buttonsContainer.createDiv();
  new import_obsidian21.ButtonComponent(anthropicButtonContainer).setIcon("bot").setButtonText("Anthropic").onClick(() => {
    openCustomProviderSetup(tabInstance, "Anthropic", "https://api.anthropic.com/v1");
  });
  const openRouterButtonContainer = buttonsContainer.createDiv();
  new import_obsidian21.ButtonComponent(openRouterButtonContainer).setIcon("network").setButtonText("OpenRouter").onClick(() => {
    openCustomProviderSetup(tabInstance, "OpenRouter", "https://openrouter.ai/api/v1");
  });
  const ollamaButtonContainer = buttonsContainer.createDiv();
  new import_obsidian21.ButtonComponent(ollamaButtonContainer).setIcon("layers").setButtonText("Ollama (Local)").onClick(() => {
    openCustomProviderSetup(tabInstance, "Ollama", "http://localhost:11434/v1");
  });
  const lmStudioButtonContainer = buttonsContainer.createDiv();
  new import_obsidian21.ButtonComponent(lmStudioButtonContainer).setIcon("cpu").setButtonText("LM Studio (Local)").onClick(() => {
    openCustomProviderSetup(tabInstance, "LM Studio", "http://localhost:1234/v1");
  });
  const addProviderButtonContainerQuick = buttonsContainer.createDiv();
  new import_obsidian21.ButtonComponent(addProviderButtonContainerQuick).setIcon("plus").setButtonText("Add Custom Provider").setCta().onClick(() => {
    openCustomProviderSetup(tabInstance, "Custom Provider", "");
  });
  const customProvidersSection = apiConnectionSection.createDiv("systemsculpt-custom-providers-section");
  customProvidersSection.createEl("h4", {
    text: "Custom Model Providers",
    cls: "systemsculpt-custom-providers-header"
  });
  const activeProvidersList = customProvidersSection.createDiv("systemsculpt-active-providers-list");
  if (!plugin.settings.customProviders || plugin.settings.customProviders.length === 0) {
    activeProvidersList.createEl("p", {
      text: "No custom model providers configured yet. Use the Quick Setup buttons above to get started.",
      cls: "systemsculpt-no-providers-message"
    });
  } else {
    plugin.settings.customProviders.forEach((provider) => {
      const providerCard = activeProvidersList.createDiv("systemsculpt-provider-card");
      const providerHeader = providerCard.createDiv("systemsculpt-provider-header");
      providerHeader.createEl("h5", { text: provider.name });
      const statusContainer = providerHeader.createDiv("systemsculpt-provider-status-container");
      let statusText;
      let statusClass;
      if (provider.isEnabled) {
        statusText = "Enabled";
        statusClass = "enabled";
      } else if ((provider.failureCount || 0) >= 3) {
        statusText = "Auto-disabled";
        statusClass = "auto-disabled";
      } else {
        statusText = "Disabled";
        statusClass = "disabled";
      }
      statusContainer.createSpan({
        cls: `systemsculpt-provider-status ${statusClass}`,
        text: statusText
      });
      new import_obsidian21.ToggleComponent(statusContainer).setValue(provider.isEnabled).setTooltip(provider.isEnabled ? "Disable Provider" : "Enable Provider").onChange(async (value) => {
        if (!value) {
          provider.isEnabled = false;
          const updatedProviders = plugin.settings.customProviders.map((p) => p.id === provider.id ? provider : p);
          await plugin.getSettingsManager().updateSettings({ customProviders: updatedProviders });
          plugin.customProviderService.clearCache();
          await plugin.modelService.refreshModels();
          tabInstance.display();
          new import_obsidian21.Notice(`${provider.name} disabled.`);
          return;
        }
        const enablingNotice = new import_obsidian21.Notice(`Testing connection to ${provider.name}...`, 0);
        const result = await plugin.customProviderService.testConnection(provider);
        enablingNotice.hide();
        if (result.success) {
          provider.isEnabled = true;
          provider.failureCount = 0;
          delete provider.lastFailureTime;
          const updatedProviders = plugin.settings.customProviders.map((p) => p.id === provider.id ? provider : p);
          await plugin.getSettingsManager().updateSettings({ customProviders: updatedProviders });
          plugin.customProviderService.clearCache();
          await plugin.modelService.refreshModels();
          tabInstance.display();
          new import_obsidian21.Notice(`${provider.name} enabled successfully!`);
        } else {
          new import_obsidian21.Notice(`Failed to enable ${provider.name}: ${result.error || "Connection failed"}`, 5e3);
          tabInstance.display();
        }
      });
      const providerDetails = providerCard.createDiv("systemsculpt-provider-details");
      providerDetails.createEl("div", {
        text: `Endpoint: ${provider.endpoint}`,
        cls: "systemsculpt-provider-endpoint"
      });
      if (provider.apiKey) {
        const apiKeyField = providerDetails.createEl("div", {
          cls: "systemsculpt-provider-api-key"
        });
        apiKeyField.createSpan({ text: "API Key: " });
        const maskedKey = provider.apiKey.substring(0, 3) + "..." + provider.apiKey.substring(provider.apiKey.length - 3);
        apiKeyField.createSpan({ text: maskedKey, cls: "systemsculpt-masked-api-key" });
      }
      if (provider.lastTested) {
        const lastTested = new Date(provider.lastTested);
        providerDetails.createEl("div", {
          text: `Last tested: ${lastTested.toLocaleString()}`,
          cls: "systemsculpt-provider-last-tested"
        });
      }
      if ((provider.failureCount || 0) >= 3 && !provider.isEnabled) {
        const failureInfo = providerDetails.createEl("div", {
          cls: "systemsculpt-provider-failure-info"
        });
        failureInfo.createSpan({
          text: `Auto-disabled after ${provider.failureCount} connection failures`,
          cls: "systemsculpt-failure-text"
        });
        if (provider.lastFailureTime) {
          const lastFailure = new Date(provider.lastFailureTime);
          failureInfo.createEl("br");
          failureInfo.createSpan({
            text: `Last failure: ${lastFailure.toLocaleString()}`,
            cls: "systemsculpt-failure-timestamp"
          });
        }
      }
      const providerActions = providerCard.createDiv("systemsculpt-provider-actions");
      const testButtonContainer = providerActions.createDiv();
      const testButton = new import_obsidian21.ButtonComponent(testButtonContainer);
      testButton.setButtonText("Test");
      testButton.onClick(async () => {
        var _a;
        testButton.setButtonText("Testing...");
        testButton.setDisabled(true);
        const result = await plugin.customProviderService.testConnection(provider);
        provider.lastTested = Date.now();
        const updatedProviders = plugin.settings.customProviders.map((p) => p.id === provider.id ? provider : p);
        await plugin.getSettingsManager().updateSettings({ customProviders: updatedProviders });
        testButton.setButtonText("Test");
        testButton.setDisabled(false);
        if (result.success) {
          new import_obsidian21.Notice(`Connection to ${provider.name} successful! Found ${((_a = result.models) == null ? void 0 : _a.length) || 0} models.`);
          tabInstance.display();
        } else {
          new import_obsidian21.Notice(`Failed to connect to ${provider.name}: ${result.error || "Unknown error"}`);
        }
      });
      const editButtonContainer = providerActions.createDiv();
      const editButton = new import_obsidian21.ButtonComponent(editButtonContainer);
      editButton.setButtonText("Edit");
      editButton.onClick(() => {
        openCustomProviderSetup(tabInstance, provider.name, provider.endpoint, provider.id, provider.apiKey, provider.isEnabled);
      });
      const deleteButtonContainer = providerActions.createDiv();
      const deleteButton = new import_obsidian21.ButtonComponent(deleteButtonContainer);
      deleteButton.setButtonText("Delete");
      deleteButton.setWarning();
      deleteButton.onClick((e) => {
        if (confirm(`Are you sure you want to delete the provider "${provider.name}"?`)) {
          const updatedProviders = plugin.settings.customProviders.filter((p) => p.id !== provider.id);
          plugin.getSettingsManager().updateSettings({ customProviders: updatedProviders }).then(() => {
            new import_obsidian21.Notice(`Deleted provider: ${provider.name}`, 3e3);
            tabInstance.display();
            setTimeout(() => {
              plugin.customProviderService.clearCache();
              plugin.modelService.refreshModels();
            }, 100);
          });
        }
      });
    });
  }
  setupContainer.createEl("hr", { cls: "systemsculpt-settings-section-divider" });
  const licenseSection = setupContainer.createDiv("systemsculpt-license-section");
  licenseSection.createEl("h3", {
    text: "Premium Features (Optional)"
  });
  licenseSection.createEl("p", {
    text: "Optionally support development and unlock premium features with a SystemSculpt license.",
    cls: "systemsculpt-setup-section-description systemsculpt-license-description"
  });
  createLicenseKeyField(licenseSection, tabInstance, isProActive);
  if (isProActive) {
    createProStatusSection(licenseSection, tabInstance);
  }
  if (!isProActive) {
    displayProPromotionSection(licenseSection, false);
  }
}

// src/settings/DirectoriesTabContent.ts
var import_obsidian23 = __toModule(require("obsidian"));
init_FolderSuggester();
init_ui();
var import_obsidian24 = __toModule(require("obsidian"));
function validateDirectory(path) {
  if (!path)
    return true;
  return !path.includes("..") && !path.startsWith("/") && !path.startsWith("\\");
}
async function handleDirectoryChange(tabInstance, value, settingKey, createFolder = false) {
  const { app, plugin } = tabInstance;
  if (!validateDirectory(value)) {
    showPopup(app, "Invalid directory path. Please use relative paths without '..' or leading slashes.");
    return;
  }
  await plugin.getSettingsManager().updateSettings({ [settingKey]: value });
  if (createFolder && plugin.directoryManager) {
    try {
      await plugin.directoryManager.handleDirectorySettingChange(settingKey, value);
    } catch (error) {
      console.warn(`[SystemSculpt] Failed to update directory for ${settingKey}:`, error);
    }
  }
}
function createDirectorySetting(containerEl, tabInstance, name, desc, settingKey, placeholder) {
  const { app, plugin } = tabInstance;
  new import_obsidian23.Setting(containerEl).setName(name).setDesc(desc).addText((text) => {
    text.setPlaceholder(placeholder).setValue(plugin.settings[settingKey]).onChange(async (value) => {
      await handleDirectoryChange(tabInstance, value, settingKey, false);
    });
    text.inputEl.addEventListener("blur", async () => {
      const value = text.inputEl.value;
      if (value && value !== plugin.settings[settingKey]) {
        await handleDirectoryChange(tabInstance, value, settingKey, true);
      }
    });
    attachFolderSuggester(text.inputEl, async (selectedPath) => {
      if (validateDirectory(selectedPath)) {
        text.setValue(selectedPath);
        await handleDirectoryChange(tabInstance, selectedPath, settingKey, true);
      } else {
        showPopup(app, "Invalid directory path. Please use relative paths without '..' or leading slashes.");
      }
    }, app);
    return text;
  });
}
function displayDirectoriesTabContent(containerEl, tabInstance) {
  containerEl.empty();
  containerEl.dataset.tab = "directories";
  const { plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Directory Settings" });
  createDirectorySetting(containerEl, tabInstance, "Chats Directory", "Select the directory for your chat history", "chatsDirectory", "Path relative to vault root (empty = SystemSculpt/Chats)");
  createDirectorySetting(containerEl, tabInstance, "Saved Chats Directory", 'Select the directory where notes created via "Save chat as note" are stored', "savedChatsDirectory", "Path relative to vault root (empty = SystemSculpt/Saved Chats)");
  createDirectorySetting(containerEl, tabInstance, "Recordings Directory", "Select the directory for your recordings", "recordingsDirectory", "Path relative to vault root (empty = SystemSculpt/Recordings)");
  createDirectorySetting(containerEl, tabInstance, "System Prompts Directory", "Select the directory for your custom system prompts", "systemPromptsDirectory", "Path relative to vault root (empty = SystemSculpt/System Prompts)");
  createDirectorySetting(containerEl, tabInstance, "Attachments Directory", "Select the directory for saved images and attachments", "attachmentsDirectory", "Path relative to vault root (empty = Attachments)");
  createDirectorySetting(containerEl, tabInstance, "Extractions Directory", "Select the directory where extracted PDFs/docs will be placed", "extractionsDirectory", "Path relative to vault root (empty = file's parent folder)");
  containerEl.createEl("h3", { text: "Directory Diagnostics" });
  const diagnosticsEl = containerEl.createDiv({ cls: "systemsculpt-diagnostics-section" });
  const infoEl = diagnosticsEl.createDiv({ cls: "systemsculpt-info" });
  infoEl.createSpan({
    text: "If you're experiencing issues with SystemSculpt directories not showing up in Obsidian, you can use the tools below to diagnose and fix the problems."
  });
  const verifyButtonContainer = diagnosticsEl.createDiv({ cls: "systemsculpt-button-container" });
  const verifyButton = new import_obsidian24.ButtonComponent(verifyButtonContainer);
  verifyButton.setButtonText("Verify Directories");
  const repairButtonContainer = diagnosticsEl.createDiv({ cls: "systemsculpt-button-container" });
  const repairButton = new import_obsidian24.ButtonComponent(repairButtonContainer);
  repairButton.setButtonText("Repair Directory Structure");
  repairButton.setCta();
  const resultsContainer = diagnosticsEl.createDiv({
    cls: "systemsculpt-diagnostics-results",
    attr: { style: "display: none;" }
  });
  verifyButton.onClick(async () => {
    resultsContainer.empty();
    resultsContainer.style.display = "block";
    resultsContainer.createDiv({ text: "Checking directories...", cls: "systemsculpt-checking" });
    try {
      const result = await plugin.checkDirectoryHealth();
      resultsContainer.empty();
      if (result.valid) {
        const successEl = resultsContainer.createDiv({ cls: "systemsculpt-success" });
        successEl.createSpan({ text: "\u2713 All directories are properly configured and accessible." });
      } else {
        const issuesEl = resultsContainer.createDiv({ cls: "systemsculpt-issues" });
        issuesEl.createEl("h4", { text: "Issues Found:" });
        const issuesList = issuesEl.createEl("ul");
        result.issues.forEach((issue) => {
          issuesList.createEl("li", { text: issue });
        });
        const helpEl = issuesEl.createDiv({ cls: "systemsculpt-help-text" });
        helpEl.createSpan({
          text: "Click 'Repair Directory Structure' to attempt to fix these issues automatically."
        });
      }
    } catch (error) {
      resultsContainer.empty();
      const errorEl = resultsContainer.createDiv({ cls: "systemsculpt-error" });
      errorEl.createSpan({ text: `Error during verification: ${error.message}` });
    }
  });
  repairButton.onClick(async () => {
    resultsContainer.empty();
    resultsContainer.style.display = "block";
    resultsContainer.createDiv({ text: "Repairing directories...", cls: "systemsculpt-checking" });
    try {
      const success = await plugin.repairDirectoryStructure();
      resultsContainer.empty();
      if (success) {
        const successEl = resultsContainer.createDiv({ cls: "systemsculpt-success" });
        successEl.createSpan({ text: "\u2713 Directory structure has been repaired successfully." });
        successEl.createEl("p", {
          text: "Restart Obsidian for changes to fully take effect.",
          cls: "systemsculpt-restart-note"
        });
      } else {
        const errorEl = resultsContainer.createDiv({ cls: "systemsculpt-error" });
        errorEl.createSpan({ text: "Failed to repair directory structure. Check console for details." });
      }
    } catch (error) {
      resultsContainer.empty();
      const errorEl = resultsContainer.createDiv({ cls: "systemsculpt-error" });
      errorEl.createSpan({ text: `Error during repair: ${error.message}` });
    }
  });
}

// src/settings/RecorderTabContent.ts
var import_obsidian25 = __toModule(require("obsidian"));
init_MobileDetection();
function displayRecorderTabContent(containerEl, tabInstance) {
  containerEl.empty();
  containerEl.dataset.tab = "recorder";
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Recording Settings" });
  const modelSettingsNote = containerEl.createEl("p", {
    text: '\u{1F4A1} To configure the post-processing model, visit the "Model Settings" tab.',
    cls: "setting-item-description systemsculpt-model-settings-note"
  });
  const microphoneSetting = new import_obsidian25.Setting(containerEl).setName("Preferred Microphone").setDesc("Select your preferred microphone for recordings");
  const microphoneContainer = microphoneSetting.controlEl.createDiv({
    cls: "systemsculpt-microphone-container"
  });
  const micSelect = microphoneContainer.createEl("select", {
    cls: "systemsculpt-microphone-select"
  });
  micSelect.createEl("option", {
    value: "",
    text: "Loading microphones..."
  }).setAttribute("disabled", "true");
  micSelect.disabled = true;
  const refreshButton = new import_obsidian25.ButtonComponent(microphoneContainer).setIcon("refresh-cw").setTooltip("Refresh microphone list").onClick(() => {
    loadMicrophoneList();
  });
  async function loadMicrophoneList() {
    try {
      micSelect.innerHTML = "";
      micSelect.createEl("option", {
        value: "",
        text: "Loading microphones..."
      }).setAttribute("disabled", "true");
      micSelect.disabled = true;
      const devices = await navigator.mediaDevices.enumerateDevices();
      const hasMicrophoneLabels = devices.some((device) => device.kind === "audioinput" && device.label);
      if (!hasMicrophoneLabels) {
        micSelect.innerHTML = "";
        micSelect.createEl("option", {
          value: "",
          text: "Requesting microphone access..."
        }).setAttribute("disabled", "true");
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach((track) => track.stop());
          new import_obsidian25.Notice("Microphone access granted. Loading microphone list...");
        } catch (error) {
          console.error("Microphone access denied:", error);
          micSelect.innerHTML = "";
          micSelect.createEl("option", {
            value: "",
            text: "Microphone access denied"
          }).setAttribute("disabled", "true");
          const defaultOption2 = micSelect.createEl("option", {
            value: "default",
            text: "Default Microphone"
          });
          if (plugin.settings.preferredMicrophoneId === "default" || !plugin.settings.preferredMicrophoneId) {
            defaultOption2.selected = true;
          }
          micSelect.disabled = false;
          return;
        }
      }
      const updatedDevices = await navigator.mediaDevices.enumerateDevices();
      const microphones = updatedDevices.filter((device) => device.kind === "audioinput");
      micSelect.innerHTML = "";
      const defaultOption = micSelect.createEl("option", {
        value: "default",
        text: "Default Microphone"
      });
      if (plugin.settings.preferredMicrophoneId === "default" || !plugin.settings.preferredMicrophoneId) {
        defaultOption.selected = true;
      }
      microphones.forEach((mic) => {
        const option = micSelect.createEl("option", {
          value: mic.deviceId,
          text: mic.label || `Microphone ${mic.deviceId.slice(0, 8)}...`
        });
        if (mic.deviceId === plugin.settings.preferredMicrophoneId) {
          option.selected = true;
        }
      });
      micSelect.disabled = false;
      if (microphones.length === 0) {
        new import_obsidian25.Notice("No microphones detected. Please check your system settings.");
        micSelect.createEl("option", {
          value: "",
          text: "No microphones detected"
        }).setAttribute("disabled", "true");
      }
    } catch (error) {
      console.error("Error loading microphones:", error);
      micSelect.innerHTML = "";
      micSelect.createEl("option", {
        value: "",
        text: "Error loading microphones"
      }).setAttribute("disabled", "true");
      const defaultOption = micSelect.createEl("option", {
        value: "default",
        text: "Default Microphone"
      });
      if (plugin.settings.preferredMicrophoneId === "default" || !plugin.settings.preferredMicrophoneId) {
        defaultOption.selected = true;
      }
      micSelect.disabled = false;
    }
  }
  loadMicrophoneList();
  tabInstance.registerListener(micSelect, "change", async () => {
    await plugin.getSettingsManager().updateSettings({ preferredMicrophoneId: micSelect.value });
    new import_obsidian25.Notice(`Microphone preference saved: ${micSelect.options[micSelect.selectedIndex].text}`);
  });
  new import_obsidian25.Setting(containerEl).setName("Auto-Transcribe Recordings").setDesc("Automatically transcribe recordings when they are completed").addToggle((toggle) => toggle.setValue(plugin.settings.autoTranscribeRecordings).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ autoTranscribeRecordings: value });
  }));
  new import_obsidian25.Setting(containerEl).setName("Auto-Paste Transcription").setDesc("Automatically paste transcriptions into the active document").addToggle((toggle) => toggle.setValue(plugin.settings.autoPasteTranscription).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ autoPasteTranscription: value });
  }));
  new import_obsidian25.Setting(containerEl).setName("Keep Recordings After Transcription").setDesc("Keep audio recording files after successful transcription (otherwise they're deleted)").addToggle((toggle) => toggle.setValue(plugin.settings.keepRecordingsAfterTranscription).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ keepRecordingsAfterTranscription: value });
  }));
  new import_obsidian25.Setting(containerEl).setName("Clean Output Only").setDesc("Generate transcriptions with just the text, no timestamps, titles, or metadata").addToggle((toggle) => toggle.setValue(plugin.settings.cleanTranscriptionOutput).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ cleanTranscriptionOutput: value });
  }));
  new import_obsidian25.Setting(containerEl).setName("Auto-Submit After Transcription").setDesc("Automatically submit the message (hit enter) after transcription or post-processing completes in chat views").addToggle((toggle) => toggle.setValue(plugin.settings.autoSubmitAfterTranscription).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ autoSubmitAfterTranscription: value });
  }));
  new import_obsidian25.Setting(containerEl).setName("Post-Processing Enabled").setDesc("Enable transcription post-processing using your configured post-processing prompt. To configure the prompt, visit the 'System Prompt Settings' tab.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.postProcessingEnabled).setTooltip("Enable/disable post-processing").onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ postProcessingEnabled: value });
    });
    return toggle;
  });
  containerEl.createEl("h3", { text: "Transcription Settings" });
  const providerSetting = new import_obsidian25.Setting(containerEl).setName("Transcription Provider").setDesc("Choose which service to use for audio transcription. SystemSculpt API requires a valid license.");
  const providerDropdown = new import_obsidian25.DropdownComponent(providerSetting.controlEl);
  providerDropdown.addOption("systemsculpt", "SystemSculpt API").addOption("custom", "Custom").setValue(plugin.settings.transcriptionProvider).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ transcriptionProvider: value });
    updateCustomEndpointVisibility();
  });
  const mobileDetection = MobileDetection.getInstance();
  if (!mobileDetection.isMobileDevice()) {
    new import_obsidian25.Setting(containerEl).setName("Automatic Audio Format Conversion").setDesc("Automatically convert audio files to compatible formats when using SystemSculpt API. This ensures audio files with incompatible sample rates (like 8000Hz) are converted to the required format (16000Hz for most files, 48000Hz for WebM).").addToggle((toggle) => {
      var _a;
      return toggle.setValue((_a = plugin.settings.enableAutoAudioResampling) != null ? _a : true).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ enableAutoAudioResampling: value });
        if (value) {
          new import_obsidian25.Notice("Audio format conversion enabled. Files will be automatically converted when needed.");
        } else {
          new import_obsidian25.Notice("Audio format conversion disabled. Files with incompatible formats may fail to transcribe.");
        }
      });
    });
  }
  const customEndpointContainer = containerEl.createDiv("custom-endpoint-settings");
  const infoEl = customEndpointContainer.createDiv("custom-endpoint-info");
  infoEl.innerHTML = "Custom endpoints should follow the OpenAI-compatible API format. Most services expect a POST request with a 'file' parameter and 'model' parameter.";
  const endpointSetting = new import_obsidian25.Setting(customEndpointContainer).setName("Custom Whisper Endpoint URL").setDesc("Enter the URL for your custom transcription service");
  const endpointInput = new import_obsidian25.TextComponent(endpointSetting.controlEl);
  endpointInput.setPlaceholder("https://api.example.com/v1/audio/transcriptions").setValue(plugin.settings.customTranscriptionEndpoint).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ customTranscriptionEndpoint: value });
  });
  const apiKeySetting = new import_obsidian25.Setting(customEndpointContainer).setName("API Key").setDesc("Enter the API key for your custom transcription service (if required)");
  const apiKeyInput = new import_obsidian25.TextComponent(apiKeySetting.controlEl);
  apiKeyInput.setPlaceholder("sk-...").setValue(plugin.settings.customTranscriptionApiKey).inputEl.type = "password";
  apiKeyInput.onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ customTranscriptionApiKey: value });
  });
  const modelSetting = new import_obsidian25.Setting(customEndpointContainer).setName("Transcription Model").setDesc("Select the model to use for transcription");
  const modelContainer = modelSetting.controlEl.createDiv("model-selection-container");
  const modelDropdown = new import_obsidian25.DropdownComponent(modelContainer);
  const modelInput = new import_obsidian25.TextComponent(modelContainer);
  modelInput.setPlaceholder("Enter model name").setValue(plugin.settings.customTranscriptionModel).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ customTranscriptionModel: value });
  });
  async function updateModelSelectionUI() {
    const endpoint = plugin.settings.customTranscriptionEndpoint.toLowerCase();
    modelDropdown.selectEl.innerHTML = "";
    modelContainer.querySelectorAll(".model-note").forEach((el) => el.remove());
    modelInput.inputEl.disabled = false;
    if (endpoint.includes("groq.com")) {
      modelDropdown.addOption("whisper-large-v3", "Whisper Large V3 (High Accuracy)").addOption("whisper-large-v3-turbo", "Whisper Large V3 Turbo (Fast)").addOption("distil-whisper-large-v3-en", "Distil Whisper (English Only)");
      modelDropdown.setValue(plugin.settings.customTranscriptionModel);
      modelDropdown.selectEl.style.display = "block";
      modelInput.inputEl.style.display = "none";
      modelDropdown.onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ customTranscriptionModel: value });
      });
    } else if (endpoint.includes("openai.com")) {
      await plugin.getSettingsManager().updateSettings({ customTranscriptionModel: "whisper-1" });
      modelDropdown.selectEl.style.display = "none";
      modelInput.inputEl.style.display = "block";
      modelInput.setValue("whisper-1");
      modelInput.inputEl.disabled = true;
      modelInput.setPlaceholder("OpenAI only supports whisper-1");
      const noteEl = modelContainer.createDiv("model-note");
      noteEl.innerHTML = "OpenAI only supports the whisper-1 model";
      noteEl.style.fontSize = "12px";
      noteEl.style.color = "var(--text-muted)";
      noteEl.style.marginTop = "4px";
    } else {
      modelDropdown.selectEl.style.display = "none";
      modelInput.inputEl.style.display = "block";
    }
  }
  const presetSetting = new import_obsidian25.Setting(customEndpointContainer).setName("Presets").setDesc("Quick setup for common transcription services");
  const groqButton = new import_obsidian25.ButtonComponent(presetSetting.controlEl);
  groqButton.setButtonText("Groq").setTooltip("Use Groq's Whisper API").onClick(async () => {
    endpointInput.setValue("https://api.groq.com/openai/v1/audio/transcriptions");
    await plugin.getSettingsManager().updateSettings({
      customTranscriptionEndpoint: "https://api.groq.com/openai/v1/audio/transcriptions",
      customTranscriptionModel: "whisper-large-v3"
    });
    updateModelSelectionUI().catch(console.error);
    new import_obsidian25.Notice("Groq endpoint set. Don't forget to add your API key.");
  });
  const openaiButton = new import_obsidian25.ButtonComponent(presetSetting.controlEl);
  openaiButton.setButtonText("OpenAI").setTooltip("Use OpenAI's Whisper API (only supports whisper-1 model)").onClick(async () => {
    endpointInput.setValue("https://api.openai.com/v1/audio/transcriptions");
    await plugin.getSettingsManager().updateSettings({
      customTranscriptionEndpoint: "https://api.openai.com/v1/audio/transcriptions",
      customTranscriptionModel: "whisper-1"
    });
    updateModelSelectionUI().catch(console.error);
    new import_obsidian25.Notice("OpenAI endpoint set with whisper-1 model. Don't forget to add your API key.");
  });
  const localButton = new import_obsidian25.ButtonComponent(presetSetting.controlEl);
  localButton.setButtonText("Local").setTooltip("Use a local Whisper server").onClick(async () => {
    endpointInput.setValue("http://localhost:9000/v1/audio/transcriptions");
    await plugin.getSettingsManager().updateSettings({
      customTranscriptionEndpoint: "http://localhost:9000/v1/audio/transcriptions",
      customTranscriptionModel: "whisper-large-v3"
    });
    updateModelSelectionUI().catch(console.error);
    new import_obsidian25.Notice("Local Whisper endpoint set.");
  });
  endpointInput.onChange(async () => {
    updateModelSelectionUI().catch(console.error);
  });
  updateModelSelectionUI().catch(console.error);
  function updateCustomEndpointVisibility() {
    if (plugin.settings.transcriptionProvider === "custom") {
      customEndpointContainer.style.display = "block";
    } else {
      customEndpointContainer.style.display = "none";
    }
  }
  updateCustomEndpointVisibility();
}

// src/settings/ChatTabContent.ts
var import_obsidian34 = __toModule(require("obsidian"));
init_SystemPromptService();
init_FavoritesService();
init_StandardModelSelectionModal();
init_StandardSystemPromptSelectionModal();
async function getCurrentDefaultPresetDisplayName(plugin, app) {
  const type = plugin.settings.systemPromptType;
  const path = plugin.settings.systemPromptPath;
  if (type === "agent") {
    console.warn(`Agent Mode cannot be used as a default system prompt. Agent Mode is now per-chat only. Falling back to General Use.`);
    await plugin.getSettingsManager().updateSettings({
      systemPromptType: "general-use",
      systemPromptPath: ""
    });
    return "General Use Preset (auto-switched from Agent Mode - now per-chat only)";
  }
  if (type === "general-use")
    return "General Use Preset";
  if (type === "concise")
    return "Concise Preset";
  if (type === "custom") {
    if (path) {
      try {
        const spService = SystemPromptService.getInstance(app, () => plugin.settings);
        const file = app.vault.getAbstractFileByPath(path);
        if (!file) {
          console.warn(`Custom system prompt file not found: ${path}. Falling back to General Use.`);
          await plugin.getSettingsManager().updateSettings({
            systemPromptType: "general-use",
            systemPromptPath: ""
          });
          return "General Use Preset (auto-switched from missing custom file)";
        }
        const fileName = path.split("/").pop() || path;
        return `Custom Preset File: ${fileName}`;
      } catch (error) {
        console.error("Error handling custom preset path:", error);
        await plugin.getSettingsManager().updateSettings({
          systemPromptType: "general-use",
          systemPromptPath: ""
        });
        return "General Use Preset (auto-switched due to custom file error)";
      }
    } else {
      return "Custom (Manually Entered Text)";
    }
  }
  const validDefaultTypes = ["general-use", "concise", "custom"];
  if (!validDefaultTypes.includes(type)) {
    console.warn(`Invalid system prompt type: ${type}. Falling back to General Use.`);
    await plugin.getSettingsManager().updateSettings({
      systemPromptType: "general-use",
      systemPromptPath: ""
    });
    return "General Use Preset (auto-switched from invalid type)";
  }
  return "General Use Preset";
}
async function displayChatTabContent(containerEl, tabInstance) {
  containerEl.empty();
  containerEl.dataset.tab = "chat";
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Chat Settings" });
  const modelSettingsNote = containerEl.createEl("p", {
    text: '\u{1F4A1} To configure AI models (chat model, title generation model, etc.), visit the "Model Settings" tab.',
    cls: "setting-item-description systemsculpt-model-settings-note"
  });
  const presetsHeader = containerEl.createDiv("systemsculpt-presets-header");
  presetsHeader.createEl("h4", { text: "Default Chat Settings", cls: "systemsculpt-presets-title" });
  presetsHeader.createEl("p", {
    text: "Configure default settings for new chat conversations.",
    cls: "systemsculpt-presets-description"
  });
  const defaultPresetDisplay = containerEl.createDiv("systemsculpt-chat-presets-display");
  let manualPromptSetting = null;
  manualPromptSetting = new import_obsidian34.Setting(containerEl).setName("Custom Default Prompt Text").setDesc("Edit the text used when 'Custom (Manually Entered Text)' is the default preset. This text is ignored if a specific preset or file is selected as the default.").addTextArea((text) => {
    text.setValue(plugin.settings.systemPrompt).setPlaceholder("Enter your custom default system prompt here...").onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ systemPrompt: value });
    });
    text.inputEl.rows = 6;
  });
  const updateDefaultPresetDisplay = async () => {
    defaultPresetDisplay.empty();
    const presetsContainer = defaultPresetDisplay.createDiv("systemsculpt-presets-container");
    const promptCard = presetsContainer.createDiv("systemsculpt-preset-card systemsculpt-preset-card-clickable");
    promptCard.createEl("div", { text: "System Prompt", cls: "systemsculpt-preset-card-title" });
    const promptValue = promptCard.createEl("div", { cls: "systemsculpt-preset-card-value" });
    const displayName = await getCurrentDefaultPresetDisplayName(plugin, app);
    const cleanDisplayName = displayName.replace("Current Default: ", "");
    promptValue.setText(cleanDisplayName);
    promptCard.addEventListener("click", () => openSystemPromptSelection());
    manualPromptSetting == null ? void 0 : manualPromptSetting.settingEl.toggle(plugin.settings.systemPromptType === "custom" && !plugin.settings.systemPromptPath);
  };
  const openSystemPromptSelection = () => {
    const modal = new StandardSystemPromptSelectionModal({
      app,
      plugin,
      currentType: plugin.settings.systemPromptType || "general-use",
      currentPath: plugin.settings.systemPromptPath,
      title: "Select Default System Prompt",
      description: "Choose the default system prompt for all new chats",
      onSelect: async (result) => {
        var _a, _b;
        try {
          const updates = {
            systemPromptType: result.type
          };
          if (result.type === "custom" && result.path) {
            updates.systemPromptPath = result.path;
          } else {
            updates.systemPromptPath = "";
          }
          if (result.type === "custom" && !result.path && result.prompt) {
            updates.systemPrompt = result.prompt;
          }
          await plugin.getSettingsManager().updateSettings(updates);
          (_b = (_a = plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
          let displayName = result.type;
          if (result.type === "general-use") {
            displayName = "General Use";
          } else if (result.type === "concise") {
            displayName = "Concise";
          } else if (result.type === "custom" && result.path) {
            const fileName = result.path.split("/").pop() || result.path;
            displayName = `Custom: ${fileName}`;
          } else if (result.type === "custom") {
            displayName = "Custom (manually entered)";
          }
          new import_obsidian34.Notice(`Default system prompt set to ${displayName}`, 3e3);
        } catch (error) {
          console.error("Error updating default system prompt:", error);
          new import_obsidian34.Notice("Failed to update default system prompt. Please try again.", 5e3);
        }
      }
    });
    modal.open();
  };
  await updateDefaultPresetDisplay();
  plugin.emitter.off("settingsChanged");
  plugin.emitter.on("settingsChanged", updateDefaultPresetDisplay);
  new import_obsidian34.Setting(containerEl).setName("Default Chat Font Size").setDesc("Select the default text size for new chat messages.").addDropdown((dropdown) => {
    dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(plugin.settings.chatFontSize || "medium").onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ chatFontSize: value });
      new import_obsidian34.Notice(`Default chat font size set to: ${value}`);
    });
  });
  const { verifyPremiumAccess: verifyPremiumAccess3 } = await Promise.resolve().then(() => (init_licenseUtils(), licenseUtils_exports));
  const isLicenseValid = verifyPremiumAccess3(plugin.settings, 0, false);
  const agentModeSetting = new import_obsidian34.Setting(containerEl).setName("Default Agent Mode").setDesc("When enabled, new chats will start with Agent Mode activated. Agent Mode enables autonomous vault exploration and advanced tool usage. Requires an active SystemSculpt Pro license.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.defaultAgentMode && isLicenseValid).setDisabled(!isLicenseValid).onChange(async (value) => {
      if (value && !isLicenseValid) {
        const hasValidLicense = verifyPremiumAccess3(plugin.settings, 0, true);
        if (!hasValidLicense) {
          toggle.setValue(false);
          return;
        }
      }
      await plugin.getSettingsManager().updateSettings({ defaultAgentMode: value });
      new import_obsidian34.Notice(`Default Agent Mode ${value ? "enabled" : "disabled"}. ${value ? "New chats will start with Agent Mode active." : "New chats will start with Agent Mode disabled."}`);
    });
  });
  if (!isLicenseValid) {
    agentModeSetting.setDesc("When enabled, new chats will start with Agent Mode activated. Agent Mode enables autonomous vault exploration and advanced tool usage. \u26A0\uFE0F Requires an active SystemSculpt Pro license - please upgrade to use this feature.");
    agentModeSetting.settingEl.addClass("systemsculpt-disabled-setting");
  }
  new import_obsidian34.Setting(containerEl).setName("Auto-Enable Vault Structure").setDesc("When enabled, new chats will automatically include the vault structure in the context. This provides the AI with an overview of your vault's organization.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.defaultIncludeVaultStructure).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ defaultIncludeVaultStructure: value });
      new import_obsidian34.Notice(`Auto-Enable Vault Structure ${value ? "enabled" : "disabled"}. ${value ? "New chats will automatically include vault structure in context." : "New chats will start without vault structure included."}`);
    });
  });
  containerEl.createEl("h3", { text: "Manage Favorite Models" });
  const favoritesContainer = containerEl.createDiv("systemsculpt-favorites-management");
  const renderFavoritesSection = async () => {
    favoritesContainer.empty();
    const favoritesService = FavoritesService.getInstance(plugin);
    const allModels = await plugin.modelService.getModels();
    favoritesService.processFavorites(allModels);
    const favoriteModels = favoritesService.getFavorites(allModels);
    if (favoriteModels.length === 0) {
      favoritesContainer.createEl("p", { text: "You haven't favorited any models yet.", cls: "setting-item-description" });
      return;
    }
    favoriteModels.sort((a, b) => a.name.localeCompare(b.name));
    favoriteModels.forEach((model) => {
      new import_obsidian34.Setting(favoritesContainer).setName(model.name).setDesc(`Provider: ${model.provider}`).addButton((button) => {
        button.setIcon("trash-2").setTooltip(`Remove ${model.name} from favorites`).setClass("mod-warning").onClick(async () => {
          await favoritesService.removeFavorite(model);
          new import_obsidian34.Notice(`${model.name} removed from favorites.`);
          renderFavoritesSection();
          plugin.emitter.emit("favoritesChanged");
        });
      });
    });
    new import_obsidian34.Setting(favoritesContainer).setName("Add/Remove Favorites").setDesc("Open the model selection screen to manage your favorites.").addButton((button) => {
      button.setButtonText("Add/Remove Favorite Models...").setTooltip("Open model selection to manage favorites").onClick(() => {
        const modelSelectionModal = new StandardModelSelectionModal({
          app,
          plugin,
          currentModelId: "",
          onSelect: (result) => {
            console.log("Model selection modal closed (from settings).");
          }
        });
        modelSelectionModal.open();
      });
    });
    if (favoriteModels.length > 0) {
      new import_obsidian34.Setting(favoritesContainer).addButton((button) => {
        button.setButtonText("Remove All Favorites").setClass("mod-warning").onClick(() => {
          const confirmationModal = new import_obsidian34.Modal(app);
          confirmationModal.contentEl.createEl("h3", { text: "Confirm Removal" });
          confirmationModal.contentEl.createEl("p", { text: "Are you sure you want to remove all favorite models? This action cannot be undone." });
          new import_obsidian34.Setting(confirmationModal.contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => confirmationModal.close())).addButton((btn) => btn.setButtonText("Remove All").setClass("mod-warning").onClick(async () => {
            await favoritesService.clearAllFavorites(allModels);
            new import_obsidian34.Notice("All favorite models removed.");
            renderFavoritesSection();
            plugin.emitter.emit("favoritesChanged");
            confirmationModal.close();
          }));
          confirmationModal.open();
        });
      });
    }
  };
  await renderFavoritesSection();
  plugin.emitter.on("favoritesChanged", renderFavoritesSection);
  const domFavoritesChangedHandler = () => {
    renderFavoritesSection();
  };
  document.addEventListener("systemsculpt:favorites-changed", domFavoritesChangedHandler);
}

// src/settings/ModelSettingsTabContent.ts
var import_obsidian35 = __toModule(require("obsidian"));
init_StandardModelSelectionModal();
async function displayModelSettingsTabContent(containerEl, tabInstance) {
  containerEl.empty();
  containerEl.dataset.tab = "model-settings";
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Model Settings" });
  containerEl.createEl("p", {
    text: "Configure which AI models are used for different features throughout SystemSculpt.",
    cls: "setting-item-description"
  });
  const availableModels = await plugin.modelService.getModels();
  const { getDisplayName: getDisplayName2, findModelById: findModelById2 } = await Promise.resolve().then(() => (init_modelUtils(), modelUtils_exports));
  const modelsContainer = containerEl.createDiv("systemsculpt-models-container");
  const chatModelCard = modelsContainer.createDiv("systemsculpt-model-card systemsculpt-model-card-clickable");
  chatModelCard.createEl("div", { text: "Default Chat Model", cls: "systemsculpt-model-card-title" });
  chatModelCard.createEl("div", { text: "The AI model used for all new chat conversations", cls: "systemsculpt-model-card-description" });
  const chatModelValue = chatModelCard.createEl("div", { cls: "systemsculpt-model-card-value" });
  const updateChatModelDisplay = () => {
    if (plugin.settings.selectedModelId) {
      const storedModel = findModelById2(availableModels, plugin.settings.selectedModelId);
      if (storedModel) {
        chatModelValue.setText(getDisplayName2(plugin.settings.selectedModelId));
        chatModelValue.removeClass("systemsculpt-model-card-value-unavailable");
      } else {
        chatModelValue.setText(`${getDisplayName2(plugin.settings.selectedModelId)} (unavailable)`);
        chatModelValue.addClass("systemsculpt-model-card-value-unavailable");
      }
    } else {
      if (availableModels.length === 0) {
        chatModelValue.setText("No models available - Set up providers first");
        chatModelValue.addClass("systemsculpt-model-card-value-empty");
        chatModelCard.removeClass("systemsculpt-model-card-clickable");
        chatModelCard.style.cursor = "not-allowed";
      } else {
        chatModelValue.setText("Click to select a model");
        chatModelValue.addClass("systemsculpt-model-card-value-empty");
      }
    }
  };
  if (availableModels.length > 0) {
    chatModelCard.addEventListener("click", async () => {
      const modal = new StandardModelSelectionModal({
        app,
        plugin,
        currentModelId: plugin.settings.selectedModelId || "",
        title: "Select Default Chat Model",
        description: "Choose the default model for all new chats",
        onSelect: async (result) => {
          var _a, _b;
          try {
            const { ensureCanonicalId: ensureCanonicalId2 } = await Promise.resolve().then(() => (init_modelUtils(), modelUtils_exports));
            const canonicalId = ensureCanonicalId2(result.modelId);
            await plugin.getSettingsManager().updateSettings({
              selectedModelId: canonicalId
            });
            (_b = (_a = plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
            updateChatModelDisplay();
            new import_obsidian35.Notice("Default chat model updated successfully.", 3e3);
          } catch (error) {
            console.error("Error updating default chat model:", error);
            new import_obsidian35.Notice("Failed to update default chat model. Please try again.", 5e3);
          }
        }
      });
      modal.open();
    });
  }
  const titleModelCard = modelsContainer.createDiv("systemsculpt-model-card systemsculpt-model-card-clickable");
  titleModelCard.createEl("div", { text: "Title Generation Model", cls: "systemsculpt-model-card-title" });
  titleModelCard.createEl("div", { text: "The AI model used for generating chat titles", cls: "systemsculpt-model-card-description" });
  const titleModelValue = titleModelCard.createEl("div", { cls: "systemsculpt-model-card-value" });
  const updateTitleModelDisplay = () => {
    if (plugin.settings.titleGenerationModelId) {
      const storedTitleModel = findModelById2(availableModels, plugin.settings.titleGenerationModelId);
      if (storedTitleModel) {
        titleModelValue.setText(getDisplayName2(plugin.settings.titleGenerationModelId));
        titleModelValue.removeClass("systemsculpt-model-card-value-unavailable");
      } else {
        titleModelValue.setText(`${getDisplayName2(plugin.settings.titleGenerationModelId)} (unavailable)`);
        titleModelValue.addClass("systemsculpt-model-card-value-unavailable");
      }
    } else {
      if (availableModels.length === 0) {
        titleModelValue.setText("No models available");
        titleModelValue.addClass("systemsculpt-model-card-value-empty");
        titleModelCard.removeClass("systemsculpt-model-card-clickable");
        titleModelCard.style.cursor = "not-allowed";
      } else {
        titleModelValue.setText("Same as chat model");
        titleModelValue.addClass("systemsculpt-model-card-value-default");
      }
    }
  };
  if (availableModels.length > 0) {
    titleModelCard.addEventListener("click", async () => {
      const modal = new StandardModelSelectionModal({
        app,
        plugin,
        currentModelId: plugin.settings.titleGenerationModelId || plugin.settings.selectedModelId || "",
        title: "Select Title Generation Model",
        description: "Choose the model used for generating chat titles",
        onSelect: async (result) => {
          var _a, _b;
          try {
            const { ensureCanonicalId: ensureCanonicalId2 } = await Promise.resolve().then(() => (init_modelUtils(), modelUtils_exports));
            const canonicalId = ensureCanonicalId2(result.modelId);
            const parsed = parseCanonicalId3(canonicalId);
            if (parsed) {
              await plugin.getSettingsManager().updateSettings({
                titleGenerationProviderId: parsed.providerId,
                titleGenerationModelId: canonicalId
              });
              (_b = (_a = plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
              updateTitleModelDisplay();
              new import_obsidian35.Notice("Title generation model updated successfully.", 3e3);
            }
          } catch (error) {
            console.error("Error updating title generation model:", error);
            new import_obsidian35.Notice("Failed to update title generation model. Please try again.", 5e3);
          }
        }
      });
      modal.open();
    });
  }
  const postProcessingModelCard = modelsContainer.createDiv("systemsculpt-model-card systemsculpt-model-card-clickable");
  postProcessingModelCard.createEl("div", { text: "Post-Processing Model", cls: "systemsculpt-model-card-title" });
  postProcessingModelCard.createEl("div", { text: "The AI model used for post-processing audio transcriptions", cls: "systemsculpt-model-card-description" });
  const postProcessingModelValue = postProcessingModelCard.createEl("div", { cls: "systemsculpt-model-card-value" });
  const updatePostProcessingModelDisplay = () => {
    if (plugin.settings.postProcessingModelId) {
      const storedModel = findModelById2(availableModels, plugin.settings.postProcessingModelId);
      if (storedModel) {
        postProcessingModelValue.setText(getDisplayName2(plugin.settings.postProcessingModelId));
        postProcessingModelValue.removeClass("systemsculpt-model-card-value-unavailable");
      } else {
        postProcessingModelValue.setText(`${getDisplayName2(plugin.settings.postProcessingModelId)} (unavailable)`);
        postProcessingModelValue.addClass("systemsculpt-model-card-value-unavailable");
      }
    } else {
      if (availableModels.length === 0) {
        postProcessingModelValue.setText("No models available");
        postProcessingModelValue.addClass("systemsculpt-model-card-value-empty");
        postProcessingModelCard.removeClass("systemsculpt-model-card-clickable");
        postProcessingModelCard.style.cursor = "not-allowed";
      } else {
        postProcessingModelValue.setText("Same as chat model");
        postProcessingModelValue.addClass("systemsculpt-model-card-value-default");
      }
    }
  };
  if (availableModels.length > 0) {
    postProcessingModelCard.addEventListener("click", async () => {
      const modal = new StandardModelSelectionModal({
        app,
        plugin,
        currentModelId: plugin.settings.postProcessingModelId || "",
        title: "Select Post-Processing Model",
        description: "Choose the model used for post-processing transcriptions",
        onSelect: async (result) => {
          var _a, _b;
          try {
            const { ensureCanonicalId: ensureCanonicalId2 } = await Promise.resolve().then(() => (init_modelUtils(), modelUtils_exports));
            const canonicalId = ensureCanonicalId2(result.modelId);
            const parsed = parseCanonicalId3(canonicalId);
            if (parsed) {
              await plugin.getSettingsManager().updateSettings({
                postProcessingProviderId: parsed.providerId,
                postProcessingModelId: canonicalId
              });
              (_b = (_a = plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
              updatePostProcessingModelDisplay();
              new import_obsidian35.Notice("Post-processing model updated successfully.", 3e3);
            }
          } catch (error) {
            console.error("Error updating post-processing model:", error);
            new import_obsidian35.Notice("Failed to update post-processing model. Please try again.", 5e3);
          }
        }
      });
      modal.open();
    });
  }
  updateChatModelDisplay();
  updateTitleModelDisplay();
  updatePostProcessingModelDisplay();
  plugin.emitter.off("settingsChanged");
  plugin.emitter.on("settingsChanged", updateDisplays);
  function updateDisplays() {
    updateChatModelDisplay();
    updateTitleModelDisplay();
    updatePostProcessingModelDisplay();
  }
  if (availableModels.length === 0) {
    const guidanceEl = containerEl.createDiv("systemsculpt-models-guidance");
    guidanceEl.createEl("p", {
      text: '\u{1F4A1} To get started, set up at least one AI model provider in the "Setup & Connect" tab.',
      cls: "systemsculpt-models-guidance-text"
    });
  }
  containerEl.createEl("h3", { text: "Model Preferences" });
  new import_obsidian35.Setting(containerEl).setName("Model List Sort Order").setDesc("Choose how models are sorted in the selection list (Favorites are always shown first if enabled).").addDropdown((dropdown) => {
    dropdown.addOption("default", "Default (Natural Order)").addOption("alphabetical", "Alphabetical (Provider/Name)").setValue(plugin.settings.favoritesFilterSettings.modelSortOrder).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({
        favoritesFilterSettings: {
          ...plugin.settings.favoritesFilterSettings,
          modelSortOrder: value
        }
      });
      new import_obsidian35.Notice(`Model sort order set to: ${value === "default" ? "Default" : "Alphabetical"}`);
    });
  });
  containerEl.createEl("h3", { text: "Transcription Model Settings" });
  const transcriptionModelSetting = new import_obsidian35.Setting(containerEl).setName("Transcription Model").setDesc("The model used for audio transcription when using custom transcription providers.");
  const transcriptionModelDisplay = transcriptionModelSetting.controlEl.createDiv("systemsculpt-transcription-model-display");
  transcriptionModelDisplay.textContent = plugin.settings.customTranscriptionModel || "Not configured";
  const transcriptionNote = containerEl.createEl("p", {
    text: "To configure transcription providers and detailed transcription settings, visit the Recorder tab.",
    cls: "setting-item-description systemsculpt-transcription-note"
  });
}
function parseCanonicalId3(canonicalId) {
  const parts = canonicalId.split("@@");
  if (parts.length === 2) {
    return { providerId: parts[0], modelId: parts[1] };
  }
  return null;
}

// src/settings/SystemPromptSettingsTabContent.ts
var import_obsidian39 = __toModule(require("obsidian"));
init_StandardSystemPromptSelectionModal();

// src/modals/TitleGenerationPromptModal.ts
var import_obsidian37 = __toModule(require("obsidian"));

// src/components/FileSuggester.ts
var import_obsidian36 = __toModule(require("obsidian"));
var FileSuggester = class extends import_obsidian36.AbstractInputSuggest {
  constructor(inputEl, onSelectCb, app, directory) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.onSelectCb = onSelectCb;
    this.directory = directory;
    this.content = getFileSuggestions(app, directory);
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLowerCase();
    return [...this.content].filter((content) => content.toLowerCase().includes(lowerCaseInputStr));
  }
  renderSuggestion(content, el) {
    el.setText(content);
  }
  selectSuggestion(content, evt) {
    this.onSelectCb(content);
    this.inputEl.value = content;
    this.inputEl.blur();
    this.close();
  }
};
function getFileSuggestions(app, directory) {
  const files = app.vault.getAllLoadedFiles().filter((file) => {
    var _a;
    if (!(file instanceof import_obsidian36.TFile))
      return false;
    if (directory) {
      const fileDir = (_a = file.parent) == null ? void 0 : _a.path;
      return fileDir === directory && file.extension === "md";
    } else {
      return true;
    }
  });
  return new Set(files.map((file) => file.path));
}
function attachFileSuggester(inputEl, onSelect, app, directory) {
  return new FileSuggester(inputEl, onSelect, app, directory);
}

// src/modals/TitleGenerationPromptModal.ts
init_StandardModal();
init_types();
var TitleGenerationPromptModal = class extends StandardModal {
  constructor(app, plugin, contentPreview, isDocument, onSubmit) {
    super(app);
    this.result = null;
    this.settingsChanged = false;
    this.presets = [
      {
        id: "precise",
        name: "Precise",
        content: DEFAULT_TITLE_GENERATION_PROMPT
      },
      {
        id: "movie-style",
        name: "Movie-Style",
        content: `You are a creative title generation assistant focused on creating engaging, movie-style titles.

Your task is to analyze the provided conversation and generate a single, attention-grabbing title that:
- Has a cinematic, dramatic quality similar to movie titles
- Uses creative, evocative language that captures the essence of the conversation
- Is between 2-6 words long
- May use metaphors, wordplay, or allusions when appropriate
- Maintains proper capitalization (typically capitalize all major words)
- NEVER includes characters that are invalid in filenames: \\ / : * ? " < > |
- Uses proper spacing between all words

The title should be memorable and distinctive while still reflecting the actual content of the conversation.
Respond with ONLY the title, nothing else.`
      }
    ];
    this.modalEl.addClass("ss-chat-settings-modal");
    this.setSize("medium");
    this.plugin = plugin;
    this.contentPreview = contentPreview;
    this.isDocument = isDocument;
    this.onSubmit = onSubmit;
    this.selectedPresetId = plugin.settings.titleGenerationPromptType === "precise" ? "precise" : plugin.settings.titleGenerationPromptType === "movie-style" ? "movie-style" : null;
    this.filePath = plugin.settings.titleGenerationPromptPath || "";
  }
  async onOpen() {
    super.onOpen();
    this.addTitle("Title Generation Prompt", "Configure how your titles should be generated");
    this.createPresetSection();
    this.createFileSection();
    this.createPromptEditorSection();
    this.addActionButton("Close", () => {
      this.close();
    }, true);
    await this.initializeContent();
  }
  createPresetSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Preset Prompts",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Choose from predefined title generation styles.",
      cls: "ss-chat-settings-modal__prompt-type-details"
    });
    const buttonContainer = section.createDiv("ss-chat-settings-modal__prompt-type-buttons");
    this.presets.forEach((preset) => {
      const button = buttonContainer.createEl("button", {
        text: preset.name,
        cls: "ss-preset-button cursor-pointer"
      });
      if (preset.id === this.selectedPresetId) {
        button.addClass("is-active");
      }
      button.addEventListener("click", async () => {
        this.selectedPresetId = preset.id;
        this.promptTextarea.value = preset.content;
        buttonContainer.querySelectorAll(".ss-preset-button").forEach((btn) => {
          btn.removeClass("is-active");
        });
        button.addClass("is-active");
        await this.saveSettings("preset", preset.id);
      });
    });
  }
  createFileSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Custom File",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Use a custom prompt from a file in your vault.",
      cls: "ss-chat-settings-modal__prompt-type-details"
    });
    new import_obsidian37.Setting(section).setName("Prompt File").setDesc("Select a file to use as your title generation prompt").addText((text) => {
      this.fileInputEl = text.inputEl;
      text.setPlaceholder("Select a file...").setValue(this.filePath);
      attachFileSuggester(text.inputEl, async (selectedPath) => {
        this.filePath = selectedPath;
        await this.loadFileContent(selectedPath);
        await this.saveSettings("file", void 0, selectedPath);
      }, this.app, this.plugin.settings.systemPromptsDirectory);
    }).addButton((button) => {
      button.setButtonText("Browse").setIcon("folder").onClick(() => {
        this.fileInputEl.focus();
      });
    });
    new import_obsidian37.Setting(section).setName("Create New").setDesc("Create a new prompt file").addButton((button) => {
      button.setButtonText("Create New Prompt File").setIcon("file-plus").onClick(async () => {
        await this.createNewPromptFile();
      });
    });
  }
  createPromptEditorSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Prompt Content",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Review and edit the prompt content below.",
      cls: "ss-chat-settings-modal__prompt-editor-note"
    });
    this.promptTextarea = section.createEl("textarea", {
      cls: "ss-chat-settings-modal__prompt-textarea",
      attr: {
        placeholder: "Enter your title generation prompt here...",
        rows: "8"
      }
    });
    this.promptTextarea.value = this.contentPreview || DEFAULT_TITLE_GENERATION_PROMPT;
  }
  async initializeContent() {
    if (this.plugin.settings.titleGenerationPromptType === "custom" && this.filePath) {
      await this.loadFileContent(this.filePath);
    } else if (this.selectedPresetId) {
      const preset = this.presets.find((p) => p.id === this.selectedPresetId);
      if (preset) {
        this.promptTextarea.value = preset.content;
      }
    }
  }
  async loadFileContent(filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian37.TFile) {
        const content = await this.app.vault.read(file);
        this.promptTextarea.value = content;
      }
    } catch (error) {
      console.error("Failed to load file content:", error);
      this.promptTextarea.value = "Error loading file content.";
    }
  }
  async createNewPromptFile() {
    const name = await this.showTextInputModal("Create New Prompt", "Enter a name for your prompt file:");
    if (!name)
      return;
    try {
      const fileName = name.replace(/[^a-zA-Z0-9-_ ]/g, "").replace(/ /g, "-");
      const filePath = `${this.plugin.settings.systemPromptsDirectory}/${fileName}.md`;
      const content = DEFAULT_TITLE_GENERATION_PROMPT;
      if (this.plugin.directoryManager) {
        await this.plugin.directoryManager.ensureDirectoryByPath(this.plugin.settings.systemPromptsDirectory);
      }
      await this.app.vault.create(filePath, content);
      this.filePath = filePath;
      this.promptTextarea.value = content;
      const fileInput = this.contentEl.querySelector("input[type='text']");
      if (fileInput) {
        fileInput.value = filePath;
      }
      await this.saveSettings("file", void 0, filePath);
      new import_obsidian37.Notice(`Created prompt file: ${fileName}.md`, 3e3);
    } catch (error) {
      console.error("Failed to create file:", error);
      new import_obsidian37.Notice("Failed to create prompt file", 3e3);
    }
  }
  async showTextInputModal(title, placeholder) {
    return new Promise((resolve) => {
      const modal = new class extends StandardModal {
        constructor(app) {
          super(app);
          this.result = null;
          this.setSize("small");
        }
        onOpen() {
          super.onOpen();
          this.addTitle(title);
          this.input = this.contentEl.createEl("input", {
            type: "text",
            placeholder,
            cls: "ss-chat-settings-modal__title-input"
          });
          this.addActionButton("Cancel", () => {
            this.close();
          }, false);
          this.addActionButton("Create", () => {
            this.result = this.input.value.trim();
            this.close();
          }, true);
          setTimeout(() => this.input.focus(), 10);
        }
        onClose() {
          resolve(this.result);
          super.onClose();
        }
      }(this.app);
      modal.open();
    });
  }
  async saveSettings(source, presetId, filePath) {
    const content = this.promptTextarea.value;
    const settingsUpdate = {
      titleGenerationPrompt: content
    };
    if (source === "preset" && presetId) {
      settingsUpdate.titleGenerationPromptType = presetId;
    } else if (source === "file" && filePath) {
      settingsUpdate.titleGenerationPromptType = "custom";
      settingsUpdate.titleGenerationPromptPath = filePath;
    }
    await this.plugin.getSettingsManager().updateSettings(settingsUpdate);
    this.settingsChanged = true;
    this.result = {
      content,
      source,
      presetId,
      filePath
    };
  }
  onClose() {
    if (this.resolvePromise) {
      this.resolvePromise(this.result);
    }
    super.onClose();
  }
  async openAndGetValue() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      this.open();
    });
  }
};
async function showTitleGenerationPromptModal(app, plugin, currentPrompt, options) {
  const modal = new TitleGenerationPromptModal(app, plugin, currentPrompt, true, () => {
  });
  return await modal.openAndGetValue();
}

// src/modals/PostProcessingPromptModal.ts
var import_obsidian38 = __toModule(require("obsidian"));
init_ui();
init_StandardModal();
var PostProcessingPromptModal = class extends StandardModal {
  constructor(app, plugin, initialPrompt, systemPromptsDirectory = "SystemSculpt/System Prompts") {
    super(app);
    this.result = null;
    this.presets = [
      {
        id: "transcript-cleaner",
        name: "Transcript Cleaner",
        description: "Clean up transcription errors and improve readability",
        content: `You are a transcription post-processor. Your task is to fix any transcription errors, correct grammar and punctuation, and ensure the text is properly formatted. Keep the original meaning intact while making the text more readable.

Please process the following raw transcript to:
- Fix grammar, punctuation, and capitalization
- Remove filler words (um, uh, like, you know)
- Format into clear paragraphs
- Maintain the original meaning and speaker's voice

Raw transcript:`
      },
      {
        id: "meeting-summarizer",
        name: "Meeting Summarizer",
        description: "Summarize meeting transcripts into key points and action items",
        content: `You are a meeting transcript processor. Transform the raw transcript into a structured summary that captures the essential information.

Please process the following meeting transcript to create:
- Executive summary (2-3 sentences)
- Key discussion points
- Decisions made
- Action items with responsible parties (if mentioned)
- Follow-up items

Format the output in clear sections with appropriate headings.

Raw transcript:`
      },
      {
        id: "interview-formatter",
        name: "Interview Formatter",
        description: "Format interview transcripts with proper speaker attribution",
        content: `You are an interview transcript formatter. Your task is to clean up and properly format interview transcripts with clear speaker attribution and improved readability.

Please process the following interview transcript to:
- Identify and label speakers consistently (Interviewer, Interviewee, etc.)
- Remove filler words and false starts
- Correct grammar and punctuation
- Break into clear question-and-answer segments
- Maintain the natural flow of conversation

Raw transcript:`
      }
    ];
    this.modalEl.addClass("ss-chat-settings-modal");
    this.setSize("medium");
    this.plugin = plugin;
    this.systemPromptsDirectory = systemPromptsDirectory;
  }
  async onOpen() {
    super.onOpen();
    this.addTitle("Post-Processing Prompt", "Configure how your transcriptions should be processed");
    this.createPresetSection();
    this.createFileSection();
    this.createPromptEditorSection();
    this.addActionButton("Close", () => {
      this.close();
    }, true);
    await this.loadCurrentState();
  }
  createPresetSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Preset Prompts",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Choose from predefined post-processing styles.",
      cls: "ss-chat-settings-modal__prompt-type-details"
    });
    this.presetButtonContainer = section.createDiv("ss-chat-settings-modal__prompt-type-buttons");
    this.presets.forEach((preset) => {
      const button = this.presetButtonContainer.createEl("button", {
        text: preset.name,
        cls: "ss-preset-button cursor-pointer"
      });
      button.setAttribute("data-preset-id", preset.id);
      button.addEventListener("click", async () => {
        await this.selectPreset(preset.id);
      });
    });
    this.presetDescriptionEl = section.createEl("div", {
      cls: "ss-chat-settings-modal__prompt-type-details",
      attr: { style: "display: none;" }
    });
  }
  createFileSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Custom File",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Use a custom prompt from a file in your vault.",
      cls: "ss-chat-settings-modal__prompt-type-details"
    });
    new import_obsidian38.Setting(section).setName("Prompt File").setDesc("Select a file to use as your post-processing prompt").addText((text) => {
      this.fileInputEl = text.inputEl;
      text.setPlaceholder("Select a file...");
      attachFileSuggester(text.inputEl, async (selectedPath) => {
        await this.selectFile(selectedPath);
      }, this.app, this.systemPromptsDirectory);
    }).addButton((button) => {
      button.setButtonText("Browse").setIcon("folder").onClick(() => {
        this.fileInputEl.focus();
      });
    });
    new import_obsidian38.Setting(section).setName("Create New").setDesc("Create a new prompt file").addButton((button) => {
      button.setButtonText("Create New Prompt File").setIcon("file-plus").onClick(async () => {
        await this.createNewPromptFile();
      });
    });
  }
  createPromptEditorSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Prompt Content",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Review and edit the prompt content below.",
      cls: "ss-chat-settings-modal__prompt-editor-note"
    });
    this.promptTextarea = section.createEl("textarea", {
      cls: "ss-chat-settings-modal__prompt-textarea",
      attr: {
        placeholder: "Enter your post-processing prompt here...",
        rows: "8"
      }
    });
  }
  async loadCurrentState() {
    const settings = this.plugin.settings;
    if (settings.postProcessingPromptType === "preset" && settings.postProcessingPromptPresetId) {
      await this.selectPreset(settings.postProcessingPromptPresetId);
    } else if (settings.postProcessingPromptType === "file" && settings.postProcessingPromptFilePath) {
      await this.selectFile(settings.postProcessingPromptFilePath);
    } else if (settings.postProcessingPrompt) {
      this.promptTextarea.value = settings.postProcessingPrompt;
    } else {
      await this.selectPreset(this.presets[0].id);
    }
  }
  async selectPreset(presetId) {
    const preset = this.presets.find((p) => p.id === presetId);
    if (!preset)
      return;
    this.promptTextarea.value = preset.content;
    this.updatePresetButtons(presetId);
    this.updatePresetDescription(preset);
    this.clearFileSelection();
    await this.saveToSettings("preset", preset.content, presetId, "");
  }
  async selectFile(filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian38.TFile)) {
        throw new Error("File not found");
      }
      const content = await this.app.vault.read(file);
      this.promptTextarea.value = content;
      this.fileInputEl.value = filePath;
      this.clearPresetSelection();
      await this.saveToSettings("file", content, "", filePath);
    } catch (error) {
      console.error("Failed to load file:", error);
      new import_obsidian38.Notice("Failed to load file. Please check the file path and try again.", 3e3);
    }
  }
  async createNewPromptFile() {
    const name = await this.showTextInputModal("Create New Prompt", "Enter a name for your prompt file:");
    if (!name)
      return;
    try {
      const fileName = name.replace(/[^a-zA-Z0-9-_ ]/g, "").replace(/ /g, "-");
      const filePath = `${this.systemPromptsDirectory}/${fileName}.md`;
      const content = `You are a transcription post-processor. Your task is to fix any transcription errors, correct grammar and punctuation, and ensure the text is properly formatted. Keep the original meaning intact while making the text more readable.

Please process the following raw transcript to:
- Fix grammar, punctuation, and capitalization
- Remove filler words (um, uh, like, you know)
- Format into clear paragraphs
- Maintain the original meaning and speaker's voice

Raw transcript:`;
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
        const confirmOverwrite = await showPopup(this.app, "", {
          title: "File Already Exists",
          description: `A file named "${fileName}.md" already exists. Do you want to overwrite it?`,
          primaryButton: "Overwrite",
          secondaryButton: "Cancel"
        });
        if (!confirmOverwrite) {
          return;
        }
      }
      if (this.plugin.directoryManager) {
        await this.plugin.directoryManager.ensureDirectoryByPath(this.systemPromptsDirectory);
      } else {
        try {
          await this.app.vault.createFolder(this.systemPromptsDirectory);
        } catch (error) {
          if (!error.message.includes("already exists")) {
            throw error;
          }
        }
      }
      if (existingFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(filePath, content);
      }
      await this.selectFile(filePath);
      new import_obsidian38.Notice(`${existingFile ? "Updated" : "Created"} prompt file: ${fileName}.md`, 3e3);
    } catch (error) {
      console.error("Failed to create file:", error);
      new import_obsidian38.Notice("Failed to create prompt file", 3e3);
    }
  }
  updatePresetButtons(selectedId) {
    this.presetButtonContainer.querySelectorAll(".ss-preset-button").forEach((btn) => {
      btn.removeClass("is-active");
      if (btn.getAttribute("data-preset-id") === selectedId) {
        btn.addClass("is-active");
      }
    });
  }
  updatePresetDescription(preset) {
    this.presetDescriptionEl.textContent = preset.description;
    this.presetDescriptionEl.style.display = "block";
  }
  clearPresetSelection() {
    this.presetButtonContainer.querySelectorAll(".ss-preset-button").forEach((btn) => {
      btn.removeClass("is-active");
    });
    this.presetDescriptionEl.style.display = "none";
  }
  clearFileSelection() {
    this.fileInputEl.value = "";
  }
  async saveToSettings(type, content, presetId, filePath) {
    await this.plugin.getSettingsManager().updateSettings({
      postProcessingPromptType: type,
      postProcessingPrompt: content,
      postProcessingPromptPresetId: presetId,
      postProcessingPromptFilePath: filePath
    });
    console.log("Saved settings:", {
      type,
      presetId,
      filePath,
      contentLength: content.length
    });
  }
  async showTextInputModal(title, placeholder) {
    return new Promise((resolve) => {
      const modal = new class extends StandardModal {
        constructor(app) {
          super(app);
          this.result = null;
          this.setSize("small");
        }
        onOpen() {
          super.onOpen();
          this.addTitle(title);
          this.input = this.contentEl.createEl("input", {
            type: "text",
            placeholder,
            cls: "ss-chat-settings-modal__title-input"
          });
          this.addActionButton("Cancel", () => {
            this.close();
          }, false);
          this.addActionButton("Create", () => {
            this.result = this.input.value.trim();
            this.close();
          }, true);
          setTimeout(() => this.input.focus(), 10);
        }
        onClose() {
          resolve(this.result);
          super.onClose();
        }
      }(this.app);
      modal.open();
    });
  }
  async onClose() {
    if (this.promptTextarea) {
      await this.plugin.getSettingsManager().updateSettings({
        postProcessingPrompt: this.promptTextarea.value
      });
    }
    if (this.resolvePromise) {
      this.result = {
        content: this.promptTextarea.value,
        source: this.plugin.settings.postProcessingPromptType,
        presetId: this.plugin.settings.postProcessingPromptPresetId || void 0,
        filePath: this.plugin.settings.postProcessingPromptFilePath || void 0
      };
      this.resolvePromise(this.result);
    }
    super.onClose();
  }
  async openAndGetResult() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      this.open();
    });
  }
};

// src/settings/SystemPromptSettingsTabContent.ts
init_SystemPromptService();
async function displaySystemPromptSettingsTabContent(containerEl, tabInstance) {
  containerEl.empty();
  containerEl.dataset.tab = "system-prompt-settings";
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "System Prompt Settings" });
  containerEl.createEl("p", {
    text: "Configure which system prompts are used for different features throughout SystemSculpt.",
    cls: "setting-item-description"
  });
  const systemPromptService = SystemPromptService.getInstance(app, () => plugin.settings);
  const promptsContainer = containerEl.createDiv("systemsculpt-models-container");
  const chatPromptCard = promptsContainer.createDiv("systemsculpt-model-card systemsculpt-model-card-clickable");
  chatPromptCard.createEl("div", { text: "Default Chat System Prompt", cls: "systemsculpt-model-card-title" });
  chatPromptCard.createEl("div", { text: "The system prompt used for all new chat conversations", cls: "systemsculpt-model-card-description" });
  const chatPromptValue = chatPromptCard.createEl("div", { cls: "systemsculpt-model-card-value" });
  const updateChatPromptDisplay = async () => {
    var _a;
    const type = plugin.settings.systemPromptType;
    const path = plugin.settings.systemPromptPath;
    if (type === "general-use") {
      chatPromptValue.setText("General Use");
      chatPromptValue.removeClass("systemsculpt-model-card-value-unavailable");
      chatPromptValue.removeClass("systemsculpt-model-card-value-empty");
    } else if (type === "concise") {
      chatPromptValue.setText("Concise");
      chatPromptValue.removeClass("systemsculpt-model-card-value-unavailable");
      chatPromptValue.removeClass("systemsculpt-model-card-value-empty");
    } else if (type === "agent") {
      chatPromptValue.setText("Agent Mode");
      chatPromptValue.removeClass("systemsculpt-model-card-value-unavailable");
      chatPromptValue.removeClass("systemsculpt-model-card-value-empty");
    } else if (type === "custom" && path) {
      try {
        const file = app.vault.getAbstractFileByPath(path);
        if (file) {
          const fileName = ((_a = path.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "Custom";
          chatPromptValue.setText(fileName);
          chatPromptValue.removeClass("systemsculpt-model-card-value-unavailable");
          chatPromptValue.removeClass("systemsculpt-model-card-value-empty");
        } else {
          chatPromptValue.setText(`Custom (${path.split("/").pop() || "unavailable"})`);
          chatPromptValue.addClass("systemsculpt-model-card-value-unavailable");
        }
      } catch (error) {
        chatPromptValue.setText("Custom (unavailable)");
        chatPromptValue.addClass("systemsculpt-model-card-value-unavailable");
      }
    } else {
      chatPromptValue.setText("Click to select a system prompt");
      chatPromptValue.addClass("systemsculpt-model-card-value-empty");
    }
  };
  chatPromptCard.addEventListener("click", async () => {
    const modal = new StandardSystemPromptSelectionModal({
      app,
      plugin,
      currentType: plugin.settings.systemPromptType,
      currentPath: plugin.settings.systemPromptPath,
      title: "Select Default Chat System Prompt",
      description: "Choose the default system prompt for all new chats",
      onSelect: async (result) => {
        var _a, _b;
        try {
          await plugin.getSettingsManager().updateSettings({
            systemPromptType: result.type,
            systemPromptPath: result.path || "",
            systemPrompt: result.prompt
          });
          (_b = (_a = plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
          updateChatPromptDisplay();
          new import_obsidian39.Notice("Default chat system prompt updated successfully.", 3e3);
        } catch (error) {
          console.error("Error updating default chat system prompt:", error);
          new import_obsidian39.Notice("Failed to update default chat system prompt. Please try again.", 5e3);
        }
      }
    });
    modal.open();
  });
  const titlePromptCard = promptsContainer.createDiv("systemsculpt-model-card systemsculpt-model-card-clickable");
  titlePromptCard.createEl("div", { text: "Title Generation Prompt", cls: "systemsculpt-model-card-title" });
  titlePromptCard.createEl("div", { text: "The system prompt used for generating chat titles", cls: "systemsculpt-model-card-description" });
  const titlePromptValue = titlePromptCard.createEl("div", { cls: "systemsculpt-model-card-value" });
  const updateTitlePromptDisplay = async () => {
    var _a;
    const type = plugin.settings.titleGenerationPromptType;
    const path = plugin.settings.titleGenerationPromptPath;
    if (type === "precise") {
      titlePromptValue.setText("Precise");
      titlePromptValue.removeClass("systemsculpt-model-card-value-unavailable");
      titlePromptValue.removeClass("systemsculpt-model-card-value-empty");
    } else if (type === "movie-style") {
      titlePromptValue.setText("Movie Style");
      titlePromptValue.removeClass("systemsculpt-model-card-value-unavailable");
      titlePromptValue.removeClass("systemsculpt-model-card-value-empty");
    } else if (type === "custom" && path) {
      try {
        const file = app.vault.getAbstractFileByPath(path);
        if (file) {
          const fileName = ((_a = path.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "Custom";
          titlePromptValue.setText(fileName);
          titlePromptValue.removeClass("systemsculpt-model-card-value-unavailable");
          titlePromptValue.removeClass("systemsculpt-model-card-value-empty");
        } else {
          titlePromptValue.setText(`Custom (${path.split("/").pop() || "unavailable"})`);
          titlePromptValue.addClass("systemsculpt-model-card-value-unavailable");
        }
      } catch (error) {
        titlePromptValue.setText("Custom (unavailable)");
        titlePromptValue.addClass("systemsculpt-model-card-value-unavailable");
      }
    } else {
      titlePromptValue.setText("Precise (default)");
      titlePromptValue.addClass("systemsculpt-model-card-value-default");
    }
  };
  titlePromptCard.addEventListener("click", async () => {
    var _a, _b;
    try {
      const result = await showTitleGenerationPromptModal(app, plugin, plugin.settings.titleGenerationPrompt, {
        systemPromptsDirectory: plugin.settings.systemPromptsDirectory
      });
      if (result) {
        (_b = (_a = plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
        updateTitlePromptDisplay();
        new import_obsidian39.Notice("Title generation prompt updated successfully.", 3e3);
      }
    } catch (error) {
      console.error("Error updating title generation prompt:", error);
      new import_obsidian39.Notice("Failed to update title generation prompt. Please try again.", 5e3);
    }
  });
  const postProcessingPromptCard = promptsContainer.createDiv("systemsculpt-model-card systemsculpt-model-card-clickable");
  postProcessingPromptCard.createEl("div", { text: "Post-Processing Prompt", cls: "systemsculpt-model-card-title" });
  postProcessingPromptCard.createEl("div", { text: "The system prompt used for processing audio transcriptions", cls: "systemsculpt-model-card-description" });
  const postProcessingPromptValue = postProcessingPromptCard.createEl("div", { cls: "systemsculpt-model-card-value" });
  const updatePostProcessingPromptDisplay = async () => {
    var _a;
    const type = plugin.settings.postProcessingPromptType;
    const path = plugin.settings.postProcessingPromptFilePath;
    const presetId = plugin.settings.postProcessingPromptPresetId;
    if (type === "preset") {
      if (presetId) {
        postProcessingPromptValue.setText(`Preset (${presetId})`);
        postProcessingPromptValue.removeClass("systemsculpt-model-card-value-unavailable");
        postProcessingPromptValue.removeClass("systemsculpt-model-card-value-empty");
      } else {
        postProcessingPromptValue.setText("Preset (default)");
        postProcessingPromptValue.addClass("systemsculpt-model-card-value-default");
      }
    } else if (type === "file" && path) {
      try {
        const file = app.vault.getAbstractFileByPath(path);
        if (file) {
          const fileName = ((_a = path.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "Custom";
          postProcessingPromptValue.setText(fileName);
          postProcessingPromptValue.removeClass("systemsculpt-model-card-value-unavailable");
          postProcessingPromptValue.removeClass("systemsculpt-model-card-value-empty");
        } else {
          postProcessingPromptValue.setText(`Custom (${path.split("/").pop() || "unavailable"})`);
          postProcessingPromptValue.addClass("systemsculpt-model-card-value-unavailable");
        }
      } catch (error) {
        postProcessingPromptValue.setText("Custom (unavailable)");
        postProcessingPromptValue.addClass("systemsculpt-model-card-value-unavailable");
      }
    } else {
      postProcessingPromptValue.setText("Preset (default)");
      postProcessingPromptValue.addClass("systemsculpt-model-card-value-default");
    }
  };
  postProcessingPromptCard.addEventListener("click", async () => {
    var _a, _b;
    try {
      const modal = new PostProcessingPromptModal(app, plugin, plugin.settings.postProcessingPrompt, plugin.settings.systemPromptsDirectory);
      const result = await modal.openAndGetResult();
      if (result) {
        (_b = (_a = plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
        updatePostProcessingPromptDisplay();
        new import_obsidian39.Notice("Post-processing prompt updated successfully.", 3e3);
      }
    } catch (error) {
      console.error("Error updating post-processing prompt:", error);
      new import_obsidian39.Notice("Failed to update post-processing prompt. Please try again.", 5e3);
    }
  });
  updateChatPromptDisplay();
  updateTitlePromptDisplay();
  updatePostProcessingPromptDisplay();
  plugin.emitter.off("systemPromptSettingsChanged");
  plugin.emitter.on("systemPromptSettingsChanged", updateDisplays);
  function updateDisplays() {
    updateChatPromptDisplay();
    updateTitlePromptDisplay();
    updatePostProcessingPromptDisplay();
  }
  const guidanceEl = containerEl.createDiv("systemsculpt-models-guidance");
  guidanceEl.createEl("p", {
    text: "\u{1F4A1} System prompts define how the AI behaves in different contexts. You can use built-in presets or create custom prompts in your vault.",
    cls: "systemsculpt-models-guidance-text"
  });
  const systemPromptsNote = containerEl.createEl("p", {
    text: `Custom system prompts are stored in your "${plugin.settings.systemPromptsDirectory}" directory. Visit the Directories tab to configure this location.`,
    cls: "setting-item-description systemsculpt-transcription-note"
  });
}

// src/settings/TemplatesTabContent.ts
var import_obsidian40 = __toModule(require("obsidian"));
function displayTemplatesTabContent(containerEl, tabInstance) {
  containerEl.empty();
  containerEl.dataset.tab = "templates";
  const { plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Templates Settings" });
  new import_obsidian40.Setting(containerEl).setName("Enable Template Hotkey").setDesc("Enable the template hotkey to quickly access system prompts").addToggle((toggle) => toggle.setValue(plugin.settings.enableTemplateHotkey).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ enableTemplateHotkey: value });
  }));
  new import_obsidian40.Setting(containerEl).setName("Template Hotkey").setDesc("Set the hotkey that will trigger the system prompts list when typed at the beginning of a new line").addText((text) => text.setPlaceholder("/").setValue(plugin.settings.templateHotkey).onChange(async (value) => {
    if (value.length > 1) {
      value = value.charAt(0);
      text.setValue(value);
    }
    await plugin.getSettingsManager().updateSettings({ templateHotkey: value });
  }));
  containerEl.createEl("div", {
    text: "When the template hotkey is pressed at the beginning of a new line, a list of all system prompts in your system prompts directory will be shown.",
    cls: "setting-item-description"
  });
}

// src/settings/AdvancedTabContent.ts
var import_obsidian42 = __toModule(require("obsidian"));
init_ui();
init_types();

// src/modals/UpdateNotificationWarningModal.ts
var import_obsidian41 = __toModule(require("obsidian"));
var UpdateNotificationWarningModal = class extends import_obsidian41.Modal {
  constructor(app) {
    super(app);
    this.result = { confirmed: false };
    this.resolve = () => {
    };
  }
  async open() {
    return new Promise((resolve) => {
      this.resolve = resolve;
      super.open();
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const headerEl = contentEl.createDiv({ cls: "modal-header" });
    const iconEl = headerEl.createDiv({ cls: "modal-header-icon" });
    iconEl.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
                <path d="M12 9v4"/>
                <path d="m12 17 .01 0"/>
            </svg>
        `;
    iconEl.addClass("ss-modal-icon--warning");
    const titleEl = headerEl.createDiv({ cls: "modal-title" });
    titleEl.textContent = "Disable Update Notifications";
    const messageEl = contentEl.createDiv({ cls: "modal-content" });
    messageEl.innerHTML = `
            <p><strong>Warning:</strong> Disabling update notifications means you'll be responsible for manually checking for plugin updates.</p>
            
            <p>Without notifications, you may miss important updates that include:</p>
            <ul>
                <li>Security fixes and bug patches</li>
                <li>New features and improvements</li>
                <li>Compatibility updates for new Obsidian versions</li>
                <li>Performance optimizations</li>
            </ul>
            
            <p>If you're not on the latest version, some features may stop working or behave unexpectedly.</p>
            
            <p><strong>Recommendation:</strong> Keep update notifications enabled to stay current with the latest improvements and fixes.</p>
            
            <p>You can re-enable notifications at any time in the Advanced settings tab.</p>
        `;
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian41.Setting(buttonContainer).addButton((btn) => {
      btn.setButtonText("Cancel").onClick(() => {
        this.result.confirmed = false;
        this.close();
      });
    }).addButton((btn) => {
      btn.setButtonText("Disable Notifications").setWarning().onClick(() => {
        this.result.confirmed = true;
        this.close();
      });
    });
  }
  onClose() {
    this.resolve(this.result);
  }
};

// src/settings/AdvancedTabContent.ts
init_errorHandling();
function displayAdvancedTabContent(containerEl, tabInstance) {
  containerEl.empty();
  containerEl.dataset.tab = "advanced";
  const { app, plugin, systemSculptService } = tabInstance;
  containerEl.createEl("h3", { text: "Advanced Settings" });
  const developmentModeSetting = new import_obsidian42.Setting(containerEl).setName("Development mode").setDesc("Enable additional logging and debugging features for troubleshooting").addToggle((toggle) => {
    toggle.setValue(plugin.settings.debugMode).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({
        debugMode: value,
        logLevel: value ? LogLevel.DEBUG : LogLevel.WARNING
      });
      setLogLevel(value ? LogLevel.DEBUG : LogLevel.WARNING);
      new import_obsidian42.Notice(`Development mode ${value ? "enabled" : "disabled"}.`);
    });
  });
  const updateNotificationsSetting = new import_obsidian42.Setting(containerEl).setName("Update notifications").setDesc("Show notifications when plugin updates are available").addToggle((toggle) => {
    toggle.setValue(plugin.settings.showUpdateNotifications).onChange(async (value) => {
      var _a, _b;
      if (!value) {
        const warningModal = new UpdateNotificationWarningModal(app);
        const result = await warningModal.open();
        if (result.confirmed) {
          await plugin.getSettingsManager().updateSettings({
            showUpdateNotifications: false
          });
          (_a = plugin.versionCheckerService) == null ? void 0 : _a.onUpdateNotificationsDisabled();
          new import_obsidian42.Notice("Update notifications disabled. You can re-enable them anytime in Advanced settings.");
        } else {
          toggle.setValue(true);
        }
      } else {
        await plugin.getSettingsManager().updateSettings({
          showUpdateNotifications: true
        });
        (_b = plugin.versionCheckerService) == null ? void 0 : _b.onUpdateNotificationsEnabled();
        new import_obsidian42.Notice("Update notifications enabled.");
      }
    });
  });
  const resetSetting = new import_obsidian42.Setting(containerEl).setName("Reset to Factory Settings").setDesc("Clear all custom settings and restore defaults for this plugin.");
  const resetButton = new import_obsidian42.ButtonComponent(resetSetting.controlEl);
  resetButton.setButtonText("Reset\u2026");
  resetButton.setWarning();
  resetButton.onClick(async () => {
    var _a;
    const confirm2 = await showPopup(app, "Reset to Factory Defaults", {
      description: "This will delete ALL saved settings and customizations for SystemSculpt, returning everything to default. Do you want to continue?",
      primaryButton: "Reset & Reload",
      secondaryButton: "Cancel"
    });
    if (!confirm2 || !confirm2.confirmed) {
      return;
    }
    try {
      (_a = plugin.customProviderService) == null ? void 0 : _a.clearCache();
      await plugin.saveData(null);
      await plugin.getSettingsManager().updateSettings({ ...DEFAULT_SETTINGS });
      new import_obsidian42.Notice("Settings reset. Reloading Obsidian...", 3e3);
      setTimeout(() => window.location.reload(), 1e3);
    } catch (error) {
      console.error("Error resetting to factory settings:", error);
      showPopup(app, "Failed to reset: " + String(error));
    }
  });
  containerEl.createEl("hr", { cls: "settings-separator" });
  containerEl.createEl("h3", { text: "Diagnostics & Troubleshooting" });
  const logsSetting = new import_obsidian42.Setting(containerEl).setName("Console Logs Collector").setDesc("Copy all SystemSculpt-related console logs to help with troubleshooting");
  const logsButton = new import_obsidian42.ButtonComponent(logsSetting.controlEl);
  logsButton.setButtonText("Copy Logs for Support");
  logsButton.setTooltip("Copy all SystemSculpt logs to clipboard");
  logsButton.onClick(async () => {
    try {
      const success = await plugin.copyAllLogsToClipboard();
      if (success) {
        new import_obsidian42.Notice("SystemSculpt logs copied to clipboard. You can now paste them to share with the developer via Discord.", 5e3);
      } else {
        new import_obsidian42.Notice("Failed to copy logs to clipboard. Please try again.", 5e3);
      }
    } catch (error) {
      console.error("[SystemSculpt] Error copying logs:", error);
      new import_obsidian42.Notice("Error copying logs: " + error.message, 5e3);
    }
  });
}

// src/settings/BackupTabContent.ts
var import_obsidian44 = __toModule(require("obsidian"));
init_ui();

// src/core/settings/BackupRestoreModal.ts
var import_obsidian43 = __toModule(require("obsidian"));
init_ListSelectionModal();
var BackupRestoreModal = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async open() {
    try {
      const backups = await this.getAvailableBackups();
      if (backups.length === 0) {
        new import_obsidian43.Notice("No settings backups found", 3e3);
        return null;
      }
      const items = backups.map((backup) => ({
        id: backup.path,
        title: backup.name,
        description: "",
        icon: "save",
        _backupDetails: backup.details || backup.date
      }));
      const modal = new ListSelectionModal(this.app, items, {
        title: "Restore Settings from Backup",
        description: "Select a backup to restore. This will replace your current settings.",
        placeholder: "Search backups...",
        emptyText: "No backups found",
        size: "medium",
        closeOnSelect: true,
        customContent: (containerEl) => {
          const styleEl = document.createElement("style");
          styleEl.textContent = `
                        .backup-details {
                            font-size: 12px;
                            color: var(--text-muted);
                            white-space: normal !important;
                            overflow: visible !important;
                            text-overflow: clip !important;
                            line-height: 1.5;
                            margin-top: 4px;
                        }
                        .backup-detail-item {
                            display: inline-block;
                            margin-right: 8px;
                            background: var(--background-secondary);
                            padding: 2px 6px;
                            border-radius: 4px;
                            margin-bottom: 4px;
                        }
                        .create-backup-button {
                            display: flex;
                            padding: 10px;
                            margin-bottom: 10px;
                            background: var(--background-secondary);
                            border-radius: 5px;
                            align-items: center;
                            cursor: pointer;
                            transition: background-color 0.2s;
                        }
                        .create-backup-button:hover {
                            background: var(--background-modifier-hover);
                        }
                        .create-backup-icon {
                            margin-right: 8px;
                            color: var(--text-accent);
                        }
                        .create-backup-text {
                            flex-grow: 1;
                        }
                        .create-backup-text-main {
                            font-weight: 500;
                            margin-bottom: 2px;
                        }
                        .create-backup-text-sub {
                            font-size: 12px;
                            color: var(--text-muted);
                        }
                        .manual-backup-container {
                            margin-bottom: 10px;
                            padding: 10px;
                            background: var(--background-secondary);
                            border-radius: 5px;
                        }
                    `;
          containerEl.appendChild(styleEl);
          const manualBackupContainer = containerEl.createDiv({ cls: "manual-backup-container" });
          manualBackupContainer.style.marginBottom = "10px";
          manualBackupContainer.style.padding = "10px";
          manualBackupContainer.style.background = "var(--background-secondary)";
          manualBackupContainer.style.borderRadius = "5px";
          const inputPromptEl = manualBackupContainer.createEl("p", { text: "Enter a name for the new manual backup:" });
          inputPromptEl.style.marginBottom = "5px";
          const backupNameInput = new import_obsidian43.TextComponent(manualBackupContainer).setPlaceholder(`Manual backup ${new Date().toLocaleString()}`).setValue(`Manual backup ${new Date().toLocaleString()}`);
          backupNameInput.inputEl.style.width = "100%";
          backupNameInput.inputEl.style.marginBottom = "8px";
          const createBackupButton = manualBackupContainer.createEl("button", {
            text: "Create Manual Backup",
            cls: "mod-cta"
          });
          createBackupButton.style.width = "100%";
          createBackupButton.addEventListener("click", async () => {
            const backupName = backupNameInput.getValue().trim();
            if (!backupName) {
              new import_obsidian43.Notice("Please enter a name for the backup.", 3e3);
              return;
            }
            try {
              await this.saveManualBackup(backupName);
              new import_obsidian43.Notice("Manual backup created successfully.", 3e3);
              modal.close();
              this.open();
            } catch (error) {
            }
          });
          if (containerEl.firstChild) {
            containerEl.insertBefore(manualBackupContainer, containerEl.firstChild);
          } else {
            containerEl.appendChild(manualBackupContainer);
          }
          const originalCreateListItem = modal.createListItem.bind(modal);
          modal.createListItem = (itemData, index) => {
            const itemEl = originalCreateListItem(itemData, index);
            if (itemData._backupDetails) {
              const defaultDesc = itemEl.querySelector(".ss-modal__item-description");
              if (defaultDesc) {
                defaultDesc.remove();
              }
              const content = itemEl.querySelector(".ss-modal__item-content");
              if (content) {
                const detailsEl = content.createDiv({ cls: "backup-details" });
                const details = itemData._backupDetails;
                if (details.includes("\n")) {
                  const detailItems = details.split("\n");
                  detailItems.forEach((item) => {
                    detailsEl.createSpan({
                      text: item,
                      cls: "backup-detail-item"
                    });
                  });
                } else {
                  detailsEl.setText(details);
                }
              }
            }
            return itemEl;
          };
        }
      });
      const selectedItems = await modal.openAndGetSelection();
      if (selectedItems.length === 0) {
        return null;
      }
      return selectedItems[0].id;
    } catch (error) {
      console.error("[SystemSculpt] Error opening backup restore modal:", error);
      new import_obsidian43.Notice("Error loading backups: " + error, 3e3);
      return null;
    }
  }
  async saveManualBackup(backupName) {
    try {
      const safeNamePart = backupName.replace(/[^a-z0-9]/gi, "-").toLowerCase();
      const timestamp = Date.now();
      const fileName = `settings-manual-${safeNamePart}-${timestamp}.json`;
      const backupDir = ".systemsculpt/settings-backups";
      try {
        await this.plugin.app.vault.createFolder(backupDir);
      } catch (e) {
        if (!e.message || !e.message.includes("already exists")) {
          throw e;
        }
      }
      const currentSettings = this.plugin.getSettingsManager().getSettings();
      const backupData = {
        ...currentSettings,
        _backupMeta: {
          type: "manual",
          name: backupName,
          timestamp,
          createdAt: new Date().toISOString()
        }
      };
      const backupPath = `.systemsculpt/settings-backups/${fileName}`;
      await this.plugin.app.vault.adapter.write(backupPath, JSON.stringify(backupData, null, 2));
      new import_obsidian43.Notice(`Manual backup "${backupName}" created successfully`, 3e3);
    } catch (error) {
      console.error("[SystemSculpt] Error saving manual backup:", error);
      new import_obsidian43.Notice("Error saving backup: " + error, 3e3);
      throw error;
    }
  }
  async getAvailableBackups() {
    try {
      const backupDir = ".systemsculpt/settings-backups";
      const exists = await this.plugin.app.vault.adapter.exists(backupDir);
      if (!exists) {
        return [];
      }
      const files = await this.plugin.app.vault.adapter.list(backupDir);
      const backupFiles = files.files.filter((f) => f.includes("settings-") && f.endsWith(".json")).sort((a, b) => {
        const aMatch = a.match(/(\d{4}-\d{2}-\d{2})|(\d+)/);
        const bMatch = b.match(/(\d{4}-\d{2}-\d{2})|(\d+)/);
        if (aMatch && bMatch) {
          if (aMatch[2] && bMatch[2]) {
            return parseInt(bMatch[2]) - parseInt(aMatch[2]);
          }
          if (aMatch[1] && bMatch[1]) {
            return bMatch[1].localeCompare(aMatch[1]);
          }
        }
        return b.localeCompare(a);
      });
      const backupsPromises = backupFiles.map(async (filePath) => {
        let name = filePath.split("/").pop() || "";
        let date = "Unknown date";
        let details = "";
        let backupSettings = null;
        try {
          const backupData = await this.plugin.app.vault.adapter.read(filePath);
          backupSettings = JSON.parse(backupData);
          if (backupSettings) {
            const customProviders = Array.isArray(backupSettings.customProviders) ? backupSettings.customProviders.length : 0;
            const favoriteModels = Array.isArray(backupSettings.favoriteModels) ? backupSettings.favoriteModels.length : 0;
            const selectedModel = backupSettings.selectedModelId || "None";
            const hasLicense = backupSettings.licenseValid === true ? "Yes" : "No";
            details = `\u{1F464} ${customProviders} provider${customProviders !== 1 ? "s" : ""}
\u2B50 ${favoriteModels} favorite${favoriteModels !== 1 ? "s" : ""}
\u{1F916} ${selectedModel.split(":").pop()}
\u{1F511} License: ${hasLicense}`;
          }
        } catch (error) {
          console.warn(`[SystemSculpt] Could not read backup file ${filePath}:`, error);
          details = "Could not read backup contents";
        }
        if (backupSettings && backupSettings._backupMeta && backupSettings._backupMeta.type === "manual") {
          const meta = backupSettings._backupMeta;
          const backupDate = new Date(meta.timestamp);
          return {
            path: filePath,
            name: `\u{1F4DD} ${meta.name}`,
            date: backupDate.toLocaleString(),
            details
          };
        }
        if (name === "settings-backup-latest.json") {
          return {
            path: filePath,
            name: "Latest Automatic Backup",
            date: "Most recent save",
            details
          };
        }
        const dateMatch = name.match(/settings-backup-(\d{4}-\d{2}-\d{2})\.json/);
        if (dateMatch) {
          const [, dateStr] = dateMatch;
          const dateObj = new Date(dateStr);
          date = dateObj.toLocaleDateString(void 0, {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric"
          });
          return {
            path: filePath,
            name: `Backup from ${date}`,
            date: dateStr,
            details
          };
        }
        const emergencyMatch = name.match(/settings-emergency-(\d+)\.json/);
        if (emergencyMatch) {
          const [, timestamp] = emergencyMatch;
          const dateObj = new Date(parseInt(timestamp));
          date = dateObj.toLocaleString();
          return {
            path: filePath,
            name: `Emergency Backup`,
            date,
            details
          };
        }
        const manualMatch = name.match(/settings-manual-(.*)-(\d+)\.json/);
        if (manualMatch) {
          const [, safeName, timestamp] = manualMatch;
          const dateObj = new Date(parseInt(timestamp));
          const readableName = safeName.replace(/-/g, " ");
          return {
            path: filePath,
            name: `\u{1F4DD} ${readableName}`,
            date: dateObj.toLocaleString(),
            details
          };
        }
        return {
          path: filePath,
          name,
          date,
          details
        };
      });
      const processedBackups = await Promise.all(backupsPromises);
      return processedBackups.sort((a, b) => {
        if (a.name.includes("Latest"))
          return -1;
        if (b.name.includes("Latest"))
          return 1;
        let dateA = 0;
        let dateB = 0;
        const aManualMatch = a.path.match(/settings-manual-.*-(\d+)\.json/);
        if (aManualMatch) {
          dateA = parseInt(aManualMatch[1]);
        }
        const bManualMatch = b.path.match(/settings-manual-.*-(\d+)\.json/);
        if (bManualMatch) {
          dateB = parseInt(bManualMatch[1]);
        }
        const aAutoMatch = a.path.match(/settings-backup-(\d{4}-\d{2}-\d{2})\.json/);
        if (aAutoMatch && !aManualMatch) {
          dateA = new Date(aAutoMatch[1]).getTime();
        }
        const bAutoMatch = b.path.match(/settings-backup-(\d{4}-\d{2}-\d{2})\.json/);
        if (bAutoMatch && !bManualMatch) {
          dateB = new Date(bAutoMatch[1]).getTime();
        }
        if (dateA && dateB) {
          return dateB - dateA;
        }
        if (dateA && !dateB)
          return -1;
        if (!dateA && dateB)
          return 1;
        return b.path.localeCompare(a.path);
      });
    } catch (error) {
      console.error("[SystemSculpt] Error getting available backups:", error);
      return [];
    }
  }
  async restoreFromBackup(backupPath) {
    try {
      const exists = await this.plugin.app.vault.adapter.exists(backupPath);
      if (!exists) {
        new import_obsidian43.Notice("Backup file not found", 3e3);
        return false;
      }
      const backupData = await this.plugin.app.vault.adapter.read(backupPath);
      const backupSettings = JSON.parse(backupData);
      if (!backupSettings || typeof backupSettings !== "object") {
        new import_obsidian43.Notice("Invalid backup file format", 3e3);
        return false;
      }
      await this.plugin.getSettingsManager().updateSettings(backupSettings);
      new import_obsidian43.Notice("Settings restored successfully", 3e3);
      return true;
    } catch (error) {
      console.error("[SystemSculpt] Error restoring from backup:", error);
      new import_obsidian43.Notice("Error restoring settings: " + error, 3e3);
      return false;
    }
  }
};

// src/settings/BackupTabContent.ts
function displayBackupTabContent(containerEl, tabInstance) {
  containerEl.empty();
  containerEl.dataset.tab = "backup";
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Settings Backup & Restore" });
  containerEl.createEl("h4", { text: "Automatic Backups" });
  const autoBackupInfoEl = containerEl.createEl("p", {
    cls: "setting-item-description",
    text: "SystemSculpt automatically backs up your settings every 24 hours to protect against data loss. Backups are stored locally and include all your custom providers, favorite models, and preferences."
  });
  const enableAutoBackupsSetting = new import_obsidian44.Setting(containerEl).setName("Enable automatic backups").setDesc("Create periodic backups of your settings automatically").addToggle((toggle) => {
    toggle.setValue(plugin.settings.automaticBackupsEnabled).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({
        automaticBackupsEnabled: value
      });
      const backupService = plugin.getSettingsManager().getAutomaticBackupService();
      if (value) {
        backupService.start();
        new import_obsidian44.Notice("Automatic backups enabled");
      } else {
        backupService.stop();
        new import_obsidian44.Notice("Automatic backups disabled");
      }
    });
  });
  containerEl.createEl("h4", { text: "Manual Backup & Restore", style: "margin-top: 32px;" });
  const manualBackupInfoEl = containerEl.createEl("p", {
    cls: "setting-item-description",
    text: "Create manual backups with custom names or restore from any existing backup. Backups are stored in your vault's .systemsculpt/settings-backups folder."
  });
  const restoreBackupSetting = new import_obsidian44.Setting(containerEl).setName("Restore from backup").setDesc("Restore your settings from any available backup");
  const restoreButton = new import_obsidian44.ButtonComponent(restoreBackupSetting.controlEl);
  restoreButton.setButtonText("Select Backup").setIcon("history").onClick(async () => {
    const backupModal = new BackupRestoreModal(app, plugin);
    const selectedBackupPath = await backupModal.open();
    if (selectedBackupPath) {
      try {
        const backupData = await plugin.app.vault.adapter.read(selectedBackupPath);
        const backupSettings = JSON.parse(backupData);
        const customProviders = Array.isArray(backupSettings.customProviders) ? backupSettings.customProviders : [];
        const favoriteModels = Array.isArray(backupSettings.favoriteModels) ? backupSettings.favoriteModels : [];
        const selectedModel = backupSettings.selectedModelId ? backupSettings.selectedModelId.split(":").pop() : "Default";
        let detailsMessage = `This backup contains:
\u2022 ${customProviders.length} custom provider${customProviders.length !== 1 ? "s" : ""}
\u2022 ${favoriteModels.length} favorite model${favoriteModels.length !== 1 ? "s" : ""}
\u2022 Selected model: ${selectedModel}
\u2022 License status: ${backupSettings.licenseValid ? "Active" : "Inactive"}`;
        const confirmed = await showPopup(app, "Restore Settings from Backup", {
          description: `This will replace your current settings with the selected backup.

${detailsMessage}

Continue?`,
          primaryButton: "Restore",
          secondaryButton: "Cancel"
        });
        if (confirmed && confirmed.confirmed) {
          const success = await backupModal.restoreFromBackup(selectedBackupPath);
          if (success) {
            displayBackupTabContent(containerEl, tabInstance);
          }
        }
      } catch (error) {
        console.error("[SystemSculpt] Error reading backup for confirmation:", error);
        const confirmed = await showPopup(app, "Restore Settings from Backup", {
          description: "This will replace your current settings with the selected backup. Continue?",
          primaryButton: "Restore",
          secondaryButton: "Cancel"
        });
        if (confirmed && confirmed.confirmed) {
          const success = await backupModal.restoreFromBackup(selectedBackupPath);
          if (success) {
            displayBackupTabContent(containerEl, tabInstance);
          }
        }
      }
    }
  });
  containerEl.createEl("h4", { text: "Backup Management", style: "margin-top: 32px;" });
  const managementInfoEl = containerEl.createEl("p", {
    cls: "setting-item-description",
    text: "View and manage your backup files. Backups are stored in your vault's .systemsculpt/settings-backups folder and include all your settings data."
  });
  const backupLocationSetting = new import_obsidian44.Setting(containerEl).setName("Backup location").setDesc("Open the folder where backups are stored");
  const openLocationButton = new import_obsidian44.ButtonComponent(backupLocationSetting.controlEl);
  openLocationButton.setButtonText("Open Folder").setIcon("folder").onClick(async () => {
    try {
      const backupDir = `.systemsculpt/settings-backups`;
      try {
        await plugin.app.vault.createFolder(backupDir);
      } catch (e) {
      }
      if (plugin.app.vault.adapter.revealInFolder) {
        plugin.app.vault.adapter.revealInFolder(backupDir);
      } else {
        new import_obsidian44.Notice(`Backups are stored in vault folder: ${backupDir}`);
      }
    } catch (error) {
      console.error("[SystemSculpt] Error opening backup folder:", error);
      new import_obsidian44.Notice("Failed to open backup folder");
    }
  });
  const tipsContainer = containerEl.createDiv("backup-tips-container");
  tipsContainer.style.marginTop = "24px";
  tipsContainer.style.padding = "16px";
  tipsContainer.style.background = "var(--background-secondary)";
  tipsContainer.style.borderRadius = "6px";
  tipsContainer.style.borderLeft = "4px solid var(--interactive-accent)";
  tipsContainer.createEl("h5", { text: "\u{1F4A1} Backup Tips" });
  const tipsList = tipsContainer.createEl("ul");
  tipsList.style.margin = "8px 0 0 0";
  tipsList.style.paddingLeft = "20px";
  const tips = [
    "Automatic backups run in the background and won't interrupt your work",
    "Manual backups with custom names help you save important configurations",
    "Backups include all settings: providers, models, directories, and preferences",
    "Old backups are automatically cleaned up based on your retention settings",
    "You can safely copy backup files to other devices for sharing configurations"
  ];
  tips.forEach((tip) => {
    const li = tipsList.createEl("li");
    li.style.marginBottom = "4px";
    li.style.color = "var(--text-muted)";
    li.textContent = tip;
  });
}

// src/settings/TitleGenerationTabContent.ts
var import_obsidian45 = __toModule(require("obsidian"));
function displayTitleGenerationTabContent(containerEl, tabInstance) {
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Title Generation Settings" });
  const modelSettingsNote = containerEl.createEl("p", {
    text: '\u{1F4A1} To configure the title generation model, visit the "Model Settings" tab. To configure the title generation prompt, visit the "System Prompt Settings" tab.',
    cls: "setting-item-description systemsculpt-model-settings-note"
  });
  new import_obsidian45.Setting(containerEl).setName("Automatic Title Generation").setDesc("Automatically generate titles for new chats without showing the modal").addToggle((toggle) => toggle.setValue(plugin.settings.automaticTitleGeneration).onChange(async (value) => {
    await plugin.getSettingsManager().updateSettings({ automaticTitleGeneration: value });
  }));
}

// src/settings/ChangeLogTabContent.ts
var import_obsidian46 = __toModule(require("obsidian"));
var GITHUB_RELEASES_URL = "https://api.github.com/repos/SystemSculpt/obsidian-systemsculpt-ai/releases";
var RELEASES_PER_BATCH = 10;
function parseLinkHeader(header) {
  if (!header) {
    return {};
  }
  const links = {};
  const parts = header.split(",");
  parts.forEach((part) => {
    const section = part.split(";");
    if (section.length < 2) {
      return;
    }
    const url = section[0].replace(/<(.*)>/, "$1").trim();
    const name = section[1].replace(/rel="(.*)"/, "$1").trim();
    links[name] = url;
  });
  return links;
}
var cachedReleases = null;
var lastFetchTime = 0;
var CACHE_DURATION = 30 * 60 * 1e3;
async function fetchGitHubReleases() {
  const now = Date.now();
  if (cachedReleases && now - lastFetchTime < CACHE_DURATION) {
    console.log("[SystemSculpt] Using cached GitHub releases data");
    return cachedReleases;
  }
  let allReleases = [];
  let nextUrl = GITHUB_RELEASES_URL;
  try {
    while (nextUrl) {
      const response = await (0, import_obsidian46.requestUrl)({ url: nextUrl });
      if (response.status === 200) {
        const releasesData = response.json;
        const newEntries = releasesData.map((release) => ({
          version: release.tag_name,
          date: new Date(release.published_at).toLocaleDateString(),
          notes: release.body || "No release notes provided.",
          url: release.html_url
        }));
        allReleases = allReleases.concat(newEntries);
        const linkHeader = response.headers["link"] || response.headers["Link"];
        const links = parseLinkHeader(linkHeader);
        nextUrl = links.next || null;
      } else if (response.status === 403) {
        console.warn("[SystemSculpt] GitHub API rate limit exceeded (403). Using fallback data.");
        if (cachedReleases) {
          return cachedReleases;
        }
        return [{
          version: "Rate Limited",
          date: new Date().toLocaleDateString(),
          notes: "GitHub API rate limit exceeded. Please visit the GitHub releases page directly to view the latest changes.",
          url: "https://github.com/SystemSculpt/obsidian-systemsculpt-ai/releases"
        }];
      } else {
        console.error("[SystemSculpt] Failed to fetch GitHub releases page:", response.status, response.text, "URL:", nextUrl);
        throw new Error(`Failed to fetch releases: ${response.status}`);
      }
    }
    cachedReleases = allReleases;
    lastFetchTime = now;
    return allReleases;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("403")) {
      console.warn("[SystemSculpt] GitHub API rate limit exceeded when fetching releases. Using fallback data.");
      if (cachedReleases) {
        console.log("[SystemSculpt] Using cached data due to rate limit");
        return cachedReleases;
      }
      return [{
        version: "Rate Limited",
        date: new Date().toLocaleDateString(),
        notes: "GitHub API rate limit exceeded. Please visit the GitHub releases page directly to view the latest changes.",
        url: "https://github.com/SystemSculpt/obsidian-systemsculpt-ai/releases"
      }];
    } else {
      console.error("[SystemSculpt] Error fetching GitHub releases:", error);
      if (cachedReleases) {
        console.log("[SystemSculpt] Using cached data due to fetch error");
        return cachedReleases;
      }
      throw error;
    }
  }
}
async function renderReleaseEntry(entry, parentEl, tabInstance) {
  const entryEl = parentEl.createEl("div", { cls: "systemsculpt-changelog-entry" });
  const headerEl = entryEl.createEl("div", { cls: "systemsculpt-changelog-entry-header" });
  headerEl.createEl("h4", { text: `Version ${entry.version}` });
  headerEl.createEl("span", { cls: "systemsculpt-changelog-entry-date", text: entry.date });
  const notesEl = entryEl.createEl("div", { cls: "systemsculpt-changelog-entry-notes-markdown" });
  await import_obsidian46.MarkdownRenderer.renderMarkdown(entry.notes, notesEl, "", tabInstance.plugin);
  const linkEl = entryEl.createEl("a", {
    cls: "systemsculpt-changelog-entry-link",
    href: entry.url,
    text: "View on GitHub",
    attr: { target: "_blank", rel: "noopener noreferrer" }
  });
  (0, import_obsidian46.setIcon)(linkEl, "external-link");
}
async function displayChangeLogTabContent(containerEl, tabInstance) {
  const app = tabInstance.plugin.app;
  containerEl.empty();
  containerEl.dataset.tab = "changelog";
  containerEl.createEl("h3", { text: "Plugin Change Log" });
  const changelogListEl = containerEl.createEl("div", { cls: "systemsculpt-changelog-list" });
  const loadingEl = changelogListEl.createEl("p", { text: "Loading all releases..." });
  let allFetchedReleases = [];
  let displayedReleasesCount = 0;
  let loadMoreButtonEl = null;
  let loadMoreContainerEl = null;
  function updateLoadMoreButtonState() {
    if (!loadMoreButtonEl)
      return;
    const remaining = allFetchedReleases.length - displayedReleasesCount;
    if (remaining > 0) {
      loadMoreButtonEl.setText(`Load More Releases (${remaining} remaining)`);
      loadMoreButtonEl.style.display = "inline-block";
    } else {
      loadMoreButtonEl.style.display = "none";
    }
  }
  async function displayNextBatchAndManageButton() {
    const startIndex = displayedReleasesCount;
    const endIndex = Math.min(startIndex + RELEASES_PER_BATCH, allFetchedReleases.length);
    if (startIndex >= allFetchedReleases.length) {
      updateLoadMoreButtonState();
      return;
    }
    const batchToDisplay = allFetchedReleases.slice(startIndex, endIndex);
    for (const entry of batchToDisplay) {
      await renderReleaseEntry(entry, changelogListEl, tabInstance);
    }
    displayedReleasesCount = endIndex;
    updateLoadMoreButtonState();
  }
  try {
    allFetchedReleases = await fetchGitHubReleases();
    loadingEl.remove();
    if (allFetchedReleases.length === 0) {
      changelogListEl.createEl("p", { text: "No changelog information available at the moment." });
    } else {
      await displayNextBatchAndManageButton();
      if (allFetchedReleases.length > displayedReleasesCount) {
        if (!loadMoreContainerEl) {
          loadMoreContainerEl = containerEl.createEl("div", { cls: "systemsculpt-load-more-container" });
        }
        loadMoreButtonEl = loadMoreContainerEl.createEl("button", {
          text: "Load More Releases",
          cls: "systemsculpt-load-more-button mod-cta"
        });
        loadMoreButtonEl.addEventListener("click", () => displayNextBatchAndManageButton());
        updateLoadMoreButtonState();
      }
    }
  } catch (error) {
    loadingEl.remove();
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("403")) {
      const rateLimitEl = changelogListEl.createEl("p", { cls: "systemsculpt-changelog-rate-limit" });
      rateLimitEl.setText("Changelog temporarily unavailable due to GitHub API rate limiting. Please try again in a few minutes.");
      console.warn("[SystemSculpt] GitHub API rate limit exceeded when displaying changelog. Will work normally once rate limit resets.");
    } else {
      const errorEl = changelogListEl.createEl("p", { cls: "systemsculpt-changelog-error" });
      errorEl.setText("Failed to load changelog. Please check your internet connection or try again later.");
      new import_obsidian46.Notice("Failed to fetch changelog from GitHub.");
      console.error("[SystemSculpt] Error displaying changelog:", error);
    }
  }
  const allReleasesLinkContainer = containerEl.createEl("div", { cls: "systemsculpt-all-releases-link-container" });
  const allReleasesLink = allReleasesLinkContainer.createEl("a", {
    href: "https://github.com/SystemSculpt/obsidian-systemsculpt-ai/releases",
    text: "View All Releases on GitHub",
    cls: "systemsculpt-all-releases-link",
    attr: { target: "_blank", rel: "noopener noreferrer" }
  });
  (0, import_obsidian46.setIcon)(allReleasesLink, "github");
}

// src/settings/EmbeddingsTabContent.ts
var import_obsidian47 = __toModule(require("obsidian"));
init_FolderSuggester();
init_licenseUtils();
async function displayEmbeddingsTabContent(containerEl, tabInstance) {
  containerEl.empty();
  containerEl.dataset.tab = "embeddings";
  containerEl.createEl("h3", { text: "Embeddings Settings" });
  containerEl.createEl("p", {
    text: "Enable embeddings to find similar notes based on content similarity. Processing happens automatically in the background."
  });
  const progressSection = containerEl.createDiv({ cls: "embeddings-progress-section" });
  await updateProgressDisplay(progressSection, tabInstance.plugin);
  let updateInterval = null;
  const startUpdates = () => {
    if (!updateInterval) {
      updateInterval = window.setInterval(async () => {
        if (containerEl.isConnected && containerEl.dataset.tab === "embeddings") {
          await updateProgressDisplay(progressSection, tabInstance.plugin);
        } else {
          if (updateInterval) {
            window.clearInterval(updateInterval);
            updateInterval = null;
          }
        }
      }, 1e3);
    }
  };
  startUpdates();
  containerEl.addEventListener("remove", () => {
    if (updateInterval) {
      window.clearInterval(updateInterval);
      updateInterval = null;
    }
  });
  const isLicenseValid = verifyPremiumAccess(tabInstance.plugin.settings, 0, false);
  const embeddingsSetting = new import_obsidian47.Setting(containerEl).setName("Enable Embeddings").setDesc("Enable the embeddings feature to find similar notes based on content").addToggle((toggle) => {
    toggle.setValue(tabInstance.plugin.settings.embeddingsEnabled && isLicenseValid || false).setDisabled(!isLicenseValid).onChange(async (value) => {
      if (value && !isLicenseValid) {
        const hasValidLicense = verifyPremiumAccess(tabInstance.plugin.settings, 0, true);
        if (!hasValidLicense) {
          toggle.setValue(false);
          const modal = new import_obsidian47.Modal(tabInstance.app);
          modal.contentEl.createEl("h3", { text: "SystemSculpt Pro License Required" });
          modal.contentEl.createEl("p", {
            text: "Embeddings require an active SystemSculpt Pro license. This feature helps you find similar notes based on content similarity."
          });
          new import_obsidian47.Setting(modal.contentEl).addButton((button) => button.setButtonText("Get Lifetime License").setCta().onClick(() => {
            window.open("https://systemsculpt.com/lifetime", "_blank");
            modal.close();
          })).addButton((button) => button.setButtonText("Close").onClick(() => modal.close()));
          modal.open();
          return;
        }
      }
      await tabInstance.plugin.getSettingsManager().updateSettings({
        embeddingsEnabled: value,
        embeddingsAutoProcess: value
      });
      if (value) {
        new import_obsidian47.Notice("Embeddings enabled. Processing will begin automatically.");
        if (tabInstance.plugin.embeddingsManager) {
          await tabInstance.plugin.embeddingsManager.enableAutoProcessing();
        } else {
          const manager = tabInstance.plugin.getOrCreateEmbeddingsManager();
          await manager.enableAutoProcessing();
        }
        if (tabInstance.plugin.embeddingsStatusBar) {
          tabInstance.plugin.embeddingsStatusBar.startMonitoring();
        }
      } else {
        new import_obsidian47.Notice("Embeddings disabled");
        if (tabInstance.plugin.embeddingsManager) {
          tabInstance.plugin.embeddingsManager.disableAutoProcessing();
        }
        if (tabInstance.plugin.embeddingsStatusBar) {
          tabInstance.plugin.embeddingsStatusBar.stopMonitoring();
        }
      }
    });
  });
  if (!isLicenseValid) {
    embeddingsSetting.setDesc("Enable the embeddings feature to find similar notes based on content. \u26A0\uFE0F Requires an active SystemSculpt Pro license.");
    embeddingsSetting.settingEl.addClass("systemsculpt-disabled-setting");
    const linkContainer = containerEl.createDiv({ cls: "systemsculpt-license-link-container" });
    linkContainer.createEl("span", { text: "\u{1F512} " });
    const link = linkContainer.createEl("a", {
      text: "Get SystemSculpt Pro License",
      href: "https://systemsculpt.com/lifetime",
      cls: "systemsculpt-license-link"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      window.open("https://systemsculpt.com/lifetime", "_blank");
    });
  }
  new import_obsidian47.Setting(containerEl).setName("Clear Embeddings Data").setDesc("Remove all stored embeddings data and start fresh").addButton((button) => {
    button.setButtonText("Clear Data").setWarning().onClick(async () => {
      if (!confirm("Are you sure you want to clear all embeddings data? This cannot be undone.")) {
        return;
      }
      try {
        if (tabInstance.plugin.embeddingsManager) {
          await tabInstance.plugin.embeddingsManager.clear();
          new import_obsidian47.Notice("Embeddings data cleared");
        } else {
          new import_obsidian47.Notice("No embeddings data to clear");
        }
      } catch (error) {
        console.error("[Embeddings] Failed to clear data:", error);
        new import_obsidian47.Notice(`Failed to clear data: ${error.message}`);
      }
    });
  });
  containerEl.createEl("h4", { text: "File Exclusions" });
  containerEl.createEl("p", {
    cls: "setting-item-description",
    text: "Configure which files and folders to exclude from embeddings processing."
  });
  new import_obsidian47.Setting(containerEl).setName("Exclude Chat History").setDesc("Automatically exclude chat history files from embeddings processing").addToggle((toggle) => {
    var _a, _b;
    toggle.setValue((_b = (_a = tabInstance.plugin.settings.embeddingsExclusions) == null ? void 0 : _a.ignoreChatHistory) != null ? _b : true).onChange(async (value) => {
      const currentExclusions = tabInstance.plugin.settings.embeddingsExclusions || {
        folders: [],
        patterns: [],
        ignoreChatHistory: true,
        respectObsidianExclusions: true
      };
      await tabInstance.plugin.getSettingsManager().updateSettings({
        embeddingsExclusions: {
          ...currentExclusions,
          ignoreChatHistory: value
        }
      });
    });
  });
  new import_obsidian47.Setting(containerEl).setName("Respect Obsidian Exclusions").setDesc("Use Obsidian's Files & Links excluded files settings for embeddings").addToggle((toggle) => {
    var _a, _b;
    toggle.setValue((_b = (_a = tabInstance.plugin.settings.embeddingsExclusions) == null ? void 0 : _a.respectObsidianExclusions) != null ? _b : true).onChange(async (value) => {
      const currentExclusions = tabInstance.plugin.settings.embeddingsExclusions || {
        folders: [],
        patterns: [],
        ignoreChatHistory: true,
        respectObsidianExclusions: true
      };
      await tabInstance.plugin.getSettingsManager().updateSettings({
        embeddingsExclusions: {
          ...currentExclusions,
          respectObsidianExclusions: value
        }
      });
    });
  });
  await createFolderExclusionsSection(containerEl, tabInstance);
  await createFileExclusionsSection(containerEl, tabInstance);
}
async function updateProgressDisplay(container, plugin) {
  if (!plugin.settings.embeddingsEnabled) {
    container.empty();
    return;
  }
  const manager = plugin.embeddingsManager;
  if (!manager) {
    container.empty();
    container.createEl("p", {
      text: "Embeddings system initializing...",
      cls: "embeddings-status-text"
    });
    return;
  }
  const totalFiles = manager.getTotalProcessableFiles();
  let processedFiles = 0;
  let filesWithEmbeddings = 0;
  let isProcessing = false;
  let progress = { current: 0, total: 0, currentFile: "" };
  try {
    isProcessing = manager.isIndexing();
    progress = manager.getProgress();
    filesWithEmbeddings = await manager.getFilesWithEmbeddingsCount();
    processedFiles = filesWithEmbeddings;
  } catch (error) {
    console.error("[Embeddings] Error getting status:", error);
  }
  let statusDiv = container.querySelector(".embeddings-status");
  if (!statusDiv) {
    statusDiv = container.createDiv({ cls: "embeddings-status" });
  }
  let statusLine = statusDiv.querySelector(".embeddings-status-line");
  let statusIcon = statusLine == null ? void 0 : statusLine.querySelector(".embeddings-status-icon");
  let statusText = statusLine == null ? void 0 : statusLine.querySelector(".embeddings-status-text");
  if (!statusLine) {
    statusLine = statusDiv.createDiv({ cls: "embeddings-status-line" });
    statusIcon = statusLine.createSpan({ cls: "embeddings-status-icon" });
    statusText = statusLine.createSpan({ cls: "embeddings-status-text" });
  }
  statusLine.removeClass("processing", "complete", "idle");
  if (isProcessing) {
    statusIcon.innerHTML = "\u{1F504}";
    statusText.textContent = "Processing embeddings...";
    statusLine.addClass("processing");
  } else if (processedFiles === totalFiles) {
    statusIcon.innerHTML = "\u2705";
    statusText.textContent = "All files embedded";
    statusLine.addClass("complete");
  } else {
    statusIcon.innerHTML = "\u23F8\uFE0F";
    statusText.textContent = "Starting processing...";
    statusLine.addClass("idle");
    if (plugin.settings.embeddingsEnabled && manager && !manager.isIndexing()) {
      setTimeout(async () => {
        try {
          await manager.forceBackgroundProcessing();
        } catch (error) {
          console.error("[Embeddings] Error triggering background processing:", error);
        }
      }, 100);
    }
  }
  let countDiv = statusDiv.querySelector(".embeddings-count");
  if (!countDiv) {
    countDiv = statusDiv.createDiv({ cls: "embeddings-count" });
  }
  countDiv.textContent = `${processedFiles} / ${totalFiles} files embedded`;
  if (totalFiles > 0) {
    let progressBar = statusDiv.querySelector(".systemsculpt-embeddings-progress-bar");
    let progressFill = progressBar == null ? void 0 : progressBar.querySelector(".embeddings-progress-fill");
    if (!progressBar) {
      progressBar = statusDiv.createDiv({ cls: "systemsculpt-embeddings-progress-bar" });
      progressFill = progressBar.createDiv({ cls: "embeddings-progress-fill" });
    }
    const percentage = processedFiles / totalFiles * 100;
    progressFill.style.width = `${percentage}%`;
    if (isProcessing) {
      progressFill.classList.add("processing");
    } else {
      progressFill.classList.remove("processing");
    }
    let percentText = statusDiv.querySelector(".embeddings-percent");
    if (!percentText) {
      percentText = statusDiv.createDiv({ cls: "embeddings-percent" });
    }
    if (isProcessing) {
      percentText.textContent = `Processing ${percentage.toFixed(1)}%`;
    } else {
      percentText.textContent = `${percentage.toFixed(1)}%`;
    }
  }
  let currentFileDiv = statusDiv.querySelector(".embeddings-current-file");
  if (isProcessing && progress.currentFile) {
    if (!currentFileDiv) {
      currentFileDiv = statusDiv.createDiv({ cls: "embeddings-current-file" });
      currentFileDiv.createSpan({ text: "Processing: " });
      currentFileDiv.createSpan({ cls: "embeddings-current-filename" });
    }
    const filenameSpan = currentFileDiv.querySelector(".embeddings-current-filename");
    if (filenameSpan) {
      filenameSpan.textContent = progress.currentFile;
    }
  } else if (currentFileDiv) {
    currentFileDiv.remove();
  }
  let detailsDiv = statusDiv.querySelector(".embeddings-details");
  if (isProcessing && progress.total > 0) {
    if (!detailsDiv) {
      detailsDiv = statusDiv.createDiv({ cls: "embeddings-details" });
    }
    detailsDiv.textContent = `Batch progress: ${progress.current} / ${progress.total} files in current batch`;
  } else if (detailsDiv) {
    detailsDiv.remove();
  }
}
async function createFolderExclusionsSection(containerEl, tabInstance) {
  var _a;
  const currentFolders = ((_a = tabInstance.plugin.settings.embeddingsExclusions) == null ? void 0 : _a.folders) || [];
  const setting = new import_obsidian47.Setting(containerEl).setName("Excluded Folders").setDesc("Add folders to exclude from embeddings processing");
  const inputContainer = setting.controlEl.createDiv({ cls: "embeddings-exclusion-input-container" });
  const inputEl = inputContainer.createEl("input", {
    type: "text",
    placeholder: "Type folder name...",
    cls: "embeddings-folder-input"
  });
  const addButton = inputContainer.createEl("button", { text: "+ Add Folder", cls: "mod-cta" });
  const gridContainer = containerEl.createDiv({ cls: "embeddings-exclusions-grid" });
  const refreshGrid = () => {
    var _a2;
    gridContainer.empty();
    const currentFolders2 = ((_a2 = tabInstance.plugin.settings.embeddingsExclusions) == null ? void 0 : _a2.folders) || [];
    if (currentFolders2.length === 0) {
      const emptyState = gridContainer.createDiv({ cls: "embeddings-exclusions-empty" });
      emptyState.textContent = 'No folders excluded. Click "Add Folder" to exclude folders from embeddings.';
      return;
    }
    currentFolders2.forEach((folder) => {
      const chip = gridContainer.createDiv({ cls: "embeddings-exclusion-chip" });
      const icon = chip.createDiv({ cls: "embeddings-exclusion-icon" });
      icon.innerHTML = "\u{1F4C1}";
      const text = chip.createDiv({ cls: "embeddings-exclusion-text" });
      text.textContent = folder;
      const removeBtn = chip.createDiv({ cls: "embeddings-exclusion-remove" });
      removeBtn.innerHTML = "\xD7";
      removeBtn.setAttribute("aria-label", `Remove ${folder} from exclusions`);
      removeBtn.addEventListener("click", async () => {
        await removeFolderExclusion(folder, tabInstance);
        refreshGrid();
      });
    });
  };
  let selectedFolder = "";
  const suggester = attachFolderSuggester(inputEl, (folder) => {
    selectedFolder = folder;
    addButton.disabled = false;
  }, tabInstance.app);
  inputEl.addEventListener("input", () => {
    const value = inputEl.value.trim();
    selectedFolder = value;
    addButton.disabled = !value;
  });
  const addFolder = async () => {
    var _a2;
    if (!selectedFolder)
      return;
    const currentFolders2 = ((_a2 = tabInstance.plugin.settings.embeddingsExclusions) == null ? void 0 : _a2.folders) || [];
    if (currentFolders2.includes(selectedFolder)) {
      new import_obsidian47.Notice("Folder already exists in exclusions.");
      return;
    }
    await addFolderExclusion(selectedFolder, tabInstance);
    new import_obsidian47.Notice(`Added folder exclusion: ${selectedFolder}`);
    inputEl.value = "";
    selectedFolder = "";
    addButton.disabled = true;
    refreshGrid();
  };
  addButton.addEventListener("click", addFolder);
  inputEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      addFolder();
    }
  });
  addButton.disabled = true;
  refreshGrid();
}
async function createFileExclusionsSection(containerEl, tabInstance) {
  var _a;
  const currentFiles = ((_a = tabInstance.plugin.settings.embeddingsExclusions) == null ? void 0 : _a.patterns) || [];
  const setting = new import_obsidian47.Setting(containerEl).setName("Excluded Files").setDesc("Add specific files to exclude from embeddings processing");
  const inputContainer = setting.controlEl.createDiv({ cls: "embeddings-exclusion-input-container" });
  const inputEl = inputContainer.createEl("input", {
    type: "text",
    placeholder: "Type file name...",
    cls: "embeddings-file-input"
  });
  const addButton = inputContainer.createEl("button", { text: "+ Add File", cls: "mod-cta" });
  const gridContainer = containerEl.createDiv({ cls: "embeddings-exclusions-grid" });
  const refreshGrid = () => {
    var _a2;
    gridContainer.empty();
    const currentFiles2 = ((_a2 = tabInstance.plugin.settings.embeddingsExclusions) == null ? void 0 : _a2.patterns) || [];
    if (currentFiles2.length === 0) {
      const emptyState = gridContainer.createDiv({ cls: "embeddings-exclusions-empty" });
      emptyState.textContent = 'No files excluded. Click "Add File" to exclude specific files from embeddings.';
      return;
    }
    currentFiles2.forEach((file) => {
      const chip = gridContainer.createDiv({ cls: "embeddings-exclusion-chip" });
      const icon = chip.createDiv({ cls: "embeddings-exclusion-icon" });
      icon.innerHTML = "\u{1F4C4}";
      const text = chip.createDiv({ cls: "embeddings-exclusion-text" });
      text.textContent = file;
      const removeBtn = chip.createDiv({ cls: "embeddings-exclusion-remove" });
      removeBtn.innerHTML = "\xD7";
      removeBtn.setAttribute("aria-label", `Remove file ${file} from exclusions`);
      removeBtn.addEventListener("click", async () => {
        await removePatternExclusion(file, tabInstance);
        refreshGrid();
      });
    });
  };
  let selectedFile = "";
  const suggester = attachFileSuggester(inputEl, (file) => {
    selectedFile = file;
    addButton.disabled = false;
  }, tabInstance.app);
  inputEl.addEventListener("input", () => {
    const value = inputEl.value.trim();
    selectedFile = value;
    addButton.disabled = !value;
  });
  const addFile = async () => {
    var _a2;
    if (!selectedFile)
      return;
    const currentFiles2 = ((_a2 = tabInstance.plugin.settings.embeddingsExclusions) == null ? void 0 : _a2.patterns) || [];
    if (currentFiles2.includes(selectedFile)) {
      new import_obsidian47.Notice("File already exists in exclusions.");
      return;
    }
    await addPatternExclusion(selectedFile, tabInstance);
    new import_obsidian47.Notice(`Added file exclusion: ${selectedFile}`);
    inputEl.value = "";
    selectedFile = "";
    addButton.disabled = true;
    refreshGrid();
  };
  addButton.addEventListener("click", addFile);
  inputEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      addFile();
    }
  });
  addButton.disabled = true;
  refreshGrid();
}
async function addFolderExclusion(folder, tabInstance) {
  const currentExclusions = tabInstance.plugin.settings.embeddingsExclusions || {
    folders: [],
    patterns: [],
    ignoreChatHistory: true,
    respectObsidianExclusions: true
  };
  const updatedFolders = [...currentExclusions.folders, folder];
  await tabInstance.plugin.getSettingsManager().updateSettings({
    embeddingsExclusions: {
      ...currentExclusions,
      folders: updatedFolders
    }
  });
}
async function removeFolderExclusion(folder, tabInstance) {
  const currentExclusions = tabInstance.plugin.settings.embeddingsExclusions || {
    folders: [],
    patterns: [],
    ignoreChatHistory: true,
    respectObsidianExclusions: true
  };
  const updatedFolders = currentExclusions.folders.filter((f) => f !== folder);
  await tabInstance.plugin.getSettingsManager().updateSettings({
    embeddingsExclusions: {
      ...currentExclusions,
      folders: updatedFolders
    }
  });
}
async function addPatternExclusion(pattern, tabInstance) {
  const currentExclusions = tabInstance.plugin.settings.embeddingsExclusions || {
    folders: [],
    patterns: [],
    ignoreChatHistory: true,
    respectObsidianExclusions: true
  };
  const updatedPatterns = [...currentExclusions.patterns, pattern];
  await tabInstance.plugin.getSettingsManager().updateSettings({
    embeddingsExclusions: {
      ...currentExclusions,
      patterns: updatedPatterns
    }
  });
}
async function removePatternExclusion(pattern, tabInstance) {
  const currentExclusions = tabInstance.plugin.settings.embeddingsExclusions || {
    folders: [],
    patterns: [],
    ignoreChatHistory: true,
    respectObsidianExclusions: true
  };
  const updatedPatterns = currentExclusions.patterns.filter((p) => p !== pattern);
  await tabInstance.plugin.getSettingsManager().updateSettings({
    embeddingsExclusions: {
      ...currentExclusions,
      patterns: updatedPatterns
    }
  });
}

// src/settings/SystemSculptSettingTab.ts
var SystemSculptSettingTab = class extends import_obsidian48.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.debounceTimer = null;
    this.listeners = [];
    this.versionInfoContainer = null;
    this.plugin = plugin;
    this.systemSculptService = SystemSculptService.getInstance(plugin);
  }
  registerListener(element, type, listener) {
    element.addEventListener(type, listener);
    this.listeners.push({ element, type, listener });
  }
  removeAllListeners() {
    this.listeners.forEach(({ element, type, listener }) => {
      element.removeEventListener(type, listener);
    });
    this.listeners = [];
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    const mainContainer = containerEl.createDiv("systemsculpt-settings-container");
    const headerContainer = mainContainer.createEl("div", {
      cls: "systemsculpt-settings-header"
    });
    headerContainer.createEl("h2", {
      text: "SystemSculpt AI Settings"
    });
    const feedbackContainer = headerContainer.createEl("div", {
      cls: "systemsculpt-feedback-link"
    });
    const feedbackLink = feedbackContainer.createEl("a", {
      cls: "systemsculpt-feedback mod-cta",
      attr: {
        href: "https://systemsculpt.com/feedback",
        target: "_blank",
        "aria-label": "Share feedback, report bugs, or suggest improvements",
        title: "Share feedback, report bugs, or suggest improvements"
      }
    });
    feedbackLink.createSpan({ text: "Share Feedback (feature requests, bugs, etc.)" });
    (0, import_obsidian48.setIcon)(feedbackLink.createSpan("feedback-icon"), "external-link");
    this.versionInfoContainer = headerContainer.createEl("div", {
      cls: "systemsculpt-version-info"
    });
    this.initializeVersionDisplay();
    const tabContainer = mainContainer.createDiv("systemsculpt-settings-tabs");
    const contentContainer = mainContainer.createDiv("systemsculpt-settings-content");
    const tabs = [
      { id: "setup", label: "Setup & Connect" },
      { id: "directories", label: "Directories" },
      { id: "model-settings", label: "Model Settings" },
      { id: "system-prompt-settings", label: "System Prompt Settings" },
      { id: "recorder", label: "Recorder" },
      { id: "chat", label: "AI Chat" },
      { id: "templates", label: "Templates" },
      { id: "embeddings", label: "Embeddings" },
      { id: "title-generation", label: "Title Generation" },
      { id: "changelog", label: "Change Log" },
      { id: "backup", label: "Backup" },
      { id: "advanced", label: "Advanced" }
    ];
    tabs.forEach((tab) => {
      const tabButton = tabContainer.createEl("button", {
        text: tab.label
      });
      tabButton.dataset.tab = tab.id;
      if (tab.id === "setup") {
        tabButton.addClass("mod-cta", "mod-active");
      }
      const contentSection = contentContainer.createDiv("systemsculpt-tab-content");
      contentSection.dataset.tab = tab.id;
      if (tab.id === "setup")
        contentSection.addClass("is-active");
    });
    const setupContent = contentContainer.querySelector('[data-tab="setup"]');
    const directoriesContent = contentContainer.querySelector('[data-tab="directories"]');
    const modelSettingsContent = contentContainer.querySelector('[data-tab="model-settings"]');
    const systemPromptSettingsContent = contentContainer.querySelector('[data-tab="system-prompt-settings"]');
    const recorderContent = contentContainer.querySelector('[data-tab="recorder"]');
    const chatContent = contentContainer.querySelector('[data-tab="chat"]');
    const templatesContent = contentContainer.querySelector('[data-tab="templates"]');
    const embeddingsContent = contentContainer.querySelector('[data-tab="embeddings"]');
    const titleGenContent = contentContainer.querySelector('[data-tab="title-generation"]');
    const changeLogContent = contentContainer.querySelector('[data-tab="changelog"]');
    const backupContent = contentContainer.querySelector('[data-tab="backup"]');
    const advancedContent = contentContainer.querySelector('[data-tab="advanced"]');
    const isProActive = this.plugin.settings.licenseValid === true;
    if (setupContent)
      displaySetupTabContent(setupContent, this, isProActive);
    if (directoriesContent)
      displayDirectoriesTabContent(directoriesContent, this);
    if (modelSettingsContent)
      displayModelSettingsTabContent(modelSettingsContent, this);
    if (systemPromptSettingsContent)
      displaySystemPromptSettingsTabContent(systemPromptSettingsContent, this);
    if (recorderContent)
      displayRecorderTabContent(recorderContent, this);
    if (chatContent)
      displayChatTabContent(chatContent, this);
    if (templatesContent)
      displayTemplatesTabContent(templatesContent, this);
    if (embeddingsContent)
      displayEmbeddingsTabContent(embeddingsContent, this);
    if (titleGenContent)
      displayTitleGenerationTabContent(titleGenContent, this);
    if (changeLogContent)
      displayChangeLogTabContent(changeLogContent, this);
    if (backupContent)
      displayBackupTabContent(backupContent, this);
    if (advancedContent)
      displayAdvancedTabContent(advancedContent, this);
    tabContainer.querySelectorAll("button[data-tab]").forEach((button) => {
      this.registerListener(button, "click", (e) => {
        var _a;
        const target = e.target;
        const tabId = target.dataset.tab;
        if (!tabId)
          return;
        const activeContent = contentContainer.querySelector(".systemsculpt-tab-content.is-active");
        if (activeContent && activeContent.cleanup) {
          activeContent.cleanup();
          activeContent.cleanup = null;
        }
        tabContainer.querySelectorAll("button[data-tab]").forEach((b) => b.removeClass("mod-active", "mod-cta"));
        contentContainer.querySelectorAll(".systemsculpt-tab-content").forEach((c) => c.classList.remove("is-active"));
        target.addClass("mod-active", "mod-cta");
        (_a = contentContainer.querySelector(`[data-tab="${tabId}"]`)) == null ? void 0 : _a.classList.add("is-active");
      });
    });
    this.ensureStyles();
  }
  ensureStyles() {
    if (!document.getElementById("systemsculpt-settings-styles")) {
      const style = document.createElement("style");
      style.id = "systemsculpt-settings-styles";
      style.textContent = `
        .systemsculpt-settings-header {
          display: flex;
          align-items: center;
          margin-bottom: 16px;
          gap: 16px;
          flex-wrap: wrap;
        }

        .systemsculpt-version-info {
          font-size: 0.85em;
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .systemsculpt-version-text {
          display: inline-flex;
          align-items: center;
          padding: 2px 8px;
          border-radius: 4px;
          background-color: var(--background-secondary);
        }

        .systemsculpt-version-latest {
          color: var(--text-success);
        }

        .systemsculpt-version-outdated {
          color: var(--text-error);
        }

        .systemsculpt-version-info a {
          opacity: 0.8;
          transition: opacity 0.2s ease;
          cursor: pointer;
        }

        .systemsculpt-version-info a:hover {
          opacity: 1;
        }

        .systemsculpt-feedback-link {
          display: flex;
          align-items: center;
        }

        .systemsculpt-feedback {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          font-size: 0.9em;
          text-decoration: none;
          border-radius: 4px;
          padding: 3px 10px;
          transition: all 0.2s ease;
        }

        .systemsculpt-feedback:hover {
          opacity: 0.9;
        }

        .feedback-icon {
          font-size: 0.9em;
          display: inline-flex;
        }

        .systemsculpt-settings-tabs {
          display: flex;
          flex-wrap: wrap;
          gap: 6px;
          margin-bottom: 16px;
          border-bottom: 1px solid var(--background-modifier-border);
          padding-bottom: 12px;
          max-width: 100%;
        }

        .systemsculpt-settings-tabs button {
          margin-right: 0;
        }

        .systemsculpt-tab-content {
          display: none;
          max-width: 100%;
          overflow-x: hidden;
        }

        .systemsculpt-tab-content.is-active {
          display: block;
          padding: 0 8px;
        }

        .systemsculpt-license-input {
          width: 100%;
          max-width: 400px;
        }

        .pro-badge {
          background: var(--interactive-accent);
          color: var(--text-on-accent);
          padding: 2px 8px;
          border-radius: 4px;
          font-size: 0.8em;
          font-weight: 600;
          margin-left: 8px;
          vertical-align: middle;
        }

        .token-balance-value {
          font-weight: 600;
          color: var(--text-accent);
          margin-left: 8px;
        }

        .pro-benefits-list {
          margin: 16px 0;
          padding-left: 20px;
          color: var(--text-muted);
        }

        .pro-benefits-list li {
          margin: 8px 0;
          list-style-type: '\u2192';
          padding-left: 20px;
          text-indent: -12px;
          word-break: break-word;
        }

        .systemsculpt-one-click-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
        }

        .button-icon {
            margin-right: 6px;
        }

        .systemsculpt-active-providers-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 16px;
            margin-bottom: 16px;
        }

        .provider-card {
            border: 1px solid var(--background-modifier-border);
            border-radius: 6px;
            padding: 12px;
            background-color: var(--background-secondary);
        }

        .provider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .provider-header h5 {
            margin: 0;
            font-size: 1.1em;
        }

        .provider-status-container {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .provider-status {
            font-size: 0.8em;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }

        .provider-status.enabled {
            background-color: var(--color-green-rgb);
            color: white;
        }

        .provider-status.disabled {
            background-color: var(--background-modifier-border);
            color: var(--text-muted);
        }

        .provider-details > div {
            font-size: 0.9em;
            color: var(--text-muted);
            margin-bottom: 4px;
            word-break: break-all;
        }

        .masked-api-key {
            font-family: monospace;
            background-color: var(--background-secondary-alt);
            padding: 1px 4px;
            border-radius: 3px;
        }

        .provider-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .add-provider-container {
            margin-top: 16px;
        }

        .settings-section-divider {
            margin: 24px 0;
            border-color: var(--background-modifier-border);
        }

        .systemsculpt-diagnostics-section {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid var(--background-modifier-border);
            border-radius: 5px;
            background-color: var(--background-secondary);
        }

        .systemsculpt-info {
            font-size: 0.9em;
            color: var(--text-muted);
            margin-bottom: 15px;
        }

        .systemsculpt-button-container {
            margin-bottom: 10px;
        }

        .systemsculpt-diagnostics-results {
            margin-top: 15px;
            padding: 10px;
            border-radius: 3px;
            background-color: var(--background-primary-alt);
        }

        .systemsculpt-checking {
            font-style: italic;
            color: var(--text-muted);
        }

        .systemsculpt-success {
            color: var(--text-success);
            font-weight: bold;
        }

        .systemsculpt-issues h4 {
            color: var(--text-warning);
            margin-bottom: 5px;
        }

        .systemsculpt-issues ul {
            margin-left: 20px;
            list-style-type: disc;
            color: var(--text-normal);
        }

        .systemsculpt-issues li {
            margin-bottom: 5px;
        }

        .systemsculpt-help-text {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--text-muted);
        }

        .systemsculpt-error {
            color: var(--text-error);
            font-weight: bold;
        }

        .systemsculpt-restart-note {
            font-size: 0.9em;
            margin-top: 8px;
            color: var(--text-accent);
        }

        /* Compact provider styles */
        .systemsculpt-compact-provider {
            padding: 8px 12px;
            margin-bottom: 12px;
        }

        .systemsculpt-primary-provider-header-compact {
            margin-bottom: 8px;
        }

        .systemsculpt-primary-provider-badge-compact {
            font-size: 0.75em;
            font-weight: 600;
            color: var(--text-accent);
            background: var(--background-modifier-border);
            padding: 2px 6px;
            border-radius: 3px;
        }

        .systemsculpt-provider-settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            align-items: start;
        }

        .systemsculpt-provider-settings-grid .setting-item {
            border: none;
            padding: 4px;
            margin: 0;
        }

        .systemsculpt-provider-settings-grid .setting-item-info {
            margin-bottom: 2px;
        }

        .systemsculpt-provider-settings-grid .setting-item-name {
            font-size: 0.9em;
            font-weight: 500;
        }

        .systemsculpt-provider-settings-grid .setting-item-description {
            font-size: 0.8em;
            opacity: 0.8;
            margin-top: 2px;
        }

        .systemsculpt-guidance-compact {
            font-size: 0.85em;
            margin-top: 8px;
            margin-bottom: 0;
        }

        /* Make custom providers more compact too */
        .systemsculpt-active-providers-list .systemsculpt-provider-card {
            padding: 8px 12px;
            margin-bottom: 8px;
        }

        .systemsculpt-active-providers-list .systemsculpt-provider-header {
            margin-bottom: 6px;
        }

        .systemsculpt-active-providers-list .systemsculpt-provider-header h5 {
            font-size: 1em;
            margin: 0;
        }

        .systemsculpt-active-providers-list .systemsculpt-provider-details > div {
            font-size: 0.85em;
            margin-bottom: 2px;
        }

        .systemsculpt-active-providers-list .systemsculpt-provider-actions {
            margin-top: 8px;
            gap: 6px;
        }

        @media (max-width: 600px) {
            .systemsculpt-provider-settings-grid {
                grid-template-columns: 1fr;
            }
        }
      `;
      document.head.appendChild(style);
    }
  }
  async initializeVersionDisplay() {
    if (!this.versionInfoContainer)
      return;
    this.versionInfoContainer.empty();
    const currentVersion = this.plugin.manifest.version;
    const versionText = this.versionInfoContainer.createEl("span", {
      cls: "systemsculpt-version-text",
      text: `v${currentVersion} (checking...)`
    });
    const refreshButton = this.versionInfoContainer.createEl("a", {
      cls: "systemsculpt-version-refresh",
      attr: {
        "aria-label": "Check for updates",
        "title": "Check for updates"
      }
    });
    (0, import_obsidian48.setIcon)(refreshButton, "refresh-cw");
    this.registerListener(refreshButton, "click", async () => {
      await this.checkForUpdates(true);
    });
    await this.checkForUpdates();
  }
  async checkForUpdates(forceRefresh = false) {
    if (!this.versionInfoContainer)
      return;
    try {
      const versionInfo = await this.plugin.getVersionCheckerService().checkVersion(forceRefresh);
      this.updateVersionDisplay(versionInfo);
    } catch (error) {
      console.error("[SystemSculpt] Failed to check for updates:", error);
      if (this.versionInfoContainer.querySelector(".systemsculpt-version-text")) {
        const versionText = this.versionInfoContainer.querySelector(".systemsculpt-version-text");
        if (versionText) {
          versionText.textContent = `v${this.plugin.manifest.version} (check failed)`;
          versionText.classList.remove("systemsculpt-version-latest", "systemsculpt-version-outdated");
        }
      }
    }
  }
  updateVersionDisplay(versionInfo) {
    var _a;
    if (!this.versionInfoContainer)
      return;
    const versionText = this.versionInfoContainer.querySelector(".systemsculpt-version-text");
    if (!versionText)
      return;
    versionText.classList.remove("systemsculpt-version-latest", "systemsculpt-version-outdated");
    if (versionInfo.isLatest) {
      versionText.textContent = `v${versionInfo.currentVersion} (latest)`;
      versionText.classList.add("systemsculpt-version-latest");
      (_a = this.versionInfoContainer.querySelector(".systemsculpt-version-update-link")) == null ? void 0 : _a.remove();
    } else {
      versionText.textContent = `v${versionInfo.currentVersion} (update available: v${versionInfo.latestVersion})`;
      versionText.classList.add("systemsculpt-version-outdated");
      if (!this.versionInfoContainer.querySelector(".systemsculpt-version-update-link")) {
        const updateLink = this.versionInfoContainer.createEl("a", {
          cls: "systemsculpt-version-update-link",
          text: "Update",
          attr: {
            href: versionInfo.updateUrl,
            "aria-label": "Open in Community Plugins",
            "title": "Update in Community Plugins"
          }
        });
        this.registerListener(updateLink, "click", (e) => {
          e.preventDefault();
          window.open(versionInfo.updateUrl, "_blank");
          const notice = new import_obsidian48.Notice("Opening SystemSculpt AI in Community Plugins...\n\nIf nothing happens, please update manually via Settings \u2192 Community plugins", 1e4);
        });
      }
    }
  }
  hide() {
    const activeContent = this.containerEl.querySelector(".systemsculpt-tab-content.is-active");
    if (activeContent && activeContent.cleanup) {
      activeContent.cleanup();
      activeContent.cleanup = null;
    }
    this.removeAllListeners();
    super.hide();
  }
};

// src/services/RecorderService.ts
var import_obsidian81 = __toModule(require("obsidian"));

// src/modals/AudioTranscriptionModal.ts
var import_obsidian50 = __toModule(require("obsidian"));

// src/services/TranscriptionService.ts
var import_obsidian49 = __toModule(require("obsidian"));
init_MobileDetection();
init_SystemSculptService();
init_errorHandling();

// src/services/AudioResampler.ts
var AudioResampler = class {
  constructor() {
    this.audioContext = null;
  }
  async resampleAudio(arrayBuffer, targetSampleRate, mimeType) {
    if (!this.audioContext || this.audioContext.sampleRate !== targetSampleRate) {
      this.audioContext = new AudioContext({ sampleRate: targetSampleRate });
    }
    try {
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer.slice(0));
      if (audioBuffer.sampleRate === targetSampleRate) {
        console.log(`[AudioResampler] Audio already at target sample rate: ${targetSampleRate}Hz`);
        return { buffer: arrayBuffer, actualSampleRate: targetSampleRate };
      }
      console.log(`[AudioResampler] Resampling from ${audioBuffer.sampleRate}Hz to ${targetSampleRate}Hz`);
      const offlineContext = new OfflineAudioContext(audioBuffer.numberOfChannels, Math.floor(audioBuffer.duration * targetSampleRate), targetSampleRate);
      const source = offlineContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(offlineContext.destination);
      source.start(0);
      const resampledBuffer = await offlineContext.startRendering();
      const wavArrayBuffer = this.audioBufferToWav(resampledBuffer);
      console.log(`[AudioResampler] Resampling complete. New size: ${Math.round(wavArrayBuffer.byteLength / 1024)}KB`);
      return {
        buffer: wavArrayBuffer,
        actualSampleRate: resampledBuffer.sampleRate
      };
    } catch (error) {
      console.error("[AudioResampler] Resampling failed:", error);
      throw new Error(`Failed to resample audio: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  audioBufferToWav(buffer) {
    const length = buffer.length * buffer.numberOfChannels * 2 + 44;
    const arrayBuffer = new ArrayBuffer(length);
    const view = new DataView(arrayBuffer);
    const channels = [];
    let offset = 0;
    let pos = 0;
    const setUint16 = (data) => {
      view.setUint16(pos, data, true);
      pos += 2;
    };
    const setUint32 = (data) => {
      view.setUint32(pos, data, true);
      pos += 4;
    };
    setUint32(1179011410);
    setUint32(length - 8);
    setUint32(1163280727);
    setUint32(544501094);
    setUint32(16);
    setUint16(1);
    setUint16(buffer.numberOfChannels);
    setUint32(buffer.sampleRate);
    setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels);
    setUint16(buffer.numberOfChannels * 2);
    setUint16(16);
    setUint32(1635017060);
    setUint32(length - pos - 4);
    const volume = 0.8;
    for (let i = 0; i < buffer.numberOfChannels; i++) {
      channels.push(buffer.getChannelData(i));
    }
    while (pos < length) {
      for (let i = 0; i < buffer.numberOfChannels; i++) {
        const sample = Math.max(-1, Math.min(1, channels[i][offset]));
        const val = sample < 0 ? sample * 32768 : sample * 32767;
        view.setInt16(pos, val * volume, true);
        pos += 2;
      }
      offset++;
    }
    return arrayBuffer;
  }
  async checkNeedsResampling(arrayBuffer, mimeType, targetSampleRate) {
    try {
      if (!this.audioContext) {
        this.audioContext = new AudioContext();
      }
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer.slice(0));
      const needsResampling = audioBuffer.sampleRate !== targetSampleRate;
      return {
        needsResampling,
        currentSampleRate: audioBuffer.sampleRate
      };
    } catch (error) {
      console.warn("[AudioResampler] Could not decode audio to check sample rate:", error);
      return { needsResampling: true };
    }
  }
  dispose() {
    if (this.audioContext && this.audioContext.state !== "closed") {
      this.audioContext.close();
      this.audioContext = null;
    }
  }
};

// src/services/TranscriptionService.ts
var SUPPORTED_AUDIO_EXTENSIONS = ["wav", "m4a", "webm", "ogg", "mp3"];
var MIME_TYPE_MAP = {
  wav: "audio/wav",
  m4a: "audio/mp4",
  webm: "audio/webm",
  ogg: "audio/ogg;codecs=opus",
  mp3: "audio/mpeg"
};
var MAX_FILE_SIZE2 = 2 * 1024 * 1024 * 1024;
var EXPECTED_SAMPLE_RATES = {
  wav: 16e3,
  m4a: 16e3,
  mp3: 16e3,
  webm: 48e3,
  ogg: 16e3
};
var TranscriptionService = class {
  constructor(plugin) {
    this.isTranscribing = false;
    this.retryCount = 0;
    this.maxRetries = 2;
    this.retryDelay = 5e3;
    this.uploadQueue = [];
    this.activeUploads = 0;
    this.maxConcurrentUploads = 1;
    this.plugin = plugin;
    this.app = plugin.app;
    this.sculptService = SystemSculptService.getInstance(plugin);
    this.mobileDetection = MobileDetection.getInstance();
    this.audioResampler = new AudioResampler();
  }
  static getInstance(plugin) {
    if (!TranscriptionService.instance) {
      TranscriptionService.instance = new TranscriptionService(plugin);
    }
    return TranscriptionService.instance;
  }
  async parseErrorResponse(response) {
    try {
      const data = await response.json();
      if (data.error) {
        if (typeof data.error === "string") {
          return { message: data.error, data };
        }
        if (data.error.message) {
          return { message: data.error.message, data };
        }
        return { message: JSON.stringify(data.error), data };
      }
      return { message: response.statusText, data };
    } catch (e) {
      return { message: response.statusText };
    }
  }
  async transcribeAudio(file, blob, context) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
    const formFields = [];
    if (this.plugin.settings.transcriptionProvider === "custom") {
      const endpoint = this.plugin.settings.customTranscriptionEndpoint.toLowerCase();
      if (endpoint.includes("groq.com")) {
        const fileName = blob.type.includes("webm") ? "recording.webm" : blob.type.includes("mp4") ? "recording.m4a" : "recording.wav";
        const mimeType = blob.type || (fileName.endsWith(".webm") ? "audio/webm" : fileName.endsWith(".m4a") ? "audio/mp4" : fileName.endsWith(".wav") ? "audio/wav" : "audio/mpeg");
        const fileBlob = new Blob([await blob.arrayBuffer()], { type: mimeType });
        formFields.push({ name: "file", value: fileBlob, filename: fileName });
        formFields.push({ name: "model", value: this.plugin.settings.customTranscriptionModel || "whisper-large-v3" });
        if (context == null ? void 0 : context.timestamped) {
          formFields.push({ name: "response_format", value: "verbose_json" });
          formFields.push({ name: "timestamp_granularities[]", value: "segment" });
        } else {
          formFields.push({ name: "response_format", value: "text" });
        }
        formFields.push({ name: "language", value: "en" });
        formFields.push({ name: "temperature", value: "0" });
      } else {
        formFields.push({ name: "file", value: blob, filename: file.name });
        formFields.push({ name: "model", value: this.plugin.settings.customTranscriptionModel || "whisper-1" });
        formFields.push({ name: "requestId", value: requestId });
        if (context == null ? void 0 : context.timestamped) {
          formFields.push({ name: "timestamped", value: "true" });
        }
      }
    } else {
      formFields.push({ name: "file", value: blob, filename: file.name });
      formFields.push({ name: "requestId", value: requestId });
      if (context == null ? void 0 : context.timestamped) {
        formFields.push({ name: "timestamped", value: "true" });
      }
    }
    const boundary = "WebKitFormBoundary" + Math.random().toString(36).substring(2, 15);
    const encoder = new TextEncoder();
    const parts = [];
    for (const field of formFields) {
      parts.push(encoder.encode(`--${boundary}\r
`));
      if (field.value instanceof Blob) {
        const contentType = field.value.type || "application/octet-stream";
        const filename = field.filename || "file";
        parts.push(encoder.encode(`Content-Disposition: form-data; name="${field.name}"; filename="${filename}"\r
`));
        parts.push(encoder.encode(`Content-Type: ${contentType}\r
`));
        parts.push(encoder.encode("\r\n"));
        parts.push(new Uint8Array(await field.value.arrayBuffer()));
        parts.push(encoder.encode("\r\n"));
      } else {
        parts.push(encoder.encode(`Content-Disposition: form-data; name="${field.name}"\r
`));
        parts.push(encoder.encode("\r\n"));
        parts.push(encoder.encode(String(field.value)));
        parts.push(encoder.encode("\r\n"));
      }
    }
    parts.push(encoder.encode(`--${boundary}--\r
`));
    const totalSize = parts.reduce((sum, part) => sum + part.length, 0);
    const formDataArray = new Uint8Array(totalSize);
    let offset = 0;
    for (const part of parts) {
      formDataArray.set(part, offset);
      offset += part.length;
    }
    let retryCount = 0;
    let lastError = null;
    while (retryCount <= this.maxRetries) {
      const decoder = new TextDecoder("utf-8", { fatal: false });
      const firstBytes = formDataArray.slice(0, 300);
      const lastBytes = formDataArray.slice(-200);
      const formDataPreview = {
        boundary,
        totalSize: formDataArray.length,
        formDataStart: decoder.decode(firstBytes),
        formDataEnd: decoder.decode(lastBytes),
        fieldCount: formFields.length,
        fields: formFields.map((f) => ({ name: f.name, type: f.value instanceof Blob ? "Blob" : "string", filename: f.filename }))
      };
      const currentFormDataVersion = "v3.0-mobile-requesturl-support";
      try {
        const retryText = retryCount > 0 ? `Retry ${retryCount}/${this.maxRetries}: ` : "";
        (_a = context == null ? void 0 : context.onProgress) == null ? void 0 : _a.call(context, 10, `${retryText}Uploading audio...`);
        let endpoint;
        const headers = {
          "Content-Type": `multipart/form-data; boundary=${boundary}`
        };
        if (this.plugin.settings.transcriptionProvider === "custom") {
          if (!this.plugin.settings.customTranscriptionEndpoint) {
            throw new Error("Custom transcription endpoint URL is required. Please enter a valid endpoint URL in the settings.");
          }
          endpoint = this.plugin.settings.customTranscriptionEndpoint;
          if (this.plugin.settings.customTranscriptionApiKey) {
            headers["Authorization"] = `Bearer ${this.plugin.settings.customTranscriptionApiKey}`;
            if (endpoint.includes("groq.com")) {
              const requestTraceId = `obsidian-client-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
              headers["X-Request-ID"] = requestTraceId;
              headers["Accept"] = "application/json";
            }
          }
        } else {
          endpoint = `${this.sculptService.baseUrl}/audio/transcriptions`;
          if (this.plugin.settings.licenseKey) {
            headers["x-license-key"] = this.plugin.settings.licenseKey;
          }
        }
        (_b = context == null ? void 0 : context.onProgress) == null ? void 0 : _b.call(context, 30, `${retryText}Transcribing audio...`);
        const isMobile = this.mobileDetection.isMobileDevice();
        let response;
        if (isMobile) {
          const audioData = await this.app.vault.adapter.readBinary(file.path);
          const multipartData = this.constructBinaryMultipartPayload(audioData, file.name);
          const mobileResponse = await (0, import_obsidian49.requestUrl)({
            url: endpoint,
            method: "POST",
            headers: {
              ...headers,
              "Content-Type": multipartData.contentType
            },
            body: multipartData.payload,
            throw: false
          });
          let responseBody;
          let responseHeaders = new Headers();
          if (mobileResponse.headers && mobileResponse.headers["content-type"]) {
            responseHeaders.set("content-type", mobileResponse.headers["content-type"]);
          }
          if (mobileResponse.text) {
            responseBody = mobileResponse.text;
          } else if (mobileResponse.json) {
            responseBody = JSON.stringify(mobileResponse.json);
            responseHeaders.set("content-type", "application/json");
          } else if (mobileResponse.arrayBuffer) {
            const decoder2 = new TextDecoder();
            responseBody = decoder2.decode(new Uint8Array(mobileResponse.arrayBuffer));
          } else {
            responseBody = "";
          }
          const contentType2 = ((_c = mobileResponse.headers) == null ? void 0 : _c["content-type"]) || "";
          if (contentType2.includes("application/x-ndjson") || responseBody.includes("\n{")) {
            const lines = responseBody.trim().split("\n");
            let finalResponse = null;
            for (const line of lines) {
              if (!line.trim())
                continue;
              try {
                const parsed = JSON.parse(line);
                if (parsed.text || parsed.error) {
                  finalResponse = parsed;
                }
              } catch (e) {
                console.warn("[TranscriptionService] Failed to parse NDJSON line:", line.substring(0, 100));
              }
            }
            if (finalResponse) {
              responseBody = JSON.stringify(finalResponse);
              responseHeaders.set("content-type", "application/json");
            } else {
              console.error("[TranscriptionService] No valid final response found in NDJSON");
              responseBody = JSON.stringify({ error: "No valid response found in streaming data" });
              responseHeaders.set("content-type", "application/json");
            }
          }
          response = new Response(responseBody, {
            status: mobileResponse.status || 500,
            statusText: mobileResponse.status >= 200 && mobileResponse.status < 300 ? "OK" : "Error",
            headers: responseHeaders
          });
        } else {
          response = await fetch(endpoint, {
            method: "POST",
            headers,
            body: formDataArray
          });
        }
        const contentType = response.headers.get("content-type") || "";
        if (!response.ok) {
          let rawResponseText = "";
          try {
            rawResponseText = await response.text();
          } catch (e) {
            console.error("[TranscriptionService] Failed to read error response text:", e);
          }
          let errorMessage = `HTTP ${response.status}`;
          let errorToLog;
          const additionalLogInfo = {
            formDataVersion: currentFormDataVersion,
            endpoint,
            status: response.status,
            statusText: response.statusText,
            headers: contentType ? { "content-type": contentType } : {},
            retryCount: retryCount + 1,
            provider: this.plugin.settings.transcriptionProvider,
            formDataDebug: formDataPreview,
            rawResponseText: rawResponseText ? rawResponseText.substring(0, 1e3) + (rawResponseText.length > 1e3 ? "..." : "") : "N/A"
          };
          try {
            const errorData = JSON.parse(rawResponseText || "{}");
            if ((_d = errorData == null ? void 0 : errorData.error) == null ? void 0 : _d.message) {
              errorMessage = errorData.error.message;
            } else if (errorData == null ? void 0 : errorData.error) {
              errorMessage = typeof errorData.error === "string" ? errorData.error : JSON.stringify(errorData.error);
            } else if (errorData == null ? void 0 : errorData.message) {
              errorMessage = errorData.message;
            }
            errorToLog = new Error(errorMessage);
            additionalLogInfo.parsedErrorData = errorData;
          } catch (jsonParseError) {
            const e = jsonParseError instanceof Error ? jsonParseError : new Error(String(jsonParseError));
            errorMessage = `Failed to parse server error response as JSON (HTTP ${response.status}). Parser error: ${e.message}`;
            errorToLog = new Error(errorMessage);
            additionalLogInfo.jsonParsingError = e.message;
          }
          errorToLog.additionalInfo = additionalLogInfo;
          await logMobileError("TranscriptionService", `API Error (HTTP ${response.status}) on attempt ${retryCount + 1}`, errorToLog, additionalLogInfo);
          throw errorToLog;
        }
        let rawResponseTextFor200 = "";
        let responseData;
        try {
          rawResponseTextFor200 = await response.text();
          if (contentType.includes("application/x-ndjson")) {
            const lines = rawResponseTextFor200.trim().split("\n");
            let progressUpdate = null;
            let mainData = null;
            for (const line of lines) {
              if (!line.trim())
                continue;
              try {
                const parsedLine = JSON.parse(line);
                if (parsedLine.progress_update) {
                  progressUpdate = parsedLine.progress_update;
                  if (progressUpdate.progress && progressUpdate.status) {
                    (_e = context == null ? void 0 : context.onProgress) == null ? void 0 : _e.call(context, progressUpdate.progress, progressUpdate.status);
                  }
                } else if (parsedLine.text) {
                  mainData = parsedLine;
                } else {
                }
              } catch (lineParseError) {
                console.warn("[TranscriptionService] Failed to parse a line in NDJSON response:", lineParseError, "Line:", line);
              }
            }
            if (mainData) {
              responseData = mainData;
            } else if (progressUpdate && lines.length === 1) {
              throw new Error("Received only progress update in NDJSON response, no transcription text.");
            } else if (!mainData && lines.length > 0) {
              throw new Error("Failed to find main transcription data in NDJSON response.");
            } else {
              throw new Error("Empty or unparseable NDJSON response.");
            }
          } else {
            responseData = JSON.parse(rawResponseTextFor200);
          }
        } catch (jsonParseError) {
          const e = jsonParseError instanceof Error ? jsonParseError : new Error(String(jsonParseError));
          let errorMessage = e.message;
          if (contentType.includes("application/x-ndjson") && e.message.includes("Unexpected non-whitespace character after JSON")) {
            errorMessage = `NDJSON parsing failed. The server returned streaming JSON but it couldn't be processed properly. This might be due to response format incompatibility.`;
          } else if (!contentType.includes("application/x-ndjson") && e.name === "SyntaxError") {
            errorMessage = `HTTP 200 but failed to parse response as JSON. Parser error: ${e.message}`;
          }
          const errorToLog = new Error(errorMessage);
          const additionalLogInfo = {
            formDataVersion: currentFormDataVersion,
            endpoint,
            status: response.status,
            headers: response.headers,
            retryCount: retryCount + 1,
            provider: this.plugin.settings.transcriptionProvider,
            formDataDebug: formDataPreview,
            rawResponseText: rawResponseTextFor200 ? rawResponseTextFor200.substring(0, 1e3) + (rawResponseTextFor200.length > 1e3 ? "..." : "") : "N/A",
            jsonParsingError: e.message,
            contentType,
            location: "transcribeAudio - HTTP 200 JSON parse failed"
          };
          errorToLog.additionalInfo = additionalLogInfo;
          await logMobileError("TranscriptionService.transcribeAudio", `HTTP 200 with unparseable JSON on attempt ${retryCount + 1}. Error: ${e.message}`, errorToLog, additionalLogInfo);
          throw errorToLog;
        }
        (_f = context == null ? void 0 : context.onProgress) == null ? void 0 : _f.call(context, 70, `${retryText}Processing response...`);
        let transcriptionText = "";
        if (this.plugin.settings.transcriptionProvider === "custom" && this.plugin.settings.customTranscriptionEndpoint.includes("groq.com")) {
          if ((context == null ? void 0 : context.timestamped) && responseData.segments) {
            transcriptionText = responseData.segments.map((segment, index) => {
              const start = this.formatTimestamp(segment.start);
              const end = this.formatTimestamp(segment.end);
              return `${index + 1}
${start} --> ${end}
${segment.text.trim()}
`;
            }).join("\n");
          } else {
            transcriptionText = responseData.text || "";
          }
        } else {
          if (typeof responseData === "string") {
            transcriptionText = responseData;
          } else if (responseData.text) {
            transcriptionText = responseData.text;
          } else if ((_g = responseData.data) == null ? void 0 : _g.text) {
            transcriptionText = responseData.data.text;
          } else {
            throw new Error("Invalid response format: no transcription text found");
          }
        }
        if (!(transcriptionText == null ? void 0 : transcriptionText.trim())) {
          throw new Error("Empty transcription text received");
        }
        (_h = context == null ? void 0 : context.onProgress) == null ? void 0 : _h.call(context, 100, "Transcription complete!");
        return transcriptionText.trim();
      } catch (error) {
        let currentError = error instanceof Error ? error : new Error(String(error));
        if ((error == null ? void 0 : error.additionalInfo) && !currentError.additionalInfo) {
          currentError.additionalInfo = error.additionalInfo;
        }
        lastError = currentError;
        const isFinalAttempt = retryCount >= this.maxRetries;
        if (isFinalAttempt) {
          const finalLogAdditionalInfo = {
            finalAttempt: retryCount + 1,
            maxRetries: this.maxRetries,
            endpoint: this.plugin.settings.transcriptionProvider === "custom" ? this.plugin.settings.customTranscriptionEndpoint : `${this.sculptService.baseUrl}/audio/transcriptions`,
            fileSize: `${Math.round(blob.size / 1024)}KB`,
            provider: this.plugin.settings.transcriptionProvider,
            ...lastError.additionalInfo || {}
          };
          finalLogAdditionalInfo.formDataVersion = ((_i = lastError.additionalInfo) == null ? void 0 : _i.formDataVersion) || currentFormDataVersion;
          await logMobileError("TranscriptionService", `All ${this.maxRetries + 1} attempts failed. Final error: ${lastError.message}`, lastError, finalLogAdditionalInfo);
        } else {
        }
        const messageForRetryCheck = lastError.message.toLowerCase();
        const is500Error = messageForRetryCheck.includes("500") || messageForRetryCheck.includes("internal_error") || messageForRetryCheck.includes("server error") || messageForRetryCheck.includes("failed to parse server error response as json");
        const isNetworkError = messageForRetryCheck.includes("network error") || messageForRetryCheck.includes("connectivity") || messageForRetryCheck.includes("offline") || messageForRetryCheck.includes("request failed") || messageForRetryCheck.includes("connection was lost");
        const shouldRetry = (is500Error || isNetworkError) && retryCount < this.maxRetries;
        if (shouldRetry) {
          retryCount++;
          const backoffMs = 1e3 * Math.pow(2, retryCount - 1);
          await new Promise((resolve) => setTimeout(resolve, backoffMs));
        } else {
          throw lastError;
        }
      }
    }
    throw lastError || new Error("Unknown transcription error");
  }
  formatTimestamp(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor(seconds % 1 * 1e3);
    return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")},${ms.toString().padStart(3, "0")}`;
  }
  findOverlap(str1, str2, maxOverlapLength = 150) {
    const searchLength = Math.min(str1.length, str2.length, maxOverlapLength);
    const normalizedStr1 = str1.toLowerCase().trim();
    const normalizedStr2 = str2.toLowerCase().trim();
    for (let i = searchLength; i > 10; i--) {
      const suffix = normalizedStr1.slice(-i);
      const prefix = normalizedStr2.slice(0, i);
      if (suffix === prefix) {
        return i;
      }
    }
    for (let i = Math.min(100, searchLength); i > 20; i--) {
      const suffix = normalizedStr1.slice(-i);
      const prefix = normalizedStr2.slice(0, i);
      const suffixWords = suffix.split(/\s+/);
      const prefixWords = prefix.split(/\s+/);
      if (suffixWords.length < 3 || prefixWords.length < 3)
        continue;
      let matchCount = 0;
      for (const word of suffixWords) {
        if (word.length > 2 && prefixWords.includes(word)) {
          matchCount++;
        }
      }
      const similarity = matchCount / suffixWords.length;
      if (similarity > 0.7) {
        for (let j = 0; j < prefixWords.length; j++) {
          if (prefixWords[j].length > 2 && suffixWords.includes(prefixWords[j])) {
            const approxPos = normalizedStr2.indexOf(prefixWords.slice(j).join(" "));
            if (approxPos >= 0) {
              return approxPos;
            }
          }
        }
        return prefix.length;
      }
    }
    return 0;
  }
  hasTimestamps(text) {
    const srtPattern = /\d{2}:\d{2}:\d{2},\d{3}\s+-->\s+\d{2}:\d{2}:\d{2},\d{3}/;
    const vttPattern = /\d{2}:\d{2}:\d{2}\.\d{3}\s+-->\s+\d{2}:\d{2}:\d{2}\.\d{3}/;
    return srtPattern.test(text) || vttPattern.test(text);
  }
  parseTimestamps(text) {
    const result = [];
    const timestampRegex = /(\d{2}:\d{2}:\d{2}[,\.]\d{3})\s+-->\s+(\d{2}:\d{2}:\d{2}[,\.]\d{3})/g;
    let match;
    while ((match = timestampRegex.exec(text)) !== null) {
      const startTime = match[1];
      const endTime = match[2];
      const startSeconds = this.timestampToSeconds(startTime);
      const endSeconds = this.timestampToSeconds(endTime);
      result.push({
        index: match.index,
        startTime,
        endTime,
        startSeconds,
        endSeconds
      });
    }
    return result;
  }
  timestampToSeconds(timestamp) {
    const normalizedTimestamp = timestamp.replace(",", ".");
    const parts = normalizedTimestamp.split(":");
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const secondsParts = parts[2].split(".");
    const seconds = parseInt(secondsParts[0], 10);
    const milliseconds = secondsParts.length > 1 ? parseInt(secondsParts[1], 10) : 0;
    return hours * 3600 + minutes * 60 + seconds + milliseconds / 1e3;
  }
  secondsToTimestamp(seconds, format = "srt") {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const secs = Math.floor(seconds % 60);
    const milliseconds = Math.floor(seconds % 1 * 1e3);
    const hoursStr = hours.toString().padStart(2, "0");
    const minutesStr = minutes.toString().padStart(2, "0");
    const secsStr = secs.toString().padStart(2, "0");
    const millisecondsStr = milliseconds.toString().padStart(3, "0");
    const separator = format === "srt" ? "," : ".";
    return `${hoursStr}:${minutesStr}:${secsStr}${separator}${millisecondsStr}`;
  }
  adjustTimestamps(text, offsetSeconds) {
    if (offsetSeconds === 0) {
      return text;
    }
    const timestamps = this.parseTimestamps(text);
    if (timestamps.length === 0) {
      return text;
    }
    const format = text.includes(",") ? "srt" : "vtt";
    const separator = format === "srt" ? "," : ".";
    timestamps.sort((a, b) => b.index - a.index);
    let result = text;
    for (const timestamp of timestamps) {
      const newStartSeconds = Math.max(0, timestamp.startSeconds + offsetSeconds);
      const newEndSeconds = Math.max(0, timestamp.endSeconds + offsetSeconds);
      const newStartTime = this.secondsToTimestamp(newStartSeconds, format);
      const newEndTime = this.secondsToTimestamp(newEndSeconds, format);
      const originalTimestamp = `${timestamp.startTime} --> ${timestamp.endTime}`;
      const newTimestamp = `${newStartTime} --> ${newEndTime}`;
      result = result.substring(0, timestamp.index) + newTimestamp + result.substring(timestamp.index + originalTimestamp.length);
    }
    return result;
  }
  parseSrtEntries(text) {
    const result = [];
    const entries = text.split(/\n\s*\n/).filter((entry) => entry.trim().length > 0);
    for (const entry of entries) {
      const lines = entry.trim().split("\n");
      if (lines.length < 3)
        continue;
      const entryNumber = parseInt(lines[0], 10);
      if (isNaN(entryNumber))
        continue;
      const timestamp = lines[1];
      if (!timestamp.includes("-->"))
        continue;
      const content = lines.slice(2).join("\n");
      result.push({
        index: text.indexOf(entry),
        entryNumber,
        timestamp,
        content
      });
    }
    return result;
  }
  isReversedSrtNumbering(entries) {
    if (entries.length < 2)
      return false;
    const firstNumber = entries[0].entryNumber;
    const lastNumber = entries[entries.length - 1].entryNumber;
    let isConsistentlyDecreasing = true;
    for (let i = 1; i < entries.length; i++) {
      if (entries[i].entryNumber >= entries[i - 1].entryNumber) {
        isConsistentlyDecreasing = false;
        break;
      }
    }
    return firstNumber > lastNumber && isConsistentlyDecreasing;
  }
  hasUnusualSrtNumbering(entries) {
    if (entries.length < 2)
      return false;
    if (entries[0].entryNumber !== 1)
      return true;
    const isReversed = this.isReversedSrtNumbering(entries);
    if (isReversed)
      return true;
    for (let i = 1; i < entries.length; i++) {
      if (entries[i].entryNumber !== entries[i - 1].entryNumber + 1) {
        return true;
      }
    }
    return false;
  }
  renumberSrtEntries(text, startNumber) {
    const entries = this.parseSrtEntries(text);
    if (entries.length === 0) {
      return text;
    }
    const isReversed = this.isReversedSrtNumbering(entries);
    let sortedEntries = [...entries];
    sortedEntries.sort((a, b) => b.index - a.index);
    let result = text;
    for (let i = 0; i < sortedEntries.length; i++) {
      const entry = sortedEntries[i];
      const newEntryNumber = isReversed ? startNumber + (sortedEntries.length - 1 - i) : startNumber + i;
      const originalEntryNumber = entry.entryNumber.toString();
      const newEntryNumberStr = newEntryNumber.toString();
      const entryStart = result.indexOf(entry.timestamp, entry.index) - originalEntryNumber.length - 1;
      if (entryStart >= 0) {
        result = result.substring(0, entryStart) + newEntryNumberStr + result.substring(entryStart + originalEntryNumber.length);
      }
    }
    return result;
  }
  isSrtFormat(text) {
    const srtPattern = /^\d+\s*\n\d{2}:\d{2}:\d{2},\d{3}\s+-->\s+\d{2}:\d{2}:\d{2},\d{3}/m;
    return srtPattern.test(text);
  }
  mergeTranscriptions(transcriptions) {
    if (transcriptions.length === 0) {
      return "";
    }
    if (transcriptions.length === 1) {
      const isSrt2 = this.isSrtFormat(transcriptions[0]);
      if (isSrt2) {
        const entries = this.parseSrtEntries(transcriptions[0]);
        const isReversed = this.isReversedSrtNumbering(entries);
        const hasUnusual = this.hasUnusualSrtNumbering(entries);
        const firstNumber = entries.length > 0 ? entries[0].entryNumber : 0;
        if (entries.length > 0 && (isReversed || hasUnusual || firstNumber !== 1)) {
          let result = "";
          const sortedEntries = [...entries].sort((a, b) => a.index - b.index);
          for (let i = 0; i < sortedEntries.length; i++) {
            const entry = sortedEntries[i];
            const entryNumber = i + 1;
            if (i > 0) {
              result += "\n\n";
            }
            result += `${entryNumber}
${entry.timestamp}
${entry.content}`;
          }
          return result;
        }
      }
      return transcriptions[0];
    }
    const hasTimestamps = this.hasTimestamps(transcriptions[0]);
    const isSrt = this.isSrtFormat(transcriptions[0]);
    if (hasTimestamps && isSrt) {
      let result = "";
      let allEntries = [];
      for (let i = 0; i < transcriptions.length; i++) {
        const transcription = transcriptions[i];
        const entries = this.parseSrtEntries(transcription);
        if (this.isReversedSrtNumbering(entries)) {
        }
        if (this.hasUnusualSrtNumbering(entries)) {
        }
        entries.forEach((entry) => {
          allEntries.push({
            ...entry,
            chunkIndex: i
          });
        });
      }
      allEntries.sort((a, b) => {
        if (a.chunkIndex !== b.chunkIndex) {
          return a.chunkIndex - b.chunkIndex;
        }
        return a.index - b.index;
      });
      for (let i = 0; i < allEntries.length; i++) {
        const entry = allEntries[i];
        const entryNumber = i + 1;
        if (i > 0) {
          result += "\n\n";
        }
        result += `${entryNumber}
${entry.timestamp}
${entry.content}`;
      }
      return result;
    } else if (hasTimestamps) {
      let result = "";
      for (let i = 0; i < transcriptions.length; i++) {
        const transcription = transcriptions[i];
        if (i > 0) {
          result += "\n\n";
        }
        result += transcription;
      }
      return result;
    } else {
      let result = transcriptions[0];
      for (let i = 1; i < transcriptions.length; i++) {
        const current = transcriptions[i];
        const overlapLength = this.findOverlap(result, current, 300);
        if (overlapLength > 0) {
          result += current.slice(overlapLength);
        } else {
          const lastChar = result.charAt(result.length - 1);
          const endsWithPunctuation = /[.!?]/.test(lastChar);
          const endsWithSpace = /\s/.test(lastChar);
          const firstChar = current.charAt(0);
          const startsWithUppercase = /[A-Z]/.test(firstChar);
          if (endsWithPunctuation) {
            result += " ";
            result += current;
          } else if (endsWithSpace) {
            result += current;
          } else {
            if (startsWithUppercase) {
              result += ". " + current;
            } else {
              result += " " + current;
            }
          }
        }
      }
      return result;
    }
  }
  constructBinaryMultipartPayload(audioData, fileName) {
    var _a;
    const boundary = `----formdata-systemsculpt-${Date.now()}-${Math.random().toString(36).substring(2)}`;
    const extension = ((_a = fileName.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "webm";
    const mimeType = MIME_TYPE_MAP[extension] || "audio/webm";
    const encoder = new TextEncoder();
    const parts = [];
    const requestId = `req_mobile_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
    parts.push(encoder.encode(`--${boundary}\r
`));
    parts.push(encoder.encode(`Content-Disposition: form-data; name="requestId"\r
\r
`));
    parts.push(encoder.encode(`${requestId}\r
`));
    parts.push(encoder.encode(`--${boundary}\r
`));
    parts.push(encoder.encode(`Content-Disposition: form-data; name="file"; filename="${fileName}"\r
`));
    parts.push(encoder.encode(`Content-Type: ${mimeType}\r
\r
`));
    parts.push(new Uint8Array(audioData));
    parts.push(encoder.encode("\r\n"));
    parts.push(encoder.encode(`--${boundary}--\r
`));
    const totalSize = parts.reduce((sum, part) => sum + part.length, 0);
    const payload = new Uint8Array(totalSize);
    let offset = 0;
    for (const part of parts) {
      payload.set(part, offset);
      offset += part.length;
    }
    return {
      boundary,
      payload: payload.buffer,
      contentType: `multipart/form-data; boundary=${boundary}`
    };
  }
  constructMultipartPayload(audioData, fileName, model = "whisper-1") {
    var _a;
    const boundary = `----formdata-systemsculpt-${Date.now()}-${Math.random().toString(36).substring(2)}`;
    const extension = ((_a = fileName.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "webm";
    const mimeType = MIME_TYPE_MAP[extension] || "audio/webm";
    const uint8Array = new Uint8Array(audioData);
    let binaryString = "";
    for (let i = 0; i < uint8Array.length; i++) {
      binaryString += String.fromCharCode(uint8Array[i]);
    }
    const base64Data = btoa(binaryString);
    let payload = "";
    const requestId = `req_mobile_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
    payload += `--${boundary}\r
`;
    payload += `Content-Disposition: form-data; name="requestId"\r
\r
`;
    payload += `${requestId}\r
`;
    payload += `--${boundary}\r
`;
    payload += `Content-Disposition: form-data; name="file"; filename="${fileName}"\r
`;
    payload += `Content-Type: ${mimeType}\r
`;
    payload += `Content-Transfer-Encoding: base64\r
\r
`;
    payload += `${base64Data}\r
`;
    payload += `--${boundary}--\r
`;
    return {
      boundary,
      payload,
      contentType: `multipart/form-data; boundary=${boundary}`
    };
  }
  async transcribeFile(file, context) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (this.isTranscribing) {
      throw new Error("Already transcribing a file");
    }
    const extension = file.extension.toLowerCase();
    if (!SUPPORTED_AUDIO_EXTENSIONS.includes(extension)) {
      throw new Error(`Unsupported file type: ${extension}`);
    }
    if (file.stat.size > MAX_FILE_SIZE2) {
      throw new Error(`File too large. Maximum allowed size is ${Math.floor(MAX_FILE_SIZE2 / (1024 * 1024))}MB.`);
    }
    this.isTranscribing = true;
    try {
      if (this.plugin.settings.transcriptionProvider === "systemsculpt" && (!this.plugin.settings.licenseKey || !this.plugin.settings.licenseValid)) {
        throw new Error("A valid SystemSculpt license is required to use the SystemSculpt API for transcription. Please enter a valid license key or switch to a custom transcription provider in the settings.");
      }
      (_a = context == null ? void 0 : context.onProgress) == null ? void 0 : _a.call(context, 0, "Reading audio file...");
      let arrayBuffer;
      try {
        arrayBuffer = await this.plugin.app.vault.readBinary(file);
        console.log(`Successfully read file from Obsidian vault: ${file.path}`);
      } catch (readError) {
        console.error(`Error reading file from Obsidian vault: ${file.path}`, readError);
        if (readError instanceof Error) {
          console.error(`Error type: ${readError.name}, message: ${readError.message}`);
          if (readError.stack)
            console.error(`Stack: ${readError.stack}`);
        }
        try {
          const fs = require("fs");
          const path = require("path");
          let vaultPath = "";
          if (this.plugin.app.vault.adapter.basePath) {
            vaultPath = this.plugin.app.vault.adapter.basePath;
          } else {
            console.warn("Could not access vault base path directly, attempting to infer from context");
            const errorMatch = readError instanceof Error && readError.message.match(/open '(.+?)'/);
            if (errorMatch && errorMatch[1]) {
              const fullErrorPath = errorMatch[1];
              vaultPath = fullErrorPath.replace(new RegExp(`${file.path}$`), "");
              vaultPath = vaultPath.replace(/\/$/, "");
              console.log("Inferred vault path from error:", vaultPath);
            }
          }
          if (!vaultPath) {
            throw new Error("Could not determine vault path");
          }
          const absolutePath = path.join(vaultPath, file.path);
          console.log(`Attempting to read file directly from filesystem: ${absolutePath}`);
          arrayBuffer = await new Promise((resolve, reject) => {
            fs.readFile(absolutePath, (err, data) => {
              if (err) {
                reject(new Error(`Failed to read file directly: ${err.message}`));
                return;
              }
              resolve(data.buffer);
            });
          });
          console.log(`Successfully read file directly from filesystem: ${absolutePath}`);
        } catch (fsError) {
          console.error("Failed to read file using direct filesystem access:", fsError);
          throw new Error(`Failed to read audio file. Original error: ${readError instanceof Error ? readError.message : String(readError)}`);
        }
      }
      let processedArrayBuffer = arrayBuffer;
      let mimeType = MIME_TYPE_MAP[extension];
      let wasResampled = false;
      const isMobile = this.mobileDetection.isMobileDevice();
      const resamplingEnabled = (_b = this.plugin.settings.enableAutoAudioResampling) != null ? _b : true;
      if (this.plugin.settings.transcriptionProvider === "systemsculpt" && !isMobile && resamplingEnabled) {
        const targetSampleRate = EXPECTED_SAMPLE_RATES[extension] || 16e3;
        try {
          (_c = context == null ? void 0 : context.onProgress) == null ? void 0 : _c.call(context, 10, "Checking audio compatibility...");
          const { needsResampling, currentSampleRate } = await this.audioResampler.checkNeedsResampling(arrayBuffer, mimeType, targetSampleRate);
          if (needsResampling) {
            (_d = context == null ? void 0 : context.onProgress) == null ? void 0 : _d.call(context, 15, `Converting audio format for optimal processing...`);
            new import_obsidian49.Notice(`Audio needs conversion from ${currentSampleRate}Hz to ${targetSampleRate}Hz. This may take a moment...`, 5e3);
            const startTime = Date.now();
            const resampleResult = await this.audioResampler.resampleAudio(arrayBuffer, targetSampleRate, mimeType);
            const resampleTime = Date.now() - startTime;
            processedArrayBuffer = resampleResult.buffer;
            mimeType = "audio/wav";
            wasResampled = true;
            if (resampleTime > 2e3) {
              (_e = context == null ? void 0 : context.onProgress) == null ? void 0 : _e.call(context, 18, "Audio conversion complete!");
            }
          }
        } catch (resampleError) {
          console.warn("[TranscriptionService] Audio resampling failed, using original:", resampleError);
          new import_obsidian49.Notice("Audio format conversion failed. Attempting with original file...", 3e3);
        }
      } else if (this.plugin.settings.transcriptionProvider === "systemsculpt" && isMobile) {
        try {
          const { needsResampling, currentSampleRate } = await this.audioResampler.checkNeedsResampling(arrayBuffer, mimeType, EXPECTED_SAMPLE_RATES[extension] || 16e3);
          if (needsResampling) {
            new import_obsidian49.Notice(`\u26A0\uFE0F Audio format (${currentSampleRate}Hz) may not be compatible. Consider converting on desktop for best results.`, 7e3);
          }
        } catch (e) {
        }
      }
      const blob = new Blob([processedArrayBuffer], {
        type: mimeType
      });
      (_f = context == null ? void 0 : context.onProgress) == null ? void 0 : _f.call(context, 20, "Uploading audio file...");
      const transcriptionText = await this.queueTranscription(file, blob, context, wasResampled);
      (_g = context == null ? void 0 : context.onProgress) == null ? void 0 : _g.call(context, 100, "Transcription complete!");
      return transcriptionText;
    } catch (error) {
      const catchedError = error instanceof Error ? error : new Error(String(error));
      const existingAdditionalInfo = catchedError.additionalInfo;
      const currentFormDataVersionForCatch = "v2.9-native-fetch-ndjson";
      let finalAdditionalInfoToLog = {
        location: "transcribeFile catch block",
        originalErrorName: catchedError.name,
        formDataVersion: currentFormDataVersionForCatch,
        provider: this.plugin.settings.transcriptionProvider,
        file: { name: file.name, path: file.path, size: file.stat.size },
        ...existingAdditionalInfo || {}
      };
      if (existingAdditionalInfo) {
        finalAdditionalInfoToLog.formDataVersion = existingAdditionalInfo.formDataVersion || currentFormDataVersionForCatch;
        finalAdditionalInfoToLog.provider = existingAdditionalInfo.provider || this.plugin.settings.transcriptionProvider;
      }
      await logMobileError("TranscriptionService.transcribeFile", `Unhandled error in transcription process: ${catchedError.message}`, catchedError, finalAdditionalInfoToLog);
      console.error("Transcription error caught by transcribeFile:", catchedError, finalAdditionalInfoToLog);
      new import_obsidian49.Notice(`Transcription failed: ${catchedError.message.substring(0, 120)}... (See debug log)`);
      throw catchedError;
    } finally {
      this.isTranscribing = false;
    }
  }
  async queueTranscription(file, blob, context, wasResampled = false) {
    var _a, _b, _c, _d;
    if (this.activeUploads >= this.maxConcurrentUploads) {
      const waitNotice = new import_obsidian49.Notice(`Another transcription is in progress. Your file will be processed next...`, 0);
      (_a = context == null ? void 0 : context.onProgress) == null ? void 0 : _a.call(context, 20, "Waiting for previous transcription to complete...");
      let waitTime = 0;
      while (this.activeUploads >= this.maxConcurrentUploads) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        waitTime += 500;
        if (waitTime % 2e3 === 0) {
          (_b = context == null ? void 0 : context.onProgress) == null ? void 0 : _b.call(context, 20, `Waiting in queue (${Math.round(waitTime / 1e3)}s)...`);
        }
      }
      waitNotice.hide();
      (_c = context == null ? void 0 : context.onProgress) == null ? void 0 : _c.call(context, 25, "Starting transcription...");
    }
    this.activeUploads++;
    try {
      if (wasResampled) {
        (_d = context == null ? void 0 : context.onProgress) == null ? void 0 : _d.call(context, 30, "Uploading converted audio...");
      }
      return await this.transcribeAudio(file, blob, context);
    } finally {
      this.activeUploads--;
      if (this.uploadQueue.length > 0) {
      }
    }
  }
  unload() {
    if (this.audioResampler) {
      this.audioResampler.dispose();
    }
  }
};

// src/services/PostProcessingService.ts
init_SystemSculptService();
init_modelUtils();
var PostProcessingService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.sculptService = SystemSculptService.getInstance(plugin);
  }
  static getInstance(plugin) {
    if (!PostProcessingService.instance) {
      PostProcessingService.instance = new PostProcessingService(plugin);
    }
    return PostProcessingService.instance;
  }
  getPostProcessingModelId() {
    let modelId = this.plugin.settings.postProcessingModelId;
    let providerId = this.plugin.settings.postProcessingProviderId;
    if (!modelId || !providerId) {
      console.warn("[SystemSculpt] Post-processing model or provider not explicitly set, using defaults.");
      const globalDefault = this.plugin.settings.selectedModelId;
      if (globalDefault) {
        const parsedGlobal = parseCanonicalId(globalDefault);
        if (parsedGlobal) {
          modelId = parsedGlobal.modelId;
          providerId = parsedGlobal.providerId;
        }
      }
    }
    modelId = ensureCanonicalId(modelId);
    if (!modelId) {
      throw new Error("Failed to determine a valid model for post-processing.");
    }
    return modelId;
  }
  async processTranscription(text) {
    if (!this.plugin.settings.postProcessingEnabled) {
      return text;
    }
    try {
      const modelId = this.getPostProcessingModelId();
      const messages = [
        {
          role: "system",
          content: this.plugin.settings.postProcessingPrompt,
          message_id: crypto.randomUUID()
        },
        {
          role: "user",
          content: text,
          message_id: crypto.randomUUID()
        }
      ];
      let processedText = "";
      for await (const chunk of this.sculptService.streamMessage({
        messages,
        model: modelId,
        temperature: 0.3
      })) {
        if (chunk.content) {
          processedText += chunk.content;
        }
      }
      return processedText.trim();
    } catch (error) {
      console.error("Error post-processing transcription:", error);
      return text;
    }
  }
};

// src/services/TranscriptionProgressManager.ts
var TranscriptionProgressManager = class {
  constructor() {
    this.activeTranscriptions = new Map();
  }
  static getInstance() {
    if (!TranscriptionProgressManager.instance) {
      TranscriptionProgressManager.instance = new TranscriptionProgressManager();
    }
    return TranscriptionProgressManager.instance;
  }
  createProgressHandler(file, onProgress) {
    const filePath = file.path;
    this.activeTranscriptions.set(filePath, {
      startTime: Date.now(),
      lastProgress: 0,
      lastStatus: "Starting transcription...",
      detailedInfo: null,
      cleanupTimeout: null
    });
    return {
      type: "note",
      onProgress: (progress, status) => {
        const transcription = this.activeTranscriptions.get(filePath);
        if (transcription) {
          transcription.lastProgress = progress;
          transcription.lastStatus = status;
          if (transcription.cleanupTimeout) {
            clearTimeout(transcription.cleanupTimeout);
            transcription.cleanupTimeout = null;
          }
          let icon = "loader-2";
          let details = null;
          if (progress === 0 && status.includes("Error")) {
            icon = "x-circle";
          } else if (progress === 100) {
            icon = "check-circle";
          } else if (status.includes("Uploading")) {
            icon = "upload";
          } else if (status.includes("Chunk") || status.includes("chunk")) {
            icon = "scissors";
          } else if (status.includes("Transcribing")) {
            icon = "file-audio";
          } else if (status.includes("Process")) {
            icon = "cpu";
          }
          onProgress == null ? void 0 : onProgress(progress, status, icon, details || transcription.detailedInfo || void 0);
          if (progress === 100 || status.includes("Error") || status.includes("Complete")) {
            transcription.detailedInfo = null;
            if (progress === 100) {
              transcription.cleanupTimeout = setTimeout(() => {
                this.activeTranscriptions.delete(filePath);
              }, 2e3);
            }
          }
        }
      }
    };
  }
  handleCompletion(filePath, resultPath, onComplete) {
    const transcription = this.activeTranscriptions.get(filePath);
    if (transcription) {
      if (transcription.cleanupTimeout) {
        clearTimeout(transcription.cleanupTimeout);
      }
      transcription.cleanupTimeout = setTimeout(() => {
        this.activeTranscriptions.delete(filePath);
      }, 2e3);
      onComplete == null ? void 0 : onComplete(resultPath);
    }
  }
  clearProgress(filePath) {
    const transcription = this.activeTranscriptions.get(filePath);
    if (transcription && transcription.cleanupTimeout) {
      clearTimeout(transcription.cleanupTimeout);
    }
    this.activeTranscriptions.delete(filePath);
  }
};

// src/modals/AudioTranscriptionModal.ts
var PersistentTranscriptionNotice = class extends import_obsidian50.Notice {
  constructor() {
    super("", 0);
    this.closeButton = null;
    this.countdownTimer = null;
    this.countdownInterval = null;
    this.lastProgress = null;
    this.noticeEl.addClass("systemsculpt-transcription-notice");
    const progressContainer = this.noticeEl.createDiv("transcription-progress");
    const statusContainer = progressContainer.createDiv("transcription-status");
    this.statusIcon = statusContainer.createDiv("transcription-status-icon");
    this.statusText = statusContainer.createDiv("transcription-status-text");
    const progressBarContainer = progressContainer.createDiv("transcription-progress-bar-container");
    this.progressBar = progressBarContainer.createDiv("transcription-progress-bar");
    if (!document.getElementById("systemsculpt-transcription-notice-styles")) {
      const style = document.createElement("style");
      style.id = "systemsculpt-transcription-notice-styles";
      style.textContent = `
        .systemsculpt-transcription-notice {
          padding: 12px 16px !important;
          min-width: 280px;
          max-width: 400px;
          transition: all 0.3s ease;
          position: fixed;
          bottom: 30px;
          right: 30px;
          z-index: 1000;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          background-color: var(--background-secondary);
          border: 1px solid var(--background-modifier-border);
        }

        .transcription-progress {
          display: flex;
          flex-direction: column;
          gap: 10px;
        }

        .transcription-status {
          display: flex;
          align-items: center;
          gap: 10px;
          color: var(--text-normal);
        }

        .transcription-status-icon {
          display: flex;
          align-items: center;
          justify-content: center;
          color: var(--text-accent);
          min-width: 20px;
        }

        .transcription-status-text {
          flex: 1;
          font-size: 14px;
          line-height: 1.4;
        }

        .transcription-progress-bar-container {
          width: 100%;
          height: 6px;
          background: var(--background-modifier-border);
          border-radius: 3px;
          overflow: hidden;
          margin-top: 2px;
        }

        .transcription-progress-bar {
          height: 100%;
          background: var(--text-accent);
          border-radius: 3px;
          transition: width 0.3s ease;
          width: 0%;
        }

        .notice-success .transcription-progress-bar {
          background: var(--text-success) !important;
        }

        .notice-error .transcription-progress-bar {
          background: var(--text-error) !important;
        }

        .notice-chunking .transcription-progress-bar {
          background: linear-gradient(90deg, var(--text-accent), var(--text-accent-hover)) !important;
          background-size: 200% 100% !important;
          animation: progress-pulse 2s infinite linear !important;
        }

        .notice-processing .transcription-progress-bar {
          background: linear-gradient(90deg, var(--text-accent-hover), var(--interactive-accent)) !important;
          background-size: 200% 100% !important;
          animation: progress-pulse 1.5s infinite linear !important;
        }

        @keyframes progress-pulse {
          0% { background-position: 0% 50%; }
          100% { background-position: 200% 50%; }
        }

        /* Add a subtle shimmer effect to the status text during processing */
        .notice-processing .transcription-status-text,
        .notice-chunking .transcription-status-text {
          position: relative;
          overflow: hidden;
        }

        .notice-processing .transcription-status-text::after,
        .notice-chunking .transcription-status-text::after {
          content: "";
          position: absolute;
          top: 0;
          left: -100%;
          width: 50%;
          height: 100%;
          background: linear-gradient(
            90deg,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.2) 50%,
            rgba(255, 255, 255, 0) 100%
          );
          animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
          0% { left: -100%; }
          100% { left: 200%; }
        }
      `;
      document.head.appendChild(style);
    }
  }
  updateProgress(progress) {
    this.lastProgress = progress;
    this.progressBar.style.width = `${progress.progress}%`;
    this.statusText.setText(progress.status);
    this.statusIcon.empty();
    (0, import_obsidian50.setIcon)(this.statusIcon, progress.icon);
    this.noticeEl.removeClass("notice-success", "notice-error", "notice-chunking", "notice-processing");
    if (progress.progress === 100) {
      this.noticeEl.addClass("notice-success");
    } else if (progress.progress === 0 && progress.icon === "x-circle") {
      this.noticeEl.addClass("notice-error");
    } else if (progress.status.includes("Chunk") || progress.status.includes("chunk")) {
      this.noticeEl.addClass("notice-chunking");
    } else if (progress.status.includes("Transcribing") || progress.status.includes("Processing")) {
      this.noticeEl.addClass("notice-processing");
    }
  }
  showSuccessState() {
    this.noticeEl.addClass("notice-success");
    this.statusIcon.empty();
    (0, import_obsidian50.setIcon)(this.statusIcon, "check-circle");
    this.progressBar.style.width = "100%";
  }
  addCloseButton() {
    var _a;
    if (this.closeButton)
      return;
    this.closeButton = this.noticeEl.createDiv("transcription-close-button");
    (0, import_obsidian50.setIcon)(this.closeButton, "x");
    this.closeButton.addEventListener("click", () => {
      this.hide();
    });
    const styleEl = document.getElementById("systemsculpt-transcription-notice-styles");
    if (styleEl && !((_a = styleEl.textContent) == null ? void 0 : _a.includes(".transcription-close-button"))) {
      styleEl.textContent += `
        .transcription-close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          cursor: pointer;
          opacity: 0.7;
          transition: opacity 0.2s ease;
          display: flex;
          align-items: center;
          justify-content: center;
          width: 24px;
          height: 24px;
          border-radius: 4px;
        }

        .transcription-close-button:hover {
          opacity: 1;
          background-color: var(--background-modifier-hover);
        }
      `;
    }
  }
  startCountdownTimer(seconds = 5) {
    var _a;
    this.clearCountdownTimer();
    if (!this.countdownTimer) {
      const countdownContainer = this.noticeEl.createDiv("transcription-countdown-container");
      this.countdownTimer = countdownContainer.createDiv("transcription-countdown");
      const styleEl = document.getElementById("systemsculpt-transcription-notice-styles");
      if (styleEl && !((_a = styleEl.textContent) == null ? void 0 : _a.includes(".transcription-countdown-container"))) {
        styleEl.textContent += `
          .transcription-countdown-container {
            display: flex;
            justify-content: center;
            margin-top: 8px;
          }

          .transcription-countdown {
            font-size: 12px;
            color: var(--text-muted);
            background-color: var(--background-secondary);
            border-radius: 10px;
            padding: 2px 8px;
            min-width: 24px;
            text-align: center;
            transition: all 0.3s ease;
          }

          .systemsculpt-transcription-notice.closing {
            animation: slide-out-right 0.5s ease forwards;
          }

          @keyframes slide-out-right {
            from {
              transform: translateX(0);
              opacity: 1;
            }
            to {
              transform: translateX(100%);
              opacity: 0;
            }
          }
        `;
      }
    }
    let timeLeft = seconds;
    if (this.countdownTimer) {
      this.countdownTimer.setText(`Closing in ${timeLeft}s`);
    }
    this.countdownInterval = window.setInterval(() => {
      timeLeft--;
      if (timeLeft <= 0) {
        this.clearCountdownTimer();
        this.noticeEl.addClass("closing");
        setTimeout(() => {
          this.hide();
        }, 500);
      } else if (this.countdownTimer) {
        this.countdownTimer.setText(`Closing in ${timeLeft}s`);
      }
    }, 1e3);
  }
  clearCountdownTimer() {
    if (this.countdownInterval) {
      clearInterval(this.countdownInterval);
      this.countdownInterval = null;
    }
  }
  hide() {
    this.clearCountdownTimer();
    super.hide();
  }
  addCompletionButtons(resultPath) {
    var _a;
    this.showSuccessState();
    this.addCloseButton();
    const existingButtons = this.noticeEl.querySelector(".transcription-buttons");
    if (existingButtons) {
      existingButtons.remove();
    }
    const buttonsContainer = this.noticeEl.createDiv("transcription-buttons");
    const viewButton = document.createElement("button");
    viewButton.className = "transcription-button primary";
    viewButton.textContent = "View Result";
    viewButton.addEventListener("click", () => {
      const app = window.app;
      const file = app.vault.getAbstractFileByPath(resultPath);
      if (file) {
        app.workspace.getLeaf().openFile(file);
        this.hide();
      }
    });
    const closeButton = document.createElement("button");
    closeButton.className = "transcription-button";
    closeButton.textContent = "Close";
    closeButton.addEventListener("click", () => {
      this.hide();
    });
    buttonsContainer.appendChild(viewButton);
    buttonsContainer.appendChild(closeButton);
    const styleEl = document.getElementById("systemsculpt-transcription-notice-styles");
    if (styleEl && !((_a = styleEl.textContent) == null ? void 0 : _a.includes(".transcription-buttons"))) {
      styleEl.textContent += `
        .transcription-buttons {
          display: flex;
          justify-content: flex-end;
          gap: 8px;
          margin-top: 12px;
        }

        .transcription-button {
          padding: 6px 12px;
          border-radius: 4px;
          font-size: 14px;
          cursor: pointer;
          background-color: var(--interactive-normal);
          color: var(--text-normal);
          border: none;
          transition: background-color 0.2s ease;
        }

        .transcription-button:hover {
          background-color: var(--interactive-hover);
        }

        .transcription-button.primary {
          background-color: var(--interactive-accent);
          color: var(--text-on-accent);
        }

        .transcription-button.primary:hover {
          background-color: var(--interactive-accent-hover);
        }
      `;
    }
  }
};
var AudioTranscriptionModal = class {
  constructor(app, options) {
    this.app = app;
    this.options = options;
    this.plugin = options.plugin;
    this.transcriptionService = TranscriptionService.getInstance(options.plugin);
    this.postProcessingService = PostProcessingService.getInstance(options.plugin);
  }
  open() {
    this.notice = new PersistentTranscriptionNotice();
    this.startTranscription();
  }
  insertTranscribedText(text) {
    try {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian50.MarkdownView);
      if (view == null ? void 0 : view.editor) {
        view.editor.replaceSelection(text);
        new import_obsidian50.Notice("\u2713 Transcription inserted into document");
      } else {
        new import_obsidian50.Notice("\u2713 Transcription copied to clipboard (no active editor)");
        navigator.clipboard.writeText(text);
      }
    } catch (error) {
      console.error("Failed to insert transcribed text:", error);
      new import_obsidian50.Notice("\u274C Failed to insert transcription");
      try {
        navigator.clipboard.writeText(text);
        new import_obsidian50.Notice("\u2713 Transcription copied to clipboard instead");
      } catch (e) {
        console.error("Failed to copy to clipboard:", e);
      }
    }
  }
  async startTranscription() {
    try {
      this.notice.updateProgress({
        progress: 0,
        status: "Starting transcription...",
        icon: "mic"
      });
      const progressManager = TranscriptionProgressManager.getInstance();
      const progressHandler = progressManager.createProgressHandler(this.options.file, (progress, status, icon, details) => {
        this.notice.updateProgress({
          progress,
          status,
          icon: icon || "audio-lines",
          details
        });
      });
      const text = await this.transcriptionService.transcribeFile(this.options.file, {
        ...progressHandler,
        type: this.options.isChat ? "chat" : "note",
        timestamped: this.options.timestamped
      });
      if (!text) {
        throw new Error("Failed to get transcription text");
      }
      let finalText = text;
      let processedText = text;
      if (this.plugin.settings.postProcessingEnabled) {
        this.notice.updateProgress({
          progress: 80,
          status: "Post-processing transcription...",
          icon: "wand"
        });
        processedText = await this.postProcessingService.processTranscription(text);
      }
      if (this.plugin.settings.cleanTranscriptionOutput || this.options.isChat) {
        finalText = processedText;
      } else if (this.plugin.settings.postProcessingEnabled) {
        let audioPlayerSection = "";
        if (this.plugin.settings.keepRecordingsAfterTranscription) {
          const audioLink = `![[${this.options.file.path}]]`;
          audioPlayerSection = `
## Audio Recording
${audioLink}

`;
        }
        finalText = `# Audio Transcription
Source: ${this.options.file.basename}
Transcribed: ${new Date().toISOString()}

${audioPlayerSection}## Raw Transcription
${text}

## Processed Transcription
${processedText}`;
      } else {
        let audioPlayerSection = "";
        if (this.plugin.settings.keepRecordingsAfterTranscription) {
          const audioLink = `![[${this.options.file.path}]]`;
          audioPlayerSection = `
## Audio Recording
${audioLink}

`;
        }
        finalText = `# Audio Transcription
Source: ${this.options.file.basename}
Transcribed: ${new Date().toISOString()}

${audioPlayerSection}## Raw Transcription
${text}`;
      }
      if (!this.options.isChat && this.plugin.settings.autoPasteTranscription) {
        this.insertTranscribedText(finalText);
      }
      if (this.options.onTranscriptionComplete) {
        this.options.onTranscriptionComplete(finalText);
      }
      await navigator.clipboard.writeText(finalText);
      const audioPath = this.options.file.path;
      const markdownPath = audioPath.substring(0, audioPath.lastIndexOf(".")) + ".md";
      const existingFile = this.app.vault.getAbstractFileByPath(markdownPath);
      if (existingFile instanceof import_obsidian50.TFile) {
        await this.app.vault.modify(existingFile, finalText);
      } else {
        await this.app.vault.create(markdownPath, finalText);
      }
      this.notice.updateProgress({
        progress: 100,
        status: "Transcription complete!",
        icon: "check-circle"
      });
      this.notice.showSuccessState();
      this.notice.addCompletionButtons(markdownPath);
      this.notice.startCountdownTimer(5);
      progressManager.handleCompletion(this.options.file.path, markdownPath);
    } catch (error) {
      console.error("Transcription error:", error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.notice.updateProgress({
        progress: 0,
        status: `Error: ${errorMessage}`,
        icon: "x-circle",
        details: `Transcription failed
File: ${this.options.file.path}
Error details: ${errorMessage}

Please try again or check the console for more information.`
      });
      this.notice.addCloseButton();
    }
  }
};
async function showAudioTranscriptionModal(app, options) {
  const modal = new AudioTranscriptionModal(app, options);
  modal.open();
}

// src/modals/RecordingModal.ts
var import_obsidian51 = __toModule(require("obsidian"));
init_MobileDetection();
var RecordingModal = class extends import_obsidian51.Modal {
  constructor(app, plugin, callbacks) {
    super(app);
    this.statusEl = null;
    this.timerEl = null;
    this.visualizerCanvas = null;
    this.visualizerCtx = null;
    this.stopButton = null;
    this.assuranceEl = null;
    this.recordingStartTime = 0;
    this.timerInterval = null;
    this.audioContext = null;
    this.analyser = null;
    this.animationId = null;
    this.plugin = plugin;
    this.callbacks = callbacks;
    this.mobileDetection = MobileDetection.getInstance();
  }
  onOpen() {
    const { contentEl } = this;
    const isMobile = this.mobileDetection.isMobileDevice();
    this.titleEl.setText("\u{1F399}\uFE0F Recording Audio");
    if (isMobile) {
      this.modalEl.addClass("systemsculpt-recording-modal-native-mobile");
    } else {
      this.modalEl.addClass("systemsculpt-recording-modal-native-desktop");
    }
    this.createRecordingInterface(contentEl, isMobile);
    this.startTimer();
  }
  onClose() {
    this.stopTimer();
    this.stopVisualization();
    this.statusEl = null;
    this.timerEl = null;
    this.visualizerCanvas = null;
    this.visualizerCtx = null;
    this.stopButton = null;
    this.assuranceEl = null;
  }
  createRecordingInterface(container, isMobile) {
    container.empty();
    container.addClass("systemsculpt-recording-content");
    if (isMobile) {
      container.addClass("systemsculpt-recording-content-mobile");
    }
    this.statusEl = container.createDiv("systemsculpt-recording-status");
    this.statusEl.setText("Recording in progress...");
    if (isMobile) {
      this.statusEl.addClass("systemsculpt-recording-status-mobile");
    }
    this.timerEl = container.createDiv("systemsculpt-recording-timer");
    this.timerEl.setText("00:00");
    if (isMobile) {
      this.timerEl.addClass("systemsculpt-recording-timer-mobile");
    }
    this.visualizerCanvas = container.createEl("canvas", {
      cls: isMobile ? "systemsculpt-recording-visualizer systemsculpt-recording-visualizer-mobile" : "systemsculpt-recording-visualizer"
    });
    if (isMobile) {
      this.visualizerCanvas.width = Math.min(400, window.innerWidth - 80);
      this.visualizerCanvas.height = 100;
    } else {
      this.visualizerCanvas.width = 300;
      this.visualizerCanvas.height = 60;
    }
    this.visualizerCtx = this.visualizerCanvas.getContext("2d");
    if (this.visualizerCtx) {
      this.visualizerCtx.fillStyle = "var(--background-secondary)";
      this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
    }
    const buttonContainer = container.createDiv("systemsculpt-recording-buttons");
    if (isMobile) {
      buttonContainer.addClass("systemsculpt-recording-buttons-mobile");
    }
    this.stopButton = new import_obsidian51.ButtonComponent(buttonContainer);
    this.stopButton.setButtonText("Stop Recording").setCta().onClick(() => {
      this.callbacks.onStop();
      this.close();
    });
    if (isMobile) {
      this.stopButton.buttonEl.addClass("systemsculpt-recording-stop-mobile");
      this.stopButton.buttonEl.innerHTML = `
        <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2"
             fill="none" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
        </svg>
        Stop Recording
      `;
    }
    if (isMobile) {
      this.assuranceEl = container.createDiv("systemsculpt-recording-assurance");
      this.assuranceEl.innerHTML = `
        <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"
             stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 11l3 3L22 4"></path>
          <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
        </svg>
        Your recording will be saved securely, even if transcription fails.
      `;
    }
  }
  updateStatus(status) {
    if (this.statusEl) {
      this.statusEl.setText(status);
    }
    this.callbacks.onStatusUpdate(status);
  }
  startTimer() {
    this.recordingStartTime = Date.now();
    this.stopTimer();
    this.timerInterval = window.setInterval(() => {
      if (!this.timerEl)
        return;
      const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1e3);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      this.timerEl.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
    }, 1e3);
  }
  stopTimer() {
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
  }
  async startVisualization(mediaStream) {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.analyser = this.audioContext.createAnalyser();
      this.analyser.fftSize = 256;
      this.analyser.smoothingTimeConstant = 0.8;
      const source = this.audioContext.createMediaStreamSource(mediaStream);
      source.connect(this.analyser);
      this.drawVisualization();
    } catch (error) {
      console.error("Failed to start visualization:", error);
    }
  }
  drawVisualization() {
    if (!this.analyser || !this.visualizerCtx || !this.visualizerCanvas) {
      return;
    }
    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    this.analyser.getByteFrequencyData(dataArray);
    this.visualizerCtx.fillStyle = getComputedStyle(document.body).getPropertyValue("--background-secondary");
    this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
    const barWidth = this.visualizerCanvas.width / bufferLength * 2.5;
    const barSpacing = 1;
    let x = 0;
    const accentColor = getComputedStyle(document.body).getPropertyValue("--text-accent");
    const mutedAccent = getComputedStyle(document.body).getPropertyValue("--text-muted");
    for (let i = 0; i < bufferLength; i++) {
      const barHeight = dataArray[i] / 255 * this.visualizerCanvas.height * 0.8;
      const gradient = this.visualizerCtx.createLinearGradient(0, this.visualizerCanvas.height - barHeight, 0, this.visualizerCanvas.height);
      gradient.addColorStop(0, accentColor);
      gradient.addColorStop(1, mutedAccent);
      this.visualizerCtx.fillStyle = gradient;
      this.visualizerCtx.fillRect(x, this.visualizerCanvas.height - barHeight, barWidth - barSpacing, barHeight);
      x += barWidth;
      if (x > this.visualizerCanvas.width)
        break;
    }
    this.animationId = requestAnimationFrame(() => this.drawVisualization());
  }
  stopVisualization() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    if (this.audioContext) {
      this.audioContext.close().catch(console.error);
      this.audioContext = null;
    }
    this.analyser = null;
  }
};

// src/views/chatview/ChatView.ts
var import_obsidian80 = __toModule(require("obsidian"));
init_SystemSculptService();

// src/views/chatview/ChatStorageService.ts
var import_obsidian52 = __toModule(require("obsidian"));

// src/views/chatview/storage/ChatMarkdownSerializer.ts
var obsidianApi = __toModule(require("obsidian"));

// src/views/chatview/utils/MessagePartList.ts
var MessagePartList = class {
  constructor(parts) {
    this.parts = Array.isArray(parts) ? parts : [];
  }
  _ofType(type) {
    return this.parts.filter((p) => p.type === type);
  }
  get contentParts() {
    return this._ofType("content").map((p) => p.data);
  }
  get reasoningParts() {
    return this._ofType("reasoning").map((p) => p.data);
  }
  get toolCalls() {
    return this._ofType("tool_call").map((p) => p.data);
  }
  contentMarkdown(delimiter = "\n\n") {
    return this.contentParts.join(delimiter);
  }
  reasoningMarkdown(delimiter = "\n---\n") {
    return this.reasoningParts.join(delimiter);
  }
  get hasReasoning() {
    return this.reasoningParts.length > 0;
  }
  get hasToolCalls() {
    return this.toolCalls.length > 0;
  }
};

// src/views/chatview/storage/ChatMarkdownSerializer.ts
var { parseYaml } = obsidianApi;
var ChatMarkdownSerializer = class {
  static serializeMessages(messages) {
    return messages.filter((msg) => msg.role !== "tool").map((msg) => this.messageToMarkdown(msg)).join("\n\n");
  }
  static parseMarkdown(content) {
    const metadata = this.parseMetadata(content);
    if (!metadata)
      return null;
    const sequential = this.parseSequentialFormat(content);
    if (sequential.success)
      return { metadata, messages: sequential.messages };
    const aggregated = this.parseAggregatedFormat(content);
    if (aggregated.success)
      return { metadata, messages: aggregated.messages };
    return null;
  }
  static parseSequentialFormat(content) {
    var _a, _b, _c, _d;
    const messages = [];
    const messageRegex = /<!-- SYSTEMSCULPT-MESSAGE-START (.*?) -->([\s\S]*?)<!-- SYSTEMSCULPT-MESSAGE-END -->/g;
    let match;
    while ((match = messageRegex.exec(content)) !== null) {
      const attrs = match[1];
      const body = match[2].trim();
      const roleMatch = attrs.match(/role="(.*?)"/);
      const idMatch = attrs.match(/message-id="(.*?)"/);
      if (!roleMatch || !idMatch)
        continue;
      const role = roleMatch[1];
      const message_id = idMatch[1];
      const parts = [];
      let ts = Date.now();
      const partRegex = /(<!-- REASONING\n[\s\S]*?\n-->)|(<!-- TOOL-CALLS\n[\s\S]*?\n-->)|([\s\S]+?(?=(<!-- REASONING|<!-- TOOL-CALLS|$)))/g;
      let partMatch;
      while ((partMatch = partRegex.exec(body)) !== null) {
        if (partMatch[1]) {
          const reasoningText = (_b = (_a = partMatch[1].match(/<!-- REASONING\n([\s\S]*?)\n-->/)) == null ? void 0 : _a[1]) == null ? void 0 : _b.trim();
          if (reasoningText) {
            parts.push({ id: `reasoning-${ts}`, type: "reasoning", data: reasoningText, timestamp: ts++ });
          }
        } else if (partMatch[2]) {
          const toolCallJson = (_d = (_c = partMatch[2].match(/<!-- TOOL-CALLS\n([\s\S]*?)\n-->/)) == null ? void 0 : _c[1]) == null ? void 0 : _d.trim();
          if (toolCallJson) {
            try {
              const toolCallsArray = JSON.parse(toolCallJson);
              if (Array.isArray(toolCallsArray) && toolCallsArray.length > 0) {
                parts.push({ id: `tool_call-${ts}`, type: "tool_call", data: toolCallsArray[0], timestamp: ts++ });
              }
            } catch (e) {
            }
          }
        } else if (partMatch[3]) {
          const contentText = partMatch[3].trim();
          if (contentText) {
            parts.push({ id: `content-${ts}`, type: "content", data: contentText, timestamp: ts++ });
          }
        }
      }
      if (parts.length > 0) {
        messages.push(this.reconstructMessageFromParts(role, message_id, parts));
      }
    }
    return { success: true, messages };
  }
  static parseAggregatedFormat(content) {
    const messages = [];
    const messageRegex = /<!-- SYSTEMSCULPT-MESSAGE-START (.*?) -->([\s\S]*?)<!-- SYSTEMSCULPT-MESSAGE-END -->/g;
    let match;
    while ((match = messageRegex.exec(content)) !== null) {
      const attrs = match[1];
      const body = match[2].trim();
      const roleMatch = attrs.match(/role="(.*?)"/);
      const idMatch = attrs.match(/message-id="(.*?)"/);
      if (!roleMatch || !idMatch)
        continue;
      const role = roleMatch[1];
      const message_id = idMatch[1];
      const parts = [];
      let ts = Date.now();
      const reasoningMatch = body.match(/<!-- REASONING\n([\s\S]*?)-->/);
      const toolCallsMatch = body.match(/<!-- TOOL-CALLS\n([\s\S]*?)-->/);
      const contentOnly = body.replace(/<!-- REASONING\n[\s\S]*?-->/, "").replace(/<!-- TOOL-CALLS\n[\s\S]*?-->/, "").trim();
      if (contentOnly) {
        parts.push({ id: `content-${ts}`, type: "content", data: contentOnly, timestamp: ts++ });
      }
      if (reasoningMatch == null ? void 0 : reasoningMatch[1]) {
        parts.push({ id: `reasoning-${ts}`, type: "reasoning", data: reasoningMatch[1].trim(), timestamp: ts++ });
      }
      if (toolCallsMatch == null ? void 0 : toolCallsMatch[1]) {
        try {
          const toolCalls = JSON.parse(toolCallsMatch[1].trim());
          if (Array.isArray(toolCalls)) {
            toolCalls.forEach((tc) => {
              parts.push({ id: `tool_call-${ts}`, type: "tool_call", data: tc, timestamp: ts++ });
            });
          }
        } catch (e) {
        }
      }
      if (parts.length > 0) {
        messages.push(this.reconstructMessageFromParts(role, message_id, parts));
      }
    }
    return { success: true, messages };
  }
  static reconstructMessageFromParts(role, message_id, messageParts) {
    const list = new MessagePartList(messageParts);
    return {
      role,
      message_id,
      content: list.contentMarkdown(),
      reasoning: list.reasoningMarkdown(),
      tool_calls: list.toolCalls,
      messageParts
    };
  }
  static parseMetadata(content) {
    var _a;
    const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontMatterMatch)
      return null;
    const yamlContent = frontMatterMatch[1];
    if (!this.isValidYamlFrontmatter(yamlContent))
      return null;
    const parsed = parseYaml(yamlContent);
    if (!parsed || typeof parsed !== "object")
      return null;
    const {
      id = "",
      model = "",
      created = new Date().toISOString(),
      lastModified = new Date().toISOString(),
      title = "Untitled Chat",
      context_files = [],
      version: versionRaw = 0
    } = parsed;
    if (!id)
      return null;
    const processedContextFiles = Array.isArray(context_files) ? context_files.map((file) => {
      if (typeof file === "string") {
        const isExtraction = file.includes("/Extractions/");
        return { path: file, type: isExtraction ? "extraction" : "source" };
      } else if (file && typeof file === "object" && file.path) {
        return {
          path: file.path,
          type: file.type || "source"
        };
      } else {
        return { path: "", type: "source" };
      }
    }) : [];
    let systemMessageType = "general-use";
    let systemMessagePath = void 0;
    if (parsed.systemMessage && typeof parsed.systemMessage === "object") {
      const type = (_a = parsed.systemMessage.type) == null ? void 0 : _a.toLowerCase();
      if (type === "general-use" || type === "concise" || type === "agent" || type === "custom") {
        systemMessageType = type;
        if (type === "custom" && parsed.systemMessage.path) {
          systemMessagePath = parsed.systemMessage.path.replace(/^\[\[(.*?)\]\]$/, "$1");
        }
      }
    } else if (parsed.customPromptFilePath) {
      systemMessageType = "custom";
      systemMessagePath = parsed.customPromptFilePath.replace(/^\[\[(.*?)\]\]$/, "$1");
    }
    return {
      id,
      model,
      created,
      lastModified,
      title,
      version: Number(versionRaw) || 0,
      context_files: processedContextFiles,
      systemMessage: {
        type: systemMessageType,
        path: systemMessagePath
      },
      agentMode: parsed.agentMode !== void 0 ? Boolean(parsed.agentMode) : void 0,
      includeVaultStructure: parsed.includeVaultStructure !== void 0 ? Boolean(parsed.includeVaultStructure) : void 0,
      chatFontSize: parsed.chatFontSize
    };
  }
  static isValidYamlFrontmatter(content) {
    return /\bid\s*:/i.test(content) || /\bmodel\s*:/i.test(content);
  }
  static messageToMarkdown(msg) {
    let messageBody = "";
    if (msg.messageParts && msg.messageParts.length > 0) {
      msg.messageParts.forEach((part) => {
        switch (part.type) {
          case "content":
            messageBody += part.data;
            break;
          case "reasoning":
            if (typeof part.data === "string") {
              messageBody += `
<!-- REASONING
${part.data.trimEnd()}
-->
`;
            }
            break;
          case "tool_call":
            const toolCallArray = [part.data];
            messageBody += `
<!-- TOOL-CALLS
${JSON.stringify(toolCallArray, null, 2)}
-->
`;
            break;
        }
      });
    } else {
      let contentString = "";
      if (typeof msg.content === "string") {
        contentString = msg.content;
      } else if (Array.isArray(msg.content)) {
        contentString = msg.content.map((part) => {
          if (part.type === "text")
            return part.text;
          if (part.type === "image_url")
            return `![Image Context](${part.image_url.url})`;
          return "";
        }).join("\n");
      }
      messageBody = contentString;
      if (msg.tool_calls && msg.tool_calls.length > 0) {
        messageBody += `
<!-- TOOL-CALLS
${JSON.stringify(msg.tool_calls, null, 2)}
-->`;
      }
      if (msg.reasoning) {
        messageBody += `
<!-- REASONING
${msg.reasoning.trimEnd()}
-->`;
      }
    }
    const hasToolCalls = msg.tool_calls && msg.tool_calls.length > 0 || msg.messageParts && msg.messageParts.some((p) => p.type === "tool_call");
    const hasReasoning = !!msg.reasoning || msg.messageParts && msg.messageParts.some((p) => p.type === "reasoning");
    const isStreaming = !!msg.streaming;
    let attributes = `role="${msg.role}" message-id="${msg.message_id}"`;
    if (hasToolCalls)
      attributes += ' has-tool-calls="true"';
    if (hasReasoning)
      attributes += ' has-reasoning="true"';
    if (isStreaming)
      attributes += ' streaming="true"';
    const messageStart = `<!-- SYSTEMSCULPT-MESSAGE-START ${attributes} -->`;
    return `${messageStart}
${messageBody.trim()}
<!-- SYSTEMSCULPT-MESSAGE-END -->`;
  }
};

// src/views/chatview/ChatStorageService.ts
function processMessageToolCalls(message, toolCallManager) {
  if (message.role === "tool" && message.content && toolCallManager) {
    try {
      const toolCall = toolCallManager.getToolCall(message.tool_call_id || "");
      if (toolCall) {
        let parsedContent;
        try {
          parsedContent = JSON.parse(message.content);
        } catch (parseError) {
          console.warn(`[ChatStorage] Failed to parse tool result JSON for tool call ${message.tool_call_id}:`, parseError);
          return message;
        }
        const processedContent = toolCallManager.processToolResult(parsedContent, toolCall.request.function.name);
        try {
          const serialized = JSON.stringify(processedContent, null, 2);
          if (serialized.length > 5e4) {
            console.warn(`[ChatStorage] Tool result too large (${serialized.length} chars), truncating`);
            return {
              ...message,
              content: JSON.stringify({
                ...processedContent,
                truncation_info: `Content truncated - original size: ${serialized.length} characters`
              }, null, 2)
            };
          }
          return { ...message, content: serialized };
        } catch (stringifyError) {
          console.error(`[ChatStorage] Failed to serialize processed tool result:`, stringifyError);
          return message;
        }
      }
    } catch (error) {
      console.error(`[ChatStorage] Error processing tool call result for ${message.tool_call_id}:`, error);
      return message;
    }
  }
  return message;
}
var ChatStorageService = class {
  constructor(app, chatDirectory, toolCallManager) {
    this.app = app;
    this.chatDirectory = chatDirectory;
    this.toolCallManager = toolCallManager;
  }
  async saveChat(chatId, messages, selectedModelId, contextFiles, customPromptFilePath, systemPromptType, systemPromptPath, title, agentMode, includeVaultStructure, chatFontSize) {
    try {
      const { version } = await this.saveChatSimple(chatId, messages, selectedModelId, contextFiles, customPromptFilePath, systemPromptType, systemPromptPath, title, agentMode, includeVaultStructure, chatFontSize);
      return { version };
    } catch (error) {
      console.error("Error saving chat:", error);
      throw new Error(`Failed to save chat to ${chatId}.md`);
    }
  }
  async saveChatSimple(chatId, messages, selectedModelId, contextFiles, customPromptFilePath, systemPromptType, systemPromptPath, title, agentMode, includeVaultStructure, chatFontSize) {
    let filePath = `[unknown-path]/${chatId}.md`;
    try {
      filePath = `${this.chatDirectory}/${chatId}.md`;
      const now = new Date().toISOString();
      const vault = this.app.vault;
      let fileExists = false;
      let existingMetadata = null;
      const file = vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian52.TFile) {
        fileExists = true;
        const content = await vault.read(file);
        existingMetadata = this.parseMetadata(content);
      }
      const creationDate = (existingMetadata == null ? void 0 : existingMetadata.created) || now;
      const currentVersion = Number(existingMetadata == null ? void 0 : existingMetadata.version) || 0;
      let newVersion = currentVersion + 1;
      if (messages.length === 0 && fileExists && existingMetadata && file instanceof import_obsidian52.TFile) {
        const existingContent = await vault.read(file);
        if (existingContent.includes("SYSTEMSCULPT-MESSAGE-START")) {
          console.error("[CRITICAL] Attempted to save empty messages over existing chat with content. Aborting save.");
          throw new Error("Cannot save empty messages over existing chat content");
        }
      }
      const metadata = {
        id: chatId,
        model: selectedModelId,
        created: creationDate,
        lastModified: now,
        title: title || (existingMetadata == null ? void 0 : existingMetadata.title) || "Untitled Chat",
        version: newVersion,
        systemMessage: {
          type: systemPromptType || "general-use",
          path: systemPromptType === "custom" && systemPromptPath ? systemPromptPath : void 0
        },
        agentMode,
        includeVaultStructure,
        chatFontSize: chatFontSize || "medium"
      };
      if (contextFiles && contextFiles.size > 0) {
        metadata.context_files = Array.from(contextFiles).map((path) => ({
          path,
          type: path.includes("/Extractions/") ? "extraction" : "source"
        }));
      }
      const processedMessages = messages.map((msg) => processMessageToolCalls(msg, this.toolCallManager));
      const messagesContent = ChatMarkdownSerializer.serializeMessages(processedMessages);
      const fullContent = `---
${(0, import_obsidian52.stringifyYaml)(metadata)}---

${messagesContent}`;
      const SystemSculptPlugin2 = this.app.plugins.plugins["systemsculpt-ai"];
      if (SystemSculptPlugin2 && SystemSculptPlugin2.directoryManager) {
        await SystemSculptPlugin2.directoryManager.ensureDirectoryByPath(this.chatDirectory);
      } else {
        const exists = await this.app.vault.adapter.exists(this.chatDirectory);
        if (!exists) {
          await this.app.vault.createFolder(this.chatDirectory);
        }
      }
      if (fileExists && file instanceof import_obsidian52.TFile) {
        await vault.modify(file, fullContent);
      } else {
        await vault.create(filePath, fullContent);
      }
      return { filePath, version: newVersion };
    } catch (error) {
      console.error(`Failed to save simple chat to ${filePath}:`, error);
      throw error;
    }
  }
  async loadChats() {
    try {
      const files = await this.app.vault.adapter.list(this.chatDirectory);
      const chatFiles = files.files.filter((f) => f.endsWith(".md"));
      const chats = await Promise.allSettled(chatFiles.map(async (filePath) => {
        var _a;
        try {
          let fileModifiedTime = null;
          const abstractFile = this.app.vault.getAbstractFileByPath(filePath);
          if (abstractFile instanceof import_obsidian52.TFile) {
            fileModifiedTime = abstractFile.stat.mtime;
          }
          const content = await this.app.vault.adapter.read(filePath);
          if (!this.isValidChatFile(content)) {
            return null;
          }
          const filename = ((_a = filePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "";
          const parsed = this.parseMarkdownContent(content, filename);
          if (!parsed)
            return null;
          if (fileModifiedTime && !isNaN(fileModifiedTime)) {
            parsed.lastModified = fileModifiedTime;
          }
          return parsed;
        } catch (error) {
          console.warn(`Failed to load chat file ${filePath}:`, error);
          return null;
        }
      }));
      const successfulChats = chats.filter((result) => result.status === "fulfilled").map((result) => result.value).filter((chat) => chat !== null);
      const failedCount = chats.length - successfulChats.length;
      if (failedCount > 0) {
        console.warn(`Failed to load ${failedCount} chat file(s) due to parsing errors`);
      }
      return successfulChats;
    } catch (error) {
      console.error("Failed to load chats:", error);
      return [];
    }
  }
  async saveStreamingMessage() {
    console.warn("[SystemSculpt] saveStreamingMessage() is deprecated \u2013 use saveChat() instead.");
    return;
  }
  async loadChat(chatId) {
    try {
      const filePath = `${this.chatDirectory}/${chatId}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian52.TFile)) {
        console.warn(`Chat file not found: ${filePath}`);
        return null;
      }
      const content = await this.app.vault.read(file);
      return this.parseMarkdownContent(content, chatId);
    } catch (error) {
      console.error(`Failed to load chat ${chatId}:`, error);
      return null;
    }
  }
  generateMarkdownContent(metadata, messages) {
    const yamlMetadata = {
      systemsculpt_chat: true,
      ...metadata
    };
    const metadataSection = [
      "---",
      (0, import_obsidian52.stringifyYaml)(yamlMetadata).trim(),
      "---",
      ""
    ].join("\n");
    const messagesSection = messages.map((msg) => [
      `<!-- SYSTEMSCULPT-MESSAGE-START role="${msg.role}" message-id="${msg.message_id}" -->`,
      msg.content,
      "<!-- SYSTEMSCULPT-MESSAGE-END -->",
      ""
    ].join("\n")).join("\n");
    return metadataSection + messagesSection;
  }
  parseMetadata(content) {
    var _a;
    try {
      const metadataMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!metadataMatch)
        return null;
      const yamlContent = metadataMatch[1];
      if (!this.isValidYamlFrontmatter(yamlContent)) {
        console.warn("Content does not appear to be valid YAML frontmatter, skipping parse");
        return null;
      }
      const parsed = (0, import_obsidian52.parseYaml)(yamlContent);
      if (!parsed || typeof parsed !== "object") {
        return null;
      }
      const {
        id = "",
        model = "",
        created = new Date().toISOString(),
        lastModified = new Date().toISOString(),
        title = "Untitled Chat",
        context_files = [],
        version: versionRaw = 0
      } = parsed;
      if (!id) {
        return null;
      }
      const processedContextFiles = Array.isArray(context_files) ? context_files.map((file) => {
        if (typeof file === "string") {
          const isExtraction = file.includes("/Extractions/");
          return { path: file, type: isExtraction ? "extraction" : "source" };
        } else if (file && typeof file === "object" && file.path) {
          return {
            path: file.path,
            type: file.type || "source"
          };
        } else {
          return { path: "", type: "source" };
        }
      }).filter((file) => file.path !== "") : [];
      let systemMessageType = "general-use";
      let systemMessagePath = void 0;
      if (parsed.systemMessage && typeof parsed.systemMessage === "object") {
        const type = (_a = parsed.systemMessage.type) == null ? void 0 : _a.toLowerCase();
        if (type === "general-use" || type === "concise" || type === "agent" || type === "custom") {
          systemMessageType = type;
          if (type === "custom" && parsed.systemMessage.path) {
            systemMessagePath = parsed.systemMessage.path.replace(/^\[\[(.*?)\]\]$/, "$1");
          }
        }
      } else if (parsed.customPromptFilePath) {
        systemMessageType = "custom";
        systemMessagePath = parsed.customPromptFilePath.replace(/^\[\[(.*?)\]\]$/, "$1");
      }
      return {
        id,
        model,
        created,
        lastModified,
        title: title || id,
        version: Number(versionRaw) || 0,
        context_files: processedContextFiles,
        systemMessage: {
          type: systemMessageType,
          path: systemMessagePath
        },
        agentMode: parsed.agentMode !== void 0 ? Boolean(parsed.agentMode) : void 0,
        includeVaultStructure: parsed.includeVaultStructure !== void 0 ? Boolean(parsed.includeVaultStructure) : void 0,
        chatFontSize: parsed.chatFontSize
      };
    } catch (error) {
      if (error instanceof Error && error.message.includes("YAML")) {
        console.warn("YAML parsing failed - file may not contain valid frontmatter:", error.message);
      } else {
        console.error("Failed to parse metadata:", error);
      }
      return null;
    }
  }
  parseMarkdownContent(content, filename) {
    if (this.isFiveBacktickLegacyFile(content)) {
      return this.parseFiveBacktickLegacyFile(content, filename);
    }
    const parsed = ChatMarkdownSerializer.parseMarkdown(content);
    if (parsed) {
      const { metadata, messages } = parsed;
      return this.finalizeParsedData(metadata, messages);
    }
    console.warn(`[ChatStorage] Failed to parse chat file '${filename}' \u2013 unknown or corrupted format.`);
    return null;
  }
  finalizeParsedData(metadata, messages) {
    var _a, _b, _c;
    return {
      id: metadata.id,
      messages,
      selectedModelId: metadata.model,
      lastModified: new Date(metadata.lastModified).getTime(),
      title: metadata.title,
      version: metadata.version || 0,
      context_files: ((_a = metadata.context_files) == null ? void 0 : _a.map((f) => f.path)) || [],
      systemPromptType: ((_b = metadata.systemMessage) == null ? void 0 : _b.type) || "general-use",
      systemPromptPath: (_c = metadata.systemMessage) == null ? void 0 : _c.path,
      agentMode: metadata.agentMode,
      includeVaultStructure: metadata.includeVaultStructure,
      chatFontSize: metadata.chatFontSize
    };
  }
  validateAndFixToolCallIds(toolCalls, idMapping) {
    const generateUUID = () => {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    return toolCalls.map((toolCall) => {
      if (!toolCall.id) {
        const newId = `call_${generateUUID().replace(/-/g, "").substring(0, 24)}`;
        return { ...toolCall, id: newId };
      }
      if (toolCall.id.startsWith("tool_") && toolCall.id.includes("_mcp-")) {
        const newId = `call_${generateUUID().replace(/-/g, "").substring(0, 24)}`;
        if (idMapping) {
          idMapping.set(toolCall.id, newId);
        }
        return { ...toolCall, id: newId };
      }
      return toolCall;
    });
  }
  isValidChatFile(content) {
    const hasFrontmatter = /^---\n[\s\S]*?\n---/.test(content);
    const hasMessageMarkers = content.includes("SYSTEMSCULPT-MESSAGE-START") && content.includes("SYSTEMSCULPT-MESSAGE-END");
    const hasLegacyFormat = this.isFiveBacktickLegacyFile(content);
    return hasFrontmatter || hasMessageMarkers || hasLegacyFormat;
  }
  isFiveBacktickLegacyFile(content) {
    const hasContextFilesHeader = content.includes("# Context Files");
    const hasChatHistoryHeader = content.includes("# AI Chat History");
    const hasUserBlocks = /`{4,5}user/.test(content);
    const hasAiBlocks = /`{4,5}ai/.test(content);
    return (hasContextFilesHeader || hasChatHistoryHeader) && (hasUserBlocks || hasAiBlocks);
  }
  isValidYamlFrontmatter(content) {
    const markdownPatterns = [
      /^\s*#\s+/,
      /\|\s*\w+\s*\|.*\|/,
      /^\s*\d+\.\s+\*\*/,
      /^\s*[-*+]\s+/,
      /```/,
      /\[.*\]\(.*\)/,
      /!\[.*\]\(.*\)/
    ];
    for (const pattern of markdownPatterns) {
      if (pattern.test(content)) {
        return false;
      }
    }
    const yamlIndicators = [
      /^\s*\w+\s*:/,
      /^\s*-\s*\w+\s*:/,
      /^\s*\w+\s*:\s*\[/,
      /^\s*\w+\s*:\s*['"]/
    ];
    const hasYamlStructure = yamlIndicators.some((pattern) => pattern.test(content));
    const hasExpectedFields = /\bid\s*:/.test(content) || /\bmodel\s*:/.test(content) || /\btitle\s*:/.test(content);
    return hasYamlStructure || hasExpectedFields;
  }
  formatToolArguments(args) {
    try {
      const parsed = JSON.parse(args);
      return JSON.stringify(parsed, null, 2);
    } catch (e) {
      return args;
    }
  }
  reconstructMessagePartsFromContent(content, reasoning, toolCalls) {
    const parts = [];
    let timestamp = Date.now();
    let toolCallIndex = 0;
    const blockPattern = /<!-- REASONING-BLOCK -->\n([\s\S]*?)\n<!-- \/REASONING-BLOCK -->|<!-- TOOL-CALL-DATA\n([\s\S]*?)\n-->|<!-- CONTENT-PART -->\n([\s\S]*?)\n<!-- \/CONTENT-PART -->/g;
    let match;
    while ((match = blockPattern.exec(content)) !== null) {
      if (match[1]) {
        const reasoningTimestamp = timestamp++;
        parts.push({
          id: `reasoning-${reasoningTimestamp}`,
          type: "reasoning",
          timestamp: reasoningTimestamp,
          data: match[1].trimEnd()
        });
      } else if (match[2]) {
        try {
          const toolCallData = JSON.parse(match[2]);
          const toolCallTimestamp = timestamp++;
          parts.push({
            id: `tool_call-${toolCallTimestamp}`,
            type: "tool_call",
            timestamp: toolCallTimestamp,
            data: toolCallData
          });
        } catch (error) {
          console.error("Failed to parse tool call data:", error);
        }
      } else if (match[3]) {
        const contentTimestamp = timestamp++;
        parts.push({
          id: `content-${contentTimestamp}`,
          type: "content",
          timestamp: contentTimestamp,
          data: match[3].trim()
        });
      }
    }
    const foundToolCallIds = new Set(parts.filter((p) => p.type === "tool_call").map((p) => p.data.id));
    if (toolCalls && toolCalls.length > 0) {
      toolCalls.forEach((toolCall) => {
        if (!foundToolCallIds.has(toolCall.id)) {
          console.log("[ChatStorage] Adding tool call from extracted array:", toolCall.id, toolCall.function.name);
          const toolCallTimestamp = timestamp++;
          parts.push({
            id: `tool_call-${toolCallTimestamp}`,
            type: "tool_call",
            timestamp: toolCallTimestamp,
            data: toolCall
          });
        }
      });
    }
    if (parts.length === 0) {
      if (reasoning) {
        const reasoningTimestamp = timestamp++;
        parts.push({
          id: `reasoning-${reasoningTimestamp}`,
          type: "reasoning",
          timestamp: reasoningTimestamp,
          data: reasoning
        });
      }
      const cleanContent = this.extractNonChronologicalContent(content);
      if (cleanContent.trim()) {
        const contentTimestamp = timestamp++;
        parts.push({
          id: `content-${contentTimestamp}`,
          type: "content",
          timestamp: contentTimestamp,
          data: cleanContent
        });
      }
    }
    if (parts.length > 0) {
      const cleanContent = this.extractNonChronologicalContent(content);
      if (cleanContent.trim()) {
        const hasContentPart = parts.some((p) => p.type === "content");
        if (!hasContentPart) {
          const contentTimestamp = timestamp++;
          parts.push({
            id: `content-${contentTimestamp}`,
            type: "content",
            timestamp: contentTimestamp,
            data: cleanContent
          });
        }
      }
    }
    return parts;
  }
  extractNonChronologicalContent(content) {
    let cleaned = content.replace(/<!-- REASONING-BLOCK -->\n[\s\S]*?\n<!-- \/REASONING-BLOCK -->/g, "").replace(/<!-- TOOL-CALL-DATA\n[\s\S]*?\n-->/g, "").replace(/<!-- CONTENT-PART -->\n[\s\S]*?\n<!-- \/CONTENT-PART -->/g, "");
    cleaned = cleaned.replace(/\n\n\n+/g, "\n\n").trim();
    return cleaned;
  }
  containsChronologicalBlocks(content) {
    return content.includes("<!-- REASONING-BLOCK -->") || content.includes("<!-- TOOL-CALL-DATA") || content.includes("<!-- CONTENT-PART -->");
  }
  parseFiveBacktickLegacyFile(content, filename) {
    try {
      const messages = [];
      const timestamp = Date.now();
      const chatId = filename || this.generateMessageId();
      const contextFiles = [];
      const contextSection = content.match(/# Context Files\n([\s\S]*?)(?=# AI Chat History|$)/);
      if (contextSection && contextSection[1]) {
        const links = contextSection[1].match(/\[\[(.*?)\]\]/g);
        if (links) {
          contextFiles.push(...links.map((link) => link.replace(/\[\[(.*?)\]\]/, "$1")));
        }
      }
      const messageRegex = /`{4,5}(user|ai(?:-[\w-]+)?)\n([\s\S]*?)\n`{4,5}/g;
      let match;
      while ((match = messageRegex.exec(content)) !== null) {
        const rolePrefix = match[1];
        const messageContent = match[2].trim();
        let role;
        if (rolePrefix === "user") {
          role = "user";
        } else if (rolePrefix.startsWith("ai")) {
          role = "assistant";
        } else {
          console.warn(`[SystemSculpt] Unknown role prefix: ${rolePrefix}, skipping`);
          continue;
        }
        const messageId = this.generateMessageId();
        messages.push({
          role,
          content: messageContent,
          message_id: messageId
        });
      }
      let title = "Legacy Chat";
      const firstUserMessage = messages.find((m) => m.role === "user");
      if (firstUserMessage && typeof firstUserMessage.content === "string") {
        title = firstUserMessage.content.substring(0, 50).replace(/\n/g, " ").trim();
        if (title.length >= 50)
          title += "...";
      }
      const result = {
        id: chatId,
        messages,
        selectedModelId: "gpt-4o",
        lastModified: timestamp,
        title,
        version: 0,
        context_files: contextFiles.length > 0 ? contextFiles : void 0,
        systemPromptType: "general-use"
      };
      return result;
    } catch (error) {
      console.error("Failed to parse legacy chat file:", error);
      return null;
    }
  }
  tryFallbackParsing(content) {
    try {
      const timestamp = Date.now();
      const fallbackId = this.generateMessageId();
      const messages = [];
      const messageRegex = /(?:^|\n)\s*<!--\s*SYSTEMSCULPT-MESSAGE-START\s*role=[\'\"]?(user|assistant)[\'\"]?\s*message-id=[\'\"]?([^\'\"\\s>]+)[\'\"]?\s*-->\s*([\s\S]*?)\s*<!--\s*SYSTEMSCULPT-MESSAGE-END\s*-->(?=\s*(?:\n|$))/gm;
      let msgMatch;
      while ((msgMatch = messageRegex.exec(content)) !== null) {
        const role = msgMatch[1];
        const messageId = msgMatch[2];
        const messageContent = msgMatch[3];
        messages.push({
          role,
          content: messageContent.trim(),
          message_id: messageId
        });
      }
      if (messages.length > 0) {
        return {
          id: fallbackId,
          messages,
          selectedModelId: "gpt-3.5-turbo",
          lastModified: timestamp,
          title: "Recovered Chat",
          version: 0,
          systemPromptType: "general-use"
        };
      }
      return null;
    } catch (error) {
      console.error("Fallback parsing also failed:", error);
      return null;
    }
  }
  async getMetadata(chatId) {
    try {
      const filePath = `${this.chatDirectory}/${chatId}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian52.TFile)) {
        return null;
      }
      const content = await this.app.vault.read(file);
      return this.parseMetadata(content);
    } catch (error) {
      console.error("Failed to get metadata:", error);
      return null;
    }
  }
  generateMessageId() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  standardizeToolCalls(toolCalls, messageId) {
    if (!toolCalls)
      return [];
    return toolCalls.map((tc) => {
      var _a;
      if ((_a = tc.request) == null ? void 0 : _a.function) {
        if (tc.result && tc.result.success === void 0) {
          tc.result = { success: true, data: tc.result };
        }
        return tc;
      }
      if (tc.function) {
        const result = tc.result;
        let standardizedResult = void 0;
        if (result) {
          if (result.success !== void 0) {
            standardizedResult = result;
          } else {
            standardizedResult = { success: true, data: result };
          }
        }
        return {
          id: tc.id,
          messageId,
          request: {
            id: tc.id,
            type: tc.type,
            function: tc.function
          },
          state: tc.state || "completed",
          timestamp: tc.timestamp || Date.now(),
          autoApproved: tc.autoApproved || false,
          result: standardizedResult
        };
      }
      return tc;
    });
  }
};

// src/views/chatview/ChatView.ts
init_ui();
init_errors();

// src/views/chatview/MessageRenderer.ts
var import_obsidian60 = __toModule(require("obsidian"));

// src/components/CollapsibleDrawer.ts
var import_obsidian53 = __toModule(require("obsidian"));
var CollapsibleDrawer = class extends import_obsidian53.Component {
  constructor(options) {
    super();
    this.isAnimating = false;
    this.animationTimeout = null;
    var _a;
    this.options = options;
    this.createStructure((_a = options.defaultCollapsed) != null ? _a : false);
    this.setupEventListeners();
  }
  createStructure(isInitiallyCollapsed) {
    this.containerEl = this.options.container.createEl("div", {
      cls: "systemsculpt-collapsible-drawer"
    });
    if (isInitiallyCollapsed) {
      this.containerEl.classList.add("systemsculpt-collapsed");
    }
    this.headerEl = this.containerEl.createEl("div", {
      cls: "systemsculpt-collapsible-header"
    });
    if (this.options.headerIcon) {
      this.iconEl = this.headerEl.createEl("div", {
        cls: "systemsculpt-collapsible-icon"
      });
      (0, import_obsidian53.setIcon)(this.iconEl, this.options.headerIcon);
    }
    if (this.options.additionalHeaderContent) {
      this.options.additionalHeaderContent(this.headerEl);
    }
    this.titleEl = this.headerEl.createEl("div", {
      cls: "systemsculpt-collapsible-title",
      text: this.options.headerText
    });
    this.contentEl = this.containerEl.createEl("div", {
      cls: "systemsculpt-collapsible-content"
    });
  }
  setupEventListeners() {
    this.clickHandler = () => {
      this.toggle();
    };
    this.headerEl.addEventListener("click", this.clickHandler);
    this.register(() => this.headerEl.removeEventListener("click", this.clickHandler));
  }
  toggle() {
    if (this.isAnimating) {
      return;
    }
    this.setAnimationState(true);
    this.containerEl.classList.toggle("systemsculpt-collapsed");
    const isCurrentlyCollapsed = this.containerEl.classList.contains("systemsculpt-collapsed");
    if (this.options.onToggle) {
      this.options.onToggle(isCurrentlyCollapsed);
    }
  }
  setCollapsed(collapsed) {
    if (this.isAnimating) {
      if (this.animationTimeout) {
        window.clearTimeout(this.animationTimeout);
      }
      this.animationTimeout = window.setTimeout(() => {
        this.setCollapsed(collapsed);
      }, 250);
      return;
    }
    const isCurrentlyCollapsed = this.containerEl.classList.contains("systemsculpt-collapsed");
    if (isCurrentlyCollapsed !== collapsed) {
      this.setAnimationState(true);
      this.containerEl.classList.toggle("systemsculpt-collapsed", collapsed);
      if (this.options.onToggle) {
        this.options.onToggle(collapsed);
      }
    }
  }
  getContentElement() {
    return this.contentEl;
  }
  getContainerElement() {
    return this.containerEl;
  }
  setHeaderText(text) {
    this.titleEl.textContent = text;
  }
  addContainerClass(className) {
    this.containerEl.classList.add(className);
  }
  removeContainerClass(className) {
    this.containerEl.classList.remove(className);
  }
  setAnimationState(isAnimating) {
    this.isAnimating = isAnimating;
    if (isAnimating) {
      if (this.animationTimeout) {
        window.clearTimeout(this.animationTimeout);
      }
      this.animationTimeout = window.setTimeout(() => {
        this.isAnimating = false;
        this.animationTimeout = null;
      }, 250);
    }
  }
  unload() {
    super.unload();
    if (this.animationTimeout) {
      window.clearTimeout(this.animationTimeout);
    }
    this.containerEl.remove();
  }
};

// src/views/chatview/MessageRenderer.ts
init_workspaceUtils();

// src/views/chatview/utils/MessagePartNormalizer.ts
var MessagePartNormalizer = class {
  static toParts(message) {
    const parts = [];
    let timestamp = 0;
    if (message.messageParts && message.messageParts.length > 0) {
      return [...message.messageParts].sort((a, b) => a.timestamp - b.timestamp);
    }
    if (message.reasoning) {
      parts.push({
        id: `reasoning-${timestamp}`,
        type: "reasoning",
        timestamp: timestamp++,
        data: message.reasoning
      });
    }
    if (message.tool_calls && message.tool_calls.length > 0) {
      message.tool_calls.forEach((tc) => {
        parts.push({
          id: `tool_call_part-${tc.id}`,
          type: "tool_call",
          timestamp: timestamp++,
          data: tc
        });
      });
    }
    if (typeof message.content === "string" && message.content.trim()) {
      parts.push({
        id: `content-${timestamp}`,
        type: "content",
        timestamp: timestamp++,
        data: message.content
      });
    }
    return parts;
  }
};

// src/views/chatview/renderers/MarkdownMessageRenderer.ts
var import_obsidian55 = __toModule(require("obsidian"));
var import_obsidian56 = __toModule(require("obsidian"));

// src/modals/MermaidPreviewModal.ts
var import_obsidian54 = __toModule(require("obsidian"));
var MermaidPreviewModal = class extends import_obsidian54.Modal {
  constructor(app, code) {
    super(app);
    this.code = code;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    modalEl.addClass("systemsculpt-mermaid-preview-modal");
    const header = contentEl.createDiv({ cls: "ss-mermaid-preview-header" });
    header.createEl("h2", { text: "Mermaid Diagram" });
    const closeBtn = header.createDiv({ cls: "ss-mermaid-preview-close" });
    (0, import_obsidian54.setIcon)(closeBtn, "x");
    closeBtn.addEventListener("click", () => this.close());
    const diagramContainer = contentEl.createDiv({ cls: "ss-mermaid-preview-diagram mermaid" });
    diagramContainer.textContent = this.code;
    const m = globalThis.mermaid;
    if (m && typeof m.init === "function") {
      try {
        m.init(void 0, diagramContainer);
      } catch (err) {
        console.warn("[SystemSculpt] Mermaid render error (expanded preview)", err);
      }
    }
    const footer = contentEl.createDiv({ cls: "ss-mermaid-preview-footer" });
    const copyBtn = footer.createEl("button", { cls: "ss-mermaid-copy-btn", text: "Copy Code" });
    copyBtn.addEventListener("click", () => {
      navigator.clipboard.writeText(this.code).then(() => {
        new import_obsidian54.Notice("Mermaid code copied to clipboard");
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/views/chatview/renderers/MarkdownMessageRenderer.ts
var MarkdownMessageRenderer = class extends import_obsidian55.Component {
  constructor(app) {
    super();
    this.throttledRenderers = new WeakMap();
    this.RENDER_THROTTLE_MS = 100;
    this.app = app;
  }
  async render(content, containerEl, isStreaming = false) {
    content = this.preprocessMermaid(content);
    if (isStreaming) {
      this.throttledRender(containerEl, content);
      return;
    }
    const state = this.throttledRenderers.get(containerEl);
    if (state == null ? void 0 : state.timeoutId) {
      clearTimeout(state.timeoutId);
      state.timeoutId = null;
    }
    containerEl.empty();
    await import_obsidian55.MarkdownRenderer.render(this.app, content, containerEl, "systemsculpt-chat.md", this);
    this.postProcess(containerEl);
  }
  renderCitations(contentEl, citations) {
    if (citations.length === 0)
      return;
    const citationsContainer = contentEl.createEl("div", {
      cls: "systemsculpt-citations-container"
    });
    citationsContainer.createEl("hr", { cls: "systemsculpt-citations-divider" });
    citationsContainer.createEl("div", {
      cls: "systemsculpt-citations-header",
      text: "Sources"
    });
    const citationsList = citationsContainer.createEl("ol", {
      cls: "systemsculpt-citations-list"
    });
    citations.forEach((citation, index) => {
      const li = citationsList.createEl("li", { cls: "systemsculpt-citation-item" });
      const displayTitle = citation.title || new URL(citation.url).hostname;
      li.createEl("a", {
        cls: "systemsculpt-citation-title",
        text: displayTitle,
        attr: {
          href: citation.url,
          target: "_blank",
          rel: "noopener noreferrer"
        }
      });
      li.createEl("div", {
        cls: "systemsculpt-citation-url",
        text: citation.url
      });
    });
  }
  throttledRender(containerEl, content) {
    let state = this.throttledRenderers.get(containerEl);
    if (!state) {
      state = { timeoutId: null, content: "" };
      this.throttledRenderers.set(containerEl, state);
    }
    state.content = content;
    if (state.timeoutId)
      return;
    state.timeoutId = setTimeout(async () => {
      const current = this.throttledRenderers.get(containerEl);
      if (!current)
        return;
      current.timeoutId = null;
      if (!containerEl.isConnected) {
        this.throttledRenderers.delete(containerEl);
        return;
      }
      containerEl.empty();
      await import_obsidian55.MarkdownRenderer.render(this.app, current.content, containerEl, "systemsculpt-chat.md", this);
      this.postProcess(containerEl);
      this.app.workspace.trigger("systemsculpt:content-rendered");
    }, this.RENDER_THROTTLE_MS);
  }
  postProcess(container) {
    container.querySelectorAll("pre").forEach((pre) => pre.classList.add("systemsculpt-code-block"));
    container.querySelectorAll("img").forEach((img) => {
      img.addClass("systemsculpt-message-image");
      img.style.cursor = "pointer";
      img.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const src = img.getAttribute("src");
        if (!src)
          return;
        if (src.startsWith("app://")) {
          const path = src.replace("app://local/", "");
          this.app.workspace.openLinkText(path, "", true);
        }
      });
    });
    container.querySelectorAll("a.internal-link").forEach((link) => {
      link.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const href = link.getAttribute("href") || link.getAttribute("data-href");
        if (href) {
          this.app.workspace.openLinkText(href, "", true);
        }
      });
    });
    this.postProcessMermaid(container);
  }
  postProcessMermaid(containerEl) {
    const mermaidDivs = containerEl.querySelectorAll(".mermaid");
    mermaidDivs.forEach((div) => {
      var _a;
      const raw = (_a = div.textContent) != null ? _a : "";
      let fixed = raw;
      fixed = fixed.replace(/\[([\s\S]*?)\]/g, (m2, p1) => `[${p1.replace(/\n+/g, " ")}]`);
      fixed = fixed.replace(/([\w-]+)\(\[([\s\S]*?)\]\)/g, '$1["$2"]');
      fixed = fixed.replace(/([\w-]+)\[([^\]]+?)\]/g, '$1["$2"]');
      if (fixed !== raw) {
        div.textContent = fixed;
      }
      const m = globalThis.mermaid;
      if (m && typeof m.init === "function") {
        try {
          m.init(void 0, div);
        } catch (err) {
          console.warn("[SystemSculpt] Mermaid render error suppressed:", err);
        }
      }
      if (!div.dataset.ssExpand) {
        div.dataset.ssExpand = "true";
        const btn = div.createDiv({ cls: "systemsculpt-mermaid-expand-btn" });
        (0, import_obsidian56.setIcon)(btn, "maximize-2");
        btn.setAttribute("aria-label", "Expand diagram");
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          new MermaidPreviewModal(this.app, fixed).open();
        });
      }
    });
  }
  preprocessMermaid(markdown) {
    let fixed = markdown;
    fixed = fixed.replace(/\[([\s\S]*?)\]/g, (m, p1) => `[${p1.replace(/\n+/g, " ")}]`);
    fixed = fixed.replace(/([\w-]+)\(\[([\s\S]*?)\]\)/g, '$1["$2"]');
    fixed = fixed.replace(/([\w-]+)\[([^\]]+?)\]/g, '$1["$2"]');
    fixed = fixed.replace(/\]\)([ \t]+)([\w-]+[\[\(])/g, "])\n  $2");
    return fixed;
  }
};

// src/views/chatview/renderers/ToolCallDrawerRenderer.ts
var import_obsidian58 = __toModule(require("obsidian"));
var import_obsidian59 = __toModule(require("obsidian"));

// src/components/DiffViewer.ts
var import_obsidian57 = __toModule(require("obsidian"));
var DiffViewer = class extends import_obsidian57.Component {
  constructor(options) {
    super();
    var _a, _b;
    this.container = options.container;
    this.diffResult = options.diffResult;
    this.fileName = options.fileName;
    this.maxContextLines = (_a = options.maxContextLines) != null ? _a : 2;
    this.showLineNumbers = (_b = options.showLineNumbers) != null ? _b : false;
  }
  render() {
    this.container.empty();
    this.container.classList.add("systemsculpt-diff-viewer");
    this.createHeader();
    this.createChangeHunks();
  }
  createHeader() {
    const header = this.container.createEl("div", {
      cls: "systemsculpt-diff-header"
    });
    const fileInfo = header.createEl("div", {
      cls: "systemsculpt-diff-file-info"
    });
    const fileName = fileInfo.createEl("span", {
      cls: "systemsculpt-diff-filename",
      text: this.fileName
    });
    const stats = fileInfo.createEl("span", {
      cls: "systemsculpt-diff-stats"
    });
    if (this.diffResult.stats.additions === 0 && this.diffResult.stats.deletions === 0) {
      stats.textContent = "No changes";
      stats.addClass("systemsculpt-diff-no-changes");
    } else {
      if (this.diffResult.stats.additions > 0) {
        const additionsSpan = stats.createEl("span", {
          cls: "systemsculpt-diff-additions",
          text: `+${this.diffResult.stats.additions}`
        });
      }
      if (this.diffResult.stats.deletions > 0) {
        if (this.diffResult.stats.additions > 0) {
          stats.createEl("span", { text: " " });
        }
        const deletionsSpan = stats.createEl("span", {
          cls: "systemsculpt-diff-deletions",
          text: `-${this.diffResult.stats.deletions}`
        });
      }
      if (this.diffResult.stats.additions > 0) {
        stats.addClass("systemsculpt-diff-has-additions");
      }
      if (this.diffResult.stats.deletions > 0) {
        stats.addClass("systemsculpt-diff-has-deletions");
      }
    }
  }
  createChangeHunks() {
    const content = this.container.createEl("div", {
      cls: "systemsculpt-diff-content"
    });
    const hunks = this.groupIntoHunks(this.diffResult.lines);
    if (hunks.length === 0) {
      const noChanges = content.createEl("div", {
        cls: "systemsculpt-diff-no-changes-notice",
        text: "No changes to display"
      });
      return;
    }
    hunks.forEach((hunk, index) => {
      this.createHunk(content, hunk, index);
    });
  }
  groupIntoHunks(lines) {
    const hunks = [];
    let currentHunk = [];
    let contextBuffer = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.type === "unchanged") {
        contextBuffer.push(line);
        if (contextBuffer.length > this.maxContextLines * 2) {
          if (currentHunk.length > 0) {
            currentHunk.push(...contextBuffer.slice(0, this.maxContextLines));
            hunks.push([...currentHunk]);
            currentHunk = [];
          }
          contextBuffer = contextBuffer.slice(-this.maxContextLines);
        }
      } else {
        if (currentHunk.length === 0) {
          currentHunk.push(...contextBuffer.slice(-this.maxContextLines));
        } else {
          currentHunk.push(...contextBuffer);
        }
        currentHunk.push(line);
        contextBuffer = [];
      }
    }
    if (currentHunk.length > 0) {
      currentHunk.push(...contextBuffer.slice(0, this.maxContextLines));
      hunks.push(currentHunk);
    }
    return hunks;
  }
  createHunk(container, hunk, index) {
    const hunkEl = container.createEl("div", {
      cls: "systemsculpt-diff-hunk"
    });
    if (index > 0) {
      hunkEl.addClass("systemsculpt-diff-hunk-separated");
    }
    const linesContainer = hunkEl.createEl("div", {
      cls: "systemsculpt-diff-lines"
    });
    hunk.forEach((line) => {
      this.createCompactLine(linesContainer, line);
    });
  }
  createCompactLine(container, line) {
    const lineEl = container.createEl("div", {
      cls: `systemsculpt-diff-line systemsculpt-diff-line-${line.type}`
    });
    if (this.showLineNumbers) {
      const lineNumbers = lineEl.createEl("span", {
        cls: "systemsculpt-diff-line-numbers"
      });
      if (line.oldLineNumber && line.newLineNumber) {
        lineNumbers.textContent = `${line.oldLineNumber}`;
      } else if (line.oldLineNumber) {
        lineNumbers.textContent = `${line.oldLineNumber}`;
      } else if (line.newLineNumber) {
        lineNumbers.textContent = `${line.newLineNumber}`;
      }
    }
    const prefix = lineEl.createEl("span", {
      cls: "systemsculpt-diff-prefix"
    });
    switch (line.type) {
      case "added":
        prefix.textContent = "+";
        break;
      case "removed":
        prefix.textContent = "-";
        break;
      case "unchanged":
        prefix.textContent = "";
        break;
    }
    const content = lineEl.createEl("span", {
      cls: "systemsculpt-diff-line-content",
      text: line.content || ""
    });
    if (!line.content && line.content !== "") {
      content.innerHTML = "&nbsp;";
    }
  }
  updateDiff(diffResult) {
    this.diffResult = diffResult;
    this.render();
  }
  destroy() {
    this.container.empty();
    this.unload();
  }
};

// src/utils/diffUtils.ts
function generateDiff(oldContent, newContent, contextLines = 10) {
  const oldLines = oldContent.split("\n");
  const newLines = newContent.split("\n");
  const result = [];
  const stats = { additions: 0, deletions: 0 };
  const matrix = createLCSMatrix(oldLines, newLines);
  const diffSequence = extractDiffSequence(matrix, oldLines, newLines);
  let oldLineNum = 1;
  let newLineNum = 1;
  const fullDiff = [];
  for (const operation of diffSequence) {
    if (operation.type === "unchanged") {
      fullDiff.push({
        type: "unchanged",
        content: operation.line,
        oldLineNumber: oldLineNum,
        newLineNumber: newLineNum
      });
      oldLineNum++;
      newLineNum++;
    } else if (operation.type === "removed") {
      fullDiff.push({
        type: "removed",
        content: operation.line,
        oldLineNumber: oldLineNum
      });
      oldLineNum++;
      stats.deletions++;
    } else if (operation.type === "added") {
      fullDiff.push({
        type: "added",
        content: operation.line,
        newLineNumber: newLineNum
      });
      newLineNum++;
      stats.additions++;
    }
  }
  const { trimmedLines, wasTruncated } = trimDiffToContext(fullDiff, contextLines);
  return { lines: trimmedLines, stats, isTruncated: wasTruncated };
}
function trimDiffToContext(diffLines, contextLines) {
  if (diffLines.length === 0)
    return { trimmedLines: diffLines, wasTruncated: false };
  let firstChangeIndex = -1;
  let lastChangeIndex = -1;
  for (let i = 0; i < diffLines.length; i++) {
    if (diffLines[i].type !== "unchanged") {
      if (firstChangeIndex === -1) {
        firstChangeIndex = i;
      }
      lastChangeIndex = i;
    }
  }
  if (firstChangeIndex === -1) {
    return { trimmedLines: diffLines, wasTruncated: false };
  }
  const startIndex = Math.max(0, firstChangeIndex - contextLines);
  const endIndex = Math.min(diffLines.length - 1, lastChangeIndex + contextLines);
  const wasTruncated = endIndex < diffLines.length - 1;
  return {
    trimmedLines: diffLines.slice(startIndex, endIndex + 1),
    wasTruncated
  };
}
function createLCSMatrix(oldLines, newLines) {
  const m = oldLines.length;
  const n = newLines.length;
  const matrix = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (oldLines[i - 1] === newLines[j - 1]) {
        matrix[i][j] = matrix[i - 1][j - 1] + 1;
      } else {
        matrix[i][j] = Math.max(matrix[i - 1][j], matrix[i][j - 1]);
      }
    }
  }
  return matrix;
}
function extractDiffSequence(matrix, oldLines, newLines) {
  const result = [];
  let i = oldLines.length;
  let j = newLines.length;
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && oldLines[i - 1] === newLines[j - 1]) {
      result.unshift({ type: "unchanged", line: oldLines[i - 1] });
      i--;
      j--;
    } else if (j > 0 && (i === 0 || matrix[i][j - 1] >= matrix[i - 1][j])) {
      result.unshift({ type: "added", line: newLines[j - 1] });
      j--;
    } else if (i > 0) {
      result.unshift({ type: "removed", line: oldLines[i - 1] });
      i--;
    }
  }
  return result;
}
function isFileOpen(app, filePath) {
  const markdownLeaves = app.workspace.getLeavesOfType("markdown");
  for (const leaf of markdownLeaves) {
    const view = leaf.view;
    if (view && view.file && view.file.path === filePath) {
      return true;
    }
  }
  return false;
}
async function getFileContent(app, filePath) {
  const markdownLeaves = app.workspace.getLeavesOfType("markdown");
  for (const leaf of markdownLeaves) {
    const view = leaf.view;
    if (view && view.file && view.file.path === filePath) {
      if (view.editor) {
        return view.editor.getValue();
      }
    }
  }
  try {
    const file = app.vault.getAbstractFileByPath(filePath);
    if (file && file.stat) {
      return await app.vault.read(file);
    }
  } catch (error) {
    console.error("Error reading file:", error);
  }
  return "";
}

// src/editors/inline-diff.ts
var import_state = __toModule(require("@codemirror/state"));
var import_view = __toModule(require("@codemirror/view"));

// src/editors/InlineEditorDiffManager.ts
var InlineEditorDiffManager = class {
  constructor() {
    this.activeDiffs = new Map();
  }
  static getInstance() {
    if (!InlineEditorDiffManager.instance) {
      InlineEditorDiffManager.instance = new InlineEditorDiffManager();
    }
    return InlineEditorDiffManager.instance;
  }
  addActiveDiff(filePath, diff) {
    if (this.hasDiff(filePath)) {
      this.removeActiveDiff(filePath);
    }
    this.activeDiffs.set(filePath, diff);
  }
  removeActiveDiff(filePath) {
    var _a;
    const activeDiff = this.activeDiffs.get(filePath);
    if (activeDiff) {
      (_a = activeDiff.notificationElement) == null ? void 0 : _a.remove();
      this.activeDiffs.delete(filePath);
    }
  }
  clearAllDiffs(app) {
    const filePaths = Array.from(this.activeDiffs.keys());
    for (const filePath of filePaths) {
      clearDiffFromView(app, filePath);
    }
  }
  hasDiff(filePath) {
    return this.activeDiffs.has(filePath);
  }
  getDiffStats(filePath) {
    var _a, _b;
    return (_b = (_a = this.activeDiffs.get(filePath)) == null ? void 0 : _a.diffResult.stats) != null ? _b : null;
  }
  findEditorViewForFile(app, filePath) {
    var _a, _b;
    const markdownView = this.findMarkdownViewForFile(app, filePath);
    return (_b = (_a = markdownView == null ? void 0 : markdownView.editor) == null ? void 0 : _a.cm) != null ? _b : null;
  }
  findMarkdownViewForFile(app, filePath) {
    var _a;
    const leaves = app.workspace.getLeavesOfType("markdown");
    for (const leaf of leaves) {
      const view = leaf.view;
      if (((_a = view.file) == null ? void 0 : _a.path) === filePath) {
        return view;
      }
    }
    return null;
  }
  createNotificationForView(view, filePath) {
    var _a;
    const activeDiff = this.activeDiffs.get(filePath);
    if (!activeDiff)
      return;
    (_a = activeDiff.notificationElement) == null ? void 0 : _a.remove();
    const stats = activeDiff.diffResult.stats;
    const banner = this.buildNotificationElement(stats, () => clearDiffFromView(view.app, filePath));
    const editorEl = view.dom;
    const parent = editorEl.parentElement;
    if (parent) {
      parent.insertBefore(banner, editorEl);
      activeDiff.notificationElement = banner;
    }
  }
  buildNotificationElement(stats, onClose) {
    const notification = document.createElement("div");
    notification.className = "cm-diff-notification";
    notification.setAttribute("role", "alert");
    const content = notification.createDiv("cm-diff-notification-content");
    content.createSpan({
      cls: "cm-diff-notification-icon",
      text: "\u26A0\uFE0F"
    });
    content.createSpan({
      cls: "cm-diff-notification-text",
      text: `Agent's Proposed Changes (+${stats.additions} / -${stats.deletions})`
    });
    const closeButton = content.createEl("button", {
      cls: "cm-diff-notification-close",
      text: "\u2715",
      attr: { "aria-label": "Dismiss changes" }
    });
    closeButton.addEventListener("click", onClose);
    return notification;
  }
};

// src/editors/inline-diff.ts
var setDiffEffect = import_state.StateEffect.define();
var clearDiffEffect = import_state.StateEffect.define();
var AddedLineWidget = class extends import_view.WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM() {
    const el = document.createElement("div");
    el.className = "cm-diff-widget-added";
    const contentSpan = el.createSpan("cm-diff-widget-text");
    contentSpan.textContent = this.content || " ";
    return el;
  }
  ignoreEvent() {
    return false;
  }
};
var diffStateField = import_state.StateField.define({
  create() {
    return import_view.Decoration.none;
  },
  update(value, tr) {
    for (const effect of tr.effects) {
      if (effect.is(setDiffEffect)) {
        if (effect.value) {
          return buildDecorations(effect.value, tr.state);
        }
        return import_view.Decoration.none;
      }
      if (effect.is(clearDiffEffect)) {
        return import_view.Decoration.none;
      }
    }
    return value.map(tr.changes);
  },
  provide: (f) => import_view.EditorView.decorations.from(f)
});
function buildDecorations(diff, state) {
  const builder = [];
  const doc = state.doc;
  let docLineNum = 1;
  for (const line of diff.lines) {
    if (line.type === "unchanged") {
      if (line.oldLineNumber)
        docLineNum = line.oldLineNumber + 1;
    } else if (line.type === "removed") {
      if (docLineNum <= doc.lines) {
        const lineInfo = doc.line(docLineNum);
        builder.push(import_view.Decoration.line({
          class: `cm-diff-line-original-removed`
        }).range(lineInfo.from, lineInfo.from));
      }
      docLineNum++;
    } else if (line.type === "added") {
      const insertPos = docLineNum > 1 ? doc.line(docLineNum - 1).to : 0;
      builder.push(import_view.Decoration.widget({
        widget: new AddedLineWidget(line.content),
        block: true,
        side: 1
      }).range(insertPos));
    }
  }
  return import_view.Decoration.set(builder, true);
}
async function applyDiffToView(app, filePath, newContent) {
  const manager = InlineEditorDiffManager.getInstance();
  const view = manager.findEditorViewForFile(app, filePath);
  if (!view) {
    console.warn(`[SystemSculpt] No active editor view found for: ${filePath}`);
    return false;
  }
  const originalContent = view.state.doc.toString();
  const diff = generateDiff(originalContent, newContent);
  manager.addActiveDiff(filePath, {
    view,
    diffResult: diff,
    notificationElement: null
  });
  view.dispatch({
    effects: setDiffEffect.of(diff)
  });
  manager.createNotificationForView(view, filePath);
  return true;
}
function clearDiffFromView(app, filePath) {
  const manager = InlineEditorDiffManager.getInstance();
  const view = manager.findEditorViewForFile(app, filePath);
  if (view) {
    view.dispatch({
      effects: clearDiffEffect.of(null)
    });
    manager.removeActiveDiff(filePath);
    return true;
  }
  return false;
}
var inlineDiffExtension = [
  diffStateField
];

// src/views/chatview/renderers/ToolCallDrawerRenderer.ts
var ToolCallDrawerRenderer = class extends import_obsidian58.Component {
  constructor(parent) {
    super();
    this.parent = parent;
  }
  renderToolCallAsContent(messageEl, toolCall, index, insertAfterElement, partId, isActivelyStreaming = false) {
    const wrapper = document.createElement("div");
    wrapper.classList.add("systemsculpt-tool-call-wrapper", "systemsculpt-unified-part");
    if (partId) {
      wrapper.dataset.partId = partId;
    }
    wrapper.dataset.state = toolCall.state || "pending";
    const functionData = this.getFunctionData(toolCall);
    if (!functionData) {
      wrapper.setText("Error: Malformed tool call");
      return wrapper;
    }
    const toolName = this.formatToolName(functionData.name);
    const summary = this.generateToolSummary(toolName, functionData.arguments);
    const drawerEl = wrapper.createDiv();
    const drawer = new CollapsibleDrawer({
      container: drawerEl,
      headerText: summary,
      headerIcon: "wrench",
      defaultCollapsed: this.shouldCollapseByDefault(toolCall),
      additionalHeaderContent: (headerEl) => {
        this.createStatusIndicator(headerEl, toolCall.state);
        if (typeof this.parent.renderOpenFileButton === "function") {
          this.parent.renderOpenFileButton(headerEl, toolCall);
        }
      },
      onToggle: (isCollapsed) => {
        if (typeof this.parent.handleDrawerToggle === "function") {
          this.parent.handleDrawerToggle(drawer, isCollapsed, toolCall);
        }
      }
    });
    this.addChild(drawer);
    const drawerContainer = drawer.getContainerElement();
    drawerContainer.dataset.toolCallId = toolCall.id;
    drawerContainer.classList.add("systemsculpt-tool-response");
    drawerContainer.dataset.state = toolCall.state;
    const contentEl = drawer.getContentElement();
    this.renderToolCallContent(contentEl, toolCall, isActivelyStreaming).catch((err) => console.error("[ToolCallDrawerRenderer] renderToolCallContent failed", err));
    if (insertAfterElement) {
      this.parent.insertElementInOrder(messageEl, wrapper, insertAfterElement);
    } else {
      messageEl.appendChild(wrapper);
    }
    return wrapper;
  }
  createStatusIndicator(headerEl, state) {
    const statusEl = headerEl.createDiv({
      cls: "systemsculpt-tool-call-status-indicator"
    });
    this.updateStatusIndicator(statusEl, state);
  }
  updateStatusIndicator(statusEl, state) {
    statusEl.empty();
    statusEl.className = "systemsculpt-tool-call-status-indicator";
    switch (state) {
      case "pending":
        (0, import_obsidian59.setIcon)(statusEl, "help-circle");
        statusEl.addClass("pending");
        break;
      case "executing":
        (0, import_obsidian59.setIcon)(statusEl, "loader");
        statusEl.addClass("executing");
        const svg = statusEl.querySelector("svg");
        if (svg)
          svg.classList.add("systemsculpt-spinning");
        break;
      case "completed":
        (0, import_obsidian59.setIcon)(statusEl, "check-circle");
        statusEl.addClass("completed");
        break;
      case "denied":
        (0, import_obsidian59.setIcon)(statusEl, "x-circle");
        statusEl.addClass("denied");
        break;
      case "error":
      case "failed":
        (0, import_obsidian59.setIcon)(statusEl, "alert-circle");
        statusEl.addClass("error");
        break;
    }
  }
  shouldCollapseByDefault(toolCall) {
    const state = toolCall.state;
    if (toolCall.autoApproved)
      return true;
    if (!state || state === "pending" || state === "executing")
      return false;
    return true;
  }
  getFunctionData(toolCall) {
    if (toolCall.request && toolCall.request.function) {
      try {
        return {
          name: toolCall.request.function.name,
          arguments: JSON.parse(toolCall.request.function.arguments)
        };
      } catch (e) {
        return {
          name: toolCall.request.function.name,
          arguments: {}
        };
      }
    }
    return null;
  }
  formatToolName(name) {
    let baseName = name.replace(/^mcp[_-]/i, "");
    if (baseName.startsWith("filesystem_")) {
      const parts = baseName.split("_");
      const namespace = parts[0];
      const functionName = parts.slice(1).join("_");
      return namespace.charAt(0).toUpperCase() + namespace.slice(1) + ": " + functionName;
    }
    return baseName.charAt(0).toUpperCase() + baseName.slice(1);
  }
  generateToolSummary(toolName, args) {
    const actualToolName = toolName.replace(/^mcp[_-]/i, "");
    if (actualToolName.startsWith("filesystem_")) {
      const parts = actualToolName.split("_");
      const namespace = parts[0];
      const functionName = parts.slice(1).join("_");
      return namespace.charAt(0).toUpperCase() + namespace.slice(1) + ": " + functionName;
    }
    return actualToolName.charAt(0).toUpperCase() + actualToolName.slice(1);
  }
  async renderToolCallContent(container, toolCall, isStreaming) {
    const functionData = this.getFunctionData(toolCall);
    if (!functionData) {
      container.empty();
      container.setText("Error: Malformed tool call content");
      return;
    }
    await this.handleToolCallStateChange(toolCall);
    if (!container.querySelector(".systemsculpt-tool-call-args")) {
      await this.renderToolCallArguments(container, functionData.arguments, toolCall);
    }
    container.querySelectorAll(".systemsculpt-tool-call-actions, .systemsculpt-tool-call-response, .systemsculpt-tool-call-result, .systemsculpt-tool-call-denied-message, .systemsculpt-tool-call-error, .systemsculpt-lazy-content-placeholder").forEach((el) => el.remove());
    const drawerEl = container.closest(".systemsculpt-collapsible-drawer");
    const isCollapsed = drawerEl == null ? void 0 : drawerEl.classList.contains("systemsculpt-collapsed");
    switch (toolCall.state) {
      case "pending":
        this.renderApprovalButtons(container, toolCall);
        break;
      case "approved":
      case "executing":
        this.renderExecutingState(container);
        break;
      case "completed":
        if (toolCall.result && !isCollapsed) {
          this.renderToolCallResult(container, toolCall.result);
        }
        break;
      case "failed":
        if (toolCall.result && !isCollapsed) {
          this.renderErrorState(container, toolCall.result.error);
        }
        break;
      case "denied":
        this.renderDeniedState(container);
        break;
    }
  }
  async renderToolCallArguments(container, args, toolCall) {
    const argsSection = container.createDiv({ cls: "systemsculpt-tool-call-args" });
    const argsContent = argsSection.createDiv({ cls: "systemsculpt-tool-call-args-content" });
    const functionData = this.getFunctionData(toolCall);
    const isWriteFile = functionData == null ? void 0 : functionData.name.includes("write_file");
    const isEditFile = functionData == null ? void 0 : functionData.name.includes("edit_file");
    if (isWriteFile || isEditFile) {
      const showDiff = await this.shouldShowFileDiff(toolCall, args);
      if (showDiff) {
        await this.renderFileDiffPreview(argsContent, toolCall, args);
      } else {
        if (isWriteFile) {
          await this.renderWriteFilePreview(argsContent, args);
        } else {
          this.renderEditFileArgs(argsContent, args);
        }
      }
    } else {
      Object.entries(args).forEach(([key, value]) => this.renderArgument(argsContent, key, value));
    }
    container.appendChild(argsSection);
  }
  renderArgument(container, key, value) {
    const argEl = container.createDiv({ cls: "systemsculpt-tool-call-arg" });
    argEl.createSpan({ cls: "systemsculpt-tool-call-arg-key", text: key });
    let displayValue;
    if (value === null || value === void 0) {
      displayValue = String(value);
    } else if (typeof value === "object") {
      displayValue = JSON.stringify(value, null, 2);
    } else {
      displayValue = String(value);
    }
    if (displayValue.length > 200)
      displayValue = displayValue.slice(0, 200) + "...";
    argEl.createSpan({ cls: "systemsculpt-tool-call-arg-value", text: displayValue });
  }
  renderApprovalButtons(container, toolCall) {
    const actions = container.createDiv({ cls: "systemsculpt-tool-call-actions" });
    const functionData = this.getFunctionData(toolCall);
    const isFileOp = functionData && /edit_file|write_file/.test(functionData.name);
    if (isFileOp) {
      const viewBtn = actions.createEl("button", { cls: "systemsculpt-tool-call-view-file" });
      viewBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><line x1="10" y1="9" x2="8" y2="9"/></svg><span>View in File</span>';
      viewBtn.addEventListener("click", () => {
        if (typeof this.parent.handleViewInFile === "function") {
          this.parent.handleViewInFile(toolCall);
        }
      });
    }
    const denyBtn = actions.createEl("button", { cls: "systemsculpt-tool-call-deny" });
    denyBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg><span>Deny</span>';
    const approveBtn = actions.createEl("button", { cls: "systemsculpt-tool-call-approve" });
    approveBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg><span>Approve & Execute</span>';
    const disableBtns = () => {
      approveBtn.disabled = true;
      denyBtn.disabled = true;
    };
    approveBtn.addEventListener("click", () => {
      disableBtns();
      container.dispatchEvent(new CustomEvent("tool-approval", {
        bubbles: true,
        detail: { toolCallId: toolCall.id, approved: true }
      }));
    });
    denyBtn.addEventListener("click", () => {
      disableBtns();
      container.dispatchEvent(new CustomEvent("tool-approval", {
        bubbles: true,
        detail: { toolCallId: toolCall.id, approved: false }
      }));
    });
  }
  renderExecutingState(container) {
    const resp = container.createDiv({ cls: "systemsculpt-tool-call-response" });
    resp.createDiv({ cls: "systemsculpt-tool-call-response-label", text: "Response:" });
    resp.createDiv({ cls: "systemsculpt-tool-response-loading", text: "\u23F3 Getting results..." });
  }
  renderToolCallResult(container, result) {
    const res = container.createDiv({ cls: "systemsculpt-tool-call-result" });
    if (result.success)
      this.renderResultData(res, result.data);
    else
      this.renderErrorState(res, result.error);
  }
  renderResultData(container, data) {
    const resultContainer = container.createDiv({ cls: "systemsculpt-tool-result-container" });
    const header = resultContainer.createDiv({ cls: "systemsculpt-tool-result-header" });
    header.createEl("h4", { text: "Result", cls: "systemsculpt-tool-result-title" });
    const content = resultContainer.createDiv({ cls: "systemsculpt-tool-result-content" });
    if (typeof data === "string") {
      this.renderTextResult(content, data);
    } else if (Array.isArray(data == null ? void 0 : data.entries)) {
      this.renderDirectoryResult(content, data.entries);
    } else if (Array.isArray(data)) {
      this.renderArrayResult(content, data);
    } else if (typeof data === "object" && data !== null) {
      this.renderObjectResult(content, data);
    } else {
      content.createEl("pre", { text: String(data), cls: "systemsculpt-tool-result-raw" });
    }
  }
  renderTextResult(container, text) {
    const lines = text.split("\n");
    const maxLines = 20;
    if (lines.length <= maxLines) {
      container.createEl("pre", { text, cls: "systemsculpt-tool-result-text" });
    } else {
      const preview = lines.slice(0, maxLines).join("\n");
      container.createEl("pre", { text: preview, cls: "systemsculpt-tool-result-text" });
      const truncated = container.createDiv({ cls: "systemsculpt-tool-result-truncated" });
      truncated.createEl("span", { text: `... ${lines.length - maxLines} more lines` });
      const expandBtn = truncated.createEl("button", {
        text: "Show all",
        cls: "systemsculpt-tool-result-expand-btn"
      });
      expandBtn.onclick = () => {
        container.empty();
        container.createEl("pre", { text, cls: "systemsculpt-tool-result-text" });
      };
    }
  }
  renderDirectoryResult(container, entries) {
    const dirs = entries.filter((e) => e.type === "directory");
    const files = entries.filter((e) => e.type === "file");
    const summary = container.createDiv({ cls: "systemsculpt-tool-result-summary" });
    summary.createEl("span", { text: `\u{1F4C1} ${dirs.length} directories, \u{1F4C4} ${files.length} files` });
    const listing = container.createDiv({ cls: "systemsculpt-tool-result-listing" });
    dirs.forEach((entry) => {
      const item = listing.createDiv({ cls: "systemsculpt-tool-result-item directory" });
      item.createEl("span", { text: "\u{1F4C1}", cls: "item-icon" });
      item.createEl("span", { text: entry.name, cls: "item-name" });
    });
    files.forEach((entry) => {
      const item = listing.createDiv({ cls: "systemsculpt-tool-result-item file" });
      item.createEl("span", { text: "\u{1F4C4}", cls: "item-icon" });
      item.createEl("span", { text: entry.name, cls: "item-name" });
    });
  }
  renderArrayResult(container, data) {
    const summary = container.createDiv({ cls: "systemsculpt-tool-result-summary" });
    summary.createEl("span", { text: `${data.length} items` });
    const listing = container.createDiv({ cls: "systemsculpt-tool-result-listing" });
    data.slice(0, 10).forEach((item, index) => {
      const itemEl = listing.createDiv({ cls: "systemsculpt-tool-result-item" });
      itemEl.createEl("span", { text: `${index + 1}.`, cls: "item-number" });
      itemEl.createEl("span", { text: JSON.stringify(item), cls: "item-content" });
    });
    if (data.length > 10) {
      const more = listing.createDiv({ cls: "systemsculpt-tool-result-truncated" });
      more.createEl("span", { text: `... ${data.length - 10} more items` });
    }
  }
  renderObjectResult(container, data) {
    const keys = Object.keys(data);
    const summary = container.createDiv({ cls: "systemsculpt-tool-result-summary" });
    summary.createEl("span", { text: `Object with ${keys.length} properties` });
    const jsonContainer = container.createDiv({ cls: "systemsculpt-tool-result-json" });
    jsonContainer.createEl("pre", {
      text: JSON.stringify(data, null, 2),
      cls: "systemsculpt-tool-result-raw"
    });
  }
  renderDeniedState(container) {
    const denied = container.createDiv({ cls: "systemsculpt-tool-call-denied-message" });
    (0, import_obsidian59.setIcon)(denied, "x-circle");
    denied.createSpan({ text: "Tool call denied." });
  }
  renderErrorState(container, error) {
    const err = container.createDiv({ cls: "systemsculpt-tool-call-error" });
    err.createEl("h4", { text: "Error" });
    err.createEl("pre", { text: typeof error === "string" ? error : JSON.stringify(error, null, 2) });
  }
  async shouldShowFileDiff(toolCall, args) {
    if (toolCall.state !== "pending")
      return false;
    const functionData = this.getFunctionData(toolCall);
    if (!functionData)
      return false;
    const toolName = functionData.name;
    const isFileEdit = /edit_file|write_file/.test(toolName);
    if (!isFileEdit)
      return false;
    const filePath = args.path || args.target_file || args.file_path;
    if (!filePath || typeof filePath !== "string")
      return false;
    const app = this.parent.app;
    const open = isFileOpen(app, filePath);
    let fileExists = false;
    if (toolName.includes("write_file")) {
      try {
        const file = app.vault.getAbstractFileByPath(filePath);
        fileExists = file !== null && file !== void 0;
      } catch (e) {
        fileExists = false;
      }
    }
    const shouldShowDiff = open || fileExists;
    if (shouldShowDiff) {
      try {
        const current = await getFileContent(app, filePath);
        const newContent = await this._getNewFileContent(toolName, args, current);
        if (newContent && open) {
          await applyDiffToView(app, filePath, newContent);
        }
      } catch (e) {
      }
    }
    return shouldShowDiff;
  }
  async _getNewFileContent(toolName, args, current) {
    if (toolName.includes("write_file"))
      return args.content || "";
    if (toolName.includes("edit_file")) {
      const edits = args.edits || [];
      let modifiedContent = current;
      for (const edit of edits) {
        if (edit.oldText && edit.newText !== void 0) {
          modifiedContent = modifiedContent.replace(edit.oldText, edit.newText);
        }
      }
      return modifiedContent;
    }
    return current;
  }
  async renderFileDiffPreview(container, toolCall, args) {
    const functionData = this.getFunctionData(toolCall);
    if (!functionData)
      return;
    const toolName = functionData.name;
    const filePath = args.path || args.target_file || args.file_path;
    if (!filePath || typeof filePath !== "string")
      return;
    try {
      const app = this.parent.app;
      const current = await getFileContent(app, filePath);
      const newContent = await this._getNewFileContent(toolName, args, current);
      const diff = generateDiff(current, newContent, 2);
      const diffContainer = container.createDiv({ cls: "systemsculpt-tool-call-diff-container" });
      if (diff.lines.length === 0) {
        const notice = diffContainer.createDiv({ cls: "systemsculpt-tool-call-diff-error" });
        notice.textContent = "No changes detected \u2013 the previous edit_file/write_file operation may have failed. Showing the latest file contents for reference:";
        const pre = diffContainer.createEl("pre", { cls: "systemsculpt-tool-call-file-content" });
        const code = pre.createEl("code");
        code.textContent = current;
        return;
      }
      const viewer = new DiffViewer({
        container: diffContainer,
        diffResult: diff,
        fileName: filePath.split("/").pop() || filePath,
        maxContextLines: 2,
        showLineNumbers: false
      });
      this.addChild(viewer);
      viewer.render();
    } catch (err) {
      console.error("Failed to generate diff preview", err);
      Object.entries(args).forEach(([k, v]) => this.renderArgument(container, k, v));
    }
  }
  async handleToolCallStateChange(toolCall) {
    if (toolCall.state === "pending")
      return;
    const functionData = this.getFunctionData(toolCall);
    if (!functionData)
      return;
    const toolName = functionData.name;
    if (!/edit_file|write_file/.test(toolName))
      return;
    const args = functionData.arguments;
    const filePath = args.path || args.target_file || args.file_path;
    if (!filePath || typeof filePath !== "string")
      return;
    try {
      const app = this.parent.app;
      await clearDiffFromView(app, filePath);
    } catch (e) {
    }
  }
  async renderWriteFilePreview(container, args) {
    const filePath = args.path;
    const content = args.content || "";
    this.renderArgument(container, "path", filePath);
    const contentPreview = container.createDiv({ cls: "systemsculpt-tool-call-content-preview" });
    const header = contentPreview.createDiv({ cls: "systemsculpt-tool-call-content-header" });
    const contentInfo = header.createDiv({ cls: "systemsculpt-tool-call-content-info" });
    const fileName = contentInfo.createEl("span", {
      cls: "systemsculpt-tool-call-content-filename",
      text: filePath.split("/").pop() || filePath
    });
    const stats = contentInfo.createEl("span", {
      cls: "systemsculpt-tool-call-content-stats",
      text: `${content.split("\n").length} lines, ${content.length} chars`
    });
    const contentContainer = contentPreview.createDiv({ cls: "systemsculpt-tool-call-content-body" });
    const lines = content.split("\n");
    const maxPreviewLines = 10;
    const linesToShow = lines.slice(0, maxPreviewLines);
    const preEl = contentContainer.createEl("pre", { cls: "systemsculpt-tool-call-content-code" });
    const codeEl = preEl.createEl("code");
    codeEl.textContent = linesToShow.join("\n");
    if (lines.length > maxPreviewLines) {
      const truncationNotice = contentContainer.createDiv({
        cls: "systemsculpt-tool-call-content-truncated",
        text: `... ${lines.length - maxPreviewLines} more lines`
      });
    }
  }
  renderEditFileArgs(container, args) {
    this.renderArgument(container, "path", args.path);
    if (args.edits && Array.isArray(args.edits)) {
      const editsPreview = container.createDiv({ cls: "systemsculpt-tool-call-edits-preview" });
      const header = editsPreview.createDiv({ cls: "systemsculpt-tool-call-edits-header" });
      header.textContent = `${args.edits.length} edit${args.edits.length === 1 ? "" : "s"}`;
      const editsContainer = editsPreview.createDiv({ cls: "systemsculpt-tool-call-edits-list" });
      args.edits.slice(0, 3).forEach((edit, index) => {
        const editEl = editsContainer.createDiv({ cls: "systemsculpt-tool-call-edit-item" });
        const removeEl = editEl.createDiv({ cls: "systemsculpt-tool-call-edit-remove" });
        removeEl.createEl("span", { cls: "systemsculpt-tool-call-edit-prefix", text: "-" });
        removeEl.createEl("span", {
          cls: "systemsculpt-tool-call-edit-text",
          text: this.truncateText(edit.oldText || "", 50)
        });
        const addEl = editEl.createDiv({ cls: "systemsculpt-tool-call-edit-add" });
        addEl.createEl("span", { cls: "systemsculpt-tool-call-edit-prefix", text: "+" });
        addEl.createEl("span", {
          cls: "systemsculpt-tool-call-edit-text",
          text: this.truncateText(edit.newText || "", 50)
        });
      });
      if (args.edits.length > 3) {
        const moreEdits = editsContainer.createDiv({
          cls: "systemsculpt-tool-call-edits-more",
          text: `... ${args.edits.length - 3} more edit${args.edits.length - 3 === 1 ? "" : "s"}`
        });
      }
    }
  }
  truncateText(text, maxLength) {
    if (text.length <= maxLength)
      return text;
    return text.substring(0, maxLength - 3) + "...";
  }
};

// src/constants/largeText.ts
var LARGE_TEXT_THRESHOLDS = {
  SOFT_WARNING_KB: 100,
  HARD_WARNING_KB: 512,
  MAX_SIZE_KB: 1024,
  MAX_LINES_PREVIEW: 5,
  COLLAPSE_THRESHOLD_LINES: 300,
  CHUNK_SIZE_CHARS: 1e3,
  BYTES_PER_KB: 1024
};
var LARGE_TEXT_MESSAGES = {
  SIZE_ERROR: "\u274C Text too large (>1MB). Please use file upload or split into smaller sections.",
  SIZE_WARNING_PREFIX: "\u26A0\uFE0F Large text detected",
  PROCESSING: "Processing large text...",
  COMPLETED: "Large text paste completed",
  CONFIRMATION_PREFIX: "Large text processed",
  TRUNCATION_INDICATOR: "... (content truncated)"
};
var LARGE_TEXT_UI = {
  PLACEHOLDER_PREFIX: "[PASTED TEXT - ",
  PLACEHOLDER_SUFFIX: " LINES OF TEXT]",
  STATS_PREFIX: "\u{1F4C4} Large text content: ",
  MODAL_TITLE_SUFFIX: " lines)"
};
var LargeTextHelpers = {
  getTextSizeKB: (text) => {
    return new Blob([text]).size / LARGE_TEXT_THRESHOLDS.BYTES_PER_KB;
  },
  getLineCount: (text) => {
    return text.split("\n").length;
  },
  shouldCollapseInHistory: (text) => {
    const sizeKB = LargeTextHelpers.getTextSizeKB(text);
    const lines = LargeTextHelpers.getLineCount(text);
    return sizeKB > LARGE_TEXT_THRESHOLDS.SOFT_WARNING_KB || lines > LARGE_TEXT_THRESHOLDS.COLLAPSE_THRESHOLD_LINES;
  },
  getTextWarningLevel: (text) => {
    const sizeKB = LargeTextHelpers.getTextSizeKB(text);
    if (sizeKB > LARGE_TEXT_THRESHOLDS.MAX_SIZE_KB)
      return "error";
    if (sizeKB > LARGE_TEXT_THRESHOLDS.HARD_WARNING_KB)
      return "hard";
    if (sizeKB > LARGE_TEXT_THRESHOLDS.SOFT_WARNING_KB)
      return "soft";
    return "none";
  },
  createPlaceholder: (lineCount) => {
    return `${LARGE_TEXT_UI.PLACEHOLDER_PREFIX}${lineCount}${LARGE_TEXT_UI.PLACEHOLDER_SUFFIX}`;
  },
  containsPlaceholder: (text) => {
    return text.includes(LARGE_TEXT_UI.PLACEHOLDER_PREFIX) && text.includes(LARGE_TEXT_UI.PLACEHOLDER_SUFFIX);
  },
  getPreviewContent: (text) => {
    const lines = text.split("\n");
    return lines.slice(0, LARGE_TEXT_THRESHOLDS.MAX_LINES_PREVIEW).join("\n");
  },
  formatSize: (sizeKB) => {
    return `${Math.round(sizeKB)}KB`;
  }
};

// src/views/chatview/MessageRenderer.ts
var MessageRenderer = class extends import_obsidian60.Component {
  constructor(app, toolCallManager) {
    super();
    this.throttledRenderers = new WeakMap();
    this.RENDER_THROTTLE_MS = 100;
    this.expandedDrawers = [];
    this.MAX_EXPANDED_DRAWERS = 3;
    this.cleanupInterval = null;
    this.app = app;
    this.toolCallManager = toolCallManager;
    this.markdownRenderer = new MarkdownMessageRenderer(app);
    this.toolCallRenderer = new ToolCallDrawerRenderer(this);
    this.addChild(this.toolCallRenderer);
    this.cleanupInterval = setInterval(() => {
      this.cleanupDestroyedDrawers();
    }, 3e4);
    this.register(() => {
      if (this.cleanupInterval) {
        clearInterval(this.cleanupInterval);
        this.cleanupInterval = null;
      }
    });
  }
  async renderMessage({
    app,
    messageId,
    role,
    content,
    annotations,
    webSearchEnabled
  }) {
    const messageEl = document.createElement("div");
    messageEl.classList.add("systemsculpt-message");
    messageEl.classList.add(`systemsculpt-${role}-message`);
    messageEl.dataset.messageId = messageId;
    const contentEl = messageEl.createEl("div", {
      cls: "systemsculpt-message-content"
    });
    if (typeof content === "string") {
      const isLargeText = LargeTextHelpers.shouldCollapseInHistory(content);
      if (isLargeText) {
        await this.renderCollapsedLargeText(content, contentEl);
      } else {
        await this.renderMarkdownContent(content, contentEl, false);
      }
    } else if (Array.isArray(content)) {
      const parts = content;
      for (const part of parts) {
        if (part.type === "text") {
          const p = contentEl.createEl("p");
          p.setText(part.text);
        } else if (part.type === "image_url") {
          const img = contentEl.createEl("img", {
            attr: { src: part.image_url.url }
          });
          img.classList.add("systemsculpt-message-image");
        }
      }
    } else {
      await this.renderMarkdownContent(String(content), contentEl, false);
    }
    if (role === "assistant" && webSearchEnabled && annotations && annotations.length > 0) {
      const urlCitations = annotations.filter((annotation) => annotation.type === "url_citation" && annotation.url_citation).map((annotation) => annotation.url_citation).filter((citation) => citation !== void 0);
      if (urlCitations.length > 0) {
        this.renderCitations(contentEl, urlCitations);
      }
    }
    return { messageEl, contentEl };
  }
  async renderMarkdownContent(content, containerEl, isStreaming = false) {
    return this.markdownRenderer.render(content, containerEl, isStreaming);
  }
  throttledRender(containerEl, content) {
    let state = this.throttledRenderers.get(containerEl);
    if (!state) {
      state = { timeoutId: null, content: "" };
      this.throttledRenderers.set(containerEl, state);
    }
    state.content = content;
    if (state.timeoutId) {
      return;
    }
    state.timeoutId = setTimeout(async () => {
      const currentState = this.throttledRenderers.get(containerEl);
      if (currentState) {
        currentState.timeoutId = null;
        if (!containerEl.isConnected) {
          this.throttledRenderers.delete(containerEl);
          return;
        }
        containerEl.empty();
        await import_obsidian60.MarkdownRenderer.render(this.app, currentState.content, containerEl, "systemsculpt-chat.md", this);
        this.processRenderedContent(containerEl);
        this.app.workspace.trigger("systemsculpt:content-rendered");
      }
    }, this.RENDER_THROTTLE_MS);
  }
  postProcessMermaid(containerEl) {
    const mermaidDivs = containerEl.querySelectorAll(".mermaid");
    mermaidDivs.forEach((div) => {
      const raw = div.textContent || "";
      let processed = raw.replace(/\[([\s\S]*?)\]/g, (m2, p1) => `[${p1.replace(/\n+/g, " ")}]`);
      processed = processed.replace(/([\w-]+)\(\[([\s\S]*?)\]\)/g, '$1["$2"]');
      processed = processed.replace(/([\w-]+)\[([^\]]+?)\]/g, '$1["$2"]');
      processed = processed.replace(/\]\)([ \t]+)([\w-]+[\[\(])/g, "])\n  $2");
      if (processed !== raw) {
        div.textContent = processed;
      }
      const m = globalThis.mermaid;
      if (m && typeof m.init === "function") {
        try {
          m.init(void 0, div);
        } catch (err) {
          console.warn("[SystemSculpt] Mermaid render error suppressed:", err);
        }
      }
      if (!div.dataset.ssExpand) {
        div.dataset.ssExpand = "true";
        const btn = div.createDiv({ cls: "systemsculpt-mermaid-expand-btn" });
        (0, import_obsidian60.setIcon)(btn, "maximize-2");
        btn.setAttribute("aria-label", "Expand diagram");
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          new MermaidPreviewModal(this.app, processed).open();
        });
      }
    });
  }
  setToolbarVisibility(toolbar, visible, expanded = false) {
  }
  expandToolbar(collapsedToolbar, expandedToolbar, chevronButton) {
    collapsedToolbar.addClass("hidden");
    expandedToolbar.addClass("active");
    const clickOutsideHandler = (e) => {
      if (!expandedToolbar.contains(e.target) && !collapsedToolbar.contains(e.target)) {
        this.collapseToolbar(collapsedToolbar, expandedToolbar, chevronButton);
        document.removeEventListener("click", clickOutsideHandler);
      }
    };
    setTimeout(() => {
      document.addEventListener("click", clickOutsideHandler);
    }, 100);
  }
  collapseToolbar(collapsedToolbar, expandedToolbar, chevronButton) {
    collapsedToolbar.removeClass("hidden");
    expandedToolbar.removeClass("active");
  }
  addMessageButtonToolbar(messageEl, content, role, messageId) {
    const collapsedToolbar = messageEl.createEl("div", {
      cls: "systemsculpt-message-button-toolbar-collapsed"
    });
    const chevronButton = new import_obsidian60.ButtonComponent(collapsedToolbar).setIcon("chevron-left").setTooltip("Show actions").setClass("mod-small").onClick(() => {
      this.expandToolbar(collapsedToolbar, expandedToolbar, chevronButton);
    });
    const expandedToolbar = messageEl.createEl("div", {
      cls: "systemsculpt-message-button-toolbar-expanded"
    });
    const copyButton = new import_obsidian60.ButtonComponent(expandedToolbar).setIcon("copy").setTooltip("Copy message").setClass("mod-small").onClick(() => {
      navigator.clipboard.writeText(content);
      copyButton.setIcon("check");
      copyButton.buttonEl.addClass("is-success");
      setTimeout(() => {
        copyButton.setIcon("copy");
        copyButton.buttonEl.removeClass("is-success");
      }, 2e3);
      this.collapseToolbar(collapsedToolbar, expandedToolbar, chevronButton);
    });
    if (role === "user") {
      let isResubmitConfirming = false;
      let resubmitTimeoutId = null;
      const resubmitButton = new import_obsidian60.ButtonComponent(expandedToolbar).setIcon("rotate-ccw").setTooltip("Resubmit this message").setClass("mod-small").onClick(async () => {
        if (!isResubmitConfirming) {
          isResubmitConfirming = true;
          resubmitButton.setButtonText("Resubmit?").setCta();
          resubmitTimeoutId = setTimeout(() => {
            resubmitButton.setIcon("rotate-ccw").setButtonText("").removeCta();
            isResubmitConfirming = false;
          }, 3e3);
        } else {
          if (resubmitTimeoutId) {
            clearTimeout(resubmitTimeoutId);
            resubmitTimeoutId = null;
          }
          resubmitButton.setButtonText("Resubmitting...").setDisabled(true);
          messageEl.dispatchEvent(new CustomEvent("resubmit", {
            bubbles: true,
            detail: { messageId, content }
          }));
          setTimeout(() => {
            resubmitButton.setIcon("rotate-ccw").setButtonText("").setDisabled(false).removeCta();
            isResubmitConfirming = false;
          }, 1e3);
          this.collapseToolbar(collapsedToolbar, expandedToolbar, chevronButton);
        }
      });
    }
    if (role === "user") {
      const editButton = new import_obsidian60.ButtonComponent(expandedToolbar).setIcon("pencil").setTooltip("Edit this message").setClass("mod-small").onClick(async (e) => {
        e.stopPropagation();
        const currentContent = messageEl.dataset.content || content;
        const EditModalClass = class extends import_obsidian60.Modal {
          constructor(app) {
            super(app);
            this.result = null;
          }
          onOpen() {
            const { contentEl } = this;
            contentEl.empty();
            this.titleEl.setText("Edit Message");
            this.textArea = new import_obsidian60.TextAreaComponent(contentEl).setValue(currentContent).setPlaceholder("Enter your message...").onChange(() => {
            });
            this.textArea.inputEl.style.width = "100%";
            this.textArea.inputEl.style.minHeight = "150px";
            this.textArea.inputEl.style.resize = "vertical";
            const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
            new import_obsidian60.ButtonComponent(buttonContainer).setButtonText("Save").setCta().onClick(() => {
              this.result = this.textArea.getValue();
              this.close();
            });
            new import_obsidian60.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
              this.result = null;
              this.close();
            });
            setTimeout(() => this.textArea.inputEl.focus(), 0);
          }
          openAndAwaitResult() {
            this.open();
            return new Promise((resolve) => {
              this.onClose = () => {
                resolve(this.result);
              };
            });
          }
        };
        const modalInstance = new EditModalClass(this.app);
        const result = await modalInstance.openAndAwaitResult();
        if (result !== null) {
          messageEl.dataset.content = result;
          const contentEl = messageEl.querySelector(".systemsculpt-message-content");
          if (contentEl) {
            await this.renderMarkdownContent(result, contentEl, false);
            messageEl.dispatchEvent(new CustomEvent("edit", {
              bubbles: true,
              detail: { messageId, newContent: result }
            }));
          }
          this.collapseToolbar(collapsedToolbar, expandedToolbar, chevronButton);
        }
      });
    }
    const deleteButton = new import_obsidian60.ButtonComponent(expandedToolbar).setIcon("trash").setTooltip("Delete this message").setClass("mod-small").setWarning().onClick(async (e) => {
      e.stopPropagation();
      const isConfirming = deleteButton.buttonEl.dataset.confirming === "true";
      if (!isConfirming) {
        deleteButton.buttonEl.dataset.confirming = "true";
        deleteButton.setButtonText("Delete?");
        const timeoutId = setTimeout(() => {
          deleteButton.setIcon("trash").setButtonText("");
          deleteButton.buttonEl.dataset.confirming = "false";
        }, 3e3);
        deleteButton.buttonEl.dataset.timeoutId = timeoutId.toString();
      } else {
        const timeoutId = deleteButton.buttonEl.dataset.timeoutId;
        if (timeoutId) {
          clearTimeout(parseInt(timeoutId));
        }
        deleteButton.setButtonText("Deleting...").setDisabled(true);
        messageEl.dispatchEvent(new CustomEvent("delete", {
          bubbles: true,
          detail: { messageId }
        }));
        this.collapseToolbar(collapsedToolbar, expandedToolbar, chevronButton);
      }
    });
    const collapseButton = new import_obsidian60.ButtonComponent(expandedToolbar).setIcon("chevron-right").setTooltip("Hide actions").setClass("mod-small").onClick(() => {
      this.collapseToolbar(collapsedToolbar, expandedToolbar, chevronButton);
    });
    collapseButton.buttonEl.addClass("chevron");
  }
  renderCitations(contentEl, citations) {
    this.markdownRenderer.renderCitations(contentEl, citations);
  }
  renderUnifiedMessageParts(messageEl, parts, isActivelyStreaming = false) {
    if (!parts || parts.length === 0) {
      const legacyContent2 = messageEl.querySelector(".systemsculpt-message-content:not(.systemsculpt-unified-part)");
      if (legacyContent2) {
        legacyContent2.style.display = "";
      }
      return;
    }
    const legacyContent = messageEl.querySelector(".systemsculpt-message-content:not(.systemsculpt-unified-part)");
    if (legacyContent) {
      legacyContent.style.display = "none";
    }
    const renderedParts = new Map();
    messageEl.querySelectorAll(".systemsculpt-unified-part[data-part-id]").forEach((el) => {
      const partId = el.dataset.partId;
      if (partId) {
        renderedParts.set(partId, el);
      }
    });
    const sortedParts = [...parts].sort((a, b) => a.timestamp - b.timestamp);
    const processedPartIds = new Set();
    let insertAfterElement = null;
    let reasoningIndex = 0;
    let toolCallIndex = 0;
    sortedParts.forEach((part) => {
      if (!part.id) {
        console.warn("[MessageRenderer] Part missing ID:", part);
        return;
      }
      processedPartIds.add(part.id);
      const existingElement = renderedParts.get(part.id);
      if (existingElement) {
        const needsUpdate = this.partNeedsUpdate(part, isActivelyStreaming, existingElement);
        if (needsUpdate) {
          this.updateExistingPart(existingElement, part, isActivelyStreaming);
        }
        insertAfterElement = existingElement;
      } else {
        let newElement = null;
        if (part.type === "reasoning") {
          newElement = this.renderUnifiedReasoning(messageEl, part.data, reasoningIndex, insertAfterElement, isActivelyStreaming, part.id);
          reasoningIndex++;
        } else if (part.type === "content") {
          newElement = this.renderUnifiedContent(messageEl, part.data, insertAfterElement, part.id, isActivelyStreaming, part);
        } else if (part.type === "tool_call") {
          const toolCall = part.data;
          newElement = this.toolCallRenderer.renderToolCallAsContent(messageEl, toolCall, toolCallIndex, insertAfterElement, part.id, isActivelyStreaming);
          toolCallIndex++;
        }
        if (newElement) {
          insertAfterElement = newElement;
        }
      }
    });
    renderedParts.forEach((element, partId) => {
      if (!processedPartIds.has(partId)) {
        element.remove();
      }
    });
  }
  partNeedsUpdate(part, isActivelyStreaming, existingElement) {
    var _a;
    if (part.type === "reasoning") {
      const drawer = existingElement == null ? void 0 : existingElement.querySelector(".is-reasoning-drawer");
      const isCurrentlyStreaming = (_a = drawer == null ? void 0 : drawer.classList.contains("is-streaming-reasoning")) != null ? _a : false;
      if (isActivelyStreaming !== isCurrentlyStreaming) {
        return true;
      }
      return isActivelyStreaming || (existingElement == null ? void 0 : existingElement.textContent) !== part.data;
    } else if (part.type === "content") {
      return isActivelyStreaming || (existingElement == null ? void 0 : existingElement.textContent) !== part.data;
    } else if (part.type === "tool_call") {
      return true;
    }
    return false;
  }
  updateExistingPart(element, part, isActivelyStreaming) {
    if (part.type === "reasoning") {
      const drawer = element.querySelector(".is-reasoning-drawer");
      if (drawer) {
        if (isActivelyStreaming) {
          drawer.classList.add("is-streaming-reasoning");
        } else {
          drawer.classList.remove("is-streaming-reasoning");
        }
      }
      const contentEl = element.querySelector(".systemsculpt-reasoning-text");
      if (contentEl && typeof part.data === "string") {
        this.renderMarkdownContent(part.data, contentEl, isActivelyStreaming);
      }
    } else if (part.type === "content") {
      if (element && typeof part.data === "string") {
        this.renderMarkdownContent(part.data, element, isActivelyStreaming);
      }
    } else if (part.type === "tool_call") {
      const toolCall = part.data;
      element.dataset.state = toolCall.state || "pending";
      const drawerEl = element.querySelector(".systemsculpt-collapsible-drawer");
      if (drawerEl instanceof HTMLElement) {
        drawerEl.setAttribute("data-state", toolCall.state || "pending");
        this.setDrawerCollapsedState(drawerEl, this.toolCallRenderer.shouldCollapseByDefault(toolCall));
      }
      if (drawerEl instanceof HTMLElement) {
        this.toolCallRenderer.renderToolCallContent(drawerEl, toolCall, isActivelyStreaming).catch((err) => {
          console.error("[MessageRenderer] Failed to update tool call content:", err);
        });
      }
      const statusEl = element.querySelector(".systemsculpt-tool-call-status-indicator");
      if (statusEl instanceof HTMLElement) {
        this.toolCallRenderer.updateStatusIndicator(statusEl, toolCall.state);
      }
      const headerEl = element.querySelector(".systemsculpt-collapsible-header");
      if (headerEl instanceof HTMLElement) {
        const existingBtn = headerEl.querySelector(".systemsculpt-tool-call-open-file-btn");
        if (existingBtn) {
          existingBtn.remove();
        }
        this.renderOpenFileButton(headerEl, toolCall);
      }
    }
  }
  renderUnifiedReasoning(messageEl, reasoning, index, insertAfterElement, isStreaming = false, partId) {
    const { container: reasoningWrapper, content: reasoningContentEl } = this.createReasoningContainer(messageEl, isStreaming);
    if (partId) {
      reasoningWrapper.dataset.partId = partId;
    }
    const drawerContainer = reasoningWrapper.querySelector(".systemsculpt-collapsible-drawer");
    if (isStreaming && drawerContainer) {
      drawerContainer.classList.add("is-streaming-reasoning");
    }
    this.insertElementInOrder(messageEl, reasoningWrapper, insertAfterElement);
    reasoningContentEl.classList.add("systemsculpt-drawer-content-container", "systemsculpt-reasoning-text", "markdown-rendered");
    this.renderMarkdownContent(reasoning, reasoningContentEl, isStreaming);
    return reasoningWrapper;
  }
  renderUnifiedContent(messageEl, content, insertAfterElement, partId, isStreaming = false, messagePart) {
    const container = document.createElement("div");
    container.className = "systemsculpt-unified-part systemsculpt-content-part";
    if (partId) {
      container.dataset.partId = partId;
    }
    this.insertElementInOrder(messageEl, container, insertAfterElement);
    if (typeof content === "string" && this.containsChronologicalBlocks(content)) {
      const cleanedContent = this.extractNonChronologicalContent(content);
      if (cleanedContent.trim()) {
        this.renderMarkdownContent(cleanedContent, container, isStreaming);
      }
    } else if (typeof content === "string") {
      this.renderMarkdownContent(content, container, isStreaming);
    } else if (Array.isArray(content)) {
      const parts = content;
      for (const part of parts) {
        if (part.type === "text") {
          const p = container.createEl("p");
          p.setText(part.text);
        } else if (part.type === "image_url") {
          const img = container.createEl("img", {
            attr: { src: part.image_url.url }
          });
          img.classList.add("systemsculpt-message-image");
        }
      }
    } else {
      this.renderMarkdownContent(String(content), container, isStreaming);
    }
    return container;
  }
  processRenderedContent(container) {
    container.querySelectorAll("pre").forEach((preEl) => {
      preEl.classList.add("systemsculpt-code-block");
    });
    container.querySelectorAll("img").forEach((img) => {
      img.style.cursor = "pointer";
      img.classList.add("systemsculpt-message-image");
      img.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const src = img.getAttribute("src");
        if (!src)
          return;
        if (src.startsWith("app://")) {
          const path = src.replace("app://local/", "");
          this.app.workspace.openLinkText(path, "", true);
        }
      });
    });
  }
  containsChronologicalBlocks(content) {
    return content.includes("<!-- REASONING-BLOCK -->") || content.includes("<!-- TOOL-CALL-BLOCK -->") || content.includes("<!-- TOOL-RESPONSE-BLOCK -->");
  }
  extractNonChronologicalContent(content) {
    let cleaned = content.replace(/<!-- REASONING-BLOCK -->\n[\s\S]*?\n<!-- \/REASONING-BLOCK -->/g, "").replace(/<!-- TOOL-CALL-BLOCK -->\n[\s\S]*?\n<!-- \/TOOL-CALL-BLOCK -->/g, "").replace(/<!-- TOOL-RESPONSE-BLOCK -->\n[\s\S]*?\n<!-- \/TOOL-RESPONSE-BLOCK -->/g, "");
    cleaned = cleaned.replace(/\n\n\n+/g, "\n\n").trim();
    return cleaned;
  }
  manageExpandedDrawers(drawer, isExpanded, isRecursiveCall = false) {
    this.cleanupDestroyedDrawers();
    if (isExpanded) {
      const existingIndex = this.expandedDrawers.indexOf(drawer);
      if (existingIndex !== -1) {
        this.expandedDrawers.splice(existingIndex, 1);
      }
      if (!isRecursiveCall && this.expandedDrawers.length >= this.MAX_EXPANDED_DRAWERS) {
        const oldestDrawer = this.expandedDrawers.shift();
        if (oldestDrawer) {
          this.performSmoothFifoCollapseAndExpand(oldestDrawer, drawer);
          return;
        }
      }
      this.expandedDrawers.push(drawer);
    } else {
      const index = this.expandedDrawers.indexOf(drawer);
      if (index !== -1) {
        this.expandedDrawers.splice(index, 1);
      }
    }
  }
  cleanupDestroyedDrawers() {
    this.expandedDrawers = this.expandedDrawers.filter((drawer) => {
      try {
        const container = drawer.getContainerElement();
        return container && container.isConnected;
      } catch (error) {
        return false;
      }
    });
  }
  performSmoothFifoCollapseAndExpand(oldDrawer, newDrawer) {
    const oldContainer = oldDrawer.getContainerElement();
    oldContainer.classList.add("auto-collapsing");
    oldDrawer.setCollapsed(true);
    oldContainer.addEventListener("transitionend", () => {
      oldContainer.classList.remove("auto-collapsing");
      oldContainer.classList.add("auto-collapsed");
      this.manageExpandedDrawers(newDrawer, true, true);
    }, { once: true });
  }
  handleDrawerToggle(drawer, isCollapsed, toolCall) {
    if (!isCollapsed) {
      drawer.getContainerElement().classList.remove("auto-collapsed");
    }
    this.manageExpandedDrawers(drawer, !isCollapsed);
    if (!isCollapsed && toolCall && (toolCall.state === "completed" || toolCall.state === "failed")) {
      const contentEl = drawer.getContentElement();
      setTimeout(() => {
        if (!drawer.getContainerElement().classList.contains("systemsculpt-collapsed") && contentEl.isConnected) {
          this.toolCallRenderer.renderToolCallContent(contentEl, toolCall, false).catch((error) => {
            console.error("Failed to render full tool call content on expand:", error);
          });
        }
      }, 0);
    }
  }
  renderResultData(container, resultData) {
    const rawContainer = container.createDiv({
      cls: "systemsculpt-tool-result-raw-container"
    });
    let content = "";
    if (typeof resultData === "string") {
      content = resultData;
    } else if (Array.isArray(resultData.entries)) {
      const entries = resultData.entries.map((entry) => {
        const type = entry.type === "directory" ? "\u{1F4C1}" : "\u{1F4C4}";
        return `${type} ${entry.name}`;
      }).join("\n");
      content = entries;
    } else if (typeof resultData === "object" && resultData !== null) {
      content = JSON.stringify(resultData, null, 2);
    } else {
      content = String(resultData);
    }
    rawContainer.setText(`Result:

${content}`);
  }
  renderDeniedState(container) {
    const deniedEl = container.createDiv({
      cls: "systemsculpt-tool-call-denied-message"
    });
    (0, import_obsidian60.setIcon)(deniedEl, "x-circle");
    deniedEl.createSpan({ text: "Tool call denied." });
  }
  renderErrorState(container, error) {
    const errorContainer = container.createDiv({
      cls: "systemsculpt-tool-call-error"
    });
    errorContainer.createEl("h4", { text: "Error" });
    const pre = errorContainer.createEl("pre");
    pre.setText(typeof error === "string" ? error : JSON.stringify(error, null, 2));
  }
  getFunctionData(toolCall) {
    if (toolCall.request && toolCall.request.function) {
      try {
        return {
          name: toolCall.request.function.name,
          arguments: JSON.parse(toolCall.request.function.arguments)
        };
      } catch (e) {
        console.error("Failed to parse tool call arguments:", e);
        return {
          name: toolCall.request.function.name,
          arguments: {}
        };
      }
    }
    return null;
  }
  insertElementInOrder(messageEl, newElement, insertAfterElement) {
    if (insertAfterElement) {
      insertAfterElement.insertAdjacentElement("afterend", newElement);
    } else {
      const contentEl = messageEl.querySelector(".systemsculpt-message-content");
      if (contentEl) {
        messageEl.insertBefore(newElement, contentEl);
      } else {
        messageEl.appendChild(newElement);
      }
    }
  }
  renderMessageParts(messageEl, message, isActivelyStreaming = false) {
    const partList = message.messageParts ? new MessagePartList(message.messageParts) : new MessagePartList(MessagePartNormalizer.toParts(message));
    this.renderUnifiedMessageParts(messageEl, partList.parts, isActivelyStreaming);
  }
  collapseAllDrawers(messageEl) {
    const drawerElements = messageEl.querySelectorAll(".systemsculpt-collapsible-drawer");
    drawerElements.forEach((drawer) => {
      const state = drawer.dataset.state;
      if (state !== "pending") {
        this.setDrawerCollapsedState(drawer, true);
        drawer.classList.remove("systemsculpt-visible");
      }
    });
  }
  async handleViewInFile(toolCall) {
    try {
      const functionData = this.getFunctionData(toolCall);
      if (!functionData)
        return;
      const args = functionData.arguments;
      const toolName = functionData.name;
      const filePath = args.path || args.target_file || args.file_path;
      if (!filePath || typeof filePath !== "string")
        return;
      const currentLeaf = this.app.workspace.activeLeaf;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian60.TFile)) {
        new import_obsidian60.Notice("File not found or is not a valid file.");
        return;
      }
      const allLeaves = this.app.workspace.getLeavesOfType("markdown");
      let existingFileLeaf = null;
      const normalizedPath = (0, import_obsidian60.normalizePath)(filePath);
      for (const leaf of allLeaves) {
        const view = leaf.view;
        if (view.file && (0, import_obsidian60.normalizePath)(view.file.path) === normalizedPath) {
          existingFileLeaf = leaf;
          break;
        }
      }
      if (existingFileLeaf) {
        this.app.workspace.setActiveLeaf(existingFileLeaf, { focus: false });
      } else {
        let targetLeaf = null;
        if (import_obsidian60.Platform.isMobile) {
          targetLeaf = this.app.workspace.getLeaf("tab");
        } else {
          let suitablePane = null;
          this.app.workspace.iterateAllLeaves((leaf) => {
            if (leaf.getRoot() === this.app.workspace.rootSplit && leaf !== currentLeaf) {
              if (!suitablePane)
                suitablePane = leaf;
            }
          });
          if (suitablePane) {
            this.app.workspace.setActiveLeaf(suitablePane, { focus: false });
            targetLeaf = this.app.workspace.getLeaf("tab");
          } else {
            if (currentLeaf && currentLeaf.getRoot() === this.app.workspace.rootSplit) {
              targetLeaf = this.app.workspace.createLeafBySplit(currentLeaf, "vertical", true);
            } else {
              targetLeaf = this.app.workspace.getLeaf(true);
            }
          }
        }
        if (targetLeaf) {
          await targetLeaf.openFile(file);
        }
      }
      if (currentLeaf) {
        this.app.workspace.setActiveLeaf(currentLeaf, { focus: true });
      }
    } catch (error) {
      console.error("[MessageRenderer] Error in handleViewInFile:", error);
    }
  }
  unload() {
    this.expandedDrawers = [];
    this.throttledRenderers = new WeakMap();
    super.unload();
  }
  formatToolName(name) {
    let baseName = name.replace(/^mcp[_-]/i, "");
    if (baseName.startsWith("filesystem_")) {
      const parts = baseName.split("_");
      const namespace = parts[0];
      const functionName = parts.slice(1).join("_");
      return namespace.charAt(0).toUpperCase() + namespace.slice(1) + ": " + functionName;
    }
    return baseName.charAt(0).toUpperCase() + baseName.slice(1);
  }
  generateToolSummary(toolName, args) {
    const actualToolName = toolName.replace(/^mcp[_-]/i, "");
    if (actualToolName.startsWith("filesystem_")) {
      const parts = actualToolName.split("_");
      const namespace = parts[0];
      const functionName = parts.slice(1).join("_");
      return namespace.charAt(0).toUpperCase() + namespace.slice(1) + ": " + functionName;
    }
    return actualToolName.charAt(0).toUpperCase() + actualToolName.slice(1);
  }
  isArgumentValueMeaningful(value) {
    if (value === null || value === void 0) {
      return false;
    }
    if (typeof value === "string") {
      return value.trim().length > 0;
    }
    return true;
  }
  filterMeaningfulArguments(args) {
    const meaningful = {};
    for (const [key, value] of Object.entries(args)) {
      if (this.isArgumentValueMeaningful(value)) {
        meaningful[key] = value;
      }
    }
    return meaningful;
  }
  createReasoningContainer(messageEl, isStreaming = false) {
    const wrapperEl = document.createElement("div");
    wrapperEl.className = "systemsculpt-reasoning-wrapper systemsculpt-unified-part";
    const drawer = new CollapsibleDrawer({
      container: wrapperEl,
      headerIcon: "brain",
      headerText: "Reasoning",
      defaultCollapsed: true,
      onToggle: (isCollapsed) => {
        this.handleDrawerToggle(drawer, isCollapsed);
      }
    });
    this.addChild(drawer);
    const container = drawer.getContainerElement();
    const content = drawer.getContentElement();
    if (container) {
      container.classList.add("is-reasoning-drawer");
      container.classList.add("systemsculpt-visible");
    }
    return { container: wrapperEl, content };
  }
  updateReasoningContent(messageEl, reasoning, isComplete = false) {
  }
  normalizeMessageToParts(message) {
    const parts = MessagePartNormalizer.toParts(message);
    return new MessagePartList(parts);
  }
  setDrawerCollapsedState(drawerEl, shouldCollapse) {
    const isCurrentlyCollapsed = drawerEl.classList.contains("systemsculpt-collapsed");
    if (isCurrentlyCollapsed === shouldCollapse) {
      return;
    }
    requestAnimationFrame(() => {
      if (shouldCollapse) {
        drawerEl.classList.add("systemsculpt-collapsed");
      } else {
        drawerEl.classList.remove("systemsculpt-collapsed");
      }
    });
  }
  renderOpenFileButton(headerEl, toolCall) {
    if (toolCall.state !== "completed") {
      return;
    }
    const functionData = this.getFunctionData(toolCall);
    if (!functionData) {
      return;
    }
    const singleFileTools = {
      "write_file": "path",
      "edit_file": "path"
    };
    const baseName = functionData.name.replace(/^mcp-filesystem_/, "");
    let filePath = null;
    if (baseName === "move_items") {
      if (functionData.arguments.items && Array.isArray(functionData.arguments.items) && functionData.arguments.items.length > 0) {
        filePath = functionData.arguments.items[0].destination;
      }
    } else {
      const pathArgument = singleFileTools[baseName];
      if (pathArgument) {
        const pathValue = functionData.arguments[pathArgument];
        if (typeof pathValue === "string") {
          filePath = pathValue;
        }
      }
    }
    if (!filePath) {
      return;
    }
    const openFileBtn = new import_obsidian60.ButtonComponent(headerEl).setButtonText("Open File").setClass("systemsculpt-tool-call-open-file-btn").setClass("mod-small").setTooltip(`Open ${filePath}`).onClick(async (event) => {
      event.stopPropagation();
      if (filePath) {
        await this.openFileInWorkspace(filePath);
      }
    });
  }
  async openFileInWorkspace(filePath) {
    try {
      const currentLeaf = this.app.workspace.activeLeaf;
      const { action } = await openFileInMainWorkspace(this.app, filePath);
      if (action !== "switched_in_pane" && currentLeaf) {
        this.app.workspace.setActiveLeaf(currentLeaf, { focus: true });
      }
    } catch (error) {
      console.error("[MessageRenderer] Error in openFileInWorkspace:", error);
      new import_obsidian60.Notice("Error opening file. See console for details.");
    }
  }
  collapseReasoningDrawers(messageEl) {
  }
  getFilePathFromToolCall(toolCall) {
    const functionData = this.getFunctionData(toolCall);
    if (!functionData)
      return null;
    const toolName = functionData.name;
    const args = functionData.arguments || {};
    if (toolName === "move_items" && args.items && Array.isArray(args.items) && args.items.length > 0) {
      return args.items[0].destination || null;
    }
    const pathArgMap = {
      "read_files": "paths",
      "write_file": "path",
      "edit_file": "path",
      "trash_files": "paths"
    };
    const argName = pathArgMap[toolName];
    if (!argName)
      return null;
    const pathValue = args[argName];
    if (typeof pathValue === "string") {
      return pathValue;
    } else if (Array.isArray(pathValue) && typeof pathValue[0] === "string") {
      return pathValue[0];
    }
    return null;
  }
  async renderCollapsedLargeText(content, contentEl) {
    const lineCount = LargeTextHelpers.getLineCount(content);
    const sizeKB = Math.round(LargeTextHelpers.getTextSizeKB(content));
    const collapsedContainer = contentEl.createEl("div", {
      cls: "systemsculpt-large-text-container"
    });
    const previewContent = LargeTextHelpers.getPreviewContent(content);
    const previewEl = collapsedContainer.createEl("div", {
      cls: "systemsculpt-large-text-preview"
    });
    await this.renderMarkdownContent(previewContent, previewEl, false);
    if (lineCount > LARGE_TEXT_THRESHOLDS.MAX_LINES_PREVIEW) {
      const truncationEl = previewEl.createEl("div", {
        cls: "systemsculpt-text-truncation",
        text: LARGE_TEXT_MESSAGES.TRUNCATION_INDICATOR
      });
    }
    const collapseIndicator = collapsedContainer.createEl("div", {
      cls: "systemsculpt-large-text-indicator"
    });
    collapseIndicator.innerHTML = `
      <span class="systemsculpt-large-text-stats">
        ${LARGE_TEXT_UI.STATS_PREFIX}${lineCount} lines (${LargeTextHelpers.formatSize(sizeKB)})
      </span>
      <div class="systemsculpt-large-text-actions">
        <button class="systemsculpt-view-button">
          \u{1F4C4} View in Modal
        </button>
        <button class="systemsculpt-save-button">
          \u{1F4BE} Save to File
        </button>
        <button class="systemsculpt-copy-button">
          \u{1F4CB} Copy to Clipboard
        </button>
      </div>
    `;
    const viewButton = collapseIndicator.querySelector(".systemsculpt-view-button");
    const saveButton = collapseIndicator.querySelector(".systemsculpt-save-button");
    const copyButton = collapseIndicator.querySelector(".systemsculpt-copy-button");
    viewButton.addEventListener("click", () => {
      this.showLargeTextModal(content, `Large Text Content (${lineCount}${LARGE_TEXT_UI.MODAL_TITLE_SUFFIX}`);
    });
    saveButton.addEventListener("click", () => {
      this.saveLargeTextToFile(content, sizeKB);
    });
    copyButton.addEventListener("click", () => {
      navigator.clipboard.writeText(content);
      copyButton.textContent = "\u2713 Copied";
      setTimeout(() => {
        copyButton.innerHTML = "\u{1F4CB} Copy to Clipboard";
      }, 1e3);
    });
  }
  showLargeTextModal(content, title) {
    new LargeTextModal(this.app, content, title).open();
  }
  async saveLargeTextToFile(content, sizeKB) {
    try {
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `large-text-${Date.now()}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      const notice = document.createElement("div");
      notice.className = "systemsculpt-notice";
      notice.textContent = `\u2713 Large text saved to file (${LargeTextHelpers.formatSize(sizeKB)})`;
      document.body.appendChild(notice);
      setTimeout(() => {
        notice.remove();
      }, 3e3);
    } catch (error) {
      console.error("Failed to save large text:", error);
    }
  }
};
var LargeTextModal = class extends import_obsidian60.Modal {
  constructor(app, content, title) {
    super(app);
    this.content = content;
    this.title = title;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText(this.title);
    const container = contentEl.createEl("div", {
      cls: "large-text-modal-container"
    });
    const textarea = container.createEl("textarea", {
      cls: "large-text-viewer",
      attr: {
        readonly: "true",
        spellcheck: "false"
      }
    });
    textarea.value = this.content;
    textarea.style.width = "100%";
    textarea.style.height = "60vh";
    textarea.style.minHeight = "400px";
    textarea.style.fontFamily = "var(--font-monospace)";
    textarea.style.fontSize = "13px";
    textarea.style.lineHeight = "1.4";
    textarea.style.resize = "vertical";
    textarea.style.border = "1px solid var(--border-color)";
    textarea.style.borderRadius = "4px";
    textarea.style.padding = "12px";
    textarea.style.backgroundColor = "var(--background-primary)";
    textarea.style.color = "var(--text-normal)";
    const buttonContainer = container.createEl("div", {
      cls: "large-text-modal-buttons"
    });
    buttonContainer.style.marginTop = "12px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "8px";
    buttonContainer.style.justifyContent = "flex-end";
    const copyButton = buttonContainer.createEl("button", {
      text: "Copy to Clipboard",
      cls: "mod-cta"
    });
    copyButton.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(this.content);
        copyButton.setText("\u2713 Copied!");
        setTimeout(() => {
          copyButton.setText("Copy to Clipboard");
        }, 1500);
      } catch (error) {
        console.error("Failed to copy text:", error);
        copyButton.setText("Copy failed");
        setTimeout(() => {
          copyButton.setText("Copy to Clipboard");
        }, 1500);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/chatview/ChatView.ts
init_SystemPromptService();
init_titleUtils();
init_StandardModelSelectionModal();
init_modelUtils();
init_prompts2();

// src/core/TypedEventEmitter.ts
var TypedEventEmitter = class {
  constructor() {
    this.events = {};
  }
  on(eventName, fn) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(fn);
    return () => {
      this.events[eventName] = this.events[eventName].filter((l) => l !== fn);
    };
  }
  once(eventName, fn) {
    const remove = this.on(eventName, (params) => {
      remove();
      fn(params);
    });
    return remove;
  }
  emit(eventName, params) {
    const callbacks = this.events[eventName];
    if (callbacks) {
      callbacks.forEach((callback) => callback(params));
    }
  }
  off(eventName) {
    delete this.events[eventName];
  }
  clear() {
    this.events = {};
  }
  listenerCount(eventName) {
    var _a;
    return ((_a = this.events[eventName]) == null ? void 0 : _a.length) || 0;
  }
  eventNames() {
    return Object.keys(this.events);
  }
};

// src/views/chatview/ToolCallManager.ts
var ToolCallManager = class {
  constructor(mcpService, chatView) {
    this.toolCalls = new Map();
    this.toolRegistry = new Map();
    this.MAX_TOOL_RESULT_SIZE = 1e4;
    this.MAX_TOOL_RESULTS_IN_CONTEXT = 15;
    this.TRUNCATION_INDICATOR = "\n\n[... truncated for brevity ...]";
    this.mcpService = mcpService;
    this.chatView = chatView;
    this.events = new TypedEventEmitter();
  }
  on(event, handler) {
    return this.events.on(event, handler);
  }
  createToolCall(request, messageId, autoApprove = false) {
    if (this.chatView && !this.chatView.agentMode) {
      const toolCall2 = {
        id: request.id,
        messageId,
        request,
        state: "denied",
        timestamp: Date.now(),
        autoApproved: false,
        result: {
          success: false,
          error: {
            code: "AGENT_MODE_DISABLED",
            message: "Tool call denied: Agent mode is not enabled for this chat. Enable agent mode in the MCP tools modal to use tools."
          }
        }
      };
      this.toolCalls.set(toolCall2.id, toolCall2);
      this.events.emit("tool-call:created", { toolCall: toolCall2 });
      this.events.emit("tool-call:denied", { toolCallId: toolCall2.id, toolCall: toolCall2 });
      return toolCall2;
    }
    const toolCall = {
      id: request.id,
      messageId,
      request,
      state: "pending",
      timestamp: Date.now(),
      autoApproved: autoApprove
    };
    this.toolCalls.set(toolCall.id, toolCall);
    this.events.emit("tool-call:created", { toolCall });
    if (autoApprove) {
      this.approveToolCall(toolCall.id);
    }
    return toolCall;
  }
  getToolCall(id) {
    return this.toolCalls.get(id);
  }
  getToolCallsForMessage(messageId) {
    return Array.from(this.toolCalls.values()).filter((tc) => tc.messageId === messageId);
  }
  updateState(toolCallId, newState) {
    const toolCall = this.toolCalls.get(toolCallId);
    if (!toolCall) {
      console.warn(`[SystemSculpt] Tool call not found: ${toolCallId}`);
      return;
    }
    const previousState = toolCall.state;
    toolCall.state = newState;
    this.events.emit("tool-call:state-changed", {
      toolCallId,
      previousState,
      newState,
      toolCall
    });
  }
  approveToolCall(toolCallId) {
    const toolCall = this.toolCalls.get(toolCallId);
    if (!toolCall || toolCall.state !== "pending") {
      return;
    }
    toolCall.approvedAt = Date.now();
    this.updateState(toolCallId, "approved");
    this.events.emit("tool-call:approved", { toolCallId, toolCall });
    this.executeToolCall(toolCallId);
  }
  denyToolCall(toolCallId) {
    const toolCall = this.toolCalls.get(toolCallId);
    if (!toolCall || toolCall.state !== "pending") {
      return;
    }
    toolCall.result = {
      success: false,
      error: {
        code: "USER_DENIED",
        message: "The user has explicitly denied this tool call request."
      }
    };
    this.updateState(toolCallId, "denied");
    this.events.emit("tool-call:denied", { toolCallId, toolCall });
  }
  cancelToolCall(toolCallId, reason) {
    const toolCall = this.toolCalls.get(toolCallId);
    if (!toolCall || toolCall.state !== "pending") {
      return;
    }
    toolCall.result = {
      success: false,
      error: {
        code: "USER_CANCELED",
        message: reason
      }
    };
    this.updateState(toolCallId, "denied");
    this.events.emit("tool-call:denied", { toolCallId, toolCall });
  }
  getPendingToolCalls() {
    const pending = [];
    for (const toolCall of this.toolCalls.values()) {
      if (toolCall.state === "pending") {
        pending.push(toolCall);
      }
    }
    return pending;
  }
  async executeToolCall(toolCallId, options) {
    const toolCall = this.toolCalls.get(toolCallId);
    if (!toolCall || toolCall.state !== "approved") {
      return;
    }
    try {
      toolCall.executionStartedAt = Date.now();
      this.updateState(toolCallId, "executing");
      this.events.emit("tool-call:execution-started", { toolCallId, toolCall });
      let args;
      try {
        args = JSON.parse(toolCall.request.function.arguments);
      } catch (e) {
        throw new Error(`Invalid tool arguments: ${e.message}`);
      }
      let result;
      if (toolCall.request.function.name.startsWith("mcp-")) {
        result = await this.executeTool(toolCall.request.function.name, args, {
          ...options,
          sourceFile: options == null ? void 0 : options.sourceFile
        });
      } else {
        result = await this.executeTool(toolCall.request.function.name, args, options);
      }
      toolCall.executionCompletedAt = Date.now();
      toolCall.result = result;
      this.updateState(toolCallId, result.success ? "completed" : "failed");
      if (result.success) {
        this.events.emit("tool-call:execution-completed", {
          toolCallId,
          result,
          toolCall
        });
      } else {
        this.events.emit("tool-call:execution-failed", {
          toolCallId,
          error: result.error,
          toolCall
        });
      }
    } catch (error) {
      const errorResult = {
        success: false,
        error: {
          code: "EXECUTION_ERROR",
          message: error.message || "Unknown error",
          details: error
        }
      };
      toolCall.executionCompletedAt = Date.now();
      toolCall.result = errorResult;
      this.updateState(toolCallId, "failed");
      this.events.emit("tool-call:execution-failed", {
        toolCallId,
        error: errorResult.error,
        toolCall
      });
    }
  }
  async executeTool(toolName, args, options) {
    try {
      if (this.chatView && !this.chatView.agentMode) {
        throw new Error("Tool execution denied: Agent mode is not enabled for this chat. Enable agent mode in the MCP tools modal to use tools.");
      }
      let resultData;
      if (toolName.startsWith("mcp-")) {
        resultData = await this.mcpService.executeTool(toolName, args, this.chatView);
      } else {
        const tool = this.toolRegistry.get(toolName);
        if (tool) {
          resultData = await tool.executor(args, options);
        } else {
          throw new Error(`Tool not found: ${toolName}`);
        }
      }
      const processedData = this.processToolResult(resultData, toolName);
      return {
        success: true,
        data: processedData
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: "TOOL_EXECUTION_ERROR",
          message: error.message || "Tool execution failed",
          details: error
        }
      };
    }
  }
  registerTool(definition, executor) {
    this.toolRegistry.set(definition.name, { definition, executor });
  }
  async getAvailableTools() {
    if (this.chatView && !this.chatView.agentMode) {
      return [];
    }
    const tools = [];
    for (const [name, entry] of this.toolRegistry) {
      tools.push(entry.definition);
    }
    if (this.mcpService) {
      const mcpTools = await this.mcpService.getAvailableTools();
      for (const tool of mcpTools) {
        tools.push({
          name: tool.function.name,
          description: tool.function.description,
          parameters: tool.function.parameters,
          autoApprove: false
        });
      }
    }
    return tools;
  }
  serializeToolCall(toolCallId) {
    const toolCall = this.toolCalls.get(toolCallId);
    if (!toolCall) {
      return void 0;
    }
    return {
      id: toolCall.id,
      request: toolCall.request,
      state: toolCall.state,
      timestamp: toolCall.timestamp,
      approvedAt: toolCall.approvedAt,
      executionStartedAt: toolCall.executionStartedAt,
      executionCompletedAt: toolCall.executionCompletedAt,
      result: toolCall.result,
      autoApproved: toolCall.autoApproved
    };
  }
  restoreToolCall(serialized, messageId) {
    const toolCall = {
      ...serialized,
      messageId
    };
    this.toolCalls.set(toolCall.id, toolCall);
    return toolCall;
  }
  clear() {
    this.toolCalls.clear();
    this.events.clear();
  }
  processToolResult(data, toolName) {
    if (!data)
      return data;
    try {
      const serialized = JSON.stringify(data);
      if (serialized.length <= this.MAX_TOOL_RESULT_SIZE) {
        return data;
      }
      return this.truncateToolResult(data, toolName, serialized);
    } catch (error) {
      console.error("[ToolCallManager] Error processing tool result:", error);
      return {
        error: "Tool result processing failed",
        originalType: typeof data,
        toolName,
        details: error.message || "Unknown error"
      };
    }
  }
  truncateToolResult(data, toolName, serialized) {
    if (toolName.includes("read") || toolName.includes("file")) {
      return this.truncateFileResult(data);
    }
    if (toolName.includes("search") || toolName.includes("find")) {
      return this.truncateSearchResult(data);
    }
    if (toolName.includes("list") || toolName.includes("directory")) {
      return this.truncateListResult(data);
    }
    const maxLength = this.MAX_TOOL_RESULT_SIZE - this.TRUNCATION_INDICATOR.length;
    if (serialized.length > maxLength) {
      let truncated = serialized.substring(0, maxLength);
      let lastValidJson = "";
      const maxAttempts = Math.min(1e3, truncated.length);
      for (let i = truncated.length; i > truncated.length - maxAttempts && i > 0; i--) {
        try {
          const candidate = truncated.substring(0, i);
          JSON.parse(candidate);
          lastValidJson = candidate;
          break;
        } catch (e) {
        }
      }
      if (lastValidJson) {
        try {
          const parsed = JSON.parse(lastValidJson);
          if (typeof parsed === "object" && parsed !== null) {
            parsed.truncation_info = "Result truncated due to size limit.";
            return parsed;
          }
        } catch (e) {
          console.warn("[ToolCallManager] Failed to parse truncated JSON, using fallback");
        }
      }
      return {
        truncated_content: truncated.substring(0, maxLength - 100),
        truncation_info: "Result truncated due to size limit. Original format could not be preserved.",
        original_length: serialized.length
      };
    }
    return data;
  }
  truncateFileResult(data) {
    if (typeof data === "object" && data.content) {
      const maxContentLength = this.MAX_TOOL_RESULT_SIZE - 500;
      return {
        ...data,
        content: data.content.length > maxContentLength ? data.content.substring(0, maxContentLength) + this.TRUNCATION_INDICATOR : data.content,
        truncated: data.content.length > maxContentLength,
        originalLength: data.content.length
      };
    }
    return data;
  }
  truncateSearchResult(data) {
    if (Array.isArray(data)) {
      const maxResults = 10;
      return {
        results: data.slice(0, maxResults),
        totalFound: data.length,
        truncated: data.length > maxResults,
        showingFirst: maxResults
      };
    }
    if (typeof data === "object" && data.results && Array.isArray(data.results)) {
      const maxResults = 10;
      return {
        ...data,
        results: data.results.slice(0, maxResults),
        totalFound: data.results.length,
        truncated: data.results.length > maxResults,
        showingFirst: maxResults
      };
    }
    return data;
  }
  truncateListResult(data) {
    if (Array.isArray(data)) {
      const maxItems = 20;
      return {
        items: data.slice(0, maxItems),
        totalCount: data.length,
        truncated: data.length > maxItems,
        showingFirst: maxItems
      };
    }
    if (typeof data === "object" && data.files && Array.isArray(data.files)) {
      const maxFiles = 20;
      return {
        ...data,
        files: data.files.slice(0, maxFiles),
        totalFiles: data.files.length,
        truncated: data.files.length > maxFiles,
        showingFirst: maxFiles
      };
    }
    return data;
  }
  getToolResultsForContext() {
    const completedCalls = Array.from(this.toolCalls.values()).filter((tc) => {
      var _a;
      return tc.state === "completed" && ((_a = tc.result) == null ? void 0 : _a.success) && tc.executionCompletedAt;
    }).sort((a, b) => (b.executionCompletedAt || 0) - (a.executionCompletedAt || 0));
    return completedCalls.slice(0, this.MAX_TOOL_RESULTS_IN_CONTEXT);
  }
  getArchivedToolResultsSummary() {
    const allCompleted = Array.from(this.toolCalls.values()).filter((tc) => {
      var _a;
      return tc.state === "completed" && ((_a = tc.result) == null ? void 0 : _a.success);
    }).sort((a, b) => (b.executionCompletedAt || 0) - (a.executionCompletedAt || 0));
    const archived = allCompleted.slice(this.MAX_TOOL_RESULTS_IN_CONTEXT);
    if (archived.length === 0)
      return "";
    const toolCounts = new Map();
    archived.forEach((tc) => {
      const toolName = tc.request.function.name;
      toolCounts.set(toolName, (toolCounts.get(toolName) || 0) + 1);
    });
    const summary = Array.from(toolCounts.entries()).map(([tool, count]) => `${tool}: ${count}`).join(", ");
    return `Previously used tools (${archived.length} total): ${summary}`;
  }
};

// src/views/chatview/ChatView.ts
init_MCPService();
init_agent2();

// src/views/chatview/uiSetup.ts
var import_obsidian75 = __toModule(require("obsidian"));
init_StandardModelSelectionModal();
init_ui();

// src/views/chatview/FileContextManager.ts
var import_obsidian65 = __toModule(require("obsidian"));

// src/views/chatview/DrawerComponent.ts
var import_obsidian61 = __toModule(require("obsidian"));
var DrawerComponent = class extends import_obsidian61.Component {
  constructor(options) {
    super();
    this.isMouseInProximity = false;
    this.hideTimeout = null;
    this.options = options;
    this.initializeDrawer();
    this.setupEventListeners();
  }
  initializeDrawer() {
    this.drawer = this.options.container.createEl("div", {
      cls: `systemsculpt-drawer ${this.options.cls || ""}`
    });
    this.header = this.drawer.createEl("div", {
      cls: "systemsculpt-drawer-header systemsculpt-model-indicator"
    });
    const iconSpan = this.header.createSpan({ cls: "systemsculpt-model-indicator-icon" });
    (0, import_obsidian61.setIcon)(iconSpan, "files");
    const titleEl = this.header.createEl("div", {
      cls: "systemsculpt-drawer-title"
    });
    titleEl.createSpan({ text: this.options.title });
    this.toggle = this.header.createSpan({
      cls: "systemsculpt-drawer-toggle systemsculpt-model-indicator-arrow"
    });
    (0, import_obsidian61.setIcon)(this.toggle, "chevron-down");
    this.content = this.drawer.createEl("div", {
      cls: "systemsculpt-drawer-content"
    });
    this.setVisibility(false);
  }
  setupEventListeners() {
    this.registerDomEvent(this.drawer, "mouseenter", () => {
      this.isMouseInProximity = true;
      this.clearHideTimeout();
      this.setVisibility(true);
    });
    this.registerDomEvent(this.content, "mouseenter", () => {
      this.isMouseInProximity = true;
      this.clearHideTimeout();
      this.setVisibility(true);
    });
    this.registerDomEvent(this.drawer, "mouseleave", (e) => {
      const rect = this.drawer.getBoundingClientRect();
      const buffer = 25;
      if (e.clientY >= rect.bottom && e.clientY <= rect.bottom + buffer && e.clientX >= rect.left && e.clientX <= rect.right) {
        return;
      }
      this.isMouseInProximity = false;
      this.scheduleHide();
    });
    this.registerDomEvent(this.content, "mouseleave", (e) => {
      const rect = this.content.getBoundingClientRect();
      const buffer = 25;
      if (e.clientY <= rect.top && e.clientY >= rect.top - buffer && e.clientX >= rect.left && e.clientX <= rect.right) {
        return;
      }
      this.isMouseInProximity = false;
      this.scheduleHide();
    });
    this.registerDomEvent(this.header, "click", () => {
      const isVisible = this.content.style.opacity === "1";
      this.setVisibility(!isVisible);
    });
  }
  clearHideTimeout() {
    if (this.hideTimeout) {
      clearTimeout(this.hideTimeout);
      this.hideTimeout = null;
    }
  }
  scheduleHide() {
    this.clearHideTimeout();
    this.hideTimeout = setTimeout(() => {
      if (!this.isMouseInProximity) {
        this.setVisibility(false);
      }
    }, 100);
  }
  setVisibility(visible) {
    this.content.style.opacity = visible ? "1" : "0";
    this.content.style.pointerEvents = visible ? "all" : "none";
    this.content.style.transform = `translateY(${visible ? "0" : "-8px"})`;
    this.drawer.setAttribute("data-visible", visible.toString());
    if (this.options.onVisibilityChange) {
      this.options.onVisibilityChange(visible);
    }
  }
  getContent() {
    return this.content;
  }
  getDrawer() {
    return this.drawer;
  }
  getHeader() {
    return this.header;
  }
  unload() {
    this.clearHideTimeout();
    super.unload();
  }
};

// src/views/chatview/FileContextManager.ts
init_DocumentProcessingService();

// src/modals/ContextSelectionModal.ts
var import_obsidian62 = __toModule(require("obsidian"));
var FILE_TYPES = {
  text: { extensions: ["md", "txt"], icon: "file-text", label: "Text" },
  documents: { extensions: ["pdf", "doc", "docx", "ppt", "pptx", "xls", "xlsx"], icon: "file", label: "Documents" },
  images: { extensions: ["png", "jpg", "jpeg", "gif", "svg", "webp"], icon: "image", label: "Images" },
  audio: { extensions: ["mp3", "wav", "m4a", "ogg", "webm"], icon: "headphones", label: "Audio" }
};
var ContextSelectionModal = class extends import_obsidian62.Modal {
  constructor(app, onSelect, plugin) {
    super(app);
    this.files = [];
    this.filteredFiles = [];
    this.selectedFiles = new Set();
    this.currentFilter = "all";
    this.searchQuery = "";
    this.addButton = null;
    this.onSelect = onSelect;
    this.plugin = plugin;
    this.initializeFiles();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Add Context Files");
    new import_obsidian62.Setting(contentEl).setName("Search files").addText((text) => {
      text.setPlaceholder("Type to search...").onChange((value) => {
        this.searchQuery = value.toLowerCase();
        this.applyFilters();
      });
      setTimeout(() => text.inputEl.focus(), 100);
    });
    const filterContainer = contentEl.createDiv("context-filter-container");
    const allBtn = filterContainer.createEl("button", {
      text: "All",
      cls: "context-filter-btn is-active"
    });
    allBtn.onclick = () => this.setFilter("all", allBtn);
    Object.entries(FILE_TYPES).forEach(([type, info]) => {
      const btn = filterContainer.createEl("button", { cls: "context-filter-btn" });
      const icon = btn.createSpan();
      (0, import_obsidian62.setIcon)(icon, info.icon);
      btn.createSpan({ text: info.label });
      btn.onclick = () => this.setFilter(type, btn);
    });
    const listContainer = contentEl.createDiv("context-file-list");
    this.renderFileList(listContainer);
    new import_obsidian62.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => {
      this.addButton = btn;
      this.updateAddButton(btn);
      console.log("[ContextSelectionModal] Setting up add button click handler");
      btn.onClick(async () => {
        console.log("[ContextSelectionModal] Add button clicked!");
        await this.handleSelection();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.selectedFiles.clear();
  }
  initializeFiles() {
    const allFiles = this.app.vault.getFiles();
    this.files = [];
    for (const file of allFiles) {
      const ext = file.extension.toLowerCase();
      for (const [typeName, typeInfo] of Object.entries(FILE_TYPES)) {
        if (typeInfo.extensions.includes(ext)) {
          this.files.push({
            file,
            type: typeName,
            searchText: `${file.basename} ${file.path} ${ext}`.toLowerCase()
          });
          break;
        }
      }
    }
    this.files.sort((a, b) => a.file.basename.localeCompare(b.file.basename));
    this.filteredFiles = [...this.files];
  }
  setFilter(filter, buttonEl) {
    var _a;
    (_a = buttonEl.parentElement) == null ? void 0 : _a.querySelectorAll(".context-filter-btn").forEach((btn) => {
      btn.removeClass("is-active");
    });
    buttonEl.addClass("is-active");
    this.currentFilter = filter;
    this.applyFilters();
  }
  applyFilters() {
    let filtered = this.files;
    if (this.currentFilter !== "all") {
      filtered = filtered.filter((item) => item.type === this.currentFilter);
    }
    if (this.searchQuery) {
      filtered = filtered.filter((item) => item.searchText.includes(this.searchQuery));
    }
    this.filteredFiles = filtered;
    const listContainer = this.contentEl.querySelector(".context-file-list");
    if (listContainer) {
      this.renderFileList(listContainer);
    }
  }
  renderFileList(container) {
    container.empty();
    if (this.filteredFiles.length === 0) {
      const empty = container.createDiv("context-empty");
      const emptyIcon = empty.createDiv();
      (0, import_obsidian62.setIcon)(emptyIcon, "file-x");
      empty.createEl("p", { text: "No files found" });
      return;
    }
    const visibleFiles = this.filteredFiles.slice(0, 100);
    visibleFiles.forEach((item) => {
      const fileEl = container.createDiv("context-file-item");
      const isSelected = this.selectedFiles.has(item.file);
      if (isSelected) {
        fileEl.addClass("is-selected");
      }
      const iconEl = fileEl.createDiv("context-file-icon");
      (0, import_obsidian62.setIcon)(iconEl, FILE_TYPES[item.type].icon);
      const infoEl = fileEl.createDiv("context-file-info");
      infoEl.createDiv({ text: item.file.basename, cls: "context-file-name" });
      infoEl.createDiv({ text: item.file.path, cls: "context-file-path" });
      const checkbox = fileEl.createEl("input", { type: "checkbox" });
      checkbox.checked = isSelected;
      fileEl.onclick = () => this.toggleFileSelection(item.file);
    });
    if (this.filteredFiles.length > 100) {
      const loadMore = container.createEl("button", {
        text: `Show ${this.filteredFiles.length - 100} more files`,
        cls: "context-load-more"
      });
      loadMore.onclick = () => {
        container.empty();
        this.filteredFiles.forEach((item) => {
        });
      };
    }
  }
  toggleFileSelection(file) {
    if (this.selectedFiles.has(file)) {
      this.selectedFiles.delete(file);
      console.log("[ContextSelectionModal] Deselected file:", file.path, "Total selected:", this.selectedFiles.size);
    } else {
      this.selectedFiles.add(file);
      console.log("[ContextSelectionModal] Selected file:", file.path, "Total selected:", this.selectedFiles.size);
    }
    const listContainer = this.contentEl.querySelector(".context-file-list");
    if (listContainer) {
      this.renderFileList(listContainer);
    }
    this.updateAddButtonState();
  }
  updateAddButton(btn) {
    const count = this.selectedFiles.size;
    if (count === 0) {
      btn.setButtonText("Add Files").setDisabled(true);
    } else {
      btn.setButtonText(`Add ${count} File${count === 1 ? "" : "s"}`).setDisabled(false).setCta();
    }
  }
  updateAddButtonState() {
    if (this.addButton) {
      this.updateAddButton(this.addButton);
    }
  }
  setLoadingState(loading) {
    const buttons = this.contentEl.querySelectorAll("button");
    const cancelButton = Array.from(buttons).find((btn) => {
      var _a;
      return (_a = btn.textContent) == null ? void 0 : _a.includes("Cancel");
    });
    if (loading) {
      if (this.addButton) {
        this.addButton.setButtonText("Processing...").setDisabled(true);
        this.addButton.buttonEl.removeClass("mod-cta");
      }
      if (cancelButton) {
        cancelButton.disabled = true;
      }
      const fileItems = this.contentEl.querySelectorAll(".context-file-item");
      fileItems.forEach((item) => {
        item.style.pointerEvents = "none";
        item.addClass("is-disabled");
      });
    } else {
      if (this.addButton) {
        this.updateAddButton(this.addButton);
      }
      if (cancelButton) {
        cancelButton.disabled = false;
      }
      const fileItems = this.contentEl.querySelectorAll(".context-file-item");
      fileItems.forEach((item) => {
        item.style.pointerEvents = "auto";
        item.removeClass("is-disabled");
      });
    }
  }
  async handleSelection() {
    console.log("[ContextSelectionModal] handleSelection called, selected files:", this.selectedFiles.size);
    if (this.selectedFiles.size === 0)
      return;
    const selectedArray = Array.from(this.selectedFiles);
    console.log("[ContextSelectionModal] Processing files:", selectedArray.map((f) => f.path));
    try {
      this.setLoadingState(true);
      console.log("[ContextSelectionModal] Calling onSelect callback");
      await this.onSelect(selectedArray);
      console.log("[ContextSelectionModal] onSelect completed successfully");
      this.close();
    } catch (error) {
      console.error("[ContextSelectionModal] Error processing files:", error);
      this.setLoadingState(false);
    }
  }
};

// src/views/chatview/FileContextManager.ts
var import_obsidian66 = __toModule(require("obsidian"));

// src/services/PreviewService.ts
var import_obsidian63 = __toModule(require("obsidian"));
var _PreviewService = class {
  static getCacheForProvider(providerType = "systemsculpt") {
    if (providerType === "custom") {
      return {
        previewCache: this.customProviderPreviewCache,
        fileModCache: this.customProviderFileModCache
      };
    }
    return {
      previewCache: this.systemSculptPreviewCache,
      fileModCache: this.systemSculptFileModCache
    };
  }
  static initializeGlobalListeners() {
    if (this.isGlobalListenerActive)
      return;
    document.addEventListener("mousemove", this.handleGlobalMouseMove);
    document.addEventListener("mousemove", (e) => {
      document.documentElement.setAttribute("data-mouse-x", e.clientX.toString());
      document.documentElement.setAttribute("data-mouse-y", e.clientY.toString());
    });
    document.addEventListener("visibilitychange", this.handleVisibilityChange);
    document.addEventListener("click", this.handleGlobalClick);
    this.isGlobalListenerActive = true;
  }
  static startSafetyTimer() {
    if (this.safetyTimer) {
      clearTimeout(this.safetyTimer);
    }
    this.safetyTimer = setTimeout(() => {
      if (this.isPreviewVisible) {
        console.log("[SystemSculpt] Preview safety timeout triggered - hiding preview");
        this.hideAllPreviews();
      }
    }, this.MAX_PREVIEW_DURATION);
  }
  static hideAllPreviews() {
    if (this.hoverTimer) {
      clearTimeout(this.hoverTimer);
      this.hoverTimer = null;
    }
    if (this.safetyTimer) {
      clearTimeout(this.safetyTimer);
      this.safetyTimer = null;
    }
    if (this.markdownPreview) {
      this.markdownPreview.classList.remove("systemsculpt-visible");
      this.isPreviewVisible = false;
      this.currentPreviewPath = null;
    }
  }
  static attachHoverPreview(app, el, filePath, providerType = "systemsculpt") {
    this.initializeGlobalListeners();
    if (!this.markdownPreview) {
      this.markdownPreview = document.body.createDiv({ cls: "systemsculpt-preview systemsculpt-markdown-preview" });
      this.markdownPreview.style.pointerEvents = "auto";
    }
    this.activeElements.add(el);
    let isElementPreviewVisible = false;
    let lastEvent;
    const showPreview = async (e) => {
      const { previewCache, fileModCache } = this.getCacheForProvider(providerType);
      lastEvent = e;
      if (this.hoverTimer) {
        clearTimeout(this.hoverTimer);
      }
      this.hoverTimer = setTimeout(async () => {
        if (isElementPreviewVisible && this.currentPreviewPath === filePath) {
          positionPreview(lastEvent);
          return;
        }
        const file = app.vault.getAbstractFileByPath(filePath);
        if (!(file instanceof import_obsidian63.TFile))
          return;
        if (file.stat.size > this.MAX_FILE_SIZE_BYTES) {
          console.log(`[SystemSculpt] File too large for preview: ${file.path} (${file.stat.size} bytes)`);
          this.markdownPreview.empty();
          this.markdownPreview.createDiv({ cls: "systemsculpt-preview-header", text: file.name });
          this.markdownPreview.createDiv({
            cls: "systemsculpt-preview-error",
            text: `This file is too large to preview (${Math.round(file.stat.size / 1024)}KB).
Open the file to view its contents.`
          });
          this.currentPreviewPath = filePath;
          positionPreview(lastEvent);
          this.markdownPreview.classList.add("systemsculpt-visible");
          isElementPreviewVisible = true;
          this.isPreviewVisible = true;
          previewCache.set(filePath, this.markdownPreview.innerHTML);
          fileModCache.set(filePath, file.stat.mtime);
          this.startSafetyTimer();
          return;
        }
        const cachedModTime = fileModCache.get(filePath);
        const currentModTime = file.stat.mtime;
        const hasChanged = cachedModTime !== currentModTime;
        if (previewCache.has(filePath) && !hasChanged) {
          console.log(`[SystemSculpt] Using cached preview for: ${filePath} (${providerType} provider)`);
          this.markdownPreview.innerHTML = previewCache.get(filePath);
        } else {
          this.markdownPreview.empty();
          this.markdownPreview.createDiv({ cls: "systemsculpt-preview-header", text: file.name });
          try {
            const content = await app.vault.read(file);
            let displayContent = content;
            let isTruncated = false;
            if (content.length > this.MAX_PREVIEW_CONTENT_LENGTH) {
              displayContent = content.substring(0, this.MAX_PREVIEW_CONTENT_LENGTH);
              isTruncated = true;
              console.log(`[SystemSculpt] Truncating large file preview: ${file.path} (${content.length} chars)`);
            }
            const renderPromise = import_obsidian63.MarkdownRenderer.renderMarkdown(displayContent, this.markdownPreview, file.path, new import_obsidian63.Component());
            await Promise.race([
              renderPromise,
              new Promise((_, reject) => {
                setTimeout(() => reject(new Error("Preview render timeout")), this.MAX_PREVIEW_RENDER_TIME);
              })
            ]);
            if (isTruncated) {
              const truncationNotice = this.markdownPreview.createDiv({
                cls: "systemsculpt-preview-truncation-notice",
                text: `This preview is truncated. The file is too large to preview completely.`
              });
            }
          } catch (err) {
            console.error("[SystemSculpt] Failed to load markdown preview:", err);
            this.markdownPreview.createDiv({
              cls: "systemsculpt-preview-error",
              text: `Error loading preview: ${err.message || "Unknown error"}`
            });
          }
          previewCache.set(filePath, this.markdownPreview.innerHTML);
          fileModCache.set(filePath, file.stat.mtime);
        }
        this.currentPreviewPath = filePath;
        positionPreview(lastEvent);
        this.markdownPreview.classList.add("systemsculpt-visible");
        isElementPreviewVisible = true;
        this.isPreviewVisible = true;
        this.startSafetyTimer();
      }, 0);
    };
    const hidePreview = () => {
      if (this.hoverTimer) {
        clearTimeout(this.hoverTimer);
        this.hoverTimer = null;
      }
      setTimeout(() => {
        const mousePos = {
          x: document.documentElement.getAttribute("data-mouse-x") ? parseInt(document.documentElement.getAttribute("data-mouse-x")) : 0,
          y: document.documentElement.getAttribute("data-mouse-y") ? parseInt(document.documentElement.getAttribute("data-mouse-y")) : 0
        };
        setTimeout(() => {
          if (this.markdownPreview && isElementPreviewVisible) {
            const rect = this.markdownPreview.getBoundingClientRect();
            const isOverPreview = mousePos.x >= rect.left && mousePos.x <= rect.right && mousePos.y >= rect.top && mousePos.y <= rect.bottom;
            const elRect = el.getBoundingClientRect();
            const isOverElement = mousePos.x >= elRect.left && mousePos.x <= elRect.right && mousePos.y >= elRect.top && mousePos.y <= elRect.bottom;
            if (!isOverPreview && !isOverElement) {
              this.markdownPreview.classList.remove("systemsculpt-visible");
              isElementPreviewVisible = false;
              this.isPreviewVisible = false;
              this.currentPreviewPath = null;
            }
          }
        }, 0);
      }, 0);
    };
    const positionPreview = (e) => {
      if (!this.markdownPreview)
        return;
      const { clientX: x, clientY: y } = e;
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const previewEl = this.markdownPreview;
      const prevDisplay = previewEl.style.display;
      const prevVisibility = previewEl.style.visibility;
      previewEl.style.visibility = "hidden";
      previewEl.style.display = "block";
      previewEl.style.left = "-9999px";
      previewEl.style.top = "-9999px";
      const { width: previewWidth, height: previewHeight } = previewEl.getBoundingClientRect();
      previewEl.style.display = prevDisplay;
      previewEl.style.visibility = prevVisibility;
      const offset = 16;
      let posX = x + offset;
      let posY = y + offset;
      if (posX + previewWidth > viewportWidth) {
        posX = Math.max(0, x - previewWidth - offset);
      }
      if (posY + previewHeight > viewportHeight) {
        posY = Math.max(0, y - previewHeight - offset);
      }
      previewEl.style.left = `${posX}px`;
      previewEl.style.top = `${posY}px`;
    };
    el.addEventListener("mouseenter", showPreview);
    el.addEventListener("mousemove", (e) => {
      lastEvent = e;
      if (isElementPreviewVisible) {
        positionPreview(lastEvent);
      }
    });
    el.addEventListener("mouseleave", hidePreview);
    this.markdownPreview.addEventListener("mouseleave", hidePreview);
    return () => {
      this.activeElements.delete(el);
    };
  }
  static cleanup() {
    document.removeEventListener("mousemove", this.handleGlobalMouseMove);
    document.removeEventListener("visibilitychange", this.handleVisibilityChange);
    document.removeEventListener("click", this.handleGlobalClick);
    if (this.hoverTimer) {
      clearTimeout(this.hoverTimer);
      this.hoverTimer = null;
    }
    if (this.safetyTimer) {
      clearTimeout(this.safetyTimer);
      this.safetyTimer = null;
    }
    if (this.markdownPreview) {
      this.markdownPreview.remove();
      this.markdownPreview = null;
    }
    this.isPreviewVisible = false;
    this.currentPreviewPath = null;
    this.activeElements.clear();
    this.isGlobalListenerActive = false;
    this.systemSculptPreviewCache.clear();
    this.customProviderPreviewCache.clear();
    this.systemSculptFileModCache.clear();
    this.customProviderFileModCache.clear();
    document.documentElement.removeAttribute("data-mouse-x");
    document.documentElement.removeAttribute("data-mouse-y");
  }
};
var PreviewService = _PreviewService;
PreviewService.markdownPreview = null;
PreviewService.systemSculptPreviewCache = new Map();
PreviewService.customProviderPreviewCache = new Map();
PreviewService.systemSculptFileModCache = new Map();
PreviewService.customProviderFileModCache = new Map();
PreviewService.hoverTimer = null;
PreviewService.safetyTimer = null;
PreviewService.currentPreviewPath = null;
PreviewService.isPreviewVisible = false;
PreviewService.activeElements = new Set();
PreviewService.isGlobalListenerActive = false;
PreviewService.MAX_PREVIEW_DURATION = 1e4;
PreviewService.MAX_PREVIEW_CONTENT_LENGTH = 5e3;
PreviewService.MAX_PREVIEW_RENDER_TIME = 500;
PreviewService.MAX_FILE_SIZE_BYTES = 1e5;
PreviewService.handleGlobalMouseMove = (0, import_obsidian63.debounce)((e) => {
  if (!_PreviewService.isPreviewVisible)
    return;
  const previewEl = _PreviewService.markdownPreview;
  if (!previewEl)
    return;
  const rect = previewEl.getBoundingClientRect();
  const isOverPreview = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
  let isOverActiveElement = false;
  _PreviewService.activeElements.forEach((el) => {
    const elRect = el.getBoundingClientRect();
    if (e.clientX >= elRect.left && e.clientX <= elRect.right && e.clientY >= elRect.top && e.clientY <= elRect.bottom) {
      isOverActiveElement = true;
    }
  });
  if (!isOverPreview && !isOverActiveElement) {
    _PreviewService.hideAllPreviews();
  }
}, 16);
PreviewService.handleVisibilityChange = () => {
  if (document.hidden) {
    _PreviewService.hideAllPreviews();
  }
};
PreviewService.handleGlobalClick = (e) => {
  if (!_PreviewService.isPreviewVisible)
    return;
  const previewEl = _PreviewService.markdownPreview;
  if (!previewEl)
    return;
  const rect = previewEl.getBoundingClientRect();
  const isOnPreview = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
  let isOnActiveElement = false;
  _PreviewService.activeElements.forEach((el) => {
    const elRect = el.getBoundingClientRect();
    if (e.clientX >= elRect.left && e.clientX <= elRect.right && e.clientY >= elRect.top && e.clientY <= elRect.bottom) {
      isOnActiveElement = true;
    }
  });
  if (!isOnPreview && !isOnActiveElement) {
    _PreviewService.hideAllPreviews();
  }
};

// src/utils/vaultStructure.ts
var import_obsidian64 = __toModule(require("obsidian"));
var VaultStructureGenerator = class {
  constructor(app) {
    this.defaultExcludePatterns = [
      ".obsidian",
      ".git",
      "node_modules",
      ".trash",
      ".DS_Store"
    ];
    this.filesProcessed = 0;
    this.foldersProcessed = 0;
    this.PERFORMANCE_WARNING_THRESHOLD = 5e3;
    this.app = app;
  }
  generateDirectoryStructure() {
    const TARGET_TOKENS = 2e3;
    const root = this.app.vault.getRoot();
    let currentDepth = 1;
    let lastValidOutput = "";
    let currentOutput = "";
    while (currentDepth <= 10) {
      currentOutput = this.generateTreeAtDepth(root, currentDepth);
      const tokens = Math.ceil(currentOutput.length / 4);
      if (tokens > TARGET_TOKENS) {
        break;
      }
      lastValidOutput = currentOutput;
      currentDepth++;
    }
    return lastValidOutput || currentOutput;
  }
  generateTreeAtDepth(root, maxDepth) {
    let output = "\u{1F4C1} Vault Structure (Directories Only)\n";
    output += "\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n";
    const rootFolders = root.children.filter((child) => child instanceof import_obsidian64.TFolder && !this.defaultExcludePatterns.includes(child.name)).sort((a, b) => a.name.localeCompare(b.name));
    rootFolders.forEach((folder, index) => {
      const isLast = index === rootFolders.length - 1;
      output += this.renderFolderTree(folder, "", isLast, 1, maxDepth);
    });
    output += "\n";
    output += `Total: ${rootFolders.length} root directories (depth: ${maxDepth})`;
    return output;
  }
  renderFolderTree(folder, prefix, isLast, currentDepth, maxDepth) {
    const connector = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
    const extension = isLast ? "    " : "\u2502   ";
    const counts = this.countSubdirectoriesAndFiles(folder);
    let line = `${prefix}${connector}\u{1F4C2} ${folder.name}`;
    if (currentDepth >= maxDepth || counts.subdirs === 0) {
      line += ` (${counts.subdirs} subdirs, ${counts.files} files)`;
    }
    line += "\n";
    if (currentDepth < maxDepth) {
      const subfolders = folder.children.filter((child) => child instanceof import_obsidian64.TFolder && !this.defaultExcludePatterns.includes(child.name)).sort((a, b) => a.name.localeCompare(b.name));
      subfolders.forEach((subfolder, index) => {
        const subIsLast = index === subfolders.length - 1;
        line += this.renderFolderTree(subfolder, prefix + extension, subIsLast, currentDepth + 1, maxDepth);
      });
    }
    return line;
  }
  countSubdirectoriesAndFiles(folder) {
    let subdirs = 0;
    let files = 0;
    for (const child of folder.children) {
      if (child instanceof import_obsidian64.TFolder && !this.defaultExcludePatterns.includes(child.name)) {
        subdirs++;
        const childCounts = this.countSubdirectoriesAndFiles(child);
        subdirs += childCounts.subdirs;
        files += childCounts.files;
      } else if (child instanceof import_obsidian64.TFile) {
        files++;
      }
    }
    return { subdirs, files };
  }
  generateTree(options = {}) {
    return this.generateDirectoryStructure();
  }
  generateCompactTree(options = {}) {
    const {
      maxDepth = 2,
      excludePatterns = this.defaultExcludePatterns,
      includeDotFolders = false,
      maxFolders = 50
    } = options;
    this.foldersProcessed = 0;
    const rootFolder = this.app.vault.getRoot();
    const stats = this.calculateQuickStats(rootFolder, excludePatterns, includeDotFolders);
    let tree = `\u{1F4C1} Vault (${stats.fileCount} files)
`;
    const folders = rootFolder.children.filter((child) => child instanceof import_obsidian64.TFolder && this.shouldInclude(child, excludePatterns, includeDotFolders)).sort((a, b) => a.name.localeCompare(b.name)).slice(0, 20);
    folders.forEach((folder, index) => {
      if (this.foldersProcessed >= maxFolders)
        return;
      const isLast = index === folders.length - 1;
      const folderStats = this.calculateQuickStats(folder, excludePatterns, includeDotFolders, 100);
      tree += this.renderCompactFolder(folder, "", isLast, 1, maxDepth, excludePatterns, folderStats.fileCount, includeDotFolders, maxFolders);
    });
    return tree;
  }
  generateCompactSummary(stats) {
    const topFolders = this.getTopLevelFolders();
    let summary = `\u{1F4C1} Large Vault Summary (${stats.fileCount.toLocaleString()} files, ${stats.folderCount.toLocaleString()} folders)

`;
    summary += `Top-level folders:
`;
    topFolders.slice(0, 10).forEach((folder, index) => {
      const folderStats = this.calculateQuickStats(folder, this.defaultExcludePatterns, false);
      summary += `\u251C\u2500\u2500 \u{1F4C2} ${folder.name} (${folderStats.fileCount} files)
`;
    });
    if (topFolders.length > 10) {
      summary += `\u2514\u2500\u2500 ... and ${topFolders.length - 10} more folders
`;
    }
    summary += `
Note: Full directory tree disabled for performance. Use Agent Mode with filesystem tools for detailed exploration.`;
    return summary;
  }
  calculateQuickStats(folder, excludePatterns, includeDotFolders, maxCount = 1e4) {
    let fileCount = 0;
    let folderCount = 0;
    let totalProcessed = 0;
    const processFolder = (f) => {
      if (totalProcessed > maxCount)
        return;
      for (const child of f.children) {
        if (totalProcessed > maxCount)
          break;
        if (!this.shouldInclude(child, excludePatterns, includeDotFolders))
          continue;
        totalProcessed++;
        if (child instanceof import_obsidian64.TFolder) {
          folderCount++;
          processFolder(child);
        } else {
          fileCount++;
        }
      }
    };
    processFolder(folder);
    return { fileCount, folderCount };
  }
  getTopLevelFolders() {
    const root = this.app.vault.getRoot();
    return root.children.filter((child) => child instanceof import_obsidian64.TFolder && !child.name.startsWith(".")).sort((a, b) => a.name.localeCompare(b.name));
  }
  renderNode(node, prefix, isLast, depth, maxDepth, excludePatterns, includeFileCounts, includeDotFolders, maxFiles, maxFolders) {
    if (depth > maxDepth || this.foldersProcessed >= maxFolders || this.filesProcessed >= maxFiles) {
      return "";
    }
    const connector = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
    const extension = isLast ? "    " : "\u2502   ";
    let line = prefix + connector;
    if (node instanceof import_obsidian64.TFolder) {
      this.foldersProcessed++;
      const stats = includeFileCounts ? this.calculateQuickStats(node, excludePatterns, includeDotFolders, 100) : null;
      const fileCountStr = stats ? ` (${stats.fileCount} files)` : "";
      line += `\u{1F4C2} ${node.name}${fileCountStr}
`;
      if (depth < maxDepth && this.foldersProcessed < maxFolders) {
        const children = node.children.filter((child) => this.shouldInclude(child, excludePatterns, includeDotFolders)).sort((a, b) => {
          if (a instanceof import_obsidian64.TFolder && !(b instanceof import_obsidian64.TFolder))
            return -1;
          if (!(a instanceof import_obsidian64.TFolder) && b instanceof import_obsidian64.TFolder)
            return 1;
          return a.name.localeCompare(b.name);
        }).slice(0, 20);
        children.forEach((child, index) => {
          if (this.foldersProcessed >= maxFolders || this.filesProcessed >= maxFiles) {
            return;
          }
          const childIsLast = index === children.length - 1;
          line += this.renderNode(child, prefix + extension, childIsLast, depth + 1, maxDepth, excludePatterns, includeFileCounts, includeDotFolders, maxFiles, maxFolders);
        });
        if (node.children.length > children.length) {
          line += prefix + extension + `\u2514\u2500\u2500 ... (${node.children.length - children.length} more items)
`;
        }
      } else if (node.children.length > 0) {
        line += prefix + extension + "\u2514\u2500\u2500 ...\n";
      }
    } else {
      this.filesProcessed++;
      if (depth <= 2) {
        const icon = node instanceof import_obsidian64.TFile ? this.getFileIcon(node.extension) : "\u{1F4C4}";
        line += `${icon} ${node.name}
`;
      }
    }
    return line;
  }
  renderCompactFolder(folder, prefix, isLast, depth, maxDepth, excludePatterns, fileCount, includeDotFolders, maxFolders) {
    if (this.foldersProcessed >= maxFolders)
      return "";
    this.foldersProcessed++;
    const connector = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
    const extension = isLast ? "    " : "\u2502   ";
    let line = prefix + connector + `\u{1F4C2} ${folder.name} (${fileCount})
`;
    if (depth < maxDepth && this.foldersProcessed < maxFolders) {
      const subfolders = folder.children.filter((child) => child instanceof import_obsidian64.TFolder && this.shouldInclude(child, excludePatterns, includeDotFolders)).sort((a, b) => a.name.localeCompare(b.name)).slice(0, 10);
      subfolders.forEach((subfolder, index) => {
        if (this.foldersProcessed >= maxFolders)
          return;
        const childIsLast = index === subfolders.length - 1;
        const subfolderStats = this.calculateQuickStats(subfolder, excludePatterns, includeDotFolders, 50);
        line += this.renderCompactFolder(subfolder, prefix + extension, childIsLast, depth + 1, maxDepth, excludePatterns, subfolderStats.fileCount, includeDotFolders, maxFolders);
      });
    }
    return line;
  }
  shouldInclude(file, excludePatterns, includeDotFolders) {
    if (!includeDotFolders && file.name.startsWith(".")) {
      return false;
    }
    for (const pattern of excludePatterns) {
      if (file.path.includes(pattern) || file.name === pattern) {
        return false;
      }
    }
    return true;
  }
  getFileIcon(extension) {
    const iconMap = {
      "md": "\u{1F4DD}",
      "png": "\u{1F5BC}\uFE0F",
      "jpg": "\u{1F5BC}\uFE0F",
      "jpeg": "\u{1F5BC}\uFE0F",
      "gif": "\u{1F5BC}\uFE0F",
      "svg": "\u{1F5BC}\uFE0F",
      "pdf": "\u{1F4C4}",
      "mp3": "\u{1F3B5}",
      "mp4": "\u{1F3AC}",
      "zip": "\u{1F4E6}",
      "json": "\u{1F4CB}",
      "js": "\u{1F4DC}",
      "ts": "\u{1F4DC}",
      "css": "\u{1F3A8}",
      "html": "\u{1F310}"
    };
    return iconMap[extension.toLowerCase()] || "\u{1F4C4}";
  }
};

// src/views/chatview/FileContextManager.ts
var FileContextManager = class extends import_obsidian65.Component {
  constructor(options) {
    super();
    this.contextFiles = new Set();
    this.processingStatus = null;
    this.processingFiles = new Map();
    this.processingTimeouts = new Map();
    this.maxProcessingDuration = 6e4;
    this.processingCleanupTimeouts = new Map();
    this.syncStatusEl = null;
    this.isSyncing = false;
    this.includeVaultStructure = false;
    this.vaultStructureCache = null;
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
      }
    };
    this.app = options.app;
    this.onContextChange = options.onContextChange;
    this.sculptService = options.sculptService;
    this.plugin = options.plugin;
    this.documentProcessingService = DocumentProcessingService.getInstance(this.app, this.plugin);
    this.drawer = new DrawerComponent({
      container: options.container,
      title: options.title || "Files"
    });
    this.contextPanel = this.drawer.getDrawer();
    document.addEventListener("visibilitychange", this.handleVisibilityChange);
    this.setupContextPanel();
    this.initializeProcessingStatus();
  }
  initializeProcessingStatus() {
    this.processingStatus = this.contextPanel.createEl("div", {
      cls: "systemsculpt-processing-status"
    });
    this.processingStatus.style.display = "none";
  }
  updateProcessingStatus(file, status, icon, remove = false, details) {
    const fileId = file.path;
    let statusEl = this.processingFiles.get(fileId);
    const existingTimeout = this.processingTimeouts.get(fileId);
    if (existingTimeout) {
      clearTimeout(existingTimeout);
      this.processingTimeouts.delete(fileId);
    }
    const existingCleanupTimeout = this.processingCleanupTimeouts.get(fileId);
    if (existingCleanupTimeout) {
      clearTimeout(existingCleanupTimeout);
      this.processingCleanupTimeouts.delete(fileId);
    }
    if ((remove || !status) && statusEl) {
      statusEl.remove();
      this.processingFiles.delete(fileId);
    } else if (!statusEl && !remove && this.processingStatus) {
      statusEl = this.processingStatus.createEl("div", {
        cls: "systemsculpt-file-status"
      });
      if (status.includes("Chunk") || status.includes("chunk")) {
        statusEl.addClass("systemsculpt-status-chunking");
      } else if (status.includes("Transcribing") || status.includes("Process")) {
        statusEl.addClass("systemsculpt-status-processing");
      } else if (status.includes("Upload")) {
        statusEl.addClass("systemsculpt-status-uploading");
      } else if (status.includes("success") || status === "Added successfully!" || status.includes("complete")) {
        statusEl.addClass("systemsculpt-status-success");
      } else if (status.includes("Error") || status.includes("error") || status.includes("failed")) {
        statusEl.addClass("systemsculpt-status-error");
      }
      const iconEl = statusEl.createSpan({
        cls: "systemsculpt-status-icon"
      });
      (0, import_obsidian65.setIcon)(iconEl, icon);
      const statusTextContainer = statusEl.createDiv({
        cls: "systemsculpt-status-content"
      });
      statusTextContainer.createSpan({
        text: `${file.basename}: ${status}`,
        cls: "systemsculpt-status-text"
      });
      if (details) {
        statusTextContainer.createDiv({
          cls: "systemsculpt-status-details",
          text: details
        });
      }
      this.processingFiles.set(fileId, statusEl);
      if (status.includes("Processing") || status.includes("Uploading") || status.includes("Downloading")) {
        const timeout = setTimeout(() => {
          this.updateProcessingStatus(file, "Operation timed out after 1 minute", "alert-circle", true);
          new import_obsidian65.Notice(`Processing of ${file.basename} timed out after 1 minute`);
        }, this.maxProcessingDuration);
        this.processingTimeouts.set(fileId, timeout);
      }
    } else if (statusEl && !remove) {
      statusEl.empty();
      statusEl.removeClass("systemsculpt-status-chunking", "systemsculpt-status-processing", "systemsculpt-status-uploading", "systemsculpt-status-success", "systemsculpt-status-error");
      if (status.includes("Chunk") || status.includes("chunk")) {
        statusEl.addClass("systemsculpt-status-chunking");
      } else if (status.includes("Transcribing") || status.includes("Process")) {
        statusEl.addClass("systemsculpt-status-processing");
      } else if (status.includes("Upload")) {
        statusEl.addClass("systemsculpt-status-uploading");
      } else if (status.includes("success") || status === "Added successfully!" || status.includes("complete")) {
        statusEl.addClass("systemsculpt-status-success");
      } else if (status.includes("Error") || status.includes("error") || status.includes("failed")) {
        statusEl.addClass("systemsculpt-status-error");
      }
      const iconEl = statusEl.createSpan({
        cls: "systemsculpt-status-icon"
      });
      (0, import_obsidian65.setIcon)(iconEl, icon);
      const statusTextContainer = statusEl.createDiv({
        cls: "systemsculpt-status-content"
      });
      statusTextContainer.createSpan({
        text: `${file.basename}: ${status}`,
        cls: "systemsculpt-status-text"
      });
      if (details) {
        statusTextContainer.createDiv({
          cls: "systemsculpt-status-details",
          text: details
        });
      }
    }
    if (this.processingStatus) {
      this.processingStatus.style.display = this.processingFiles.size > 0 ? "block" : "none";
    }
    if (remove || status.includes("successfully") || status.includes("completed") || status.includes("Error:") || status.includes("timed out")) {
      const cleanupTimeout = setTimeout(() => {
        this.updateProcessingStatus(file, "", "", true);
        this.processingCleanupTimeouts.delete(fileId);
      }, 2e3);
      this.processingCleanupTimeouts.set(fileId, cleanupTimeout);
    }
  }
  setupContextPanel() {
    const titleEl = this.contextPanel.querySelector(".systemsculpt-drawer-title");
    if (!titleEl)
      return;
    const contextCount = titleEl.createSpan({
      cls: "systemsculpt-drawer-count",
      text: "0"
    });
    this.syncStatusEl = titleEl.createSpan({
      cls: "systemsculpt-sync-status synced"
    });
    (0, import_obsidian65.setIcon)(this.syncStatusEl, "check");
    this.updateContextPanel();
  }
  updateSyncStatus(syncing = false) {
    if (!this.syncStatusEl)
      return;
    this.isSyncing = syncing;
    this.syncStatusEl.empty();
    if (syncing) {
      this.syncStatusEl.removeClass("synced");
      this.syncStatusEl.addClass("syncing");
      (0, import_obsidian65.setIcon)(this.syncStatusEl, "loader-2");
    } else {
      this.syncStatusEl.removeClass("syncing");
      this.syncStatusEl.addClass("synced");
      (0, import_obsidian65.setIcon)(this.syncStatusEl, "check");
    }
  }
  async checkSyncStatus() {
    if (this.contextFiles.size === 0) {
      this.updateSyncStatus(false);
      return;
    }
    this.updateSyncStatus(true);
    this.updateSyncStatus(false);
  }
  triggerFileChangeFlash() {
    const header = this.contextPanel.querySelector(".systemsculpt-drawer-header");
    if (!header)
      return;
    header.classList.remove("files-changed");
    header.offsetHeight;
    header.classList.add("files-changed");
    setTimeout(() => {
      header.classList.remove("files-changed");
    }, 2e3);
  }
  updateContextPanel() {
    var _a;
    if (!this.contextPanel)
      return;
    const header = this.contextPanel.querySelector(".systemsculpt-drawer-header");
    const content = this.contextPanel.querySelector(".systemsculpt-drawer-content");
    const count = this.contextPanel.querySelector(".systemsculpt-drawer-count");
    if (!header || !content || !count)
      return;
    const totalCount = this.contextFiles.size + (this.includeVaultStructure ? 1 : 0);
    count.textContent = totalCount.toString();
    content.empty();
    const buttonContainer = content.createEl("div", {
      cls: "systemsculpt-drawer-buttons-container"
    });
    new import_obsidian66.ButtonComponent(buttonContainer).setButtonText("Add Context Files").setIcon("plus").setClass("systemsculpt-add-context-button").onClick((e) => {
      e.stopPropagation();
      this.addContextFile();
    });
    const vaultToggleContainer = content.createEl("div", {
      cls: "systemsculpt-vault-structure-toggle"
    });
    const toggleEl = vaultToggleContainer.createEl("label", {
      cls: "systemsculpt-toggle-label"
    });
    const checkbox = toggleEl.createEl("input", {
      type: "checkbox",
      cls: "systemsculpt-toggle-checkbox"
    });
    checkbox.checked = this.includeVaultStructure;
    checkbox.addEventListener("change", async () => {
      await this.toggleVaultStructure();
    });
    const toggleText = toggleEl.createEl("span", {
      cls: "systemsculpt-toggle-text"
    });
    (0, import_obsidian65.setIcon)(toggleText.createSpan({ cls: "systemsculpt-toggle-icon" }), "folder-tree");
    toggleText.createSpan({ text: "Include vault structure" });
    if (this.contextFiles.size > 0 || this.includeVaultStructure) {
      new import_obsidian66.ButtonComponent(buttonContainer).setButtonText("Clear All").setWarning().setClass("systemsculpt-clear-all-button").onClick(async (e) => {
        e.stopPropagation();
        await this.clearAllContextFiles();
        if (this.includeVaultStructure) {
          await this.toggleVaultStructure();
        }
      });
    }
    if (this.includeVaultStructure) {
      const vaultItem = content.createEl("div", {
        cls: "systemsculpt-vault-structure-item"
      });
      const itemHeader = vaultItem.createEl("div", {
        cls: "systemsculpt-vault-item-header"
      });
      (0, import_obsidian65.setIcon)(itemHeader.createSpan({ cls: "systemsculpt-vault-icon" }), "folder-tree");
      itemHeader.createEl("span", {
        cls: "systemsculpt-vault-title",
        text: "\u{1F4C1} Vault Structure"
      });
      vaultItem.setAttribute("title", "Click to preview vault structure");
      vaultItem.addEventListener("click", () => {
        this.showVaultStructurePreview();
      });
    }
    if (this.contextFiles.size === 0 && !this.includeVaultStructure) {
      content.createEl("div", {
        cls: "systemsculpt-drawer-empty",
        text: "No context files added yet."
      });
      return;
    }
    const categories = {
      text: {
        label: "Text Files",
        files: [],
        extensions: ["md", "txt", "markdown"]
      },
      images: {
        label: "Images",
        files: [],
        extensions: ["jpg", "jpeg", "png", "gif", "webp", "svg"]
      },
      audio: {
        label: "Audio Files",
        files: [],
        extensions: ["mp3", "wav", "ogg", "m4a"]
      },
      documents: {
        label: "Documents",
        files: [],
        extensions: ["doc", "docx", "ppt", "pptx", "xls", "xlsx", "pdf"]
      }
    };
    const documentGroups = new Map();
    const nonExtractedFiles = new Set();
    for (const filePath of this.contextFiles) {
      const cleanPath = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
      if (cleanPath.includes("/Extractions/")) {
        const parts = cleanPath.split("/");
        const extractionDirIndex = parts.indexOf("Extractions");
        if (extractionDirIndex >= 0 && extractionDirIndex + 1 < parts.length) {
          const sourceDoc = parts[extractionDirIndex + 1];
          if (!documentGroups.has(sourceDoc)) {
            documentGroups.set(sourceDoc, new Set());
          }
          (_a = documentGroups.get(sourceDoc)) == null ? void 0 : _a.add(filePath);
        } else {
          nonExtractedFiles.add(filePath);
        }
      } else {
        nonExtractedFiles.add(filePath);
      }
    }
    this.categorizeFiles(Array.from(nonExtractedFiles), categories);
    for (const categoryKey of ["text", "images", "audio"]) {
      const category = categories[categoryKey];
      if (category.files.length > 0) {
        this.renderCategory(content, category);
      }
    }
    if (categories.documents.files.length > 0 || documentGroups.size > 0) {
      content.createEl("div", {
        cls: "systemsculpt-drawer-category",
        text: "Documents"
      });
      this.renderFiles(content, categories.documents.files);
      for (const [sourceDoc, extractedFiles] of documentGroups) {
        content.createEl("div", {
          cls: "systemsculpt-drawer-category",
          text: `\u{1F4C4} ${sourceDoc} Extractions`
        });
        const extractedCategories = this.createCategories();
        this.categorizeFiles(Array.from(extractedFiles), extractedCategories);
        const textFiles = extractedCategories.text.files;
        if (textFiles.length > 0) {
          this.renderFiles(content, textFiles);
        }
        const imageFiles = extractedCategories.images.files;
        if (imageFiles.length > 0) {
          this.renderFiles(content, imageFiles);
        }
        const otherFiles = [
          ...extractedCategories.audio.files,
          ...extractedCategories.documents.files
        ];
        if (otherFiles.length > 0) {
          this.renderFiles(content, otherFiles);
        }
      }
    }
  }
  createCategories() {
    return {
      text: {
        label: "Text Files",
        files: [],
        extensions: ["md", "txt", "markdown"]
      },
      images: {
        label: "Images",
        files: [],
        extensions: ["jpg", "jpeg", "png", "gif", "webp", "svg"]
      },
      audio: {
        label: "Audio Files",
        files: [],
        extensions: ["mp3", "wav", "ogg", "m4a"]
      },
      documents: {
        label: "Documents",
        files: [],
        extensions: ["doc", "docx", "ppt", "pptx", "xls", "xlsx", "pdf"]
      }
    };
  }
  categorizeFiles(files, categories) {
    for (const filePath of files) {
      const linkText = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
      try {
        let resolvedFile = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
        if (!resolvedFile) {
          const directResult = this.app.vault.getAbstractFileByPath(linkText);
          if (directResult instanceof import_obsidian65.TFile) {
            resolvedFile = directResult;
          }
        }
        if (!resolvedFile && !linkText.endsWith(".md")) {
          const withExtension = this.app.vault.getAbstractFileByPath(`${linkText}.md`);
          if (withExtension instanceof import_obsidian65.TFile) {
            resolvedFile = withExtension;
          }
        }
        if (resolvedFile instanceof import_obsidian65.TFile) {
          const extension = resolvedFile.extension.toLowerCase();
          let categoryFound = false;
          for (const [category, info] of Object.entries(categories)) {
            if (info.extensions.includes(extension)) {
              info.files.push({ file: resolvedFile, path: filePath, linkText });
              categoryFound = true;
              break;
            }
          }
          if (!categoryFound) {
            categories.documents.files.push({
              file: resolvedFile,
              path: filePath,
              linkText
            });
          }
        } else {
        }
      } catch (error) {
      }
    }
  }
  renderCategory(container, category) {
    if (category.files.length === 0)
      return;
    container.createEl("div", {
      cls: "systemsculpt-drawer-category",
      text: category.label
    });
    this.renderFiles(container, category.files);
  }
  renderFiles(container, files) {
    files.sort((a, b) => a.file.basename.localeCompare(b.file.basename));
    const imagePreview = document.body.createEl("img", {
      cls: "systemsculpt-preview systemsculpt-image-preview"
    });
    const calculatePreviewDimensions = (naturalWidth, naturalHeight, viewportWidth, viewportHeight) => {
      const maxWidth = Math.min(viewportWidth * 0.4, naturalWidth);
      const maxHeight = Math.min(viewportHeight * 0.6, naturalHeight);
      let width = naturalWidth;
      let height = naturalHeight;
      if (width > maxWidth) {
        height = naturalHeight * maxWidth / naturalWidth;
        width = maxWidth;
      }
      if (height > maxHeight) {
        width = naturalWidth * maxHeight / naturalHeight;
        height = maxHeight;
      }
      return { width, height };
    };
    const updatePreviewPosition = (e, previewEl) => {
      if (!previewEl)
        return;
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const rect = previewEl.getBoundingClientRect();
      let x = e.clientX + 16;
      let y = e.clientY + 16;
      if (x + rect.width > viewportWidth) {
        x = e.clientX - rect.width - 16;
      }
      if (y + rect.height > viewportHeight) {
        y = e.clientY - rect.height - 16;
      }
      previewEl.style.left = `${x}px`;
      previewEl.style.top = `${y}px`;
    };
    this.register(() => {
      imagePreview.remove();
    });
    for (const { file, path, linkText } of files) {
      const item = container.createEl("div", {
        cls: "systemsculpt-drawer-item"
      });
      const pathEl = item.createEl("div", {
        cls: "systemsculpt-drawer-item-path"
      });
      const iconContainer = pathEl.createSpan({
        cls: "systemsculpt-file-icon"
      });
      const extension = file.extension.toLowerCase();
      let iconName = "file";
      const link = pathEl.createEl("a", {
        cls: "internal-link",
        text: file.basename,
        attr: {
          href: path,
          "data-href": path
        }
      });
      if (["md", "txt", "markdown"].includes(extension)) {
        iconName = "file-text";
        PreviewService.attachHoverPreview(this.app, item, file.path);
      } else if (["jpg", "jpeg", "png", "gif", "webp", "svg"].includes(extension)) {
        iconName = "image";
        const showImagePreview = async (e) => {
          try {
            const imageFile = this.app.vault.getAbstractFileByPath(file.path);
            if (imageFile instanceof import_obsidian65.TFile) {
              const arrayBuffer = await this.app.vault.readBinary(imageFile);
              const blob = new Blob([arrayBuffer]);
              const url = URL.createObjectURL(blob);
              imagePreview.src = url;
              imagePreview.onload = () => {
                URL.revokeObjectURL(url);
                imagePreview.classList.add("systemsculpt-visible");
                const { width, height } = calculatePreviewDimensions(imagePreview.naturalWidth, imagePreview.naturalHeight, window.innerWidth, window.innerHeight);
                imagePreview.style.width = `${width}px`;
                imagePreview.style.height = `${height}px`;
                updatePreviewPosition(e, imagePreview);
              };
            }
          } catch (error) {
          }
        };
        const hideImagePreview = () => {
          imagePreview.classList.remove("systemsculpt-visible");
          imagePreview.src = "";
          imagePreview.style.width = "";
          imagePreview.style.height = "";
        };
        this.registerDomEvent(item, "mouseenter", showImagePreview);
        this.registerDomEvent(item, "mouseleave", hideImagePreview);
        this.registerDomEvent(item, "mousemove", (e) => updatePreviewPosition(e, imagePreview));
        this.registerDomEvent(imagePreview, "mouseleave", hideImagePreview);
        this.registerDomEvent(this.contextPanel, "mouseleave", hideImagePreview);
      } else if (["mp3", "wav", "ogg", "m4a"].includes(extension)) {
        iconName = "audio-lines";
      } else if (["doc", "docx", "ppt", "pptx", "xls", "xlsx", "pdf"].includes(extension)) {
        iconName = "file";
      }
      (0, import_obsidian65.setIcon)(iconContainer, iconName);
      this.registerDomEvent(link, "click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.app.workspace.openLinkText(linkText, "", true);
      });
      const meta = item.createDiv({ cls: "systemsculpt-context-meta" });
      new import_obsidian66.ButtonComponent(meta).setIcon("x").setTooltip("Remove file").setClass("mod-small").setClass("systemsculpt-remove-button").onClick((e) => {
        e.stopPropagation();
        this.removeContextFile(path);
      });
      const updateMetaInfo = () => {
        const availableWidth = container.offsetWidth - 40;
        const fileNameWidth = link.offsetWidth;
        const removeBtnWidth = 24;
        const remainingWidth = availableWidth - fileNameWidth - removeBtnWidth;
        const existingMeta = meta.querySelectorAll(".systemsculpt-context-type, .systemsculpt-context-size");
        existingMeta.forEach((el) => el.remove());
        if (remainingWidth > 150) {
          if (remainingWidth > 200) {
            const type = meta.createDiv({ cls: "systemsculpt-context-type" });
            type.setText(file.extension.toUpperCase());
          }
          if (remainingWidth > 100) {
          }
        }
      };
      updateMetaInfo();
      const resizeObserver = new ResizeObserver(() => {
        updateMetaInfo();
      });
      resizeObserver.observe(container);
      this.register(() => {
        resizeObserver.disconnect();
      });
    }
  }
  async addContextFile() {
    const modal = new ContextSelectionModal(this.app, async (files) => {
      for (const file of files) {
        try {
          await this.addFileToContext(file);
        } catch (error) {
          this.updateProcessingStatus(file, `Error: ${error instanceof Error ? error.message : String(error)}`, "x-circle", true);
          throw error;
        }
      }
    }, this.plugin);
    modal.open();
  }
  async removeContextFile(filePath) {
    const normalizedPath = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
    this.contextFiles.delete(filePath);
    this.contextFiles.delete(`[[${normalizedPath}]]`);
    this.updateContextPanel();
    await this.onContextChange();
    document.dispatchEvent(new CustomEvent("systemsculpt:context-changed"));
    this.triggerFileChangeFlash();
  }
  async addFileToContext(file) {
    const { DocumentContextManager: DocumentContextManager2 } = await Promise.resolve().then(() => (init_DocumentContextManager(), DocumentContextManager_exports));
    const documentContextManager = DocumentContextManager2.getInstance(this.app, this.plugin);
    await documentContextManager.addFileToContext(file, this, {
      showNotices: true,
      updateUI: true,
      saveChanges: true
    });
  }
  addToContextFiles(wikiLink) {
    if (this.contextFiles.has(wikiLink)) {
      return false;
    }
    this.contextFiles.add(wikiLink);
    this.triggerFileChangeFlash();
    return true;
  }
  hasContextFile(wikiLink) {
    return this.contextFiles.has(wikiLink);
  }
  async removeFromContextFiles(filePath) {
    const normalizedPath = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
    const wikiLink = `[[${normalizedPath}]]`;
    const hadFile = this.contextFiles.has(filePath) || this.contextFiles.has(wikiLink);
    if (hadFile) {
      this.contextFiles.delete(filePath);
      this.contextFiles.delete(wikiLink);
      this.updateContextPanel();
      await this.onContextChange();
      document.dispatchEvent(new CustomEvent("systemsculpt:context-changed"));
      this.triggerFileChangeFlash();
      return true;
    }
    return false;
  }
  async triggerContextChange() {
    await this.onContextChange();
    document.dispatchEvent(new CustomEvent("systemsculpt:context-changed"));
    this.triggerFileChangeFlash();
  }
  getContextFiles() {
    return this.contextFiles;
  }
  getContextFilesWithVaultStructure() {
    const files = new Set(this.contextFiles);
    if (this.includeVaultStructure && this.vaultStructureCache) {
      files.add("@@vault-structure@@");
    }
    return files;
  }
  getVaultStructureContent() {
    return this.includeVaultStructure ? this.vaultStructureCache : null;
  }
  async setContextFiles(files) {
    const validFiles = files.filter((file) => !!file && typeof file === "string");
    const normalizedFiles = validFiles.map((file) => {
      if (!file.startsWith("[[") && !file.endsWith("]]")) {
        return `[[${file}]]`;
      }
      return file;
    });
    const existingFiles = [];
    for (const file of normalizedFiles) {
      if (await this.validateFileExists(file)) {
        existingFiles.push(file);
      }
    }
    this.contextFiles = new Set(existingFiles);
    this.updateContextPanel();
    await this.checkSyncStatus();
  }
  getContainer() {
    return this.contextPanel;
  }
  isVaultStructureIncluded() {
    return this.includeVaultStructure;
  }
  async toggleVaultStructure() {
    this.includeVaultStructure = !this.includeVaultStructure;
    if (this.includeVaultStructure) {
      const generator = new VaultStructureGenerator(this.app);
      this.vaultStructureCache = generator.generateTree();
    }
    this.updateContextPanel();
    await this.onContextChange();
    this.triggerFileChangeFlash();
  }
  getVaultStructure() {
    if (!this.includeVaultStructure)
      return null;
    if (!this.vaultStructureCache) {
      const generator = new VaultStructureGenerator(this.app);
      this.vaultStructureCache = generator.generateTree();
    }
    return this.vaultStructureCache;
  }
  clearVaultStructureCache() {
    this.vaultStructureCache = null;
  }
  showVaultStructurePreview() {
    const structure = this.getVaultStructure();
    if (!structure)
      return;
    const modal = new import_obsidian65.Modal(this.app);
    modal.contentEl.createEl("h2", { text: "Vault Structure Preview" });
    const pre = modal.contentEl.createEl("pre", {
      cls: "systemsculpt-vault-structure-preview"
    });
    pre.textContent = structure;
    modal.open();
  }
  unload() {
    document.removeEventListener("visibilitychange", this.handleVisibilityChange);
    this.processingTimeouts.forEach((timeout) => clearTimeout(timeout));
    this.processingCleanupTimeouts.forEach((timeout) => clearTimeout(timeout));
    this.processingTimeouts.clear();
    this.processingCleanupTimeouts.clear();
    super.unload();
  }
  async clearAllContextFiles() {
    this.contextFiles.clear();
    this.updateContextPanel();
    await this.onContextChange();
    await this.checkSyncStatus();
    this.triggerFileChangeFlash();
    new import_obsidian65.Notice("All context files cleared");
  }
  clearContext() {
    this.contextFiles.clear();
    this.updateContextPanel();
    this.checkSyncStatus();
  }
  async processAudioFile(file, timestamped = false) {
    var _a, _b;
    this.updateProcessingStatus(file, "Transcribing audio...", "loader-2");
    try {
      const progressManager = TranscriptionProgressManager.getInstance();
      const progressHandler = progressManager.createProgressHandler(file, (progress, status, icon, details) => {
        this.updateProcessingStatus(file, status, icon || "loader-2");
      });
      const transcriptionService = TranscriptionService.getInstance(this.plugin);
      const text = await transcriptionService.transcribeFile(file, {
        ...progressHandler,
        timestamped
      });
      const extractionFolder = this.sculptService.extractionsDirectory;
      const baseName = file.basename.replace(/[\\/:*?"<>|]/g, "-").trim();
      const parentPath = extractionFolder ? `${extractionFolder}/${baseName}` : `${(_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : ""}/${baseName}`;
      if (extractionFolder) {
        await this.plugin.directoryManager.ensureDirectoryByKey("extractionsDirectory");
      }
      if (this.plugin.directoryManager) {
        await this.plugin.directoryManager.ensureDirectoryByPath(parentPath);
      } else {
        await this.plugin.createDirectory(parentPath);
      }
      const outputPath = `${parentPath}/${baseName}.md`;
      let finalContent;
      if (this.plugin.settings.cleanTranscriptionOutput) {
        finalContent = text;
      } else {
        finalContent = `# Audio Transcription
Source: ${file.basename}
Transcribed: ${new Date().toISOString()}

${text}`;
      }
      try {
        const existingFile = this.app.vault.getAbstractFileByPath(outputPath);
        if (existingFile instanceof import_obsidian65.TFile) {
          await this.app.vault.modify(existingFile, finalContent);
        } else {
          await this.app.vault.create(outputPath, finalContent);
        }
      } catch (error) {
        throw error;
      }
      this.updateProcessingStatus(file, "Transcription complete!", "check-circle");
      progressManager.handleCompletion(file.path, outputPath, () => {
        this.updateProcessingStatus(file, "Added successfully!", "check-circle", true);
      });
      return outputPath;
    } catch (error) {
      this.updateProcessingStatus(file, `Error: ${error instanceof Error ? error.message : String(error)}`, "x-circle", true);
      throw error;
    }
  }
  async validateFileExists(filePath) {
    const linkText = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
    let resolvedFile = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
    if (!resolvedFile) {
      const directResult = this.app.vault.getAbstractFileByPath(linkText);
      if (directResult instanceof import_obsidian65.TFile) {
        resolvedFile = directResult;
      }
    }
    if (!resolvedFile && !linkText.endsWith(".md")) {
      const withExtension = this.app.vault.getAbstractFileByPath(`${linkText}.md`);
      if (withExtension instanceof import_obsidian65.TFile) {
        resolvedFile = withExtension;
      }
    }
    return resolvedFile instanceof import_obsidian65.TFile;
  }
  async validateAndCleanContextFiles() {
    const validFiles = [];
    let removedCount = 0;
    for (const file of this.contextFiles) {
      if (await this.validateFileExists(file)) {
        validFiles.push(file);
      } else {
        removedCount++;
        console.log(`[FileContextManager] Removing non-existent file from context: ${file}`);
      }
    }
    if (removedCount > 0) {
      this.contextFiles = new Set(validFiles);
      this.updateContextPanel();
      await this.onContextChange();
      new import_obsidian65.Notice(`Removed ${removedCount} non-existent file${removedCount > 1 ? "s" : ""} from context`);
    }
  }
};

// src/views/chatview/ScrollManagerService.ts
var ScrollManagerService = class {
  constructor(config) {
    this.autoScroll = true;
    this.lastScrollHeight = 0;
    this.scrollThreshold = 50;
    this.programmaticScroll = false;
    this.isGenerating = false;
    this.scrollUpdatePending = false;
    this.lastUserScroll = 0;
    this.handleScroll = () => {
      if (this.programmaticScroll)
        return;
      this.lastUserScroll = Date.now();
      const { scrollTop, scrollHeight, clientHeight } = this.container;
      const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
      const wasAutoScroll = this.autoScroll;
      this.autoScroll = distanceFromBottom <= this.scrollThreshold;
      if (wasAutoScroll !== this.autoScroll && this.onAutoScrollChange) {
        this.onAutoScrollChange(this.autoScroll);
      }
    };
    this.container = config.container;
    this.onAutoScrollChange = config.onAutoScrollChange;
    this.lastScrollHeight = this.container.scrollHeight;
    this.mutationObserver = new MutationObserver(() => {
      this.debouncedScrollHeightCheck();
    });
    this.mutationObserver.observe(this.container, {
      childList: true,
      subtree: true,
      characterData: true
    });
    this.container.addEventListener("scroll", this.handleScroll, { passive: true });
  }
  debouncedScrollHeightCheck() {
    if (this.isGenerating && this.scrollUpdatePending) {
      return;
    }
    if (this.isGenerating) {
      this.scrollUpdatePending = true;
      requestAnimationFrame(() => {
        this.checkForScrollHeightChange();
        this.scrollUpdatePending = false;
      });
    } else {
      this.checkForScrollHeightChange();
    }
  }
  checkForScrollHeightChange() {
    const currentScrollHeight = this.container.scrollHeight;
    if (currentScrollHeight > this.lastScrollHeight && this.autoScroll) {
      this.lastScrollHeight = currentScrollHeight;
      if (this.isGenerating) {
        const timeSinceUserScroll = Date.now() - this.lastUserScroll;
        if (timeSinceUserScroll > 1e3) {
          this.smoothScrollToBottom();
        }
      } else {
        this.scrollToBottom();
      }
    } else {
      this.lastScrollHeight = currentScrollHeight;
    }
  }
  forceScrollToBottom() {
    this.autoScroll = true;
    this.scrollToBottom();
    if (this.onAutoScrollChange) {
      this.onAutoScrollChange(true);
    }
  }
  scrollToBottom() {
    this.programmaticScroll = true;
    this.container.scrollTop = this.container.scrollHeight;
    setTimeout(() => {
      this.programmaticScroll = false;
    }, 50);
  }
  smoothScrollToBottom() {
    this.programmaticScroll = true;
    const behavior = this.isGenerating ? "smooth" : "auto";
    this.container.scrollTo({
      top: this.container.scrollHeight,
      behavior
    });
    setTimeout(() => {
      this.programmaticScroll = false;
    }, this.isGenerating ? 300 : 50);
  }
  isAutoScrollEnabled() {
    return this.autoScroll;
  }
  cleanup() {
    this.mutationObserver.disconnect();
    this.container.removeEventListener("scroll", this.handleScroll);
  }
  updateContentHeight() {
  }
  resetScrollState() {
    this.forceScrollToBottom();
  }
  setGenerating(isGenerating) {
    const wasGenerating = this.isGenerating;
    this.isGenerating = isGenerating;
    if (isGenerating && !wasGenerating) {
      this.lastUserScroll = Date.now();
    }
    if (!isGenerating && wasGenerating) {
      this.scrollUpdatePending = false;
      requestAnimationFrame(() => this.checkForScrollHeightChange());
    }
  }
  getScrollState() {
    return {
      scrollTop: this.container.scrollTop,
      isAtBottom: this.autoScroll
    };
  }
  restoreScrollState(state) {
    if (state.isAtBottom) {
      this.scrollToBottom();
    } else {
      this.container.scrollTop = state.scrollTop;
    }
  }
};

// src/views/chatview/InputHandler.ts
var import_obsidian73 = __toModule(require("obsidian"));
init_FileValidator();

// src/views/chatview/SlashCommandMenu.ts
var import_obsidian67 = __toModule(require("obsidian"));
var SlashCommandMenu = class extends import_obsidian67.Component {
  constructor(options) {
    super();
    this.commands = [];
    this.filteredCommands = [];
    this.selectedIndex = 0;
    this.isVisible = false;
    this.plugin = options.plugin;
    this.chatView = options.chatView;
    this.inputElement = options.inputElement;
    this.inputHandler = options.inputHandler;
    this.onClose = options.onClose;
    this.onExecute = options.onExecute;
    this.initializeCommands();
    this.createMenuElement();
    this.setupEventListeners();
  }
  initializeCommands() {
    this.commands = [
      {
        id: "new",
        name: "New Chat",
        description: "Start a new chat conversation",
        icon: "plus-circle",
        execute: async (chatView) => {
          const { workspace } = this.plugin.app;
          const leaf = workspace.getLeaf("tab");
          await leaf.setViewState({
            type: CHAT_VIEW_TYPE,
            state: {
              chatId: "",
              selectedModelId: this.plugin.settings.selectedModelId
            }
          });
          workspace.setActiveLeaf(leaf, { focus: true });
        }
      },
      {
        id: "clear",
        name: "Clear Chat",
        description: "Remove all messages from the current chat",
        icon: "eraser",
        execute: async (chatView) => {
          const confirmModal = new import_obsidian67.Modal(this.plugin.app);
          confirmModal.onOpen = () => {
            const { contentEl } = confirmModal;
            contentEl.createEl("h2", { text: "Clear chat?" });
            contentEl.createEl("p", { text: "This will remove all messages from the current chat." });
            const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
            const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
            cancelBtn.addEventListener("click", () => confirmModal.close());
            const clearBtn = buttonContainer.createEl("button", {
              text: "Clear",
              cls: "mod-warning"
            });
            clearBtn.addEventListener("click", async () => {
              var _a, _b;
              try {
                chatView.messages.splice(0, chatView.messages.length);
                chatView.chatId = "";
                chatView.chatVersion = 0;
                chatView.isFullyLoaded = false;
                chatView.chatContainer.empty();
                (_a = chatView.contextManager) == null ? void 0 : _a.clearContext();
                new import_obsidian67.Notice("Chat cleared");
                (_b = chatView.inputHandler) == null ? void 0 : _b.focus();
              } catch (err) {
                console.error("[SystemSculpt] Failed to clear chat:", err);
                new import_obsidian67.Notice("Failed to clear chat");
              } finally {
                confirmModal.close();
              }
            });
            contentEl.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                clearBtn.click();
              }
            });
            setTimeout(() => clearBtn.focus(), 0);
          };
          confirmModal.open();
        }
      },
      {
        id: "export",
        name: "Export Chat",
        description: "Export chat as markdown note",
        icon: "download",
        execute: async (chatView) => {
          try {
            const markdownContent = await chatView.exportChatAsMarkdown();
            const now = new Date();
            const date = now.toISOString().slice(0, 10);
            const hour = String(now.getHours()).padStart(2, "0");
            const minute = String(now.getMinutes()).padStart(2, "0");
            const filename = `${date} ${hour}-${minute} - Chat Export.md`;
            const chatDirectory = this.plugin.settings.chatsDirectory;
            const filePath = `${chatDirectory}/${filename}`;
            const file = await this.plugin.app.vault.create(filePath, markdownContent);
            new import_obsidian67.Notice(`Chat exported to "${filename}"`, 8e3);
            const leaf = this.plugin.app.workspace.getLeaf(false);
            await leaf.openFile(file);
          } catch (error) {
            console.error("Error exporting chat:", error);
            new import_obsidian67.Notice(`Failed to export chat: ${error instanceof Error ? error.message : String(error)}`, 6e3);
          }
        }
      },
      {
        id: "history",
        name: "Open Chat History",
        description: "Open the chat history file",
        icon: "file-text",
        execute: async (chatView) => {
          await this.inputHandler.handleOpenChatHistoryFile();
        }
      },
      {
        id: "save",
        name: "Save as Note",
        description: "Save chat as a markdown note",
        icon: "file-plus",
        execute: async (chatView) => {
          await this.inputHandler.handleSaveChatAsNote();
        }
      },
      {
        id: "delete",
        name: "Delete This Chat",
        description: "Permanently delete this chat and close the view",
        icon: "trash-2",
        execute: async (chatView) => {
          if (!chatView.chatId) {
            new import_obsidian67.Notice("No chat to delete - this is a new conversation");
            return;
          }
          const confirmModal = new import_obsidian67.Modal(this.plugin.app);
          confirmModal.onOpen = () => {
            const { contentEl } = confirmModal;
            contentEl.createEl("h2", { text: "Delete this chat?" });
            contentEl.createEl("p", {
              text: "This will permanently delete the chat file and close this view. This action cannot be undone."
            });
            const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
            const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
            cancelBtn.addEventListener("click", () => confirmModal.close());
            const deleteBtn = buttonContainer.createEl("button", {
              text: "Delete Chat",
              cls: "mod-warning"
            });
            deleteBtn.addEventListener("click", async () => {
              try {
                const chatDirectory = this.plugin.settings.chatsDirectory;
                const filePath = `${chatDirectory}/${chatView.chatId}.md`;
                const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
                if (file) {
                  await this.plugin.app.vault.trash(file, true);
                  console.log(`[SystemSculpt] Deleted chat file: ${filePath}`);
                }
                if (chatView.leaf) {
                  chatView.leaf.detach();
                  console.log("[SystemSculpt] Closed ChatView after deletion");
                }
                new import_obsidian67.Notice("Chat deleted successfully");
              } catch (err) {
                console.error("[SystemSculpt] Failed to delete chat:", err);
                new import_obsidian67.Notice("Failed to delete chat");
              } finally {
                confirmModal.close();
              }
            });
            contentEl.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                deleteBtn.click();
              }
            });
            setTimeout(() => deleteBtn.focus(), 0);
          };
          confirmModal.open();
        }
      }
    ];
    this.filteredCommands = [...this.commands];
  }
  createMenuElement() {
    this.menuElement = document.createElement("div");
    this.menuElement.className = "systemsculpt-slash-command-menu";
    this.resultsContainer = this.menuElement.createEl("div", { cls: "systemsculpt-slash-results-container" });
    const searchContainer = this.menuElement.createEl("div", { cls: "systemsculpt-slash-search-container" });
    const searchIcon = searchContainer.createEl("div", { cls: "systemsculpt-slash-search-icon" });
    (0, import_obsidian67.setIcon)(searchIcon, "search");
    this.searchInput = searchContainer.createEl("input", {
      cls: "systemsculpt-slash-search-input",
      attr: { placeholder: "Search commands..." }
    });
    this.menuElement.style.display = "none";
    document.body.appendChild(this.menuElement);
  }
  setupEventListeners() {
    this.registerDomEvent(this.searchInput, "input", () => {
      this.filterCommands();
    });
    this.registerDomEvent(this.searchInput, "keydown", (e) => {
      this.handleSearchKeydown(e);
    });
    this.registerDomEvent(document, "click", (e) => {
      if (!this.menuElement.contains(e.target)) {
        this.hide();
      }
    });
  }
  filterCommands() {
    const query = this.searchInput.value.toLowerCase();
    this.filteredCommands = this.commands.filter((cmd) => cmd.name.toLowerCase().includes(query) || cmd.description.toLowerCase().includes(query));
    this.selectedIndex = 0;
    this.renderResults();
  }
  renderResults() {
    this.resultsContainer.empty();
    if (this.filteredCommands.length === 0) {
      const emptyState = this.resultsContainer.createEl("div", { cls: "systemsculpt-slash-empty-state" });
      emptyState.textContent = "No commands found";
      return;
    }
    this.filteredCommands.forEach((command, index) => {
      const item = this.resultsContainer.createEl("div", {
        cls: `systemsculpt-slash-result-item ${index === this.selectedIndex ? "is-selected" : ""}`
      });
      const icon = item.createEl("div", { cls: "systemsculpt-slash-result-icon" });
      (0, import_obsidian67.setIcon)(icon, command.icon);
      const content = item.createEl("div", { cls: "systemsculpt-slash-result-content" });
      const title = content.createEl("div", { cls: "systemsculpt-slash-result-title", text: command.name });
      const description = content.createEl("div", { cls: "systemsculpt-slash-result-description", text: command.description });
      this.registerDomEvent(item, "click", () => {
        this.executeCommand(command);
      });
      this.registerDomEvent(item, "mouseover", () => {
        this.selectedIndex = index;
        this.updateSelection();
      });
    });
  }
  handleSearchKeydown(e) {
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        this.selectedIndex = (this.selectedIndex + 1) % this.filteredCommands.length;
        this.updateSelection();
        break;
      case "ArrowUp":
        e.preventDefault();
        this.selectedIndex = this.selectedIndex === 0 ? this.filteredCommands.length - 1 : this.selectedIndex - 1;
        this.updateSelection();
        break;
      case "Enter":
        e.preventDefault();
        if (this.filteredCommands.length > 0) {
          this.executeCommand(this.filteredCommands[this.selectedIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        this.hide();
        break;
      case "Backspace":
        if (this.searchInput.value === "") {
          e.preventDefault();
          this.removeSlashAndClose();
        }
        break;
    }
  }
  updateSelection() {
    const items = this.resultsContainer.querySelectorAll(".systemsculpt-slash-result-item");
    items.forEach((item, index) => {
      item.classList.toggle("is-selected", index === this.selectedIndex);
    });
    const selectedItem = items[this.selectedIndex];
    if (selectedItem) {
      selectedItem.scrollIntoView({ block: "nearest" });
    }
  }
  async executeCommand(command) {
    try {
      await this.onExecute(command);
      this.hide();
    } catch (error) {
      console.error("Error executing slash command:", error);
      new import_obsidian67.Notice(`Error executing command: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  show(query = "") {
    this.isVisible = true;
    this.searchInput.value = query;
    this.filterCommands();
    this.positionMenu();
    this.menuElement.style.display = "block";
    this.searchInput.focus();
  }
  hide() {
    if (!this.isVisible)
      return;
    this.isVisible = false;
    this.menuElement.style.display = "none";
    this.searchInput.value = "";
    this.onClose();
  }
  isOpen() {
    return this.isVisible;
  }
  updateQuery(query) {
    if (!this.isVisible)
      return;
    this.searchInput.value = query;
    this.filterCommands();
  }
  handleKeydown(e) {
    if (!this.isVisible)
      return false;
    if (["ArrowDown", "ArrowUp", "Enter", "Escape"].includes(e.key)) {
      this.handleSearchKeydown(e);
      return true;
    }
    return false;
  }
  positionMenu() {
    const inputRect = this.inputElement.getBoundingClientRect();
    const menuWidth = 400;
    let bottom = window.innerHeight - inputRect.top + 10;
    let left = inputRect.left;
    if (left + menuWidth > window.innerWidth - 10) {
      left = window.innerWidth - menuWidth - 10;
    }
    if (inputRect.top < 320) {
      this.menuElement.style.position = "fixed";
      this.menuElement.style.top = `${inputRect.bottom + 10}px`;
      this.menuElement.style.bottom = "auto";
    } else {
      this.menuElement.style.position = "fixed";
      this.menuElement.style.top = "auto";
      this.menuElement.style.bottom = `${bottom}px`;
    }
    this.menuElement.style.left = `${left}px`;
    this.menuElement.style.zIndex = "1000";
  }
  removeSlashAndClose() {
    const currentValue = this.inputElement.value;
    if (currentValue.startsWith("/")) {
      this.inputElement.value = currentValue.substring(1);
      this.inputElement.selectionStart = this.inputElement.selectionEnd = 0;
    }
    this.hide();
  }
  unload() {
    if (this.menuElement && this.menuElement.parentNode) {
      this.menuElement.parentNode.removeChild(this.menuElement);
    }
    super.unload();
  }
};

// src/views/chatview/controllers/StreamingController.ts
var import_obsidian69 = __toModule(require("obsidian"));

// src/views/chatview/MessagePartManager.ts
var import_obsidian68 = __toModule(require("obsidian"));
var MessagePartManager = class extends import_obsidian68.Component {
  constructor(options) {
    super();
    this.assistantMessageParts = [];
    this.createChronologicalTimestamp = () => Date.now();
    this.isRenderBatched = false;
    this.batchTimeout = null;
    this.isReasoningActive = false;
    this.messageEl = options.messageEl;
    this.messageRenderer = options.messageRenderer;
    this.saveCallback = options.saveCallback;
    this.toolCallManager = options.toolCallManager;
  }
  startBatch() {
    this.isRenderBatched = true;
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
    }
    this.batchTimeout = setTimeout(() => {
      this.endBatch();
    }, 100);
  }
  endBatch() {
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }
    if (this.isRenderBatched) {
      this.isRenderBatched = false;
      this.render();
      this.saveCallback();
    }
  }
  processChunk(chunk) {
    let chunkType = null;
    let needsSave = false;
    const lastPart = this.assistantMessageParts.length > 0 ? this.assistantMessageParts[this.assistantMessageParts.length - 1] : null;
    if (!chunk || typeof chunk !== "object") {
      console.warn("[MessagePartManager] Invalid chunk received:", chunk);
      return null;
    }
    try {
      if (chunk.content) {
        chunkType = "content";
        this.isReasoningActive = false;
        const lastContentPart = this.assistantMessageParts.length > 0 ? this.assistantMessageParts[this.assistantMessageParts.length - 1] : null;
        if (lastContentPart && lastContentPart.type === "content") {
          lastContentPart.data += chunk.content;
        } else {
          const contentTimestamp = this.createChronologicalTimestamp();
          this.assistantMessageParts.push({
            id: `content-${contentTimestamp}`,
            type: "content",
            timestamp: contentTimestamp,
            data: chunk.content
          });
          needsSave = true;
        }
      }
      if (chunk.reasoning) {
        chunkType = "reasoning";
        this.isReasoningActive = true;
        const lastReasoningPart = this.assistantMessageParts.length > 0 ? this.assistantMessageParts[this.assistantMessageParts.length - 1] : null;
        if (lastReasoningPart && lastReasoningPart.type === "reasoning") {
          const existingText = lastReasoningPart.data;
          const incoming = chunk.reasoning;
          const hasParagraphBreak = /\n\n\s*$/.test(existingText);
          const headingLike = /^(\*\*[^*]+\*\*|#{1,6}\s)/.test(incoming);
          const prefix = !hasParagraphBreak && headingLike ? "\n\n" : "";
          lastReasoningPart.data += prefix + incoming;
        } else {
          const reasoningTimestamp = this.createChronologicalTimestamp();
          this.assistantMessageParts.push({
            id: `reasoning-${reasoningTimestamp}`,
            type: "reasoning",
            timestamp: reasoningTimestamp,
            data: chunk.reasoning
          });
          needsSave = true;
        }
      }
      if (chunk.toolCalls && chunk.toolCalls.length > 0) {
        chunkType = "tool_call";
        this.isReasoningActive = false;
        needsSave = true;
      }
      if (!this.isRenderBatched) {
        this.render();
      }
      if (needsSave && !this.isRenderBatched) {
        this.saveCallback();
      }
      return chunkType;
    } catch (error) {
      console.error("[MessagePartManager] Error processing chunk:", error, "Chunk:", chunk);
      return null;
    }
  }
  addToolCallPart(toolCall) {
    const existingPart = this.assistantMessageParts.find((p) => p.type === "tool_call" && p.data.id === toolCall.id);
    if (existingPart) {
      existingPart.data = toolCall;
    } else {
      this.assistantMessageParts.push({
        id: `tool_call_part-${toolCall.id}`,
        type: "tool_call",
        timestamp: toolCall.timestamp,
        data: toolCall
      });
    }
    if (!this.isRenderBatched) {
      this.render();
      this.saveCallback();
    }
  }
  updateToolCall(updatedToolCall) {
    const part = this.assistantMessageParts.find((p) => p.type === "tool_call" && p.data.id === updatedToolCall.id);
    if (part && part.type === "tool_call") {
      part.data = { ...part.data, ...updatedToolCall };
      if (!this.isRenderBatched) {
        this.render();
        this.saveCallback();
      }
    }
  }
  getParts() {
    return this.assistantMessageParts;
  }
  getFinalContent() {
    const list = new MessagePartList(this.assistantMessageParts);
    return list.contentMarkdown("");
  }
  getFinalReasoning() {
    const list = new MessagePartList(this.assistantMessageParts);
    return list.reasoningMarkdown("");
  }
  getFinalToolCalls() {
    return this.assistantMessageParts.filter((p) => p.type === "tool_call").map((p) => p.data).filter((p) => p !== void 0);
  }
  render() {
    this.messageRenderer.renderMessageParts(this.messageEl, { messageParts: this.sortMessageParts(this.assistantMessageParts) }, this.isReasoningActive);
  }
  sortMessageParts(parts) {
    return [...parts].sort((a, b) => a.timestamp - b.timestamp);
  }
  onunload() {
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
      this.batchTimeout = null;
    }
    super.onunload();
  }
};

// src/views/chatview/controllers/StreamingController.ts
init_errors();
var StreamingController = class extends import_obsidian69.Component {
  constructor(options) {
    super();
    this.activeMessagePartManagers = new Map();
    this.opts = options;
  }
  async stream(stream, messageEl, messageId, abortSignal, webSearchEnabled) {
    const {
      toolCallManager,
      scrollManager,
      messageRenderer,
      requestDebouncedSave,
      generateMessageId,
      extractAnnotations,
      showStreamingStatus,
      hideStreamingStatus,
      updateStreamingStatus,
      toggleStopButton,
      shouldToolAutoAccept,
      onAssistantResponse,
      onError
    } = this.opts;
    toggleStopButton(true);
    const assistantMessage = {
      role: "assistant",
      content: "",
      message_id: messageId,
      messageParts: []
    };
    let messagePartManager = this.activeMessagePartManagers.get(messageId);
    if (!messagePartManager) {
      messagePartManager = new MessagePartManager({
        messageEl,
        messageRenderer,
        saveCallback: async () => {
          requestDebouncedSave();
        },
        toolCallManager
      });
      this.activeMessagePartManagers.set(messageId, messagePartManager);
      this.addChild(messagePartManager);
    }
    assistantMessage.messageParts = messagePartManager.getParts();
    try {
      let toolCallsProcessed = false;
      const modelProvidedIds = new Set();
      showStreamingStatus(messageEl);
      for await (const chunk of stream) {
        if (abortSignal.aborted) {
          console.log(`[SystemSculpt] Stream for message ${messageId} aborted by user.`);
          break;
        }
        const chunkType = messagePartManager.processChunk(chunk);
        if (chunkType === "reasoning") {
          showStreamingStatus(messageEl);
          updateStreamingStatus(messageEl, "reasoning", "Thinking...");
        } else if (chunkType === "content") {
          showStreamingStatus(messageEl);
          updateStreamingStatus(messageEl, "content", "Processing...");
        }
        if (!toolCallsProcessed && chunk.toolCalls && Array.isArray(chunk.toolCalls) && chunk.toolCalls.length > 0) {
          toolCallsProcessed = true;
          showStreamingStatus(messageEl);
          updateStreamingStatus(messageEl, "tool_calls", "Processing tool calls...");
          chunk.toolCalls.forEach((tc) => {
            if (modelProvidedIds.has(tc.id) || !tc.id.startsWith("call_")) {
              const uniqueSuffix = generateMessageId().slice(-8);
              const baseId = tc.id.slice(0, 31);
              tc.id = `${baseId}_${uniqueSuffix}`;
            }
            modelProvidedIds.add(tc.id);
          });
          if (chunk.toolCalls.length > 1 && messagePartManager) {
            messagePartManager.startBatch();
          }
          for (const toolCallRequest of chunk.toolCalls) {
            const autoApprove = shouldToolAutoAccept(toolCallRequest.function.name);
            const toolCall = toolCallManager.createToolCall(toolCallRequest, messageId, autoApprove);
            if (toolCall) {
              messagePartManager.addToolCallPart(toolCall);
            }
          }
          if (chunk.toolCalls.length > 1 && messagePartManager) {
            messagePartManager.endBatch();
          }
        }
      }
    } catch (err) {
      const errorDetails = {
        message: err.message || "Unknown error",
        name: err.name || "Error",
        stack: err.stack || "No stack trace",
        code: err.code,
        cause: err.cause,
        messageId,
        streamType: typeof stream,
        hasStream: !!stream,
        toString: err.toString()
      };
      try {
        console.error("[SystemSculpt] Stream processing error details:", JSON.stringify(errorDetails, null, 2));
      } catch (jsonError) {
        console.error("[SystemSculpt] Stream processing error (JSON serialization failed):", {
          message: errorDetails.message,
          name: errorDetails.name,
          messageId: errorDetails.messageId,
          jsonError: jsonError.message
        });
      }
      const errorMessage = err.message || err.toString() || "Unknown error";
      const detailedError = `Stream processing failed: ${errorMessage}`;
      onError(new SystemSculptError(detailedError, "STREAM_ERROR", err));
    } finally {
      toggleStopButton(false);
      hideStreamingStatus(messageEl);
      const mpm = this.activeMessagePartManagers.get(messageId);
      if (mpm) {
        const finalContent = mpm.getFinalContent();
        const finalReasoning = mpm.getFinalReasoning();
        const allParts = mpm.getParts();
        const finalToolCalls = allParts.filter((p) => p.type === "tool_call").map((p) => p.data);
        assistantMessage.content = finalContent;
        assistantMessage.reasoning = finalReasoning || void 0;
        assistantMessage.tool_calls = finalToolCalls.length > 0 ? finalToolCalls : void 0;
        assistantMessage.messageParts = allParts;
        assistantMessage.annotations = extractAnnotations(finalContent);
        assistantMessage.webSearchEnabled = webSearchEnabled;
        await onAssistantResponse(assistantMessage);
        this.activeMessagePartManagers.delete(messageId);
        this.removeChild(mpm);
      }
      if (scrollManager.isAutoScrollEnabled()) {
        scrollManager.scrollToBottom();
      }
    }
  }
};

// src/views/chatview/messageHandling.ts
var import_obsidian71 = __toModule(require("obsidian"));

// src/views/chatview/BatchToolCallApprover.ts
var import_obsidian70 = __toModule(require("obsidian"));
var BatchToolCallApprover = class extends import_obsidian70.Component {
  constructor(options) {
    super();
    this.currentIndex = 0;
    this.timerId = null;
    this.advanceAndRender = () => {
      this.currentIndex++;
      if (this.currentIndex < this.options.toolCalls.length) {
        this.render();
      } else {
        this.options.container.remove();
        this.unload();
      }
    };
    this.handleApprove = () => {
      if (this.timerId)
        clearTimeout(this.timerId);
      const currentToolCall = this.options.toolCalls[this.currentIndex];
      this.options.toolCallManager.approveToolCall(currentToolCall.id);
      this.advanceAndRender();
    };
    this.handleDeny = async () => {
      if (this.timerId)
        clearTimeout(this.timerId);
      const currentToolCall = this.options.toolCalls[this.currentIndex];
      this.options.toolCallManager.denyToolCall(currentToolCall.id);
      if (this.options.addMessageToHistory) {
        const toolResponseMessage = {
          role: "tool",
          content: JSON.stringify({ error: "Tool call denied by user." }),
          tool_call_id: currentToolCall.id,
          message_id: this.generateMessageId()
        };
        try {
          await this.options.addMessageToHistory(toolResponseMessage);
        } catch (err) {
          console.error("Failed to add tool response message:", err);
        }
      }
      this.advanceAndRender();
    };
    this.options = options;
    this.options.container.classList.add("systemsculpt-batch-tool-call-approver");
  }
  onload() {
    this.render();
  }
  onunload() {
    if (this.timerId) {
      clearTimeout(this.timerId);
    }
    this.options.container.empty();
  }
  render() {
    const { container, toolCalls, autoApprove } = this.options;
    container.empty();
    const toolCall = toolCalls[this.currentIndex];
    if (!toolCall)
      return;
    const header = container.createDiv({ cls: "bta-header" });
    (0, import_obsidian70.setIcon)(header, "wrench");
    header.createSpan({ text: `Tool Call (${this.currentIndex + 1} of ${toolCalls.length})` });
    const body = container.createDiv({ cls: "bta-body" });
    const functionData = this.getFunctionData(toolCall);
    if (!functionData) {
      body.textContent = "Malformed tool call";
      return;
    }
    body.createEl("h4", { text: functionData.name });
    const argsEl = body.createDiv({ cls: "bta-args" });
    argsEl.createEl("pre", {
      text: JSON.stringify(functionData.arguments, null, 2)
    });
    const actions = container.createDiv({ cls: "bta-actions" });
    const denyBtn = new import_obsidian70.ButtonComponent(actions).setButtonText("Deny").onClick(this.handleDeny);
    const approveBtn = new import_obsidian70.ButtonComponent(actions).setButtonText("Approve & Execute").setCta().onClick(this.handleApprove);
    if (autoApprove) {
      denyBtn.setDisabled(true);
      approveBtn.setDisabled(true);
      const timerWrapper = container.createDiv({ cls: "bta-timer-wrapper" });
      const timerBar = timerWrapper.createDiv({ cls: "bta-timer-bar" });
      setTimeout(() => {
        timerBar.style.transition = "width 1s linear";
        timerBar.style.width = "100%";
      }, 10);
      this.timerId = setTimeout(this.handleApprove, 1e3);
    }
  }
  generateMessageId() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  getFunctionData(toolCall) {
    if (toolCall.request && toolCall.request.function) {
      try {
        return {
          name: toolCall.request.function.name,
          arguments: JSON.parse(toolCall.request.function.arguments)
        };
      } catch (e) {
        console.error("Failed to parse tool call arguments:", e);
        return {
          name: toolCall.request.function.name,
          arguments: {}
        };
      }
    }
    return null;
  }
};

// src/views/chatview/messageHandling.ts
var messageHandling = {
  addMessage: async function(chatView, role, content, existingMessageId, completeMessage) {
    const messageId = existingMessageId || chatView.generateMessageId();
    const { messageEl, contentEl } = await chatView.messageRenderer.renderMessage({ app: chatView.app, messageId, role, content: content || "" });
    const contentStr = typeof content === "string" ? content : content ? JSON.stringify(content) : "";
    messageEl.dataset.content = contentStr;
    if (completeMessage && completeMessage.role === "assistant") {
      await this.renderAssistantMessage(chatView, messageEl, completeMessage);
    }
    this.registerMessageEventHandlers(chatView, messageEl);
    const groupInfo = this.addMessageToContainer(chatView, messageEl, role);
    if (role === "user" || role === "assistant" && groupInfo.isNewGroup) {
      if (role === "user") {
        chatView.messageRenderer.addMessageButtonToolbar(messageEl, contentStr, role, messageId);
      } else {
        this.addGroupToolbar(chatView, groupInfo.groupContainer, messageId);
      }
    }
    if (chatView.isGenerating) {
      if (window.requestIdleCallback) {
        window.requestIdleCallback(() => chatView.manageDomSize(), { timeout: 1e3 });
      } else {
        setTimeout(() => chatView.manageDomSize(), 50);
      }
    } else {
      chatView.manageDomSize();
    }
  },
  addMessageToContainer: function(chatView, messageEl, role) {
    if (role === "assistant") {
      const lastContainer = chatView.chatContainer.lastElementChild;
      if (lastContainer == null ? void 0 : lastContainer.classList.contains("systemsculpt-assistant-message-group")) {
        lastContainer.appendChild(messageEl);
        return { isNewGroup: false, groupContainer: lastContainer };
      } else {
        const groupContainer = document.createElement("div");
        groupContainer.className = "systemsculpt-assistant-message-group";
        groupContainer.appendChild(messageEl);
        chatView.chatContainer.appendChild(groupContainer);
        return { isNewGroup: true, groupContainer };
      }
    } else {
      chatView.chatContainer.appendChild(messageEl);
      return { isNewGroup: false };
    }
  },
  addGroupToolbar: function(chatView, groupContainer, messageId) {
    const collapsedToolbar = groupContainer.createEl("div", {
      cls: "systemsculpt-message-button-toolbar-collapsed"
    });
    const chevronButton = new import_obsidian71.ButtonComponent(collapsedToolbar).setIcon("chevron-left").setTooltip("Show actions").setClass("mod-small").onClick(() => {
      this.expandGroupToolbar(collapsedToolbar, expandedToolbar, chevronButton);
    });
    const expandedToolbar = groupContainer.createEl("div", {
      cls: "systemsculpt-message-button-toolbar-expanded"
    });
    const copyButton = new import_obsidian71.ButtonComponent(expandedToolbar).setIcon("copy").setTooltip("Copy entire conversation").setClass("mod-small").onClick(() => {
      const groupContent = this.extractGroupContent(groupContainer);
      navigator.clipboard.writeText(groupContent);
      copyButton.setIcon("check");
      copyButton.buttonEl.addClass("is-success");
      setTimeout(() => {
        copyButton.setIcon("copy");
        copyButton.buttonEl.removeClass("is-success");
      }, 2e3);
      this.collapseGroupToolbar(collapsedToolbar, expandedToolbar, chevronButton);
    });
    let isDeleteConfirming = false;
    let deleteTimeoutId = null;
    const deleteButton = new import_obsidian71.ButtonComponent(expandedToolbar).setIcon("trash").setTooltip("Delete entire conversation").setClass("mod-small").setWarning().onClick(async (e) => {
      e.stopPropagation();
      if (!isDeleteConfirming) {
        isDeleteConfirming = true;
        deleteButton.setButtonText("Delete All?");
        deleteTimeoutId = setTimeout(() => {
          deleteButton.setIcon("trash").setButtonText("");
          isDeleteConfirming = false;
        }, 3e3);
      } else {
        if (deleteTimeoutId) {
          clearTimeout(deleteTimeoutId);
        }
        deleteButton.setButtonText("Deleting...").setDisabled(true);
        await this.deleteMessageGroup(chatView, groupContainer);
        this.collapseGroupToolbar(collapsedToolbar, expandedToolbar, chevronButton);
      }
    });
    const collapseButton = new import_obsidian71.ButtonComponent(expandedToolbar).setIcon("chevron-right").setTooltip("Hide actions").setClass("mod-small").onClick(() => {
      this.collapseGroupToolbar(collapsedToolbar, expandedToolbar, chevronButton);
    });
    collapseButton.buttonEl.addClass("chevron");
  },
  extractGroupContent: function(groupContainer) {
    const messages = groupContainer.querySelectorAll(".systemsculpt-message");
    let content = "";
    messages.forEach((messageEl, index) => {
      var _a, _b;
      if (index > 0)
        content += "\n\n---\n\n";
      const reasoning = messageEl.querySelector(".systemsculpt-reasoning-text");
      if (reasoning && ((_a = reasoning.textContent) == null ? void 0 : _a.trim())) {
        content += `**Reasoning:**
${reasoning.textContent.trim()}

`;
      }
      const toolCalls = messageEl.querySelectorAll(".systemsculpt-tool-call-wrapper");
      toolCalls.forEach((toolCall) => {
        var _a2, _b2;
        const toolHeader = toolCall.querySelector(".systemsculpt-collapsible-title");
        const toolContent = toolCall.querySelector(".systemsculpt-tool-call-args, .systemsculpt-tool-call-response");
        if (toolHeader && toolContent) {
          content += `**Tool Call: ${((_a2 = toolHeader.textContent) == null ? void 0 : _a2.trim()) || "Unknown"}**
`;
          content += `${((_b2 = toolContent.textContent) == null ? void 0 : _b2.trim()) || ""}

`;
        }
      });
      const mainContent = messageEl.querySelector(".systemsculpt-message-content, .systemsculpt-content-part");
      if (mainContent && ((_b = mainContent.textContent) == null ? void 0 : _b.trim())) {
        content += `**Response:**
${mainContent.textContent.trim()}
`;
      }
    });
    return content.trim();
  },
  deleteMessageGroup: async function(chatView, groupContainer) {
    const messageElements = groupContainer.querySelectorAll(".systemsculpt-message[data-message-id]");
    const messageIds = Array.from(messageElements).map((el) => el.getAttribute("data-message-id")).filter(Boolean);
    messageIds.forEach((messageId) => {
      const index = chatView.messages.findIndex((msg) => msg.message_id === messageId);
      if (index !== -1) {
        chatView.messages.splice(index, 1);
      }
    });
    await chatView.saveChat();
    groupContainer.remove();
  },
  setupGroupToolbarBehavior: function(groupContainer, toolbar) {
  },
  expandGroupToolbar: function(collapsedToolbar, expandedToolbar, chevronButton) {
    collapsedToolbar.addClass("hidden");
    expandedToolbar.addClass("active");
    const clickOutsideHandler = (e) => {
      if (!expandedToolbar.contains(e.target) && !collapsedToolbar.contains(e.target)) {
        this.collapseGroupToolbar(collapsedToolbar, expandedToolbar, chevronButton);
        document.removeEventListener("click", clickOutsideHandler);
      }
    };
    setTimeout(() => {
      document.addEventListener("click", clickOutsideHandler);
    }, 100);
  },
  collapseGroupToolbar: function(collapsedToolbar, expandedToolbar, chevronButton) {
    collapsedToolbar.removeClass("hidden");
    expandedToolbar.removeClass("active");
  },
  renderAssistantMessage: async function(chatView, messageEl, message) {
    var _a;
    if (message.tool_calls && message.tool_calls.length > 0 && chatView.toolCallManager) {
      for (const toolCall of message.tool_calls) {
        const existingToolCall = chatView.toolCallManager.getToolCall(toolCall.id);
        if (!existingToolCall) {
          const serializedToolCall = {
            id: toolCall.id,
            request: toolCall.request,
            state: toolCall.state,
            timestamp: toolCall.timestamp,
            approvedAt: toolCall.approvedAt,
            executionStartedAt: toolCall.executionStartedAt,
            executionCompletedAt: toolCall.executionCompletedAt,
            result: toolCall.result,
            autoApproved: toolCall.autoApproved
          };
          chatView.toolCallManager.restoreToolCall(serializedToolCall, message.message_id);
        }
      }
    }
    const pendingToolCalls = ((_a = message.tool_calls) == null ? void 0 : _a.filter((tc) => tc.state === "pending")) || [];
    if (pendingToolCalls.length > 1) {
      messageEl.classList.add("has-batch-approval");
    }
    const partList = chatView.messageRenderer.normalizeMessageToParts(message);
    if (partList.parts.length > 0) {
      chatView.messageRenderer.renderUnifiedMessageParts(messageEl, partList.parts);
    }
    if (pendingToolCalls.length > 1) {
      const batchApproverContainer = messageEl.createDiv();
      const batchApprover = new BatchToolCallApprover({
        app: chatView.app,
        container: batchApproverContainer,
        toolCalls: pendingToolCalls,
        toolCallManager: chatView.toolCallManager,
        messageRenderer: chatView.messageRenderer,
        autoApprove: chatView.plugin.settings.mcpAutoAccept
      });
      chatView.addChild(batchApprover);
    }
    if (message.webSearchEnabled && message.annotations) {
      const urlCitations = message.annotations.filter((annotation) => annotation.type === "url_citation" && annotation.url_citation).map((annotation) => annotation.url_citation).filter((citation) => citation !== void 0);
      if (urlCitations.length > 0) {
        const contentEl = messageEl.querySelector(".systemsculpt-message-content");
        if (contentEl) {
          chatView.messageRenderer.renderCitations(contentEl, urlCitations);
        }
      }
    }
  },
  registerMessageEventHandlers: function(chatView, messageEl) {
    const registerHandler = (element, eventName, handler) => {
      element.addEventListener(eventName, handler);
      chatView.register(() => element.removeEventListener(eventName, handler));
    };
    const resubmitHandler = async (e) => {
      const { messageId, content } = e.detail;
      const index = chatView.messages.findIndex((msg) => msg.message_id === messageId);
      if (index === -1)
        return;
      chatView.messages.splice(index);
      if (chatView.messages.length === 0) {
        chatView.chatId = "";
        chatView.chatVersion = 0;
        chatView.isFullyLoaded = false;
      } else {
        await chatView.saveChat();
      }
      await this.reloadAllMessages(chatView);
      if (chatView.inputHandler) {
        chatView.inputHandler.setValue(content);
        chatView.inputHandler.focus();
      }
    };
    const editHandler = async (e) => {
      const { messageId, newContent } = e.detail;
      const index = chatView.messages.findIndex((msg) => msg.message_id === messageId);
      if (index !== -1) {
        const existingMessage = chatView.messages[index];
        const updatedMessage = {
          ...existingMessage,
          content: newContent,
          messageParts: void 0
        };
        chatView.messages[index] = updatedMessage;
        await chatView.saveChat();
        const { contentEl: newContentEl } = await chatView.messageRenderer.renderMessage({
          app: chatView.app,
          messageId,
          role: updatedMessage.role,
          content: updatedMessage.content
        });
        if (updatedMessage.role === "assistant") {
          await this.renderAssistantMessage(chatView, messageEl, updatedMessage);
        }
        const oldContentEl = messageEl.querySelector(".systemsculpt-message-content");
        if (oldContentEl && newContentEl) {
          oldContentEl.replaceWith(newContentEl);
        }
        const updatedStr = typeof updatedMessage.content === "string" ? updatedMessage.content : JSON.stringify(updatedMessage.content);
        messageEl.dataset.content = updatedStr;
      }
    };
    const deleteHandler = async (e) => {
      const { messageId } = e.detail;
      const index = chatView.messages.findIndex((msg) => msg.message_id === messageId);
      if (index !== -1) {
        chatView.messages.splice(index, 1);
        await chatView.saveChat();
        const parentGroup = messageEl.closest(".systemsculpt-assistant-message-group");
        if (parentGroup) {
          messageEl.remove();
          if (parentGroup.children.length === 0) {
            parentGroup.remove();
          }
        } else {
          messageEl.remove();
        }
      }
    };
    registerHandler(messageEl, "resubmit", resubmitHandler);
    registerHandler(messageEl, "edit", editHandler);
    registerHandler(messageEl, "delete", deleteHandler);
  },
  reloadAllMessages: async function(chatView) {
    await chatView.renderMessagesInChunks();
    return;
  },
  consolidateConsecutiveAssistantMessages: function(messages) {
    return messages;
  },
  loadMessages: async function(chatView) {
    if (!chatView.chatContainer)
      return;
    await this.reloadAllMessages(chatView);
  }
};

// src/views/chatview/InputHandler.ts
init_agent2();

// src/components/AtMentionMenu.ts
var import_obsidian72 = __toModule(require("obsidian"));
var AtMentionMenu = class extends import_obsidian72.Component {
  constructor(chatView, inputElement) {
    super();
    this.selectedIndex = 0;
    this.filteredFiles = [];
    this.isVisible = false;
    this.triggerPosition = -1;
    this.maxResults = 50;
    this.searchQuery = "";
    this.allFiles = [];
    this.chatView = chatView;
    this.inputElement = inputElement;
    this.vault = this.chatView.app.vault;
    this.createMenu();
    this.cacheFiles();
  }
  cacheFiles() {
    this.allFiles = this.vault.getMarkdownFiles();
  }
  createMenu() {
    this.container = document.createElement("div");
    this.container.addClass("at-mention-menu");
    this.container.style.display = "none";
    const header = this.container.createDiv("at-mention-header");
    header.createEl("span", { text: "Add file to context", cls: "at-mention-title" });
    this.itemsContainer = this.container.createDiv("at-mention-items");
    const searchContainer = this.container.createDiv("at-mention-search");
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search files...",
      cls: "at-mention-search-input"
    });
    this.searchInput.addEventListener("input", () => {
      this.handleSearch();
    });
    this.searchInput.addEventListener("keydown", (e) => {
      e.stopPropagation();
      if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "Enter" || e.key === "Escape") {
        e.preventDefault();
        this.handleKeyDown(e);
      } else if (e.key === "Backspace" && this.searchInput.value === "") {
        e.preventDefault();
        this.removeAtSymbolAndClose();
      }
    });
    document.body.appendChild(this.container);
  }
  show(triggerPosition) {
    this.triggerPosition = triggerPosition;
    this.isVisible = true;
    this.selectedIndex = 0;
    this.searchQuery = "";
    this.searchInput.value = "";
    this.updateFilteredFiles();
    this.render();
    this.positionMenu();
    this.container.style.display = "block";
    this.searchInput.focus();
  }
  hide() {
    this.isVisible = false;
    this.container.style.display = "none";
    this.inputElement.focus();
  }
  positionMenu() {
    const inputRect = this.inputElement.getBoundingClientRect();
    const menuHeight = 300;
    this.container.style.position = "fixed";
    this.container.style.bottom = `${window.innerHeight - inputRect.top + 10}px`;
    this.container.style.left = `${inputRect.left}px`;
    this.container.style.width = `${inputRect.width}px`;
    this.container.style.maxHeight = `${menuHeight}px`;
  }
  updateFilteredFiles() {
    if (!this.searchQuery) {
      this.filteredFiles = this.allFiles.slice(0, this.maxResults - 1).map((file) => ({ file, score: 0 }));
      return;
    }
    const query = this.searchQuery.toLowerCase();
    if ("vault structure".includes(query) || "vault".startsWith(query)) {
      const results = [];
      for (const file of this.allFiles) {
        const score = this.fuzzyScore(query, file.path.toLowerCase());
        if (score > 0) {
          results.push({ file, score });
        }
      }
      results.sort((a, b) => b.score - a.score);
      this.filteredFiles = results.slice(0, this.maxResults - 1);
    } else {
      const results = [];
      for (const file of this.allFiles) {
        const score = this.fuzzyScore(query, file.path.toLowerCase());
        if (score > 0) {
          results.push({ file, score });
        }
      }
      results.sort((a, b) => b.score - a.score);
      this.filteredFiles = results.slice(0, this.maxResults);
    }
  }
  fuzzyScore(query, target) {
    if (!query || !target)
      return 0;
    if (target === query)
      return 1e3;
    if (target.includes(query))
      return 500 + (100 - target.indexOf(query));
    let score = 0;
    let queryIndex = 0;
    let targetIndex = 0;
    while (queryIndex < query.length && targetIndex < target.length) {
      if (query[queryIndex] === target[targetIndex]) {
        score += 10;
        queryIndex++;
      }
      targetIndex++;
    }
    if (queryIndex === query.length) {
      score += Math.max(0, 100 - target.length);
      return score;
    }
    return 0;
  }
  handleSearch() {
    this.searchQuery = this.searchInput.value;
    this.selectedIndex = 0;
    this.updateFilteredFiles();
    this.render();
  }
  render() {
    this.itemsContainer.empty();
    const showVaultOption = !this.searchQuery || "vault structure".includes(this.searchQuery.toLowerCase()) || "vault".startsWith(this.searchQuery.toLowerCase());
    if (showVaultOption) {
      const vaultItemEl = this.itemsContainer.createDiv({
        cls: "at-mention-item at-mention-vault" + (this.selectedIndex === 0 ? " selected" : "")
      });
      const iconEl = vaultItemEl.createDiv("at-mention-item-icon");
      iconEl.innerHTML = "\u{1F5C2}\uFE0F";
      const contentEl = vaultItemEl.createDiv("at-mention-item-content");
      const nameEl = contentEl.createDiv("at-mention-item-name");
      nameEl.setText("Vault Structure");
      const pathEl = contentEl.createDiv("at-mention-item-path");
      pathEl.setText("Add directory structure to context");
      vaultItemEl.addEventListener("click", () => {
        this.selectVaultStructure();
      });
      vaultItemEl.addEventListener("mouseenter", () => {
        this.selectedIndex = 0;
        this.render();
      });
    }
    const startIndex = showVaultOption ? 1 : 0;
    if (this.filteredFiles.length === 0 && !showVaultOption) {
      this.itemsContainer.createDiv("at-mention-empty").setText("No files found");
      return;
    }
    this.filteredFiles.forEach((item, index) => {
      const actualIndex = showVaultOption ? index + 1 : index;
      const itemEl = this.itemsContainer.createDiv({
        cls: "at-mention-item" + (actualIndex === this.selectedIndex ? " selected" : "")
      });
      const iconEl = itemEl.createDiv("at-mention-item-icon");
      iconEl.innerHTML = "\u{1F4C4}";
      const contentEl = itemEl.createDiv("at-mention-item-content");
      const nameEl = contentEl.createDiv("at-mention-item-name");
      nameEl.setText(item.file.basename);
      const pathEl = contentEl.createDiv("at-mention-item-path");
      pathEl.setText(item.file.path);
      itemEl.addEventListener("click", () => {
        this.selectFile(item.file);
      });
      itemEl.addEventListener("mouseenter", () => {
        this.selectedIndex = actualIndex;
        this.render();
      });
    });
  }
  handleKeyDown(e) {
    const showVaultOption = !this.searchQuery || "vault structure".includes(this.searchQuery.toLowerCase()) || "vault".startsWith(this.searchQuery.toLowerCase());
    const maxIndex = this.filteredFiles.length + (showVaultOption ? 0 : -1);
    switch (e.key) {
      case "ArrowUp":
        this.selectedIndex = Math.max(0, this.selectedIndex - 1);
        this.render();
        this.scrollToSelected();
        break;
      case "ArrowDown":
        this.selectedIndex = Math.min(maxIndex, this.selectedIndex + 1);
        this.render();
        this.scrollToSelected();
        break;
      case "Enter":
        if (showVaultOption && this.selectedIndex === 0) {
          this.selectVaultStructure();
        } else {
          const fileIndex = showVaultOption ? this.selectedIndex - 1 : this.selectedIndex;
          if (this.filteredFiles[fileIndex]) {
            this.selectFile(this.filteredFiles[fileIndex].file);
          }
        }
        break;
      case "Escape":
        this.hide();
        break;
    }
  }
  scrollToSelected() {
    const selectedEl = this.itemsContainer.querySelector(".at-mention-item.selected");
    if (selectedEl) {
      selectedEl.scrollIntoView({ block: "nearest" });
    }
  }
  selectFile(file) {
    const currentValue = this.inputElement.value;
    const beforeTrigger = currentValue.substring(0, this.triggerPosition);
    const afterCursor = currentValue.substring(this.inputElement.selectionEnd);
    const link = `[[${file.path}]]`;
    const newValue = beforeTrigger + link + " " + afterCursor;
    this.inputElement.value = newValue;
    this.inputElement.selectionStart = this.inputElement.selectionEnd = beforeTrigger.length + link.length + 1;
    this.chatView.addContextFile(file);
    this.inputElement.dispatchEvent(new Event("input", { bubbles: true }));
    this.hide();
  }
  isOpen() {
    return this.isVisible;
  }
  selectVaultStructure() {
    if (this.chatView.contextManager && this.chatView.contextManager.isVaultStructureIncluded()) {
      new import_obsidian72.Notice("Your vault structure is already added into the context for this chat. Remove it from the context drawer at the top of your chat view if you don't want to include it anymore.", 5e3);
    } else {
      if (this.chatView.contextManager) {
        this.chatView.contextManager.toggleVaultStructure();
      }
    }
    const currentValue = this.inputElement.value;
    const beforeTrigger = currentValue.substring(0, this.triggerPosition);
    const afterCursor = currentValue.substring(this.inputElement.selectionEnd);
    const newValue = beforeTrigger + afterCursor;
    this.inputElement.value = newValue;
    this.inputElement.selectionStart = this.inputElement.selectionEnd = this.triggerPosition;
    this.inputElement.dispatchEvent(new Event("input", { bubbles: true }));
    this.hide();
  }
  removeAtSymbolAndClose() {
    const currentValue = this.inputElement.value;
    const beforeAt = currentValue.substring(0, this.triggerPosition);
    const afterAt = currentValue.substring(this.triggerPosition + 1);
    this.inputElement.value = beforeAt + afterAt;
    this.inputElement.selectionStart = this.inputElement.selectionEnd = this.triggerPosition;
    this.hide();
  }
  onunload() {
    this.container.remove();
  }
};

// src/views/chatview/InputHandler.ts
init_webSearch();
var InputHandler = class extends import_obsidian73.Component {
  constructor(options) {
    super();
    this.isGenerating = false;
    this.renderTimeout = null;
    this.recorderVisualizer = null;
    this.isRecording = false;
    this.abortController = null;
    this.stopButton = null;
    this.webSearchEnabled = false;
    this.pendingLargeTextContent = null;
    this.toolCallEventUnsubscribers = [];
    this.continuedMessageIds = new Set();
    this.continuationCheckInProgress = new Set();
    this.pendingContinuations = new Set();
    this.pendingToolCallUpdates = new Set();
    this.scheduledToolCallUpdateFrame = null;
    this.deferredStreamingSave = null;
    this.app = options.app;
    this.container = options.container;
    this.aiService = options.aiService;
    this.getMessages = options.getMessages;
    this.getSelectedModelId = options.getSelectedModelId;
    this.getContextFiles = options.getContextFiles;
    this.getSystemPrompt = options.getSystemPrompt;
    this.chatContainer = options.chatContainer;
    this.scrollManager = options.scrollManager;
    this.messageRenderer = options.messageRenderer;
    this.onMessageSubmit = options.onMessageSubmit;
    this.onAssistantResponse = options.onAssistantResponse;
    this.onContextFileAdd = options.onContextFileAdd;
    this.addMessageToHistory = options.addMessageToHistory;
    this.onError = options.onError;
    this.onAddContextFile = options.onAddContextFile;
    this.onEditSystemPrompt = options.onEditSystemPrompt;
    this.plugin = options.plugin;
    this.getChatMarkdown = options.getChatMarkdown;
    this.getChatTitle = options.getChatTitle;
    this.addFileToContext = options.addFileToContext;
    this.chatStorage = options.chatStorage;
    this.getChatId = options.getChatId;
    this.toolCallManager = options.toolCallManager;
    this.chatView = options.chatView;
    if (this.toolCallManager) {
      this.setupToolCallEventListeners();
    }
    this.registerDomEvent(this.chatContainer, "tool-approval", (event) => {
      var _a, _b, _c;
      const customEvent = event;
      const { toolCallId, approved } = customEvent.detail;
      const toolCall = (_a = this.toolCallManager) == null ? void 0 : _a.getToolCall(toolCallId);
      if (approved) {
        (_b = this.toolCallManager) == null ? void 0 : _b.approveToolCall(toolCallId);
      } else {
        (_c = this.toolCallManager) == null ? void 0 : _c.denyToolCall(toolCallId);
        const toolResponseMessage = {
          role: "tool",
          content: JSON.stringify({ error: "Tool call denied by user." }),
          tool_call_id: toolCallId,
          message_id: this.generateMessageId()
        };
        this.addMessageToHistory(toolResponseMessage).catch((err) => console.error("Failed to add tool response message:", err));
      }
    });
    this.recorderService = RecorderService.getInstance(this.app, this.plugin, {
      isInChat: true,
      onTranscriptionComplete: (text) => {
        console.log("Received transcription, inserting at cursor position");
        this.insertTextAtCursor(text);
        if (this.plugin.settings.autoSubmitAfterTranscription) {
          setTimeout(() => {
            this.handleSendMessage();
          }, 100);
        }
      }
    });
    const originalMessageSubmit = options.onMessageSubmit;
    this.onMessageSubmit = async (message) => {
      await originalMessageSubmit(message);
    };
    const originalAssistantResponse = options.onAssistantResponse;
    this.onAssistantResponse = async (message) => {
      await originalAssistantResponse(message);
      const currentMessageEl = this.chatContainer.querySelector(`.systemsculpt-message[data-message-id="${message.message_id}"]`);
      if (currentMessageEl) {
        const parentGroup = currentMessageEl.closest(".systemsculpt-assistant-message-group");
        currentMessageEl.remove();
        if (parentGroup && parentGroup.children.length === 0) {
          parentGroup.remove();
        }
        await messageHandling.addMessage(this.chatView, message.role, message.content, message.message_id, message);
      }
    };
    this.setupInput();
    this.initializeSlashCommands();
    this.initializeAtMentionMenu();
    this.streamingController = new StreamingController({
      toolCallManager: this.toolCallManager,
      scrollManager: this.scrollManager,
      messageRenderer: this.messageRenderer,
      requestDebouncedSave: this.requestDebouncedStreamingSave.bind(this),
      generateMessageId: this.generateMessageId.bind(this),
      extractAnnotations: this.extractAnnotationsFromResponse.bind(this),
      showStreamingStatus: this.showStreamingStatus.bind(this),
      hideStreamingStatus: this.hideStreamingStatus.bind(this),
      updateStreamingStatus: this.updateStreamingStatus.bind(this),
      toggleStopButton: this.toggleStopButton.bind(this),
      shouldToolAutoAccept: this.shouldToolAutoAccept.bind(this),
      onAssistantResponse: this.onAssistantResponse,
      onError: this.onError
    });
    this.addChild(this.streamingController);
  }
  setGeneratingState(generating) {
    this.isGenerating = generating;
    this.scrollManager.setGenerating(generating);
    this.updateGeneratingState();
  }
  setupInput() {
    var _a;
    this.inputContainer = this.container.createEl("div", {
      cls: "systemsculpt-input-container"
    });
    this.buttonGrid = this.inputContainer.createEl("div", {
      cls: "systemsculpt-button-grid"
    });
    const settingsButtonContainer = this.buttonGrid.createDiv();
    this.settingsButton = new import_obsidian73.ButtonComponent(settingsButtonContainer).setIcon("settings").setTooltip("This Chat's Settings").setClass("mod-small").onClick(() => {
      this.onEditSystemPrompt();
    });
    const attachButtonContainer = this.buttonGrid.createDiv();
    this.attachButton = new import_obsidian73.ButtonComponent(attachButtonContainer).setIcon("paperclip").setTooltip("Add context file or upload document").setClass("mod-small").onClick((_e) => {
      this.onAddContextFile();
    });
    const webSearchButtonContainer = this.buttonGrid.createDiv();
    this.webSearchButton = new import_obsidian73.ButtonComponent(webSearchButtonContainer).setIcon("globe").setTooltip("Toggle web search (SystemSculpt & OpenRouter only)").setClass("mod-small").onClick(() => {
      this.webSearchEnabled = !this.webSearchEnabled;
      this.updateWebSearchButtonState();
      if (this.webSearchEnabled) {
        new import_obsidian73.Notice("Web search enabled");
      } else {
        new import_obsidian73.Notice("Web search disabled");
      }
    });
    this.updateWebSearchButtonState();
    const mcpToolsButtonContainer = this.buttonGrid.createDiv();
    this.mcpToolsButton = new import_obsidian73.ButtonComponent(mcpToolsButtonContainer).setIcon("brain").setTooltip("Toggle Agent Mode").setClass("mod-small").onClick(async () => {
      var _a2;
      const agentModeActive = ((_a2 = this.chatView) == null ? void 0 : _a2.agentMode) || false;
      if (agentModeActive) {
        await this.disableAgentModeForChat();
      } else {
        await this.enableAgentModeForChat();
      }
    });
    this.updateMcpToolsButtonState();
    const hasProLicense = ((_a = this.plugin.settings.licenseKey) == null ? void 0 : _a.trim()) && this.plugin.settings.licenseValid;
    const micButtonContainer = this.buttonGrid.createDiv();
    this.micButton = new import_obsidian73.ButtonComponent(micButtonContainer).setIcon("mic").setTooltip("Record audio message").setClass("mod-small").setDisabled(!hasProLicense).onClick(() => {
      this.handleMicClick();
    });
    const sendButtonContainer = this.buttonGrid.createDiv();
    this.sendButton = new import_obsidian73.ButtonComponent(sendButtonContainer).setIcon("send").setTooltip("Send message").setClass("mod-small").setCta().onClick(this.handleSendMessage.bind(this));
    const stopButtonContainer = this.buttonGrid.createDiv();
    this.stopButton = new import_obsidian73.ButtonComponent(stopButtonContainer).setIcon("square").setTooltip("Stop generation").setClass("mod-small").setWarning().onClick(this.handleStopGeneration.bind(this));
    this.stopButton.buttonEl.style.display = "none";
    this.input = this.inputContainer.createEl("textarea", {
      cls: "systemsculpt-input systemsculpt-chat-input",
      attr: {
        rows: "1",
        placeholder: "Type a message..."
      }
    });
    this.registerDomEvent(this.input, "keydown", this.handleKeyDown.bind(this));
    this.registerDomEvent(this.input, "input", this.handleInputChange.bind(this));
    this.registerDomEvent(this.input, "paste", this.handlePaste.bind(this));
    this.recorderService.onToggle((isRecording) => {
      this.isRecording = isRecording;
      if (this.micButton && this.micButton.buttonEl) {
        this.micButton.buttonEl.classList.toggle("ss-active", isRecording);
        if (isRecording) {
          this.micButton.setTooltip("Recording in progress (click to stop)");
          this.micButton.setCta();
        } else {
          this.micButton.setTooltip("Record audio message");
          this.micButton.removeCta();
        }
      }
    });
    this.updateGeneratingState = () => {
      this.input.disabled = false;
      this.settingsButton.setDisabled(false);
      this.attachButton.setDisabled(false);
      this.webSearchButton.setDisabled(false);
      this.micButton.setDisabled(false);
      this.sendButton.setDisabled(this.isGenerating);
      if (this.stopButton) {
        this.stopButton.setDisabled(!this.isGenerating);
        this.stopButton.buttonEl.style.display = this.isGenerating ? "flex" : "none";
        this.sendButton.buttonEl.style.display = "flex";
      }
      this.input.placeholder = this.isGenerating ? "Type your next message while AI generates..." : "Message SystemSculpt...";
      this.input.classList.remove("disabled");
      this.scrollManager.setGenerating(this.isGenerating);
    };
  }
  initializeSlashCommands() {
    this.slashCommandMenu = new SlashCommandMenu({
      plugin: this.plugin,
      chatView: this.chatView,
      inputElement: this.input,
      inputHandler: this,
      onClose: () => {
        this.input.focus();
      },
      onExecute: async (command) => {
        const currentValue = this.input.value;
        const slashIndex = currentValue.lastIndexOf("/");
        if (slashIndex !== -1) {
          this.input.value = currentValue.substring(0, slashIndex);
        }
        await command.execute(this.chatView);
      }
    });
    this.addChild(this.slashCommandMenu);
  }
  initializeAtMentionMenu() {
    this.atMentionMenu = new AtMentionMenu(this.chatView, this.input);
    this.addChild(this.atMentionMenu);
  }
  handleStopGeneration() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    this.setGeneratingState(false);
    this.updateGeneratingState();
  }
  async handleStream(stream, messageEl, messageId, _messagePartManager) {
    var _a, _b;
    this.setGeneratingState(true);
    const abortSignal = (_b = (_a = this.abortController) == null ? void 0 : _a.signal) != null ? _b : new AbortController().signal;
    await this.streamingController.stream(stream, messageEl, messageId, abortSignal, this.webSearchEnabled);
    this.setGeneratingState(false);
    this.abortController = null;
  }
  async handleSendMessage() {
    if (this.isGenerating)
      return;
    let messageText = this.input.value.trim();
    if (!messageText)
      return;
    if (this.pendingLargeTextContent && LargeTextHelpers.containsPlaceholder(messageText)) {
      const placeholderRegex = /\[PASTED TEXT - \d+ LINES OF TEXT\]/g;
      messageText = messageText.replace(placeholderRegex, this.pendingLargeTextContent);
      this.pendingLargeTextContent = null;
    }
    this.setGeneratingState(true);
    this.abortController = new AbortController();
    try {
      this.input.value = "";
      this.adjustInputHeight();
      const userMessage = {
        role: "user",
        content: messageText,
        message_id: this.generateMessageId()
      };
      await this.onMessageSubmit(userMessage);
      this.app.workspace.trigger("systemsculpt:chat-message-added", this.getChatId());
      if (this.toolCallManager) {
        const pendingToolCalls = this.toolCallManager.getPendingToolCalls();
        for (const toolCall of pendingToolCalls) {
          this.toolCallManager.cancelToolCall(toolCall.id, "The user sent a follow-up message instead of approving this tool call.");
          const toolResponseMessage = {
            role: "tool",
            content: JSON.stringify({ error: "Tool call denied by user." }),
            tool_call_id: toolCall.id,
            message_id: this.generateMessageId()
          };
          await this.addMessageToHistory(toolResponseMessage);
        }
      }
      const { messageEl } = this.createAssistantMessageContainer(false);
      requestAnimationFrame(() => {
        this.scrollManager.forceScrollToBottom();
      });
      const messageId = messageEl.dataset.messageId;
      const stream = this.aiService.streamMessage({
        messages: this.getMessages().map(({ messageParts, ...apiMsg }) => apiMsg),
        model: this.getSelectedModelId(),
        contextFiles: this.chatView.contextManager.getContextFilesWithVaultStructure(),
        systemPromptType: this.getSystemPrompt().type,
        systemPromptPath: this.getSystemPrompt().path,
        agentMode: this.chatView.agentMode,
        signal: this.abortController.signal,
        toolCallManager: this.chatView.toolCallManager,
        plugins: this.webSearchEnabled ? [{ id: WEB_SEARCH_CONFIG.PLUGIN_ID, max_results: WEB_SEARCH_CONFIG.MAX_RESULTS }] : void 0
      });
      await this.handleStream(stream, messageEl, messageId);
    } catch (error) {
      console.error("Error in handleSendMessage:", error);
    } finally {
      this.setGeneratingState(false);
      this.abortController = null;
      this.updateGeneratingState();
      this.focus();
      await this.chatView.contextManager.validateAndCleanContextFiles();
      this.app.workspace.trigger("systemsculpt:chat-message-added", this.getChatId());
    }
  }
  handleMicClick() {
    this.toggleRecording();
  }
  async toggleRecording() {
    await this.recorderService.toggleRecording();
    this.input.focus();
  }
  async handlePaste(e) {
    var _a;
    const dt = e.clipboardData;
    if (!dt)
      return;
    const pastedText = (_a = dt.getData("text/plain")) != null ? _a : "";
    const allFiles = Array.from(dt.files);
    if (!allFiles.length && pastedText) {
      const warningLevel = LargeTextHelpers.getTextWarningLevel(pastedText);
      if (warningLevel === "error") {
        e.preventDefault();
        new import_obsidian73.Notice(LARGE_TEXT_MESSAGES.SIZE_ERROR);
        return;
      } else if (warningLevel === "hard") {
        e.preventDefault();
        const textSizeKB = LargeTextHelpers.getTextSizeKB(pastedText);
        const proceed = await this.showLargeTextWarning(textSizeKB, pastedText);
        if (!proceed)
          return;
        await this.handleLargeTextPaste(pastedText);
        return;
      } else if (warningLevel === "soft") {
        const textSizeKB = LargeTextHelpers.getTextSizeKB(pastedText);
        new import_obsidian73.Notice(`${LARGE_TEXT_MESSAGES.SIZE_WARNING_PREFIX} (${LargeTextHelpers.formatSize(textSizeKB)}). Processing...`);
      }
      return;
    }
    e.preventDefault();
    if (!allFiles.length) {
      return;
    }
    for (const file of allFiles) {
      try {
        const isValidSize = await validateBrowserFileSize(file, this.app);
        if (!isValidSize) {
          continue;
        }
        let extension = "bin";
        if (file.name && file.name.includes(".")) {
          const dotIdx = file.name.lastIndexOf(".");
          if (dotIdx >= 0) {
            extension = file.name.substring(dotIdx + 1).toLowerCase();
          }
        } else if (file.type) {
          const mimeParts = file.type.split("/");
          if (mimeParts.length === 2) {
            extension = mimeParts[1].toLowerCase().replace(/[^a-z0-9]/g, "");
          }
        }
        const now = new Date();
        const isoString = now.toISOString().replace(/[:.]/g, "-");
        const newFileName = `pasted-${isoString}.${extension}`;
        const arrayBuffer = await file.arrayBuffer();
        const attachmentsDir = this.plugin.settings.attachmentsDirectory || "Attachments";
        const finalPath = `${attachmentsDir}/${newFileName}`;
        if (this.plugin.directoryManager) {
          await this.plugin.directoryManager.ensureDirectoryByPath(attachmentsDir);
        } else {
          await this.plugin.createDirectory(attachmentsDir);
        }
        await this.app.vault.createBinary(finalPath, arrayBuffer);
        const createdFile = this.app.vault.getAbstractFileByPath(finalPath);
        if (createdFile instanceof import_obsidian73.TFile) {
          await this.addFileToContext(createdFile);
          new import_obsidian73.Notice(`Pasted file saved & added to context: ${createdFile.name}`);
        } else {
          throw new Error("Failed to locate pasted file in vault.");
        }
      } catch (err) {
        console.error("Error handling pasted file:", err);
        new import_obsidian73.Notice(`Failed to handle pasted file: ${err.message}`);
      }
    }
    if (pastedText) {
      if (LargeTextHelpers.shouldCollapseInHistory(pastedText)) {
        await this.handleLargeTextPaste(pastedText);
      } else {
        this.insertTextAtCursor(pastedText);
      }
    }
  }
  async showLargeTextWarning(sizeKB, text) {
    return new Promise((resolve) => {
      const modal = new import_obsidian73.Modal(this.app);
      modal.titleEl.setText("Large Text Detected");
      const content = modal.contentEl;
      content.createEl("p", {
        text: `You're trying to paste ${Math.round(sizeKB)}KB of text. This might cause performance issues.`
      });
      const preview = content.createEl("div", { cls: "systemsculpt-large-text-preview" });
      preview.createEl("p", { text: "Preview (first 200 characters):" });
      preview.createEl("pre", {
        text: text.substring(0, 200) + (text.length > 200 ? "..." : ""),
        cls: "systemsculpt-text-preview"
      });
      const buttonContainer = content.createDiv({ cls: "systemsculpt-modal-buttons" });
      const proceedBtn = buttonContainer.createEl("button", { text: "Proceed Anyway" });
      proceedBtn.addEventListener("click", () => {
        modal.close();
        resolve(true);
      });
      const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
      cancelBtn.addEventListener("click", () => {
        modal.close();
        resolve(false);
      });
      modal.open();
    });
  }
  async handleLargeTextPaste(text) {
    const lineCount = LargeTextHelpers.getLineCount(text);
    const placeholder = LargeTextHelpers.createPlaceholder(lineCount);
    this.pendingLargeTextContent = text;
    this.insertTextAtCursor(placeholder);
    new import_obsidian73.Notice(`${LARGE_TEXT_MESSAGES.CONFIRMATION_PREFIX} (${lineCount} lines). Full content will be sent when you submit.`);
  }
  async handleKeyDown(event) {
    var _a, _b;
    if ((_a = this.slashCommandMenu) == null ? void 0 : _a.handleKeydown(event)) {
      return;
    }
    if ((_b = this.atMentionMenu) == null ? void 0 : _b.isOpen()) {
      if (event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Enter" || event.key === "Escape") {
        return;
      }
    }
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      if (this.isGenerating) {
        new import_obsidian73.Notice("Please wait for the current response to complete before sending another message");
        return;
      }
      await this.handleSendMessage();
    }
  }
  handleInputChange() {
    this.adjustInputHeight();
    this.handleSlashCommandDetection();
    this.handleAtMentionDetection();
    if (this.pendingLargeTextContent && !LargeTextHelpers.containsPlaceholder(this.input.value)) {
      this.pendingLargeTextContent = null;
    }
  }
  adjustInputHeight() {
    if (!this.input)
      return;
    this.input.style.height = "auto";
    const newHeight = Math.min(Math.max(this.input.scrollHeight, 48), 200);
    this.input.style.height = newHeight + "px";
  }
  handleSlashCommandDetection() {
    if (!this.slashCommandMenu)
      return;
    const value = this.input.value;
    const cursorPos = this.input.selectionStart || 0;
    const isLeadingSlash = value.startsWith("/") && cursorPos >= 1;
    if (isLeadingSlash) {
      const query = value.substring(1, cursorPos);
      if (!this.slashCommandMenu.isOpen()) {
        this.slashCommandMenu.show(query);
      } else {
        this.slashCommandMenu.updateQuery(query);
      }
    } else if (this.slashCommandMenu.isOpen()) {
      this.slashCommandMenu.hide();
    }
  }
  handleAtMentionDetection() {
    if (!this.atMentionMenu)
      return;
    const value = this.input.value;
    const cursorPos = this.input.selectionStart || 0;
    let atIndex = -1;
    for (let i = cursorPos - 1; i >= 0; i--) {
      if (value[i] === "@") {
        if (i === 0 || /\s/.test(value[i - 1])) {
          atIndex = i;
          break;
        }
      } else if (/\s/.test(value[i])) {
        break;
      }
    }
    if (atIndex !== -1) {
      if (!this.atMentionMenu.isOpen()) {
        this.atMentionMenu.show(atIndex);
      }
    } else if (this.atMentionMenu.isOpen()) {
      this.atMentionMenu.hide();
    }
  }
  focus() {
    this.input.focus();
  }
  getValue() {
    return this.input.value;
  }
  setValue(value) {
    if (!this.input) {
      console.error("Input element not found in setValue");
      return;
    }
    try {
      this.input.value = value;
      const inputEvent = new Event("input", {
        bubbles: true,
        cancelable: true
      });
      this.input.dispatchEvent(inputEvent);
      this.adjustInputHeight();
      this.input.focus();
      this.input.setSelectionRange(value.length, value.length);
    } catch (error) {
      console.error("Error in setValue:", error);
      new import_obsidian73.Notice("\u274C Failed to set input value");
    }
  }
  unload() {
    if (this.renderTimeout) {
      clearTimeout(this.renderTimeout);
    }
    if (this.recorderVisualizer) {
      this.recorderVisualizer.remove();
      this.recorderVisualizer = null;
    }
    if (this.recorderService) {
      this.recorderService.onToggle(() => {
      });
    }
    if (this.slashCommandMenu) {
      this.slashCommandMenu.unload();
    }
    if (this.atMentionMenu) {
      this.atMentionMenu.unload();
    }
    super.unload();
  }
  generateMessageId() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  addMessageToContainer(messageEl, role, breakGroup = false) {
    if (role === "assistant") {
      const lastContainer = this.chatContainer.lastElementChild;
      if (!breakGroup && (lastContainer == null ? void 0 : lastContainer.classList.contains("systemsculpt-assistant-message-group"))) {
        lastContainer.appendChild(messageEl);
        return { isNewGroup: false, groupContainer: lastContainer };
      } else {
        const groupContainer = document.createElement("div");
        groupContainer.className = "systemsculpt-assistant-message-group";
        groupContainer.appendChild(messageEl);
        this.chatContainer.appendChild(groupContainer);
        return { isNewGroup: true, groupContainer };
      }
    } else {
      this.chatContainer.appendChild(messageEl);
      return { isNewGroup: false };
    }
  }
  createAssistantMessageContainer(breakGroup = false) {
    const messageEl = createDiv({
      cls: "systemsculpt-message systemsculpt-assistant-message"
    });
    messageEl.setAttribute("data-message-id", this.generateMessageId());
    const contentEl = createDiv({ cls: "systemsculpt-message-content" });
    messageEl.appendChild(contentEl);
    const statusIndicator = messageEl.createEl("span", {
      cls: "systemsculpt-streaming-status"
    });
    const groupInfo = this.addMessageToContainer(messageEl, "assistant", breakGroup);
    if (groupInfo.isNewGroup && groupInfo.groupContainer) {
      messageHandling.addGroupToolbar(this.chatView, groupInfo.groupContainer, messageEl.getAttribute("data-message-id") || "");
    }
    return { messageEl, contentEl };
  }
  sortMessageParts(parts) {
    return [...parts].sort((a, b) => a.timestamp - b.timestamp);
  }
  insertTextAtCursor(text) {
    const cursorPos = this.input.selectionStart;
    const currentValue = this.input.value;
    if (cursorPos !== null) {
      const newValue = currentValue.slice(0, cursorPos) + text + currentValue.slice(cursorPos);
      this.input.value = newValue;
      this.input.selectionStart = this.input.selectionEnd = cursorPos + text.length;
    } else {
      this.input.value = currentValue + text;
      this.input.selectionStart = this.input.selectionEnd = this.input.value.length;
    }
    this.input.dispatchEvent(new Event("input"));
    this.input.focus();
  }
  updateWebSearchButtonState() {
    if (!this.webSearchButton || !this.webSearchButton.buttonEl)
      return;
    const isNativeProvider = this.plugin.settings.activeProvider.type === "native";
    const currentProvider = this.plugin.settings.customProviders.find((p) => p.id === this.plugin.settings.activeProvider.id);
    const isOpenRouter = currentProvider == null ? void 0 : currentProvider.endpoint.includes("openrouter.ai");
    const webSearchAllowed = isNativeProvider || isOpenRouter;
    if (!webSearchAllowed && this.webSearchEnabled) {
      this.webSearchEnabled = false;
    }
    if (!webSearchAllowed) {
      this.webSearchButton.buttonEl.style.display = "none";
      return;
    }
    this.webSearchButton.buttonEl.style.display = "flex";
    if (this.webSearchEnabled) {
      this.webSearchButton.buttonEl.classList.add("ss-active");
      this.webSearchButton.setTooltip("Web search enabled (click to disable)");
      this.webSearchButton.setCta();
    } else {
      this.webSearchButton.buttonEl.classList.remove("ss-active");
      this.webSearchButton.setTooltip("Toggle web search (SystemSculpt & OpenRouter only)");
      this.webSearchButton.removeCta();
    }
  }
  updateMcpToolsButtonState() {
    var _a;
    if (!this.mcpToolsButton || !this.mcpToolsButton.buttonEl)
      return;
    const mcpEnabled = this.plugin.settings.mcpEnabled;
    const agentMode = ((_a = this.chatView) == null ? void 0 : _a.agentMode) || false;
    if (!mcpEnabled) {
      this.mcpToolsButton.buttonEl.style.display = "none";
      return;
    }
    this.mcpToolsButton.buttonEl.style.display = "flex";
    if (agentMode) {
      this.mcpToolsButton.buttonEl.classList.add("ss-active");
      this.mcpToolsButton.setTooltip("Agent settings & MCP tools - Agent mode ON");
      this.mcpToolsButton.setCta();
    } else {
      this.mcpToolsButton.buttonEl.classList.remove("ss-active");
      this.mcpToolsButton.setTooltip("Agent settings & MCP tools");
      this.mcpToolsButton.removeCta();
    }
  }
  onModelChange() {
    this.updateWebSearchButtonState();
    this.updateMcpToolsButtonState();
  }
  updateAgentModeButtonState() {
    this.updateMcpToolsButtonState();
  }
  async handleOpenChatHistoryFile() {
    try {
      const chatId = this.getChatId();
      if (!chatId) {
        new import_obsidian73.Notice("No active chat to open history for");
        return;
      }
      const chatDirectory = this.plugin.settings.chatsDirectory || "SystemSculpt/Chats";
      const chatFilePath = `${chatDirectory}/${chatId}.md`;
      const file = this.app.vault.getAbstractFileByPath(chatFilePath);
      if (!(file instanceof import_obsidian73.TFile)) {
        new import_obsidian73.Notice("Chat history file not found");
        return;
      }
      await this.app.workspace.getLeaf(true).openFile(file);
      new import_obsidian73.Notice("Opened chat history file");
    } catch (error) {
      console.error("Error opening chat history file:", error);
      new import_obsidian73.Notice("Error opening chat history file");
    }
  }
  async handleSaveChatAsNote() {
    try {
      if (typeof this.getChatMarkdown !== "function" || typeof this.getChatTitle !== "function") {
        console.error("[SaveNote] Required functions missing!");
        new import_obsidian73.Notice("Error saving chat: Missing required functions.", 4e3);
        return;
      }
      const chatContent = await this.getChatMarkdown();
      const currentChatTitle = this.getChatTitle();
      const now = new Date();
      const defaultFileName = `Chat ${now.toLocaleDateString()} ${now.toLocaleTimeString().replace(/:/g, "-")}`;
      const folderPath = this.plugin.settings.savedChatsDirectory || "SystemSculpt/Saved Chats";
      let fileName = currentChatTitle || defaultFileName;
      fileName = fileName.replace(/[\\/:*?"<>|]/g, "-");
      try {
        if (this.plugin.directoryManager) {
          await this.plugin.directoryManager.ensureDirectoryByPath(folderPath);
        } else {
          await this.plugin.app.vault.createFolder(folderPath).catch((err) => {
            console.warn("[SaveNote] Non-critical error creating folder (might exist already):", err);
          });
        }
        const filePath = `${folderPath}/${fileName}.md`;
        const fileExists = await this.plugin.app.vault.adapter.exists(filePath);
        if (fileExists) {
          console.log("[SaveNote] File already exists, showing confirmation dialog");
          const confirmOverwrite = await new Promise((resolve) => {
            const modal = new class extends import_obsidian73.Modal {
              constructor(app) {
                super(app);
              }
              onOpen() {
                this.titleEl.setText("File Already Exists");
                this.contentEl.createEl("p", { text: `"${fileName}.md" already exists. Do you want to overwrite it with the latest chat content?` });
                new import_obsidian73.Setting(this.contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
                  this.close();
                  resolve(false);
                })).addButton((btn) => btn.setButtonText("Overwrite").setWarning().onClick(() => {
                  this.close();
                  resolve(true);
                }));
              }
              onClose() {
                this.contentEl.empty();
              }
            }(this.app);
            modal.open();
          });
          if (!confirmOverwrite) {
            console.log("[SaveNote] User cancelled overwrite");
            return;
          }
          console.log("[SaveNote] User confirmed overwrite, modifying existing file");
          const existingFile = this.app.vault.getAbstractFileByPath(filePath);
          if (existingFile instanceof import_obsidian73.TFile) {
            await this.plugin.app.vault.modify(existingFile, chatContent);
            console.log("[SaveNote] File modified successfully");
          } else {
            throw new Error("Could not locate the existing file to modify it");
          }
        } else {
          await this.plugin.app.vault.create(filePath, chatContent);
          console.log("[SaveNote] File created successfully.");
        }
        new import_obsidian73.Notice(`Chat saved to "${filePath}"`, 4e3);
        console.log("[SaveNote] Opening file:", filePath);
        const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian73.TFile) {
          await this.plugin.app.workspace.openLinkText(file.path, "", true);
          console.log("[SaveNote] File opened.");
        }
      } catch (error) {
        console.error("[SaveNote] Error during file operations:", error);
        new import_obsidian73.Notice("Failed to save chat as note. Please try again.", 4e3);
      }
    } catch (error) {
      console.error("[SaveNote] Error in handleSaveChatAsNote (outer catch):", error);
      new import_obsidian73.Notice("An error occurred while saving chat as note", 4e3);
    }
  }
  setInputText(content) {
    this.setValue(typeof content === "string" ? content : JSON.stringify(content));
    this.focus();
  }
  extractAnnotationsFromResponse(responseText) {
    const annotations = [];
    try {
      const markdownLinkRegex = /\[([^\]]+)\]\(([^\)]+)\)/g;
      let match;
      while ((match = markdownLinkRegex.exec(responseText)) !== null) {
        const domain = match[1];
        const url = match[2];
        const surroundingTextStart = Math.max(0, match.index - 200);
        const surroundingTextEnd = Math.min(responseText.length, match.index + match[0].length + 200);
        const surroundingText = responseText.substring(surroundingTextStart, surroundingTextEnd);
        const sentences = surroundingText.split(/(?<=\.|\?|\!)\s+/);
        const matchText = match[0];
        const sentenceWithCitation = sentences.find((s) => s.includes(matchText)) || "";
        annotations.push({
          type: "url_citation",
          url_citation: {
            title: `Source: ${domain}`,
            url,
            content: sentenceWithCitation.replace(match[0], "").trim(),
            start_index: match.index,
            end_index: match.index + match[0].length
          }
        });
      }
      if (annotations.length > 0) {
      }
    } catch (error) {
      console.error("[SystemSculpt] Error extracting annotations:", error);
    }
    return annotations;
  }
  async checkAndContinue(toolCall) {
    if (!this.toolCallManager)
      return;
    const messageId = toolCall.messageId;
    const msgs = this.getMessages();
    const requestIdx = msgs.findIndex((m) => m.message_id === messageId);
    if (requestIdx !== -1) {
      const hasLaterUserMsg = msgs.slice(requestIdx + 1).some((m) => m.role === "user");
      if (hasLaterUserMsg) {
        return;
      }
    }
    if (this.continuationCheckInProgress.has(messageId) || this.continuedMessageIds.has(messageId)) {
      return;
    }
    this.continuationCheckInProgress.add(messageId);
    try {
      if (this.continuedMessageIds.has(messageId)) {
        return;
      }
      const toolCallsForMessage = this.toolCallManager.getToolCallsForMessage(messageId);
      const allToolsHandled = toolCallsForMessage.every((tc) => tc.state === "completed" || tc.state === "failed" || tc.state === "denied");
      if (allToolsHandled) {
        this.continuedMessageIds.add(messageId);
        if (!this.pendingContinuations.has(messageId)) {
          this.pendingContinuations.add(messageId);
          this.scheduleContinuation(messageId);
        }
      }
    } finally {
      this.continuationCheckInProgress.delete(messageId);
    }
  }
  async scheduleContinuation(messageId, attempt = 0) {
    if (attempt > 10) {
      console.warn("[Continue] Giving up on auto-continuation after multiple attempts:", messageId);
      this.pendingContinuations.delete(messageId);
      return;
    }
    if (this.isGenerating) {
      setTimeout(() => {
        this.scheduleContinuation(messageId, attempt + 1);
      }, 500);
      return;
    }
    this.pendingContinuations.delete(messageId);
    await this.continueAfterToolExecution(messageId);
  }
  async continueAfterToolExecution(messageId) {
    var _a;
    if (this.isGenerating) {
      console.warn("[Continue] Still generating, rescheduling continuation for", messageId);
      if (!this.pendingContinuations.has(messageId)) {
        this.pendingContinuations.add(messageId);
        this.scheduleContinuation(messageId, 1);
      }
      return;
    }
    this.setGeneratingState(true);
    this.updateGeneratingState();
    const continuationAbortController = new AbortController();
    this.abortController = continuationAbortController;
    try {
      const { messageEl } = this.createAssistantMessageContainer(false);
      const newContinuationMessageId = messageEl.dataset.messageId;
      const currentMessages = this.getMessages();
      const toolRequestMessage = currentMessages.find((m) => m.message_id === messageId);
      if (!toolRequestMessage) {
        console.error("Could not find tool request message in history.");
        this.setGeneratingState(false);
        this.updateGeneratingState();
        this.abortController = null;
        messageEl.remove();
        return;
      }
      const MAX_TOOL_RESULT_LENGTH = 1e4;
      const toolResultMessages = (toolRequestMessage.tool_calls || []).map((tc) => {
        var _a2, _b, _c, _d, _e;
        const result = (_a2 = this.toolCallManager) == null ? void 0 : _a2.getToolCall(tc.id);
        if (!result)
          return null;
        if (result.state === "denied") {
          return {
            role: "tool",
            content: JSON.stringify({ error: "Tool call denied by user." }),
            tool_call_id: result.id,
            message_id: this.generateMessageId()
          };
        }
        const content = (_e = (_b = result.result) == null ? void 0 : _b.data) != null ? _e : { error: ((_d = (_c = result.result) == null ? void 0 : _c.error) == null ? void 0 : _d.message) || "Tool execution failed." };
        let contentString = typeof content === "string" ? content : JSON.stringify(content, null, 2);
        if (contentString.length > MAX_TOOL_RESULT_LENGTH) {
          contentString = contentString.substring(0, MAX_TOOL_RESULT_LENGTH) + `

... (result truncated due to excessive length)`;
        }
        return {
          role: "tool",
          content: contentString,
          tool_call_id: result.id,
          message_id: this.generateMessageId()
        };
      }).filter((m) => m !== null);
      for (const msg of toolResultMessages) {
        await this.addMessageToHistory(msg);
      }
      const messagesForApi = this.getMessages().map(({ messageParts, ...apiMsg }) => apiMsg);
      const systemPromptInfo = this.getSystemPrompt();
      const stream = this.aiService.streamMessage({
        messages: messagesForApi,
        model: this.getSelectedModelId(),
        contextFiles: this.chatView.contextManager.getContextFilesWithVaultStructure(),
        systemPromptType: systemPromptInfo.type,
        systemPromptPath: systemPromptInfo.path,
        agentMode: (_a = this.chatView) == null ? void 0 : _a.agentMode,
        signal: continuationAbortController.signal,
        toolCallManager: this.chatView.toolCallManager,
        plugins: this.webSearchEnabled ? [{ id: WEB_SEARCH_CONFIG.PLUGIN_ID, max_results: WEB_SEARCH_CONFIG.MAX_RESULTS }] : void 0
      });
      await this.handleStream(stream, messageEl, newContinuationMessageId);
    } catch (error) {
      if (error.name !== "AbortError") {
        this.onError(error);
      }
    } finally {
      this.setGeneratingState(false);
      this.updateGeneratingState();
      this.abortController = null;
      await this.chatView.contextManager.validateAndCleanContextFiles();
      this.app.workspace.trigger("systemsculpt:chat-message-added", this.getChatId());
    }
  }
  setupToolCallEventListeners() {
    if (!this.toolCallManager)
      return;
    this.toolCallEventUnsubscribers.forEach((unsub) => unsub());
    this.toolCallEventUnsubscribers = [];
    const unsubStateChange = this.toolCallManager.on("tool-call:state-changed", ({ toolCallId, toolCall }) => {
      this.pendingToolCallUpdates.add(toolCallId);
      if (this.scheduledToolCallUpdateFrame === null) {
        this.scheduledToolCallUpdateFrame = requestAnimationFrame(() => {
          this.processPendingToolCallUpdates();
          this.scheduledToolCallUpdateFrame = null;
        });
      }
    });
    this.toolCallEventUnsubscribers.push(unsubStateChange);
    const unsubDenied = this.toolCallManager.on("tool-call:denied", ({ toolCall }) => {
      this.checkAndContinue(toolCall);
    });
    this.toolCallEventUnsubscribers.push(unsubDenied);
    const unsubCompleted = this.toolCallManager.on("tool-call:execution-completed", ({ toolCall }) => {
      this.checkAndContinue(toolCall);
    });
    this.toolCallEventUnsubscribers.push(unsubCompleted);
    const unsubFailed = this.toolCallManager.on("tool-call:execution-failed", ({ toolCall }) => {
      this.checkAndContinue(toolCall);
    });
    this.toolCallEventUnsubscribers.push(unsubFailed);
  }
  processPendingToolCallUpdates() {
    this.pendingToolCallUpdates.forEach((toolCallId) => {
      var _a;
      const drawerElement = this.chatContainer.querySelector(`.systemsculpt-collapsible-drawer[data-tool-call-id="${toolCallId}"]`);
      if (!drawerElement)
        return;
      const wrapperElement = drawerElement.closest(".systemsculpt-tool-call-wrapper");
      if (wrapperElement instanceof HTMLElement) {
        const toolCall = (_a = this.toolCallManager) == null ? void 0 : _a.getToolCall(toolCallId);
        if (!toolCall)
          return;
        const part = {
          id: wrapperElement.dataset.partId || `tool_call_part-${toolCall.id}`,
          type: "tool_call",
          timestamp: toolCall.timestamp,
          data: toolCall
        };
        this.messageRenderer.updateExistingPart(wrapperElement, part, false);
      }
    });
    this.pendingToolCallUpdates.clear();
  }
  shouldToolAutoAccept(toolName) {
    const autoAcceptTools = this.plugin.settings.mcpAutoAcceptTools || [];
    const firstUnderscoreIndex = toolName.indexOf("_");
    if (firstUnderscoreIndex === -1) {
      const enabledTools = this.plugin.settings.mcpEnabledTools || [];
      for (const server of this.plugin.settings.mcpServers || []) {
        const toolKey2 = `${server.id}:${toolName}`;
        if (autoAcceptTools.includes(toolKey2) && enabledTools.includes(toolKey2)) {
          return true;
        }
      }
      return false;
    }
    const serverId = toolName.substring(0, firstUnderscoreIndex);
    const actualToolName = toolName.substring(firstUnderscoreIndex + 1);
    const toolKey = `${serverId}:${actualToolName}`;
    if (autoAcceptTools.includes(toolKey)) {
      const enabledTools = this.plugin.settings.mcpEnabledTools || [];
      if (!enabledTools.includes(toolKey)) {
        return false;
      }
      return true;
    }
    return false;
  }
  hasAnyAutoAcceptTools() {
    const autoAcceptTools = this.plugin.settings.mcpAutoAcceptTools || [];
    const enabledTools = this.plugin.settings.mcpEnabledTools || [];
    return autoAcceptTools.some((toolKey) => enabledTools.includes(toolKey));
  }
  onunload() {
    this.toolCallEventUnsubscribers.forEach((unsub) => unsub());
    this.toolCallEventUnsubscribers = [];
    this.cleanupAllStatusIndicators();
    super.unload();
  }
  cleanupAllStatusIndicators() {
    var _a;
    (_a = this.chatContainer) == null ? void 0 : _a.querySelectorAll(".systemsculpt-streaming-status").forEach((el) => {
      el.remove();
    });
  }
  updateStreamingStatus(messageEl, status, text) {
  }
  hideStreamingStatus(messageEl) {
    const statusIndicator = this.getStatusIndicator(messageEl);
    if (statusIndicator) {
      statusIndicator.remove();
    }
  }
  showStreamingStatus(messageEl) {
  }
  getStatusIndicator(messageEl) {
    return messageEl.querySelector(".systemsculpt-streaming-status");
  }
  toggleStopButton(show) {
    if (this.stopButton) {
      this.stopButton.setDisabled(!show);
      this.stopButton.buttonEl.style.display = show ? "flex" : "none";
    }
  }
  requestDebouncedStreamingSave() {
    if (this.deferredStreamingSave) {
      clearTimeout(this.deferredStreamingSave);
    }
    this.deferredStreamingSave = setTimeout(async () => {
      this.deferredStreamingSave = null;
      if (this.chatView.isFullyLoaded) {
        try {
          await this.chatView.saveChat();
        } catch (e) {
          console.error("[SystemSculpt] Failed debounced save:", e);
        }
      }
    }, 1e3);
  }
  async enableAgentModeForChat() {
    if (!this.chatView)
      return;
    const { verifyPremiumAccess: verifyPremiumAccess3 } = await Promise.resolve().then(() => (init_licenseUtils(), licenseUtils_exports));
    if (!verifyPremiumAccess3(this.plugin.settings, 0, true)) {
      return;
    }
    this.chatView.agentMode = true;
    this.chatView.systemPromptType = "agent";
    this.chatView.systemPromptPath = void 0;
    const agentModelId = AGENT_CONFIG.MODEL_ID;
    await this.chatView.setSelectedModelId(agentModelId);
    const { SystemPromptService: SystemPromptService2 } = await Promise.resolve().then(() => (init_SystemPromptService(), SystemPromptService_exports));
    const service = SystemPromptService2.getInstance(this.app, () => this.plugin.settings);
    this.chatView.currentPrompt = await service.getSystemPromptContent("agent", void 0, true);
    new import_obsidian73.Notice("Agent Mode enabled - Now using agent model and prompt", 3e3);
    await this.chatView.saveChat();
    if (this.chatView.updateSystemPromptIndicator)
      await this.chatView.updateSystemPromptIndicator();
    if (this.chatView.updateModelIndicator)
      await this.chatView.updateModelIndicator();
    this.updateAgentModeButtonState();
  }
  async disableAgentModeForChat() {
    var _a, _b;
    if (!this.chatView)
      return;
    this.chatView.agentMode = false;
    const defaultType = ((_a = this.plugin.settings) == null ? void 0 : _a.systemPromptType) || "general-use";
    const defaultPath = ((_b = this.plugin.settings) == null ? void 0 : _b.systemPromptPath) || void 0;
    if (this.chatView.systemPromptType === "agent") {
      this.chatView.systemPromptType = defaultType === "agent" ? "general-use" : defaultType;
      this.chatView.systemPromptPath = this.chatView.systemPromptType === "custom" ? defaultPath : void 0;
    }
    new import_obsidian73.Notice("Agent Mode disabled - Model and system prompt changes are now available", 3e3);
    await this.chatView.saveChat();
    if (this.chatView.updateSystemPromptIndicator)
      await this.chatView.updateSystemPromptIndicator();
    if (this.chatView.updateModelIndicator)
      await this.chatView.updateModelIndicator();
    this.updateAgentModeButtonState();
  }
};

// src/views/chatview/uiSetup.ts
init_modelUtils();
var buildAgentToolingLabel = (plugin) => {
  var _a, _b;
  const enabledTools = Array.isArray((_a = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _a.mcpEnabledTools) ? [...new Set(plugin.settings.mcpEnabledTools)] : [];
  const autoApproveTools = Array.isArray((_b = plugin == null ? void 0 : plugin.settings) == null ? void 0 : _b.mcpAutoAcceptTools) ? [...new Set(plugin.settings.mcpAutoAcceptTools)] : [];
  return `Agent Tooling (${enabledTools.length} enabled, ${autoApproveTools.length} auto-approve)`;
};
var uiSetup = {
  onOpen: async function(chatView) {
    try {
      const plugins = chatView.app.plugins;
      if (plugins && !plugins.enabledPlugins.has("mermaid")) {
        await plugins.enablePlugin("mermaid");
      }
    } catch (e) {
    }
    const container = chatView.containerEl.children[1];
    container.empty();
    container.addClass("systemsculpt-chat-container");
    chatView.setupDragAndDrop(container);
    const headerContainer = container.createEl("div", { cls: "systemsculpt-chat-header" });
    const headerRow = headerContainer.createEl("div", { cls: "systemsculpt-chat-header-row" });
    const leftSection = headerRow.createEl("div", { cls: "systemsculpt-header-section-left" });
    chatView.contextManager = new FileContextManager({
      app: chatView.app,
      container: leftSection,
      onContextChange: async () => {
        if (chatView.isFullyLoaded || !chatView.chatId) {
          await chatView.saveChat();
        }
        await chatView.contextManager.checkSyncStatus();
      },
      sculptService: chatView.aiService,
      plugin: chatView.plugin
    });
    console.log("[SystemSculpt] uiSetup: agentMode is", chatView.agentMode);
    if (chatView.pendingVaultStructureState !== void 0) {
      const shouldBeEnabled = chatView.pendingVaultStructureState;
      const currentlyEnabled = chatView.contextManager.isVaultStructureIncluded();
      if (shouldBeEnabled !== currentlyEnabled) {
        await chatView.contextManager.toggleVaultStructure();
      }
      chatView.pendingVaultStructureState = void 0;
    }
    chatView.chatContainer = container.createEl("div", { cls: "systemsculpt-messages-container" });
    chatView.chatContainer.classList.add(`systemsculpt-chat-${chatView.chatFontSize}`);
    const handleMessageEdited = async (event) => {
      const customEvent = event;
      const { messageId, newContent } = customEvent.detail;
      const messageIndex = chatView.messages.findIndex((msg) => msg.message_id === messageId);
      if (messageIndex !== -1) {
        if (typeof chatView.messages[messageIndex].content === "string") {
          chatView.messages[messageIndex].content = newContent;
          await chatView.saveChat();
          console.log(`Message ${messageId} updated and saved.`);
        } else {
          console.warn(`Editing non-string content for message ${messageId} not fully implemented yet.`);
          if (Array.isArray(chatView.messages[messageIndex].content)) {
            const textPart = chatView.messages[messageIndex].content.find((p) => p.type === "text");
            if (textPart) {
              textPart.text = newContent;
              await chatView.saveChat();
              console.log(`Text part of message ${messageId} updated and saved.`);
            } else {
              console.error(`Could not find text part to update for message ${messageId}`);
            }
          }
        }
      } else {
        console.error(`Could not find message with ID ${messageId} to update.`);
      }
    };
    chatView.chatContainer.addEventListener("message-edited", handleMessageEdited);
    chatView.register(() => {
      chatView.chatContainer.removeEventListener("message-edited", handleMessageEdited);
    });
    const scrollToBottomButton = document.createElement("button");
    scrollToBottomButton.className = "systemsculpt-scroll-to-bottom";
    scrollToBottomButton.setAttribute("aria-label", "Scroll to bottom");
    scrollToBottomButton.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M8 3v10m0 0l-4-4m4 4l4-4"/>
      </svg>
    `;
    scrollToBottomButton.style.display = "none";
    container.appendChild(scrollToBottomButton);
    chatView.scrollManager = new ScrollManagerService({
      container: chatView.chatContainer,
      onAutoScrollChange: (isAutoScroll) => {
        scrollToBottomButton.style.display = isAutoScroll ? "none" : "flex";
      }
    });
    scrollToBottomButton.addEventListener("click", () => {
      chatView.scrollManager.forceScrollToBottom();
    });
    const modelIndicatorSection = container.createEl("div", {
      cls: "systemsculpt-model-indicator-section"
    });
    chatView.inputHandler = new InputHandler({
      app: chatView.app,
      container,
      aiService: chatView.aiService,
      getMessages: () => chatView.getMessages(),
      getSelectedModelId: () => chatView.selectedModelId,
      getContextFiles: () => chatView.contextManager.getContextFiles(),
      getSystemPrompt: () => ({ type: chatView.systemPromptType, path: chatView.systemPromptPath }),
      chatContainer: chatView.chatContainer,
      scrollManager: chatView.scrollManager,
      messageRenderer: chatView.messageRenderer,
      onMessageSubmit: async (message) => {
        chatView.messages.push(message);
        await chatView.saveChat();
        await chatView.addMessage(message.role, message.content, message.message_id);
      },
      onAssistantResponse: async (message) => {
        const existingMessageIndex = chatView.messages.findIndex((m) => m.message_id === message.message_id);
        if (existingMessageIndex !== -1) {
          const existingMessage = chatView.messages[existingMessageIndex];
          let mergedToolCalls = void 0;
          if (existingMessage.tool_calls || message.tool_calls) {
            const existingMap = new Map((existingMessage.tool_calls || []).map((tc) => [tc.id, tc]));
            const newMap = new Map((message.tool_calls || []).map((tc) => [tc.id, tc]));
            const mergedMap = new Map([...existingMap, ...newMap]);
            for (const [id, existingTc] of existingMap) {
              if (existingTc.result && mergedMap.has(id)) {
                const mergedTc = mergedMap.get(id);
                if (!mergedTc.result) {
                  mergedTc.result = existingTc.result;
                }
              }
            }
            mergedToolCalls = Array.from(mergedMap.values());
          }
          const mergedMessage = {
            ...existingMessage,
            ...message,
            content: message.content || existingMessage.content,
            reasoning: message.reasoning || existingMessage.reasoning,
            tool_calls: mergedToolCalls,
            messageParts: message.messageParts || existingMessage.messageParts
          };
          chatView.messages[existingMessageIndex] = mergedMessage;
        } else {
          chatView.messages.push(message);
        }
        await chatView.saveChat();
      },
      onContextFileAdd: async (wikilink) => {
        const files = chatView.contextManager.getContextFiles();
        files.add(wikilink);
        chatView.contextManager.setContextFiles(Array.from(files));
        await chatView.saveChat();
      },
      onError: (error) => chatView.handleError(error),
      onAddContextFile: () => {
        chatView.contextManager.addContextFile();
      },
      onEditSystemPrompt: () => chatView.handleSystemPromptEdit(),
      plugin: chatView.plugin,
      getChatMarkdown: () => chatView.exportChatAsMarkdown(),
      getChatTitle: () => chatView.getChatTitle(),
      addFileToContext: (file) => chatView.addFileToContext(file),
      chatStorage: chatView.chatStorage,
      getChatId: () => chatView.chatId,
      toolCallManager: chatView.toolCallManager,
      addMessageToHistory: chatView.addMessageToHistory.bind(chatView),
      chatView
    });
    chatView.inputHandler.onModelChange();
    chatView.registerEvent(chatView.app.workspace.on("active-leaf-change", (leaf) => {
      if (leaf === chatView.leaf && chatView.inputHandler) {
        chatView.inputHandler.focus();
      }
    }));
    chatView.inputHandler.focus();
    if (chatView.agentMode && !chatView.currentPrompt) {
      try {
        const { SystemPromptService: SystemPromptService2 } = await Promise.resolve().then(() => (init_SystemPromptService(), SystemPromptService_exports));
        const svc = SystemPromptService2.getInstance(chatView.app, () => chatView.plugin.settings);
        chatView.currentPrompt = await svc.getSystemPromptContent("agent", void 0, true);
      } catch (e) {
        console.error("[SystemSculpt] Failed to load agent system prompt", e);
      }
    }
    await chatView.updateModelIndicator();
    await chatView.updateSystemPromptIndicator();
    if (!chatView.plugin.settings.selectedModelId && !chatView.plugin.hasPromptedForDefaultModel) {
      chatView.plugin.hasPromptedForDefaultModel = true;
      setTimeout(async () => {
        const result = await showPopup(chatView.app, "Welcome to SystemSculpt! To get started, please select a default AI model for your chats.", { title: "Select Default Model", icon: "bot", primaryButton: "Choose Model", secondaryButton: "Skip for Now" });
        if (result == null ? void 0 : result.confirmed) {
          try {
            const models = await chatView.plugin.modelService.getModels();
            const modal = new StandardModelSelectionModal({
              app: chatView.app,
              plugin: chatView.plugin,
              currentModelId: "",
              onSelect: async (result2) => {
                await chatView.plugin.getSettingsManager().updateSettings({ selectedModelId: result2.modelId });
                chatView.selectedModelId = result2.modelId;
                await chatView.updateModelIndicator();
                new import_obsidian75.Notice("Default model set! You can change this anytime in settings.", 3e3);
              }
            });
            modal.open();
          } catch (error) {
            console.error("Error loading models:", error);
            new import_obsidian75.Notice("Failed to load models. Please try again from settings.", 5e3);
          }
        }
      }, 500);
    } else if (chatView.plugin.settings.selectedModelId) {
      if (!chatView.selectedModelId) {
        chatView.selectedModelId = chatView.plugin.settings.selectedModelId;
      }
      try {
        const models = await chatView.plugin.modelService.getModels();
        const currentModel = models.find((model) => model.id === chatView.selectedModelId);
        if (currentModel) {
          const customProvider = chatView.plugin.settings.customProviders.find((p) => p.name.toLowerCase() === currentModel.provider.toLowerCase());
          if (customProvider) {
            await chatView.plugin.getSettingsManager().updateSettings({
              activeProvider: {
                id: customProvider.id,
                name: customProvider.name,
                type: "custom"
              }
            });
          } else {
            await chatView.plugin.getSettingsManager().updateSettings({
              activeProvider: {
                id: "systemsculpt",
                name: "SystemSculpt",
                type: "native"
              }
            });
          }
        }
      } catch (error) {
        console.error("Error syncing provider:", error);
      }
    }
    chatView.toolCallManager.on("tool-call:state-changed", async ({ toolCall }) => {
      var _a;
      const message = chatView.messages.find((m) => m.message_id === toolCall.messageId);
      if (!message)
        return;
      const toolCallInMessage = (_a = message.tool_calls) == null ? void 0 : _a.find((tc) => tc.id === toolCall.id);
      if (!toolCallInMessage)
        return;
      toolCallInMessage.state = toolCall.state;
      toolCallInMessage.result = toolCall.result;
      if (chatView.isFullyLoaded) {
        await chatView.saveChat();
      }
      const messageEl = chatView.chatContainer.querySelector(`.systemsculpt-message[data-message-id="${message.message_id}"]`);
      if (messageEl) {
        const partList = chatView.messageRenderer.normalizeMessageToParts(message);
        chatView.messageRenderer.renderUnifiedMessageParts(messageEl, partList.parts);
      }
    });
    try {
      const m = globalThis.mermaid;
      if (m && !m.__ssConfigured) {
        const rootStyle = getComputedStyle(document.body);
        const accent = rootStyle.getPropertyValue("--interactive-accent").trim() || "#666";
        const bgPrimary = rootStyle.getPropertyValue("--background-primary").trim() || "#fff";
        const bgSecondary = rootStyle.getPropertyValue("--background-secondary").trim() || "#f4f4f4";
        const textNorm = rootStyle.getPropertyValue("--text-normal").trim() || "#333";
        m.initialize({
          startOnLoad: false,
          theme: "base",
          themeVariables: {
            primaryColor: bgSecondary,
            primaryBorderColor: accent,
            primaryTextColor: textNorm,
            lineColor: accent,
            textColor: textNorm,
            tertiaryColor: bgPrimary
          }
        });
        m.__ssConfigured = true;
      }
    } catch (e) {
      console.warn("[SystemSculpt] Failed to configure Mermaid colors:", e);
    }
  },
  updateModelIndicator: async function(chatView) {
    const container = chatView.containerEl.children[1];
    const modelSection = container == null ? void 0 : container.querySelector(".systemsculpt-model-indicator-section");
    if (!modelSection)
      return;
    if (!chatView.agentMode && chatView.manageAgentToolingButton) {
      chatView.manageAgentToolingButton.remove();
      chatView.manageAgentToolingButton = void 0;
    }
    if (!chatView.modelIndicator) {
      chatView.modelIndicator = modelSection.createEl("div", {
        cls: "systemsculpt-model-indicator"
      });
      chatView.registerDomEvent(chatView.modelIndicator, "click", async () => {
        if (chatView.agentMode) {
          new import_obsidian75.Notice("Model is locked when Agent Mode is active for this chat. Disable Agent Mode to change models.", 5e3);
          return;
        }
        const modal = new StandardModelSelectionModal({
          app: chatView.app,
          plugin: chatView.plugin,
          currentModelId: chatView.selectedModelId || "",
          onSelect: async (result) => {
            await chatView.setSelectedModelId(result.modelId);
            new import_obsidian75.Notice("Model updated for this chat.", 3e3);
          }
        });
        modal.open();
      });
      chatView.registerDomEvent(chatView.modelIndicator, "keydown", (event) => {
        var _a;
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          (_a = event.target) == null ? void 0 : _a.click();
        }
      });
    } else {
      chatView.modelIndicator.empty();
    }
    if (chatView.agentMode && (!chatView.selectedModelId || chatView.selectedModelId.includes("unknown"))) {
      const { AGENT_CONFIG: AGENT_CONFIG2 } = await Promise.resolve().then(() => (init_agent2(), agent_exports));
      const models = await chatView.plugin.modelService.getModels();
      const agentModelAvailable = models.some((model) => model.id === AGENT_CONFIG2.MODEL_ID);
      if (agentModelAvailable) {
        chatView.selectedModelId = AGENT_CONFIG2.MODEL_ID;
        console.log("[SystemSculpt] updateModelIndicator: Fixed agent mode model to:", AGENT_CONFIG2.MODEL_ID);
      } else {
        chatView.agentMode = false;
        console.warn("[SystemSculpt] updateModelIndicator: Agent mode DISABLED - required model not available:", AGENT_CONFIG2.MODEL_ID);
        new import_obsidian75.Notice("Agent mode disabled: SystemSculpt Agent Model not available", 5e3);
        setTimeout(() => {
          chatView.updateModelIndicator();
          chatView.updateSystemPromptIndicator();
        }, 100);
      }
    }
    if (!chatView.agentMode) {
      chatView.modelIndicator.setAttrs({
        role: "button",
        tabindex: 0,
        "aria-label": "Change chat model"
      });
    } else {
      chatView.modelIndicator.removeAttribute("role");
      chatView.modelIndicator.removeAttribute("tabindex");
      chatView.modelIndicator.setAttr("aria-label", "Agent Mode - Model is locked");
    }
    if (!chatView.selectedModelId || chatView.selectedModelId.trim() === "" || chatView.selectedModelId === "unknown" || chatView.selectedModelId.includes("unknown")) {
      if (chatView.modelIndicator) {
        const iconSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-icon" });
        (0, import_obsidian75.setIcon)(iconSpan, "bot");
        chatView.modelIndicator.createSpan({ text: "No model selected" });
        chatView.modelIndicator.addClass("systemsculpt-no-model");
        chatView.modelIndicator.setAttr("aria-label", "No model selected, click to choose one");
      }
      return;
    }
    try {
      const models = await chatView.plugin.modelService.getModels();
      const currentModel = models.find((model) => getCanonicalId(model) === ensureCanonicalId(chatView.selectedModelId));
      if (currentModel) {
        let providerPrefix = currentModel.provider === "systemsculpt" ? "" : `[${currentModel.provider.toUpperCase()}] `;
        chatView.currentModelName = currentModel.name;
        if (chatView.modelIndicator) {
          chatView.modelIndicator.removeClass("systemsculpt-no-model");
        }
        if (chatView.agentMode) {
          if (chatView.modelIndicator) {
            const iconSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-icon" });
            (0, import_obsidian75.setIcon)(iconSpan, "bot");
            chatView.modelIndicator.createSpan({ text: "Agent Mode" });
            const arrowSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-arrow" });
            (0, import_obsidian75.setIcon)(arrowSpan, "lock");
            chatView.modelIndicator.setAttr("aria-label", "Agent Mode. Model is locked when Agent Mode is active.");
            chatView.modelIndicator.setAttr("title", "Agent Mode - Model is locked. Disable Agent Mode in the MCP tools modal (brain icon) to change models.");
            chatView.modelIndicator.addClass("systemsculpt-model-locked");
          }
        } else {
          if (chatView.modelIndicator) {
            const iconSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-icon" });
            (0, import_obsidian75.setIcon)(iconSpan, "bot");
            const labelText = `${providerPrefix}${chatView.currentModelName}`;
            chatView.modelIndicator.createSpan({ text: labelText });
            const arrowSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-arrow" });
            (0, import_obsidian75.setIcon)(arrowSpan, "chevron-down");
            chatView.modelIndicator.setAttr("aria-label", `Current model: ${labelText}. Click to change.`);
            chatView.modelIndicator.setAttr("title", `Current model: ${labelText}`);
            chatView.modelIndicator.removeClass("systemsculpt-model-locked");
          }
        }
      } else {
        const validation = await chatView.plugin.modelService.validateSpecificModel(chatView.selectedModelId, models);
        if (!validation.isAvailable && validation.alternativeModel) {
          const alternativeModel = validation.alternativeModel;
          const oldModelId = chatView.selectedModelId;
          chatView.selectedModelId = ensureCanonicalId(alternativeModel.id);
          if (chatView.isFullyLoaded) {
            await chatView.saveChat();
          }
          let providerPrefix = alternativeModel.provider === "systemsculpt" ? "" : `[${alternativeModel.provider.toUpperCase()}] `;
          chatView.currentModelName = alternativeModel.name;
          if (chatView.modelIndicator) {
            chatView.modelIndicator.removeClass("systemsculpt-no-model");
          }
          const iconSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-icon" });
          (0, import_obsidian75.setIcon)(iconSpan, "bot");
          const labelText = `${providerPrefix}${chatView.currentModelName}`;
          chatView.modelIndicator.createSpan({ text: labelText });
          const arrowSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-arrow" });
          (0, import_obsidian75.setIcon)(arrowSpan, "chevron-down");
          chatView.modelIndicator.setAttr("aria-label", `Current model switched to: ${labelText}. Click to change.`);
          chatView.modelIndicator.setAttr("title", `Current model switched to: ${labelText}`);
          new import_obsidian75.Notice(`Model "${oldModelId}" is no longer available. Switched to "${alternativeModel.name}"`, 8e3);
          setTimeout(async () => {
            await showPopup(chatView.app, `The model "${oldModelId}" you were using is no longer available. This can happen when models are updated or removed by providers. I've automatically switched you to "${alternativeModel.name}" so you can continue chatting. Click below to choose a different model if you prefer.`, {
              title: "Model Automatically Changed",
              icon: "alert-triangle",
              primaryButton: "Choose Different Model"
            }).then((result) => {
              var _a;
              if (result == null ? void 0 : result.confirmed) {
                (_a = chatView.modelIndicator) == null ? void 0 : _a.click();
              }
            });
          }, 500);
        } else {
          chatView.currentModelName = chatView.selectedModelId;
          if (chatView.modelIndicator) {
            chatView.modelIndicator.removeClass("systemsculpt-no-model");
          }
          const unknownText = `Unknown Model (${chatView.selectedModelId})`;
          chatView.modelIndicator.createSpan({ text: unknownText });
          const arrowSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-arrow" });
          (0, import_obsidian75.setIcon)(arrowSpan, "chevron-down");
          chatView.modelIndicator.setAttr("aria-label", `${unknownText}. Click to change.`);
          chatView.modelIndicator.setAttr("title", `${unknownText}`);
          setTimeout(async () => {
            var _a;
            const result = await showPopup(chatView.app, "The model selected for this chat is no longer available. This can happen if models are updated or removed. Click below to choose a different model for this chat.", {
              title: "Model Not Available",
              icon: "alert-triangle",
              primaryButton: "Choose Model"
            });
            if (result == null ? void 0 : result.confirmed) {
              (_a = chatView.modelIndicator) == null ? void 0 : _a.click();
            }
          }, 500);
        }
      }
    } catch (error) {
      console.error("[SystemSculpt] Error fetching models for indicator:", error);
      chatView.currentModelName = chatView.selectedModelId || "Error";
      if (chatView.modelIndicator) {
        chatView.modelIndicator.removeClass("systemsculpt-no-model");
        const errorText = `Error loading model (${chatView.currentModelName})`;
        chatView.modelIndicator.createSpan({ text: errorText });
        chatView.modelIndicator.setAttr("aria-label", `${errorText}. Click to try changing.`);
        chatView.modelIndicator.setAttr("title", `${errorText}`);
      }
    }
    if (chatView.agentMode) {
      if (chatView.modelIndicator)
        chatView.modelIndicator.style.display = "none";
      if (chatView.systemPromptIndicator)
        chatView.systemPromptIndicator.style.display = "none";
      if (!chatView.manageAgentToolingButton) {
        chatView.manageAgentToolingButton = modelSection.createEl("div", {
          cls: "systemsculpt-model-indicator systemsculpt-manage-agent-tooling-btn"
        });
        chatView.manageAgentToolingButton.setAttrs({
          role: "button",
          tabindex: 0,
          "aria-label": "Manage Agent Tooling"
        });
        chatView.manageAgentToolingButton.createSpan({ text: buildAgentToolingLabel(chatView.plugin) });
        chatView.manageAgentToolingButton.style.width = "100%";
        const refreshLabel = () => {
          if (chatView.manageAgentToolingButton) {
            chatView.manageAgentToolingButton.innerText = buildAgentToolingLabel(chatView.plugin);
          }
        };
        chatView.registerDomEvent(chatView.manageAgentToolingButton, "click", async () => {
          const { showMCPManagerModal: showMCPManagerModal2 } = await Promise.resolve().then(() => (init_MCPManagerModal(), MCPManagerModal_exports));
          await showMCPManagerModal2(chatView.app, chatView.plugin);
          refreshLabel();
        });
        chatView.registerDomEvent(chatView.manageAgentToolingButton, "keydown", (event) => {
          var _a;
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            (_a = event.target) == null ? void 0 : _a.click();
          }
        });
      } else {
        chatView.manageAgentToolingButton.innerText = buildAgentToolingLabel(chatView.plugin);
        chatView.manageAgentToolingButton.style.display = "flex";
      }
      return;
    }
    if (chatView.modelIndicator) {
      chatView.modelIndicator.style.display = "";
    }
  },
  updateSystemPromptIndicator: async function(chatView) {
    console.log("[SystemSculpt] updateSystemPromptIndicator called, agentMode:", chatView.agentMode);
    const container = chatView.containerEl.children[1];
    const modelSection = container == null ? void 0 : container.querySelector(".systemsculpt-model-indicator-section");
    if (!modelSection) {
      console.error("[SystemSculpt] Model indicator section not found when updating system prompt indicator");
      return;
    }
    if (!chatView.agentMode && chatView.manageAgentToolingButton) {
      chatView.manageAgentToolingButton.remove();
      chatView.manageAgentToolingButton = void 0;
    }
    if (chatView.agentMode) {
      console.log("[SystemSculpt] Agent mode is ON, hiding system prompt indicator");
      if (chatView.systemPromptIndicator) {
        chatView.systemPromptIndicator.style.display = "none";
      }
      if (!chatView.manageAgentToolingButton) {
        chatView.manageAgentToolingButton = modelSection.createEl("div", {
          cls: "systemsculpt-model-indicator systemsculpt-manage-agent-tooling-btn"
        });
        chatView.manageAgentToolingButton.setAttrs({
          role: "button",
          tabindex: 0,
          "aria-label": "Manage Agent Tooling"
        });
        chatView.manageAgentToolingButton.createSpan({ text: buildAgentToolingLabel(chatView.plugin) });
        chatView.manageAgentToolingButton.style.width = "100%";
        chatView.registerDomEvent(chatView.manageAgentToolingButton, "click", async () => {
          const { showMCPManagerModal: showMCPManagerModal2 } = await Promise.resolve().then(() => (init_MCPManagerModal(), MCPManagerModal_exports));
          await showMCPManagerModal2(chatView.app, chatView.plugin);
        });
        chatView.registerDomEvent(chatView.manageAgentToolingButton, "keydown", (event) => {
          var _a;
          if (event.key === "Enter" || event.key === " ") {
            event.preventDefault();
            (_a = event.target) == null ? void 0 : _a.click();
          }
        });
      } else {
        chatView.manageAgentToolingButton.style.display = "flex";
      }
      return;
    }
    console.log("[SystemSculpt] Agent mode is OFF, showing system prompt indicator");
    if (chatView.systemPromptIndicator) {
      chatView.systemPromptIndicator.style.display = "";
    }
    if (!chatView.systemPromptIndicator) {
      console.log("[SystemSculpt] Creating new system prompt indicator");
      chatView.systemPromptIndicator = modelSection.createEl("div", {
        cls: "systemsculpt-model-indicator"
      });
      chatView.registerDomEvent(chatView.systemPromptIndicator, "click", async () => {
        if (chatView.agentMode) {
          new import_obsidian75.Notice("System prompt is locked when Agent Mode is active for this chat. Disable Agent Mode to change system prompts.", 5e3);
          return;
        }
        const { StandardSystemPromptSelectionModal: StandardSystemPromptSelectionModal2 } = await Promise.resolve().then(() => (init_StandardSystemPromptSelectionModal(), StandardSystemPromptSelectionModal_exports));
        const modal = new StandardSystemPromptSelectionModal2({
          app: chatView.app,
          plugin: chatView.plugin,
          currentType: chatView.systemPromptType || "general-use",
          currentPath: chatView.systemPromptPath,
          onSelect: async (result) => {
            chatView.systemPromptType = result.type;
            if (result.type === "custom") {
              chatView.systemPromptPath = result.path;
            } else {
              chatView.systemPromptPath = void 0;
            }
            chatView.currentPrompt = result.prompt;
            await chatView.saveChat();
            await chatView.updateSystemPromptIndicator();
            new import_obsidian75.Notice("System prompt updated for this chat.", 3e3);
          }
        });
        modal.open();
      });
      chatView.registerDomEvent(chatView.systemPromptIndicator, "keydown", (event) => {
        var _a;
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          (_a = event.target) == null ? void 0 : _a.click();
        }
      });
    } else {
      chatView.systemPromptIndicator.empty();
    }
    chatView.systemPromptIndicator.setAttrs({
      role: "button",
      tabindex: 0,
      "aria-label": "Change system prompt"
    });
    let promptLabel = "System Prompt";
    switch (chatView.systemPromptType) {
      case "general-use":
        promptLabel = "General Use";
        break;
      case "concise":
        promptLabel = "Concise";
        break;
      case "agent":
        promptLabel = "Agent Prompt";
        break;
      case "custom":
        if (chatView.systemPromptPath) {
          const filename = chatView.systemPromptPath.split("/").pop() || "Custom";
          const baseName = filename.replace(".md", "");
          promptLabel = baseName;
        } else {
          promptLabel = "Custom";
        }
        break;
    }
    const iconSpan = chatView.systemPromptIndicator.createSpan({ cls: "systemsculpt-model-indicator-icon" });
    (0, import_obsidian75.setIcon)(iconSpan, chatView.systemPromptType === "agent" ? "folder-open" : "sparkles");
    chatView.systemPromptIndicator.createSpan({ text: promptLabel });
    const arrowSpan = chatView.systemPromptIndicator.createSpan({ cls: "systemsculpt-model-indicator-arrow" });
    (0, import_obsidian75.setIcon)(arrowSpan, "chevron-down");
    console.log("[SystemSculpt] System prompt indicator updated with label:", promptLabel);
    chatView.systemPromptIndicator.setAttr("aria-label", `Current system prompt: ${promptLabel}. Click to change.`);
    chatView.systemPromptIndicator.setAttr("title", `Current system prompt: ${promptLabel}`);
    if (chatView.systemPromptIndicator) {
      chatView.systemPromptIndicator.removeClass("systemsculpt-system-prompt-locked");
    }
  }
};

// src/views/chatview/eventHandling.ts
var import_obsidian76 = __toModule(require("obsidian"));
init_ui();
init_types();
init_DocumentContextManager();
var eventHandling = {
  setupDragAndDrop: function(chatView, container) {
    const overlay = container.createEl("div", { cls: "systemsculpt-drag-overlay" });
    const message = overlay.createEl("div", { cls: "systemsculpt-drag-message", text: "Drop files, folders, or search results to add to context" });
    const detailMessage = overlay.createEl("div", { cls: "systemsculpt-drag-detail", text: "" });
    const MAX_FILES = 100;
    const parseObsidianUri = (uri) => {
      try {
        if (!uri.startsWith("obsidian://open"))
          return null;
        const url = new URL(uri);
        const filePath = url.searchParams.get("file");
        if (!filePath)
          return null;
        const decodedPath = decodeURIComponent(filePath);
        console.log(`[DragDrop] parseObsidianUri: "${uri}" -> "${decodedPath}"`);
        return decodedPath;
      } catch (e) {
        console.error("[DragDrop] Error parsing URI:", uri, e);
        return null;
      }
    };
    const getFilesFromFolder2 = (folder) => {
      const files = [];
      const processFolder = (currentFolder) => {
        for (const child of currentFolder.children) {
          if (child instanceof import_obsidian76.TFile)
            files.push(child);
          else if (child instanceof import_obsidian76.TFolder)
            processFolder(child);
        }
      };
      processFolder(folder);
      return files.slice(0, MAX_FILES);
    };
    const parseSearchResults = (text) => {
      try {
        const data = JSON.parse(text);
        if (data.type === "search-results" && Array.isArray(data.results)) {
          return data;
        }
      } catch (e) {
      }
      const lines = text.split("\n").filter((line) => line.trim());
      if (lines.length < 2) {
        const line = lines[0];
        const scoreMatch = line == null ? void 0 : line.match(/^(.+?)\s+\((\d+(?:\.\d+)?)%?\)$/);
        const titlePathMatch = line == null ? void 0 : line.match(/^(.+?)\s*-\s*(.+)$/);
        if (!scoreMatch && !titlePathMatch) {
          return null;
        }
      }
      const searchResults = [];
      for (const line of lines) {
        const scoreMatch = line.match(/^(.+?)\s+\((\d+(?:\.\d+)?)%?\)$/);
        const titlePathMatch = line.match(/^(.+?)\s*-\s*(.+)$/);
        if (scoreMatch) {
          const [, path, scoreStr] = scoreMatch;
          const score = parseFloat(scoreStr) / 100;
          searchResults.push({ path: path.trim(), score });
        } else if (titlePathMatch) {
          const [, title, path] = titlePathMatch;
          searchResults.push({ path: path.trim(), title: title.trim() });
        } else if (line.trim()) {
          if (lines.length > 1) {
            searchResults.push({ path: line.trim() });
          }
        }
      }
      if (searchResults.length > 0) {
        return {
          type: "search-results",
          results: searchResults
        };
      }
      return null;
    };
    const parseFolderData = (text) => {
      try {
        const data = JSON.parse(text);
        if (data.type === "folder" && data.path) {
          return data;
        }
      } catch (e) {
      }
      return null;
    };
    const parseSimilarNoteData = (dt) => {
      try {
        const similarNoteData = dt.getData("application/x-systemsculpt-similar-note");
        if (similarNoteData) {
          const data = JSON.parse(similarNoteData);
          if (data.source === "similar-notes" && data.path) {
            return {
              type: "similar-note",
              path: data.path,
              title: data.title || data.path.split("/").pop() || data.path,
              score: data.score || 0,
              source: data.source
            };
          }
        }
      } catch (e) {
      }
      return null;
    };
    const getFileCount = async (dt) => {
      const currentContextSize = chatView.contextManager.getContextFiles().size;
      if (currentContextSize >= MAX_FILES)
        return { count: 0, type: "limit-reached" };
      const remainingSlots = MAX_FILES - currentContextSize;
      const similarNote = parseSimilarNoteData(dt);
      if (similarNote) {
        const file = chatView.app.vault.getAbstractFileByPath(similarNote.path);
        if (file instanceof import_obsidian76.TFile) {
          const scorePercent = Math.round(similarNote.score * 100);
          return {
            count: 1,
            type: "similar-note",
            details: `Similar note: "${similarNote.title}" (${scorePercent}% match)`
          };
        }
        return { count: 0, type: "similar-note-not-found" };
      }
      let newFileCount = 0;
      let filesToProcess = [];
      let contentType = "files";
      let details = "";
      if (dt.items && dt.items.length > 0) {
        for (const item of Array.from(dt.items)) {
          if (item.type === "text/plain") {
            const text = await new Promise((resolve) => item.getAsString(resolve));
            const lines = text.split("\n").filter((line) => line.trim());
            if (lines.length === 1) {
              const singlePath = lines[0].trim();
              let abstractFile = null;
              if (singlePath.startsWith("obsidian://")) {
                const filePath = parseObsidianUri(singlePath);
                if (filePath) {
                  abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
                  if (!abstractFile && !filePath.endsWith(".md")) {
                    const mdPath = `${filePath}.md`;
                    abstractFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                  }
                }
              } else {
                abstractFile = chatView.app.vault.getAbstractFileByPath(singlePath);
                if (!abstractFile && !singlePath.includes("/") && !singlePath.includes("\\")) {
                  const allFolders = chatView.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian76.TFolder);
                  abstractFile = allFolders.find((f) => f.name === singlePath);
                }
              }
              if (abstractFile instanceof import_obsidian76.TFolder) {
                contentType = "folder";
                details = `Folder: "${abstractFile.name}"`;
                filesToProcess.push(abstractFile);
                break;
              } else if (abstractFile instanceof import_obsidian76.TFile) {
                contentType = "files";
                filesToProcess.push(abstractFile);
                break;
              }
            }
            const searchData = parseSearchResults(text);
            if (searchData) {
              contentType = "search-results";
              details = searchData.query ? `Query: "${searchData.query}"` : "";
              for (const result of searchData.results) {
                const abstractFile = chatView.app.vault.getAbstractFileByPath(result.path);
                if (abstractFile instanceof import_obsidian76.TFile) {
                  filesToProcess.push(abstractFile);
                } else if (!result.path.includes(".")) {
                  const mdPath = `${result.path}.md`;
                  const mdFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                  if (mdFile instanceof import_obsidian76.TFile)
                    filesToProcess.push(mdFile);
                }
              }
              break;
            }
            const folderData = parseFolderData(text);
            if (folderData) {
              const folder = chatView.app.vault.getAbstractFileByPath(folderData.path);
              if (folder instanceof import_obsidian76.TFolder) {
                contentType = "folder";
                details = `Folder: "${folderData.name || folder.name}"`;
                filesToProcess.push(folder);
                break;
              }
            }
            for (const line of lines) {
              let filePath = line;
              let abstractFile = null;
              if (line.startsWith("obsidian://"))
                filePath = parseObsidianUri(line) || line;
              abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
              if (abstractFile instanceof import_obsidian76.TFolder) {
                filesToProcess.push(abstractFile);
                contentType = "folder";
                details = `Folder: "${abstractFile.name}"`;
              } else if (abstractFile instanceof import_obsidian76.TFile) {
                filesToProcess.push(abstractFile);
              } else if (!filePath.includes(".")) {
                const mdPath = `${filePath}.md`;
                const mdFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                if (mdFile instanceof import_obsidian76.TFile)
                  filesToProcess.push(mdFile);
              }
            }
          }
        }
      }
      for (const item of filesToProcess) {
        if (item instanceof import_obsidian76.TFolder)
          newFileCount += getFilesFromFolder2(item).length;
        else if (item instanceof import_obsidian76.TFile)
          newFileCount++;
      }
      if (newFileCount === 0 && dt.types.includes("text/uri-list")) {
        const uriData = await new Promise((resolve) => dt.items[1].getAsString(resolve));
        const uris = uriData.split("obsidian://open").filter((uri) => uri.trim()).map((uri) => "obsidian://open" + uri.trim());
        for (const uri of uris) {
          const filePath = parseObsidianUri(uri);
          if (!filePath)
            continue;
          const abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
          if (abstractFile instanceof import_obsidian76.TFolder)
            newFileCount += getFilesFromFolder2(abstractFile).length;
          else if (abstractFile instanceof import_obsidian76.TFile)
            newFileCount++;
        }
      }
      return {
        count: Math.min(newFileCount, remainingSlots),
        type: contentType,
        details
      };
    };
    const updateMessage = async (dt) => {
      const currentContextSize = chatView.contextManager.getContextFiles().size;
      if (currentContextSize >= MAX_FILES) {
        message.textContent = `Cannot add more files (max ${MAX_FILES} reached)`;
        detailMessage.textContent = "";
        container.removeAttribute("data-drag-type");
        return;
      }
      const fileInfo = await getFileCount(dt);
      if (fileInfo.count > 0) {
        const typeLabel = fileInfo.type === "search-results" ? "search results" : fileInfo.type === "folders" ? "multiple folders" : fileInfo.type === "folder" ? "folder contents" : fileInfo.type === "similar-note" ? "similar notes" : "files";
        if (fileInfo.type === "similar-note") {
          message.textContent = `Add similar note to context (${currentContextSize + fileInfo.count}/${MAX_FILES} total)`;
        } else {
          message.textContent = `Add ${fileInfo.count} file${fileInfo.count > 1 ? "s" : ""} from ${typeLabel} (${currentContextSize + fileInfo.count}/${MAX_FILES} total)`;
        }
        detailMessage.textContent = fileInfo.details || "";
        container.setAttribute("data-drag-type", fileInfo.type);
      } else {
        message.textContent = `Drop files, folders, or search results to add to context (${currentContextSize}/${MAX_FILES})`;
        detailMessage.textContent = "";
        container.removeAttribute("data-drag-type");
      }
    };
    let dragCounter = 0;
    let dragOverTimeout = null;
    const handlers = {
      dragenter: (e) => {
        e.preventDefault();
        e.stopPropagation();
        dragCounter++;
        if (dragCounter === 1) {
          container.addClass("systemsculpt-drag-active");
          if (e.dataTransfer)
            updateMessage(e.dataTransfer);
        }
      },
      dragleave: (e) => {
        e.preventDefault();
        e.stopPropagation();
        dragCounter--;
        if (dragCounter === 0) {
          container.removeClass("systemsculpt-drag-active");
          container.removeAttribute("data-drag-type");
        }
      },
      dragover: async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (dragOverTimeout)
          clearTimeout(dragOverTimeout);
        dragOverTimeout = setTimeout(async () => {
          if (e.dataTransfer)
            await updateMessage(e.dataTransfer);
        }, 100);
      },
      drop: async (e) => {
        var _a, _b, _c, _d;
        e.preventDefault();
        e.stopPropagation();
        dragCounter = 0;
        container.removeClass("systemsculpt-drag-active");
        container.removeAttribute("data-drag-type");
        const dt = e.dataTransfer;
        if (!dt)
          return;
        const startingContextSize = chatView.contextManager.getContextFiles().size;
        if (startingContextSize >= MAX_FILES) {
          await showAlert(chatView.app, `Cannot add more files (max ${MAX_FILES} reached)`, { type: "info", icon: "alert-triangle" });
          return;
        }
        try {
          const similarNote = parseSimilarNoteData(dt);
          if (similarNote) {
            console.log(`[DragDrop] Processing similar note:`, similarNote);
            const file = chatView.app.vault.getAbstractFileByPath(similarNote.path);
            if (file instanceof import_obsidian76.TFile) {
              const documentContextManager2 = DocumentContextManager.getInstance(chatView.app, chatView.plugin);
              await documentContextManager2.addFileToContext(file, chatView.contextManager, {
                showNotices: false,
                updateUI: true,
                saveChanges: true
              });
              const scorePercent = Math.round(similarNote.score * 100);
              new import_obsidian76.Notice(`Added "${similarNote.title}" (${scorePercent}% match) to context`, 3e3);
              return;
            } else {
              new import_obsidian76.Notice(`Similar note not found: ${similarNote.path}`, 4e3);
              return;
            }
          }
          let filesToProcess = [];
          let dropType = "files";
          let dropDetails = "";
          if (dt.items && dt.items.length > 0) {
            for (const item of Array.from(dt.items)) {
              if (item.type === "text/plain") {
                const text = await new Promise((resolve) => item.getAsString(resolve));
                const lines = text.split("\n").filter((line) => line.trim());
                if (lines.length === 1) {
                  const singlePath = lines[0].trim();
                  let abstractFile = null;
                  console.log(`[DragDrop] Attempting to resolve single path: "${singlePath}"`);
                  if (singlePath.startsWith("obsidian://")) {
                    const filePath = parseObsidianUri(singlePath);
                    console.log(`[DragDrop] Parsed URI path: "${filePath}"`);
                    if (filePath) {
                      abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
                      console.log(`[DragDrop] URI resolved to:`, abstractFile);
                      if (!abstractFile && !filePath.endsWith(".md")) {
                        const mdPath = `${filePath}.md`;
                        abstractFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                        console.log(`[DragDrop] Tried with .md extension: "${mdPath}" ->`, abstractFile);
                      }
                    }
                  } else {
                    abstractFile = chatView.app.vault.getAbstractFileByPath(singlePath);
                    console.log(`[DragDrop] Direct path resolved to:`, abstractFile);
                    if (!abstractFile && !singlePath.includes("/") && !singlePath.includes("\\")) {
                      console.log(`[DragDrop] Searching for folder by name: "${singlePath}"`);
                      const allFolders = chatView.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian76.TFolder);
                      abstractFile = allFolders.find((f) => f.name === singlePath);
                      console.log(`[DragDrop] Found folder by name:`, abstractFile);
                    }
                  }
                  if (abstractFile instanceof import_obsidian76.TFolder) {
                    dropType = "folder";
                    dropDetails = `Folder: "${abstractFile.name}"`;
                    filesToProcess.push(abstractFile);
                    console.log(`[DragDrop] Detected folder: ${abstractFile.path}`);
                    break;
                  } else if (abstractFile instanceof import_obsidian76.TFile) {
                    dropType = "files";
                    filesToProcess.push(abstractFile);
                    console.log(`[DragDrop] Detected file: ${abstractFile.path}`);
                    break;
                  }
                }
                const searchData = parseSearchResults(text);
                if (searchData) {
                  dropType = "search-results";
                  dropDetails = searchData.query ? `Search: "${searchData.query}"` : "Search results";
                  console.log(`[DragDrop] Processing search results with ${searchData.results.length} items`);
                  for (const result of searchData.results) {
                    const abstractFile = chatView.app.vault.getAbstractFileByPath(result.path);
                    if (abstractFile instanceof import_obsidian76.TFile) {
                      filesToProcess.push(abstractFile);
                    } else if (!result.path.includes(".")) {
                      const mdPath = `${result.path}.md`;
                      const mdFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                      if (mdFile instanceof import_obsidian76.TFile)
                        filesToProcess.push(mdFile);
                    }
                  }
                  break;
                }
                const folderData = parseFolderData(text);
                if (folderData) {
                  const folder = chatView.app.vault.getAbstractFileByPath(folderData.path);
                  if (folder instanceof import_obsidian76.TFolder) {
                    dropType = "folder";
                    dropDetails = `Folder: "${folderData.name || folder.name}"`;
                    filesToProcess.push(folder);
                    break;
                  }
                }
                let folderCount = 0;
                for (const line of lines) {
                  let filePath = line;
                  let abstractFile = null;
                  if (line.startsWith("obsidian://"))
                    filePath = parseObsidianUri(line) || line;
                  abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
                  if (abstractFile instanceof import_obsidian76.TFolder) {
                    filesToProcess.push(abstractFile);
                    folderCount++;
                    dropType = folderCount > 1 ? "folders" : "folder";
                    dropDetails = folderCount > 1 ? `${folderCount} folders` : `Folder: "${abstractFile.name}"`;
                  } else if (abstractFile instanceof import_obsidian76.TFile) {
                    const extension = abstractFile.extension.toLowerCase();
                    const requiresPro = ["pdf", "doc", "docx", "mp3", "wav", "m4a", "ogg", "webm"].includes(extension);
                    if (requiresPro && (!((_a = chatView.plugin.settings.licenseKey) == null ? void 0 : _a.trim()) || !chatView.plugin.settings.licenseValid)) {
                      await showPopup(chatView.app, "Document processing is a Pro feature...", { title: "Pro Feature", primaryButton: "Get License", secondaryButton: "Maybe Later" }).then((result) => {
                        if (result == null ? void 0 : result.confirmed)
                          window.open(LICENSE_URL, "_blank");
                      });
                      return;
                    }
                    filesToProcess.push(abstractFile);
                  } else if (!filePath.includes(".")) {
                    const mdPath = `${filePath}.md`;
                    const mdFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                    if (mdFile instanceof import_obsidian76.TFile)
                      filesToProcess.push(mdFile);
                  }
                }
              }
            }
          }
          if (filesToProcess.length === 0 && dt.types.includes("text/uri-list")) {
            const uriData = await new Promise((resolve) => dt.items[1].getAsString(resolve));
            const uris = uriData.split("obsidian://open").filter((uri) => uri.trim()).map((uri) => "obsidian://open" + uri.trim());
            for (const uri of uris) {
              const filePath = parseObsidianUri(uri);
              if (!filePath)
                continue;
              let abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
              if (abstractFile instanceof import_obsidian76.TFile) {
                const extension = abstractFile.extension.toLowerCase();
                const requiresPro = ["pdf", "doc", "docx", "mp3", "wav", "m4a", "ogg", "webm"].includes(extension);
                if (requiresPro && (!((_b = chatView.plugin.settings.licenseKey) == null ? void 0 : _b.trim()) || !chatView.plugin.settings.licenseValid)) {
                  await showPopup(chatView.app, "Document processing is a Pro feature...", { title: "Pro Feature", primaryButton: "Get License", secondaryButton: "Maybe Later" }).then((result) => {
                    if (result == null ? void 0 : result.confirmed)
                      window.open(LICENSE_URL, "_blank");
                  });
                  return;
                }
              }
              if (abstractFile instanceof import_obsidian76.TFile || abstractFile instanceof import_obsidian76.TFolder)
                filesToProcess.push(abstractFile);
            }
          }
          let totalFilesAdded = 0;
          const remainingSlots = MAX_FILES - startingContextSize;
          const documentContextManager = DocumentContextManager.getInstance(chatView.app, chatView.plugin);
          console.log(`[DragDrop] Processing ${filesToProcess.length} items of type: ${dropType}`);
          if (dropDetails)
            console.log(`[DragDrop] Details: ${dropDetails}`);
          const folders = filesToProcess.filter((item) => item instanceof import_obsidian76.TFolder);
          const files = filesToProcess.filter((item) => item instanceof import_obsidian76.TFile);
          for (const folder of folders) {
            const folderFiles = getFilesFromFolder2(folder);
            console.log(`[DragDrop] Processing folder ${folder.path} with ${folderFiles.length} files`);
            const proFiles = folderFiles.filter((file) => {
              const extension = file.extension.toLowerCase();
              return ["pdf", "doc", "docx", "mp3", "wav", "m4a", "ogg", "webm"].includes(extension);
            });
            if (proFiles.length > 0 && (!((_c = chatView.plugin.settings.licenseKey) == null ? void 0 : _c.trim()) || !chatView.plugin.settings.licenseValid)) {
              await showPopup(chatView.app, "Document processing is a Pro feature...", {
                title: "Pro Feature",
                primaryButton: "Get License",
                secondaryButton: "Maybe Later"
              }).then((result) => {
                if (result == null ? void 0 : result.confirmed)
                  window.open(LICENSE_URL, "_blank");
              });
              continue;
            }
            const addedCount = await documentContextManager.addFilesToContext(folderFiles, chatView.contextManager, {
              showNotices: true,
              updateUI: true,
              saveChanges: true,
              maxFiles: MAX_FILES
            });
            totalFilesAdded += addedCount;
          }
          if (files.length > 0) {
            console.log(`[DragDrop] Processing ${files.length} individual files`);
            const proFiles = files.filter((file) => {
              const extension = file.extension.toLowerCase();
              return ["pdf", "doc", "docx", "mp3", "wav", "m4a", "ogg", "webm"].includes(extension);
            });
            if (proFiles.length > 0 && (!((_d = chatView.plugin.settings.licenseKey) == null ? void 0 : _d.trim()) || !chatView.plugin.settings.licenseValid)) {
              await showPopup(chatView.app, "Document processing is a Pro feature...", {
                title: "Pro Feature",
                primaryButton: "Get License",
                secondaryButton: "Maybe Later"
              }).then((result) => {
                if (result == null ? void 0 : result.confirmed)
                  window.open(LICENSE_URL, "_blank");
              });
              return;
            }
            const addedCount = await documentContextManager.addFilesToContext(files, chatView.contextManager, {
              showNotices: true,
              updateUI: true,
              saveChanges: true,
              maxFiles: MAX_FILES
            });
            totalFilesAdded += addedCount;
          }
          if (totalFilesAdded > 0) {
            const contextMessage = dropType === "search-results" ? "from search results" : dropType === "folders" ? "from multiple folders" : dropType === "folder" ? "from folder" : "";
            new import_obsidian76.Notice(`Added ${totalFilesAdded} file${totalFilesAdded > 1 ? "s" : ""} to context ${contextMessage}`, 3e3);
          } else if ((dropType === "folder" || dropType === "folders") && filesToProcess.length > 0) {
            const folderNames = filesToProcess.filter((item) => item instanceof import_obsidian76.TFolder).map((folder) => folder.name);
            if (folderNames.length === 1) {
              new import_obsidian76.Notice(`The "${folderNames[0]}" folder is empty - no files to add to context`, 4e3);
            } else if (folderNames.length > 1) {
              new import_obsidian76.Notice(`The selected folders are empty - no files to add to context`, 4e3);
            }
          }
          console.log(`[DragDrop] Added ${totalFilesAdded} files to context from ${dropType}`);
        } catch (error) {
          console.error("[DragDrop] Error processing drop:", error);
          await showAlert(chatView.app, "Failed to process dropped files", { type: "error" });
        }
      }
    };
    container.addEventListener("dragenter", handlers.dragenter);
    container.addEventListener("dragleave", handlers.dragleave);
    container.addEventListener("dragover", handlers.dragover);
    container.addEventListener("drop", handlers.drop);
    return () => {
      container.removeEventListener("dragenter", handlers.dragenter);
      container.removeEventListener("dragleave", handlers.dragleave);
      container.removeEventListener("dragover", handlers.dragover);
      container.removeEventListener("drop", handlers.drop);
      if (dragOverTimeout) {
        clearTimeout(dragOverTimeout);
        dragOverTimeout = null;
      }
    };
  }
};

// src/modals/StandardChatSettingsModal.ts
var import_obsidian79 = __toModule(require("obsidian"));
init_SystemPromptService();
init_StandardModelSelectionModal();
init_StandardModal();
init_TitleGenerationService();
init_modelUtils();
init_prompts2();
init_licenseUtils();
var CustomPromptFileSuggestModal2 = class extends import_obsidian79.SuggestModal {
  constructor(app, systemPromptService, onSelect) {
    super(app);
    this.systemPromptService = systemPromptService;
    this.onSelectCallback = onSelect;
    this.setPlaceholder("Select a custom system prompt file...");
  }
  async getSuggestions(query) {
    const files = await this.systemPromptService.getCustomPromptFiles();
    if (!query) {
      return files;
    }
    return files.filter((file) => file.name.toLowerCase().includes(query.toLowerCase()));
  }
  renderSuggestion(file, el) {
    el.createEl("div", { text: file.name });
    el.createEl("small", { text: file.path, cls: "ss-suggestion-path" });
  }
  onChooseSuggestion(file, evt) {
    this.onSelectCallback(file);
  }
};
var StandardChatSettingsModal = class extends StandardModal {
  constructor(app, options) {
    super(app);
    this.result = null;
    this.presetButtons = {};
    this.isGeneratingTitle = false;
    this.settingsChangedListener = null;
    this.selectPreset = async (type) => {
      var _a, _b, _c;
      if (type === "agent" && !this.isAgentModeAvailable()) {
        verifyPremiumAccess(this.options.plugin.settings, 0, true);
        return;
      }
      this.currentType = type;
      if (type === "general-use") {
        this.currentPrompt = GENERAL_USE_PRESET.systemPrompt;
        this.currentPath = void 0;
      } else if (type === "concise") {
        this.currentPrompt = CONCISE_PRESET.systemPrompt;
        this.currentPath = void 0;
      } else if (type === "agent") {
        this.currentPrompt = AGENT_PRESET.systemPrompt;
        this.currentPath = void 0;
      } else if (type === "custom") {
        if (!this.currentPath) {
          this.openCustomPromptSelector();
          this.currentPrompt = "";
        } else {
          await this.loadInitialPrompt();
        }
      }
      if (this.promptTextEditor) {
        this.promptTextEditor.value = this.currentPrompt;
      }
      this.updatePresetButtons();
      this.updateSelectedFileInfo();
      if (this.options.mode === "defaults-only" && this.options.plugin) {
        await this.options.plugin.getSettingsManager().updateSettings({
          systemPromptType: this.currentType,
          systemPromptPath: (_a = this.currentPath) != null ? _a : ""
        });
        (_c = (_b = this.options.plugin.emitter) == null ? void 0 : _b.emit) == null ? void 0 : _c.call(_b, "settingsChanged");
        new import_obsidian79.Notice("Default system prompt updated.", 2e3);
      }
    };
    this.openCustomPromptSelector = () => {
      new CustomPromptFileSuggestModal2(this.app, this.systemPromptService, async (file) => {
        this.currentPath = file.path;
        this.currentType = "custom";
        await this.loadInitialPrompt();
        this.updatePresetButtons();
        this.updateSelectedFileInfo();
      }).open();
    };
    this.openChangeDefaultPromptModal = () => {
      const modal = new (init_DefaultChatPresetsModal(), DefaultChatPresetsModal_exports).DefaultChatPresetsModal(this.app, this.options.plugin);
      modal.open();
    };
    this.openModelSelectModal = async () => {
      var _a;
      if (!this.options.plugin) {
        new import_obsidian79.Notice("Cannot change model: plugin instance not available", 1e4);
        return;
      }
      if ((_a = this.options.chatView) == null ? void 0 : _a.agentMode) {
        new import_obsidian79.Notice("Model is locked when Agent Mode is active for this chat. Disable Agent Mode to change models.", 5e3);
        return;
      }
      const modelSelectionOptions = {
        app: this.app,
        plugin: this.options.plugin,
        currentModelId: this.currentModelId || "",
        isAgentPromptActive: false,
        onSelect: async (result) => {
          const canonicalId = ensureCanonicalId(result.modelId);
          if (this.options.onModelSelect) {
            try {
              await this.options.onModelSelect(canonicalId);
              this.currentModelId = canonicalId;
              this.updateModelDisplay();
            } catch (error) {
              console.error("Error selecting model:", error);
              new import_obsidian79.Notice("Failed to select model", 1e4);
            }
          } else {
            console.warn("onModelSelect callback not provided in options.");
            this.currentModelId = canonicalId;
            this.updateModelDisplay();
          }
        }
      };
      const modal = new StandardModelSelectionModal(modelSelectionOptions);
      modal.open();
    };
    this.handleTitleGeneration = async () => {
      var _a;
      if (this.isGeneratingTitle || !this.options.plugin)
        return;
      this.isGeneratingTitle = true;
      this.generateTitleButton.setText("Generating...");
      this.generateTitleButton.disabled = true;
      let newTitle;
      try {
        newTitle = await this.titleGenerationService.generateTitle((_a = this.options.messages) != null ? _a : []);
        if (newTitle) {
          newTitle = newTitle.trim();
          this.titleInput.value = newTitle;
          this.currentTitle = newTitle;
          new import_obsidian79.Notice("Title generated!", 2e3);
        } else {
          new import_obsidian79.Notice("Could not generate title.", 5e3);
        }
      } catch (error) {
        const isBenign2000 = ((error == null ? void 0 : error.error) === 2e3 || (error == null ? void 0 : error.message) === "2000") && newTitle;
        if (isBenign2000) {
        } else {
          console.error("Title generation error:", error);
          if ((error == null ? void 0 : error.error) === 2e3 || (error == null ? void 0 : error.message) === "2000") {
            new import_obsidian79.Notice("Title generation failed (error 2000).", 1e4);
          } else {
            new import_obsidian79.Notice("Failed to generate title.", 1e4);
          }
        }
      } finally {
        this.isGeneratingTitle = false;
        this.generateTitleButton.setText("Generate Title");
        this.generateTitleButton.disabled = false;
      }
    };
    this.resolvePromise = null;
    var _a, _b, _c, _d, _e;
    this.options = options;
    this.systemPromptService = SystemPromptService.getInstance(this.app, () => this.options.plugin.settings);
    this.titleGenerationService = TitleGenerationService.getInstance(this.options.plugin);
    this.currentPrompt = (_a = options.currentPrompt) != null ? _a : "";
    this.currentType = (_b = options.currentSystemPromptType) != null ? _b : "general-use";
    this.currentPath = options.systemPromptPath;
    this.currentTitle = (_c = options.chatTitle) != null ? _c : "";
    this.currentModelId = (_d = options.currentModelId) != null ? _d : "";
    this.currentChatFontSize = ((_e = options.chatView) == null ? void 0 : _e.chatFontSize) || options.plugin.settings.chatFontSize || "medium";
    this.modalEl.addClass("ss-chat-settings-modal");
    this.setSize("large");
  }
  onOpen() {
    super.onOpen();
    const title = this.options.mode === "defaults-only" ? "Default Chat Presets" : "Chat Settings";
    this.addTitle(title);
    this.display();
    this.updatePresetButtons();
    this.updateSelectedFileInfo();
    this.updateModelDisplay();
    this.loadInitialPrompt();
    if (this.options.plugin && this.options.plugin.emitter) {
      this.settingsChangedListener = () => {
        this.updateSelectedFileInfo();
        this.updatePresetButtons();
      };
      this.options.plugin.emitter.on("settingsChanged", this.settingsChangedListener);
    }
  }
  display() {
    var _a, _b;
    const { contentEl } = this;
    contentEl.empty();
    if (this.options.mode === "defaults-only") {
      contentEl.createEl("h3", { text: "Default Chat Presets" });
      const intro = contentEl.createDiv();
      intro.createEl("div", {
        text: "Set your default AI model and system prompt type for new chats. These presets will be used every time you start a new, fresh chat."
      });
      contentEl.createEl("hr");
      contentEl.createEl("h3", { text: "AI Model" });
      const modelSetting = new import_obsidian79.Setting(contentEl).addButton((btn) => {
        btn.setButtonText("Change Model").onClick(this.openModelSelectModal);
      });
      const modelInput = modelSetting.controlEl.createEl("input", {
        type: "text",
        value: this.currentModelId ? getDisplayName(this.currentModelId) : ((_b = (_a = this.options.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.selectedModelId) ? getDisplayName(this.options.plugin.settings.selectedModelId) : "No model selected",
        attr: { readonly: "true" }
      });
      modelInput.style.marginRight = "8px";
      this.modelNameDisplay = modelInput;
      contentEl.createEl("hr");
      contentEl.createEl("h3", { text: "System Prompt Type" });
      const promptSetting = new import_obsidian79.Setting(contentEl);
      const buttonContainer = promptSetting.controlEl.createDiv();
      this.createPresetButtons(buttonContainer);
      this.selectedFileInfo = promptSetting.controlEl.createDiv();
      this.updateSelectedFileInfo();
      this.updatePresetButtons();
      contentEl.createEl("hr");
    } else {
      const leftPanel = contentEl.createDiv("ss-chat-settings-modal__left-panel");
      const rightPanel = contentEl.createDiv("ss-chat-settings-modal__right-panel");
      this.createTitleSection(leftPanel);
      this.createModelSection(leftPanel);
      this.createChatFontSizeSection(leftPanel);
      this.createSystemPromptTypeSection(leftPanel, false);
      this.createPromptEditorSection(rightPanel);
      this.createDefaultSettingsSection(rightPanel);
    }
  }
  createTitleSection(containerEl) {
    var _a, _b, _c, _d;
    const section = containerEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", { text: "Chat Title", cls: "ss-chat-settings-modal__section-title" });
    const controls = section.createDiv("ss-chat-settings-modal__model-controls");
    controls.style.display = "flex";
    controls.style.gap = "5px";
    controls.style.width = "100%";
    this.titleInput = controls.createEl("input", {
      type: "text",
      value: this.currentTitle,
      cls: "ss-chat-settings-modal__model-input"
    });
    this.titleInput.style.flexGrow = "1";
    this.titleInput.style.minWidth = "0";
    this.titleInput.addEventListener("change", (e) => {
      this.currentTitle = e.target.value;
    });
    this.generateTitleButton = controls.createEl("button", {
      text: "Generate Title",
      cls: "ss-chat-settings-modal__model-change-btn"
    });
    this.generateTitleButton.addEventListener("click", this.handleTitleGeneration);
    const isEmpty = ((_d = (_c = (_a = this.options.chatView) == null ? void 0 : _a.messages.length) != null ? _c : (_b = this.options.messages) == null ? void 0 : _b.length) != null ? _d : 0) === 0;
    this.generateTitleButton.disabled = isEmpty;
  }
  createModelSection(containerEl) {
    var _a, _b, _c;
    const section = containerEl.createDiv("ss-chat-settings-modal__section");
    const isAgentModeActive = ((_a = this.options.chatView) == null ? void 0 : _a.agentMode) || false;
    if (isAgentModeActive) {
      section.createEl("h3", { text: "AI Model (Agent Mode Active)", cls: "ss-chat-settings-modal__section-title" });
      const lockedDiv = section.createDiv("ss-chat-settings-modal__model-locked");
      lockedDiv.style.padding = "16px";
      lockedDiv.style.backgroundColor = "var(--background-secondary)";
      lockedDiv.style.borderRadius = "8px";
      lockedDiv.style.opacity = "0.7";
      const lockIcon = lockedDiv.createSpan({ cls: "ss-lock-icon" });
      lockIcon.style.marginRight = "8px";
      (0, import_obsidian79.setIcon)(lockIcon, "lock");
      lockedDiv.createSpan({ text: "Model is locked to 'Agent Mode Model' while Agent Mode is active. Disable Agent Mode to change models." });
      return;
    }
    section.createEl("h3", { text: "AI Model", cls: "ss-chat-settings-modal__section-title" });
    const controls = section.createDiv("ss-chat-settings-modal__model-controls");
    controls.style.display = "flex";
    controls.style.gap = "5px";
    controls.style.width = "100%";
    const modelInput = controls.createEl("input", {
      type: "text",
      value: "",
      cls: "ss-chat-settings-modal__model-input",
      attr: { readonly: "true" }
    });
    modelInput.style.flexGrow = "1";
    modelInput.style.minWidth = "0";
    this.modelNameDisplay = modelInput;
    if (this.currentModelId) {
      this.modelNameDisplay.value = getDisplayName(this.currentModelId);
    } else if ((_c = (_b = this.options.plugin) == null ? void 0 : _b.settings) == null ? void 0 : _c.selectedModelId) {
      this.modelNameDisplay.value = getDisplayName(this.options.plugin.settings.selectedModelId);
    } else {
      this.modelNameDisplay.value = "No model selected";
    }
    this.changeModelButton = controls.createEl("button", {
      text: "Change Model",
      cls: "ss-chat-settings-modal__model-change-btn"
    });
    this.changeModelButton.addEventListener("click", this.openModelSelectModal);
    this.updateModelDisplay();
  }
  createChatFontSizeSection(containerEl) {
    const section = containerEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", { text: "Chat Size", cls: "ss-chat-settings-modal__section-title" });
    const sizeSetting = new import_obsidian79.Setting(section).setName("Message Text Size").setDesc("Change the text size for messages in this chat only.").addDropdown((dropdown) => {
      dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.currentChatFontSize).onChange(async (value) => {
        this.currentChatFontSize = value;
        if (this.options.chatView) {
          await this.options.chatView.setChatFontSize(this.currentChatFontSize);
        }
      });
    });
  }
  createSystemPromptTypeSection(containerEl, defaultsOnlyMode = false) {
    var _a;
    const section = containerEl.createDiv("ss-chat-settings-modal__section");
    const isAgentModeActive = ((_a = this.options.chatView) == null ? void 0 : _a.agentMode) || false;
    if (isAgentModeActive) {
      section.createEl("h3", { text: "System Prompt Type (Agent Mode Active)", cls: "ss-chat-settings-modal__section-title" });
      const lockedDiv = section.createDiv("ss-chat-settings-modal__prompt-locked");
      lockedDiv.style.padding = "16px";
      lockedDiv.style.backgroundColor = "var(--background-secondary)";
      lockedDiv.style.borderRadius = "8px";
      lockedDiv.style.opacity = "0.7";
      const lockIcon = lockedDiv.createSpan({ cls: "ss-lock-icon" });
      lockIcon.style.marginRight = "8px";
      (0, import_obsidian79.setIcon)(lockIcon, "lock");
      lockedDiv.createSpan({ text: "System prompt is locked to 'Agent Mode' while Agent Mode is active. Disable Agent Mode to change system prompts." });
      return;
    }
    section.createEl("h3", { text: "System Prompt Type", cls: "ss-chat-settings-modal__section-title" });
    const buttonContainer = section.createDiv("ss-chat-settings-modal__prompt-type-buttons");
    this.createPresetButtons(buttonContainer);
    this.selectedFileInfo = section.createDiv("ss-chat-settings-modal__prompt-type-details");
    const controlsContainer = section.createDiv("ss-chat-settings-modal__prompt-type-controls");
    this.changeFileButton = new import_obsidian79.ButtonComponent(controlsContainer).setButtonText("Change Custom File...").setClass("ss-chat-settings-modal__prompt-change-file-btn").onClick(this.openCustomPromptSelector);
    this.updateSelectedFileInfo();
    this.updatePresetButtons();
  }
  createPromptEditorSection(containerEl) {
    var _a;
    const section = containerEl.createDiv("ss-chat-settings-modal__prompt-editor-section ss-chat-settings-modal__section");
    const isAgentModeActive = ((_a = this.options.chatView) == null ? void 0 : _a.agentMode) || false;
    if (isAgentModeActive) {
      section.createEl("h3", { text: "System Prompt Preview (Agent Mode)", cls: "ss-chat-settings-modal__section-title" });
      this.promptTextEditor = section.createEl("textarea", {
        cls: "ss-chat-settings-modal__prompt-textarea",
        attr: {
          readonly: "true",
          placeholder: "Agent mode system prompt (read-only)"
        }
      });
      this.promptTextEditor.style.opacity = "0.7";
      this.promptTextEditor.style.cursor = "not-allowed";
      const noteEl2 = section.createDiv("ss-chat-settings-modal__prompt-editor-note");
      const lockIcon = noteEl2.createSpan({ cls: "ss-lock-icon" });
      (0, import_obsidian79.setIcon)(lockIcon, "lock");
      lockIcon.style.marginRight = "4px";
      noteEl2.createSpan().innerHTML = "<strong>Agent Mode Active:</strong> System prompt is locked and cannot be edited. Disable Agent Mode to modify system prompts.";
      noteEl2.style.color = "var(--text-muted)";
      return;
    }
    section.createEl("h3", { text: "System Prompt Preview/Edit", cls: "ss-chat-settings-modal__section-title" });
    this.promptTextEditor = section.createEl("textarea", {
      cls: "ss-chat-settings-modal__prompt-textarea",
      attr: {
        placeholder: "System prompt content will appear here..."
      }
    });
    this.promptTextEditor.addEventListener("input", () => {
      this.currentPrompt = this.promptTextEditor.value;
    });
    const noteEl = section.createDiv("ss-chat-settings-modal__prompt-editor-note");
    noteEl.setText("Note: Changes to built-in presets (General Use, Concise) apply only to this chat. To save edits permanently, select or save as a new custom prompt file.");
  }
  createDefaultSettingsSection(containerEl) {
    const section = containerEl.createDiv("ss-chat-settings-modal__default-settings-section ss-chat-settings-modal__section");
    const defaultSettingsContainer = section.createDiv("default-settings-container");
    defaultSettingsContainer.style.backgroundColor = "var(--background-secondary)";
    defaultSettingsContainer.style.padding = "12px";
    defaultSettingsContainer.style.borderRadius = "var(--radius-s)";
    defaultSettingsContainer.style.marginTop = "16px";
    defaultSettingsContainer.createEl("h4", {
      text: "Default Settings",
      cls: "setting-item-heading"
    }).style.marginTop = "0";
    const defaultSettingsDescription = defaultSettingsContainer.createDiv();
    defaultSettingsDescription.innerHTML = "Configure the <strong>default model</strong> and <strong>system prompt type</strong> that will be used for all new chats.";
    defaultSettingsDescription.addClass("setting-item-description");
    defaultSettingsDescription.style.marginBottom = "12px";
    this.changeDefaultButton = new import_obsidian79.ButtonComponent(defaultSettingsContainer).setButtonText("Change Default Presets").setCta().onClick(this.openChangeDefaultPromptModal);
  }
  isAgentModeAvailable() {
    return verifyPremiumAccess(this.options.plugin.settings, 0, false);
  }
  createPresetButtons(container) {
    const presets = [
      { id: "general-use", label: "General Use Preset" },
      { id: "concise", label: "Concise Preset" },
      { id: "custom", label: "Custom Prompt" }
    ];
    presets.forEach((preset) => {
      this.presetButtons[preset.id] = new import_obsidian79.ButtonComponent(container).setButtonText(preset.label).setClass("ss-preset-button").onClick(() => this.selectPreset(preset.id));
    });
    if (this.options.mode !== "defaults-only") {
      const isAgentAvailable = this.isAgentModeAvailable();
      const agentButton = new import_obsidian79.ButtonComponent(container).setButtonText("Agent Mode").setClass("ss-preset-button").onClick(() => this.selectPreset("agent"));
      if (!isAgentAvailable) {
        agentButton.setClass("ss-preset-button-disabled");
        agentButton.setTooltip("Agent Mode requires an active SystemSculpt Pro license");
        agentButton.buttonEl.setAttribute("disabled", "true");
      }
      this.presetButtons["agent"] = agentButton;
    }
  }
  updatePresetButtons() {
    for (const id in this.presetButtons) {
      if (this.presetButtons.hasOwnProperty(id)) {
        const isActive = id === this.currentType;
        this.presetButtons[id].buttonEl.toggleClass("is-active", isActive);
        if (id === "agent") {
          const isAgentAvailable = this.isAgentModeAvailable();
          if (!isAgentAvailable) {
            this.presetButtons[id].buttonEl.setAttribute("disabled", "true");
            this.presetButtons[id].buttonEl.addClass("ss-preset-button-disabled");
          } else {
            this.presetButtons[id].buttonEl.removeAttribute("disabled");
            this.presetButtons[id].buttonEl.removeClass("ss-preset-button-disabled");
          }
        }
      }
    }
    if (this.changeFileButton) {
      this.changeFileButton.buttonEl.style.display = this.currentType === "custom" ? "block" : "none";
    }
  }
  updateSelectedFileInfo() {
    if (!this.selectedFileInfo)
      return;
    this.selectedFileInfo.empty();
    if (this.currentType === "custom") {
      if (this.currentPath) {
        const file = this.app.vault.getAbstractFileByPath(this.currentPath);
        if (!file) {
          console.warn(`Custom system prompt file not found: ${this.currentPath}. Falling back to General Use.`);
          this.currentType = "general-use";
          this.currentPath = void 0;
          this.currentPrompt = GENERAL_USE_PRESET.systemPrompt;
          this.selectedFileInfo.createEl("span", { text: "General Use (auto-switched from missing custom file)", cls: "ss-text-warning" });
        } else {
          const basename = this.currentPath.split("/").pop() || this.currentPath;
          this.selectedFileInfo.createEl("span", { text: `Selected: ${basename}` });
        }
      } else {
        this.selectedFileInfo.createEl("span", { text: "No custom file selected. Please choose one.", cls: "ss-text-warning" });
      }
    } else {
      let presetLabel;
      if (this.currentType === "general-use") {
        presetLabel = "General Use";
      } else if (this.currentType === "concise") {
        presetLabel = "Concise";
      } else if (this.currentType === "agent") {
        presetLabel = "Agent Mode";
      } else {
        let validTypes;
        if (this.options.mode === "defaults-only") {
          validTypes = ["general-use", "concise", "custom"];
        } else {
          validTypes = ["general-use", "concise", "custom", "agent"];
        }
        if (!validTypes.includes(this.currentType)) {
          console.warn(`Invalid system prompt type: ${this.currentType}. Falling back to General Use.`);
          this.currentType = "general-use";
          this.currentPrompt = GENERAL_USE_PRESET.systemPrompt;
          presetLabel = "General Use (auto-switched from invalid type)";
        } else {
          presetLabel = "General Use";
        }
      }
      this.selectedFileInfo.createEl("span", { text: `Using ${presetLabel} Preset` });
    }
    let defaultType;
    let defaultPath;
    if (this.options.mode === "defaults-only") {
      defaultType = this.currentType;
      defaultPath = this.currentPath;
    } else {
      defaultType = this.options.plugin.settings.systemPromptType || "general-use";
      defaultPath = this.options.plugin.settings.systemPromptPath;
    }
    const defaultDesc = this.selectedFileInfo.createEl("div", { cls: "ss-modal-description" });
    let defaultDisplayText = "";
    if (defaultType === "custom" && defaultPath) {
      const fileName = defaultPath.split("/").pop() || "Custom";
      defaultDisplayText = `Custom: ${fileName}`;
    } else {
      defaultDisplayText = defaultType === "general-use" ? "General Use" : defaultType.charAt(0).toUpperCase() + defaultType.slice(1);
    }
    defaultDesc.setText(`Default for new chats: ${defaultDisplayText}`);
  }
  async loadInitialPrompt() {
    try {
      let promptContent = "";
      if (this.currentType === "general-use") {
        promptContent = GENERAL_USE_PRESET.systemPrompt;
      } else if (this.currentType === "concise") {
        promptContent = CONCISE_PRESET.systemPrompt;
      } else if (this.currentType === "agent") {
        promptContent = AGENT_PRESET.systemPrompt;
      } else if (this.currentType === "custom" && this.currentPath) {
        promptContent = await this.systemPromptService.getSystemPromptContent("custom", this.currentPath);
      } else {
        promptContent = this.currentPrompt || "";
      }
      this.currentPrompt = promptContent;
      if (this.promptTextEditor) {
        this.promptTextEditor.value = this.currentPrompt;
      }
    } catch (error) {
      console.error("Error loading system prompt content:", error);
      new import_obsidian79.Notice("Could not load system prompt content.", 1e4);
      if (this.promptTextEditor) {
        this.promptTextEditor.value = "Error loading prompt.";
      }
    }
  }
  async updateModelDisplay() {
    if (!this.modelNameDisplay || !this.currentModelId)
      return;
    try {
      let modelInfo = null;
      if (this.options.plugin) {
        const allModels = await this.options.plugin.modelService.getModels();
        modelInfo = await findModelById(allModels, this.currentModelId);
      }
      const displayName = modelInfo ? modelInfo.name : getDisplayName(this.currentModelId);
      this.modelNameDisplay.value = displayName;
    } catch (error) {
      console.error("Error updating model display:", error);
      this.modelNameDisplay.value = this.currentModelId;
    }
  }
  async onClose() {
    var _a, _b;
    if (this.settingsChangedListener && this.options.plugin && this.options.plugin.emitter) {
      this.options.plugin.emitter.off("settingsChanged");
      this.settingsChangedListener = null;
    }
    const { contentEl } = this;
    contentEl.empty();
    const result = {
      type: this.currentType,
      prompt: this.currentPrompt,
      path: this.currentPath,
      modelId: this.currentModelId,
      title: this.currentTitle
    };
    if (result.type === "custom" && !result.path) {
      new import_obsidian79.Notice("Please select a custom prompt file before saving.", 5e3);
      if (this.resolvePromise)
        this.resolvePromise(null);
      return;
    }
    try {
      if (this.options.chatView) {
        this.options.chatView.systemPromptType = result.type;
        this.options.chatView.systemPromptPath = result.path;
        this.options.chatView.selectedModelId = result.modelId || ((_a = this.options.currentModelId) != null ? _a : "");
        const newTitle = result.title || ((_b = this.options.chatTitle) != null ? _b : "");
        await this.options.chatView.setTitle(newTitle, true);
        this.options.chatView.leaf.setViewState(this.options.chatView.leaf.getViewState());
        this.options.chatView.updateModelIndicator();
        this.options.chatView.updateSystemPromptIndicator();
      }
      if (this.resolvePromise)
        this.resolvePromise(result);
    } catch (error) {
      console.error("Error saving chat settings:", error);
      new import_obsidian79.Notice("Failed to save settings.", 1e4);
      if (this.resolvePromise)
        this.resolvePromise(null);
    }
  }
  async switchToVaultAgentModel() {
    const vaultAgentModelId = "systemsculpt/vault-agent";
    this.currentModelId = vaultAgentModelId;
    await this.updateModelDisplay();
    if (this.options.onModelSelect) {
      await this.options.onModelSelect(vaultAgentModelId);
    }
    new import_obsidian79.Notice("Switched to Vault Agent model for agent prompt", 3e3);
  }
  openModal() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      this.open();
    });
  }
};
function showStandardChatSettingsModal(app, options) {
  const modal = new StandardChatSettingsModal(app, options);
  return modal.openModal();
}

// src/views/chatview/systemPromptHandling.ts
var systemPromptHandling = {
  async handleSystemPromptEdit(chatView) {
    try {
      const currentPromptContent = await chatView.getCurrentSystemPrompt();
      const currentType = chatView.systemPromptType || "general-use";
      const currentPath = chatView.systemPromptPath;
      const result = await showStandardChatSettingsModal(chatView.app, {
        currentPrompt: currentPromptContent,
        currentSystemPromptType: currentType,
        systemPromptPath: currentPath,
        chatView,
        plugin: chatView.plugin,
        chatTitle: chatView.getChatTitle(),
        onTitleChange: async (newTitle) => {
          await chatView.setTitle(newTitle);
        },
        messages: chatView.getMessages(),
        currentModelId: chatView.getSelectedModelId(),
        onModelSelect: async (modelId) => {
          await chatView.setSelectedModelId(modelId);
        }
      });
      if (result) {
      } else {
      }
    } catch (error) {
      console.error("Error editing system prompt:", error);
      chatView.handleError("Failed to edit system prompt");
    }
  }
};

// src/views/chatview/ChatView.ts
var CHAT_VIEW_TYPE = "systemsculpt-chat-view";
var ChatView = class extends import_obsidian80.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    this.currentModelName = "";
    this.isGenerating = false;
    this.isFullyLoaded = false;
    this.chatVersion = 0;
    this.webSearchEnabled = false;
    this.agentMode = false;
    this.dragDropCleanup = null;
    this.virtualStartIndex = 0;
    this.VIRTUAL_BATCH_SIZE = 40;
    this.hasAdjustedInitialWindow = false;
    this.updateModelIndicator = () => uiSetup.updateModelIndicator(this);
    this.updateSystemPromptIndicator = () => uiSetup.updateSystemPromptIndicator(this);
    this.addMessage = (role, content, existingMessageId, completeMessage) => messageHandling.addMessage(this, role, content, existingMessageId, completeMessage);
    this.loadMessages = () => messageHandling.loadMessages(this);
    this.setupDragAndDrop = (container) => {
      const cleanup = eventHandling.setupDragAndDrop(this, container);
      if (typeof cleanup === "function") {
        this.dragDropCleanup = cleanup;
      }
    };
    this.handleSystemPromptEdit = () => systemPromptHandling.handleSystemPromptEdit(this);
    this.plugin = plugin;
    this.settings = plugin.settings;
    this.app = plugin.app;
    this.aiService = SystemSculptService.getInstance(plugin);
    const state = this.leaf.getViewState();
    const initialState = (state == null ? void 0 : state.state) || {};
    this.messages = [];
    this.chatId = initialState.chatId || "";
    this.initializeChatTitle(initialState.chatTitle);
    this.selectedModelId = initialState.selectedModelId || plugin.settings.selectedModelId;
    this.currentModelName = "";
    this.isGenerating = false;
    this.isFullyLoaded = false;
    this.systemPromptPath = initialState.systemPromptPath;
    this.chatVersion = initialState.version !== void 0 ? initialState.version : -1;
    this.toolCallManager = new ToolCallManager(new MCPService(plugin, this.app), this);
    this.chatStorage = new ChatStorageService(this.app, plugin.settings.chatsDirectory);
    this.messageRenderer = new MessageRenderer(this.app, this.toolCallManager);
    this.systemPromptService = SystemPromptService.getInstance(this.app, () => this.plugin.settings);
    this.chatFontSize = initialState.chatFontSize || plugin.settings.chatFontSize || "medium";
    this.systemPromptType = initialState.systemPromptType || plugin.settings.systemPromptType || "general-use";
    if (this.systemPromptType === "custom" && !this.systemPromptPath) {
      this.systemPromptPath = plugin.settings.systemPromptPath;
    }
    this.initializeAgentMode(initialState).catch((error) => {
      console.error("[SystemSculpt] Failed to initialize agent mode:", error);
    });
    if (initialState.includeVaultStructure !== void 0) {
      this.pendingVaultStructureState = initialState.includeVaultStructure;
    } else if (!this.chatId || this.chatId === "") {
      this.pendingVaultStructureState = this.plugin.settings.defaultIncludeVaultStructure;
    }
    this.layoutChangeHandler = this.onLayoutChange.bind(this);
  }
  async initializeAgentMode(initialState) {
    if (initialState.agentMode !== void 0) {
      this.agentMode = initialState.agentMode;
      return;
    }
    if (!this.chatId || this.chatId === "") {
      this.agentMode = this.plugin.settings.defaultAgentMode || false;
      if (this.agentMode) {
        const { verifyPremiumAccess: verifyPremiumAccess3 } = await Promise.resolve().then(() => (init_licenseUtils(), licenseUtils_exports));
        if (verifyPremiumAccess3(this.plugin.settings, 0, false)) {
          const models = await this.plugin.modelService.getModels();
          const agentModelAvailable = models.some((model) => model.id === AGENT_CONFIG.MODEL_ID);
          if (agentModelAvailable) {
            this.selectedModelId = AGENT_CONFIG.MODEL_ID;
            this.systemPromptType = "agent";
            this.systemPromptPath = void 0;
          } else {
            this.agentMode = false;
            console.warn("[SystemSculpt] ChatView: Agent mode DISABLED - required model not available:", AGENT_CONFIG.MODEL_ID);
            new import_obsidian80.Notice("Agent mode disabled: SystemSculpt Agent Model not available", 5e3);
          }
        } else {
          this.agentMode = false;
          console.log("[SystemSculpt] ChatView: Agent mode disabled due to invalid license");
        }
      }
      return;
    }
    this.agentMode = false;
  }
  async setAgentModeFromChatData(chatDataAgentMode) {
    const requestedAgentMode = chatDataAgentMode !== void 0 ? chatDataAgentMode : false;
    if (requestedAgentMode) {
      const { verifyPremiumAccess: verifyPremiumAccess3 } = await Promise.resolve().then(() => (init_licenseUtils(), licenseUtils_exports));
      if (!verifyPremiumAccess3(this.plugin.settings, 0, false)) {
        this.agentMode = false;
        console.warn("Agent mode disabled for chat due to invalid license");
        new import_obsidian80.Notice("Agent mode disabled - SystemSculpt Pro license required", 5e3);
        return;
      }
      const models = await this.plugin.modelService.getModels();
      const agentModelAvailable = models.some((model) => model.id === AGENT_CONFIG.MODEL_ID);
      if (agentModelAvailable) {
        this.agentMode = true;
        this.selectedModelId = AGENT_CONFIG.MODEL_ID;
        this.systemPromptType = "agent";
        this.systemPromptPath = void 0;
        console.log("[SystemSculpt] ChatView: Agent mode enabled with verified model:", AGENT_CONFIG.MODEL_ID);
      } else {
        this.agentMode = false;
        console.warn("[SystemSculpt] ChatView: Agent mode DISABLED in setAgentModeFromChatData - required model not available:", AGENT_CONFIG.MODEL_ID);
        new import_obsidian80.Notice("Agent mode disabled: SystemSculpt Agent Model not available", 5e3);
      }
    } else {
      this.agentMode = false;
      console.log("[SystemSculpt] ChatView: Agent mode disabled");
    }
  }
  getViewType() {
    return CHAT_VIEW_TYPE;
  }
  getDisplayText() {
    return this.chatTitle || "Loading...";
  }
  async onOpen() {
    await uiSetup.onOpen(this);
  }
  async saveChat() {
    var _a, _b, _c;
    if (!this.isFullyLoaded && this.chatId) {
      console.warn("[SystemSculpt] Skipping save - chat state restore in progress");
      return;
    }
    const hasMessages = this.messages.length > 0;
    const hasContextFiles = ((_a = this.contextManager) == null ? void 0 : _a.getContextFiles().size) > 0;
    const hasContent = hasMessages || hasContextFiles;
    if (!this.chatId && !hasContent) {
      this.updateViewState();
      return;
    }
    if (!this.chatId) {
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, "0");
      const day = String(now.getDate()).padStart(2, "0");
      const hour = String(now.getHours()).padStart(2, "0");
      const minute = String(now.getMinutes()).padStart(2, "0");
      const second = String(now.getSeconds()).padStart(2, "0");
      this.chatId = `${year}-${month}-${day} ${hour}-${minute}-${second}`;
      if (!this.chatTitle) {
        this.initializeChatTitle();
      }
      this.updateViewState();
    }
    try {
      const savedChat = await this.chatStorage.saveChat(this.chatId, this.messages, this.selectedModelId, ((_b = this.contextManager) == null ? void 0 : _b.getContextFiles()) || new Set(), void 0, this.systemPromptType, this.systemPromptPath, this.chatTitle, this.agentMode, ((_c = this.contextManager) == null ? void 0 : _c.isVaultStructureIncluded()) || false, this.chatFontSize);
      this.chatVersion = savedChat.version || this.chatVersion;
      const wasNewChat = !this.isFullyLoaded;
      if (wasNewChat && !this.isFullyLoaded) {
        this.isFullyLoaded = true;
      }
      this.updateViewState();
    } catch (error) {
      this.handleError("Failed to save chat");
    }
  }
  async addMessageToHistory(message) {
    if (!this.messages.find((m) => m.message_id === message.message_id)) {
      this.messages.push(message);
      this.app.workspace.trigger("systemsculpt:chat-message-added", this.chatId);
    }
    await this.saveChat();
  }
  async handleError(error) {
    var _a;
    console.error("Chat error:", {
      error,
      message: typeof error === "string" ? error : error.message,
      code: error instanceof SystemSculptError ? error.code : void 0,
      metadata: error instanceof SystemSculptError ? error.metadata : void 0
    });
    let errorMessage = typeof error === "string" ? error : error.message;
    if (error instanceof SystemSculptError && (error.code === "MODEL_UNAVAILABLE" || error.code === "MODEL_REQUEST_ERROR" || error.code === "QUOTA_EXCEEDED")) {
      if (error.code === "MODEL_UNAVAILABLE") {
        try {
          const unavailableModelId = ((_a = error.metadata) == null ? void 0 : _a.model) || this.selectedModelId;
          const models = await this.plugin.modelService.getModels();
          const alternativeModel = this.plugin.modelService.findBestAlternativeModel(unavailableModelId, models);
          if (alternativeModel) {
            const oldModelId = this.selectedModelId;
            this.selectedModelId = ensureCanonicalId(alternativeModel.id);
            await this.updateModelIndicator();
            const isLicenseHolder = this.plugin.settings.licenseValid === true;
            const isAgentModel = alternativeModel.id === AGENT_CONFIG.MODEL_ID;
            if (isLicenseHolder && isAgentModel) {
              console.log("[SystemSculpt] License holder silently switched to SystemSculpt Agent Model due to model unavailability");
            } else {
              new import_obsidian80.Notice(`Model "${oldModelId}" is unavailable. Switched to "${alternativeModel.name}"`, 1e4);
              setTimeout(async () => {
                await showPopup(this.app, `The model "${oldModelId}" you were using is unavailable. This can happen when models are updated or removed by providers. I've automatically switched you to "${alternativeModel.name}" so you can continue chatting. Click below if you'd like to choose a different model.`, {
                  title: "Model Automatically Changed",
                  icon: "alert-triangle",
                  primaryButton: "Choose Different Model",
                  secondaryButton: "Continue With New Model"
                }).then((result) => {
                  var _a2;
                  if (result == null ? void 0 : result.confirmed) {
                    (_a2 = this.modelIndicator) == null ? void 0 : _a2.click();
                  }
                });
              }, 500);
            }
            const lastMessage2 = this.chatContainer.querySelector(".systemsculpt-message:last-child");
            if (lastMessage2)
              lastMessage2.remove();
            const lastUserMessage2 = [...this.messages].reverse().find((msg) => msg.role === "user");
            if (lastUserMessage2 && this.inputHandler) {
              this.inputHandler.setInputText(lastUserMessage2.content || "");
            }
            return;
          }
        } catch (altError) {
          console.error("[SystemSculpt] Error selecting alternative model:", altError);
        }
      }
      new import_obsidian80.Notice(errorMessage, 1e4);
      const modal = new StandardModelSelectionModal({
        app: this.app,
        plugin: this.plugin,
        currentModelId: this.selectedModelId,
        onSelect: async (result) => {
          this.selectedModelId = ensureCanonicalId(result.modelId);
          this.updateModelIndicator();
        }
      });
      modal.open();
      const lastMessage = this.chatContainer.querySelector(".systemsculpt-message:last-child");
      if (lastMessage)
        lastMessage.remove();
      const lastUserMessage = [...this.messages].reverse().find((msg) => msg.role === "user");
      if (lastUserMessage && this.inputHandler) {
        this.inputHandler.setInputText(lastUserMessage.content || "");
      }
    } else {
      new import_obsidian80.Notice(errorMessage, 1e4);
    }
  }
  async onLayoutChange() {
    var _a;
    if (((_a = this.app.workspace.getActiveViewOfType(import_obsidian80.ItemView)) == null ? void 0 : _a.leaf) === this.leaf) {
      if (this.inputHandler)
        this.inputHandler.focus();
    }
  }
  generateMessageId() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  async getCurrentSystemPrompt() {
    try {
      return await this.systemPromptService.getSystemPromptContent(this.systemPromptType, this.systemPromptPath);
    } catch (error) {
      console.error("Error getting system prompt content:", error);
      return GENERAL_USE_PRESET.systemPrompt;
    }
  }
  getInputValue() {
    return this.inputHandler.getValue();
  }
  onunload() {
    this.scrollManager.cleanup();
    this.app.workspace.off("active-leaf-change", this.onLayoutChange);
    if (this.dragDropCleanup) {
      this.dragDropCleanup();
      this.dragDropCleanup = null;
    }
    this.contextManager.unload();
    this.inputHandler.unload();
  }
  getState() {
    var _a;
    return {
      chatId: this.chatId,
      selectedModelId: this.selectedModelId,
      chatTitle: this.chatTitle,
      systemPromptType: this.systemPromptType,
      systemPromptPath: this.systemPromptPath,
      version: this.chatVersion,
      agentMode: this.agentMode,
      includeVaultStructure: ((_a = this.contextManager) == null ? void 0 : _a.isVaultStructureIncluded()) || false,
      chatFontSize: this.chatFontSize
    };
  }
  async setState(state) {
    var _a, _b, _c;
    try {
      const currentState = this.getState();
      if (JSON.stringify(state) === JSON.stringify(currentState)) {
        return;
      }
    } catch (e) {
      console.warn("Error comparing states in setState:", e);
    }
    if (!(state == null ? void 0 : state.chatId)) {
      this.chatId = "";
      this.initializeChatTitle();
      if (this.plugin.settings.defaultAgentMode) {
        const { verifyPremiumAccess: verifyPremiumAccess3 } = await Promise.resolve().then(() => (init_licenseUtils(), licenseUtils_exports));
        this.agentMode = verifyPremiumAccess3(this.plugin.settings, 0, false);
        if (this.agentMode) {
          const models = await this.plugin.modelService.getModels();
          const agentModelAvailable = models.some((model) => model.id === AGENT_CONFIG.MODEL_ID);
          if (agentModelAvailable) {
            this.selectedModelId = AGENT_CONFIG.MODEL_ID;
            this.systemPromptType = "agent";
            this.systemPromptPath = void 0;
          } else {
            this.agentMode = false;
            console.warn("[SystemSculpt] ChatView: Agent mode DISABLED in setState - required model not available:", AGENT_CONFIG.MODEL_ID);
            new import_obsidian80.Notice("Agent mode disabled: SystemSculpt Agent Model not available", 5e3);
            this.selectedModelId = this.plugin.settings.selectedModelId || "";
            this.systemPromptType = this.plugin.settings.systemPromptType || "general-use";
            this.systemPromptPath = this.systemPromptType === "custom" ? this.plugin.settings.systemPromptPath : void 0;
          }
        } else {
          this.selectedModelId = this.plugin.settings.selectedModelId || "";
          this.systemPromptType = this.plugin.settings.systemPromptType || "general-use";
          this.systemPromptPath = this.systemPromptType === "custom" ? this.plugin.settings.systemPromptPath : void 0;
        }
      } else {
        this.agentMode = false;
        this.selectedModelId = this.plugin.settings.selectedModelId || "";
        this.systemPromptType = this.plugin.settings.systemPromptType || "general-use";
        this.systemPromptPath = this.systemPromptType === "custom" ? this.plugin.settings.systemPromptPath : void 0;
      }
      this.pendingVaultStructureState = this.plugin.settings.defaultIncludeVaultStructure;
      if (state == null ? void 0 : state.chatFontSize) {
        this.chatFontSize = state.chatFontSize;
        setTimeout(() => {
          if (this.chatContainer) {
            this.chatContainer.classList.remove("systemsculpt-chat-small", "systemsculpt-chat-medium", "systemsculpt-chat-large");
            this.chatContainer.classList.add(`systemsculpt-chat-${this.chatFontSize}`);
          }
        }, 0);
      }
      this.virtualStartIndex = 0;
      this.messages = [];
      (_a = this.contextManager) == null ? void 0 : _a.clearContext();
      this.updateModelIndicator();
      this.updateSystemPromptIndicator();
      this.renderMessagesInChunks();
      this.isFullyLoaded = true;
      this.app.workspace.trigger("systemsculpt:chat-loaded", this.chatId);
      if (this.inputHandler && this.inputHandler.updateAgentModeButtonState) {
        this.inputHandler.updateAgentModeButtonState();
      }
      return;
    }
    if (this.chatId === state.chatId && this.isFullyLoaded) {
      return;
    }
    this.chatId = state.chatId;
    if (state.agentMode && this.agentMode) {
      const models = await this.plugin.modelService.getModels();
      const agentModelAvailable = models.some((model) => model.id === AGENT_CONFIG.MODEL_ID);
      if (agentModelAvailable) {
        this.selectedModelId = AGENT_CONFIG.MODEL_ID;
        console.log("[SystemSculpt] ChatView: Loading agent mode chat with verified model:", AGENT_CONFIG.MODEL_ID);
      } else {
        this.agentMode = false;
        console.warn("[SystemSculpt] ChatView: Agent mode DISABLED for chat load - required model not available:", AGENT_CONFIG.MODEL_ID);
        new import_obsidian80.Notice("Agent mode disabled for this chat: SystemSculpt Agent Model not available", 5e3);
        this.selectedModelId = state.selectedModelId || this.plugin.settings.selectedModelId || "";
      }
    } else {
      this.selectedModelId = state.selectedModelId || this.plugin.settings.selectedModelId || "";
    }
    this.initializeChatTitle(state.chatTitle);
    this.chatVersion = state.version !== void 0 ? state.version : -1;
    this.systemPromptType = state.systemPromptType || "general-use";
    this.systemPromptPath = this.systemPromptType === "custom" ? state.systemPromptPath : void 0;
    if (state.agentMode !== void 0) {
      this.agentMode = state.agentMode;
    }
    if (state.chatFontSize) {
      this.chatFontSize = state.chatFontSize;
      setTimeout(() => {
        if (this.chatContainer) {
          this.chatContainer.classList.remove("systemsculpt-chat-small", "systemsculpt-chat-medium", "systemsculpt-chat-large");
          this.chatContainer.classList.add(`systemsculpt-chat-${this.chatFontSize}`);
        }
      }, 0);
    }
    this.pendingVaultStructureState = state.includeVaultStructure;
    try {
      await this.loadChatById(state.chatId);
      if (((_b = this.app.workspace.getActiveViewOfType(import_obsidian80.ItemView)) == null ? void 0 : _b.leaf) === this.leaf && this.inputHandler) {
        this.inputHandler.focus();
      }
    } catch (error) {
      console.error("Failed to restore chat state:", error);
      this.handleError(`Failed to load chat ${state.chatId}`);
      this.chatId = "";
      this.initializeChatTitle();
      this.virtualStartIndex = 0;
      this.messages = [];
      (_c = this.contextManager) == null ? void 0 : _c.clearContext();
      this.systemPromptType = "general-use";
      this.systemPromptPath = void 0;
      this.renderMessagesInChunks();
      this.isFullyLoaded = true;
    }
  }
  async loadChatById(chatId) {
    var _a;
    this.chatId = chatId;
    this.isFullyLoaded = false;
    try {
      const chatData = await this.chatStorage.loadChat(chatId);
      if (!chatData) {
        console.warn(`Chat data not found for ID ${chatId}.`);
        this.messages = [];
        this.chatContainer.empty();
        this.setTitle("Chat not found");
        this.systemPromptType = "general-use";
        this.systemPromptPath = void 0;
        this.updateModelIndicator();
        this.updateSystemPromptIndicator();
        (_a = this.contextManager) == null ? void 0 : _a.clearContext();
        this.isFullyLoaded = true;
        return;
      }
      this.selectedModelId = chatData.selectedModelId || this.plugin.settings.selectedModelId;
      this.setTitle(chatData.title || generateDefaultChatTitle(), false);
      this.messages = chatData.messages || [];
      this.chatVersion = chatData.version || 0;
      this.systemPromptType = chatData.systemPromptType || "general-use";
      this.systemPromptPath = this.systemPromptType === "custom" ? chatData.systemPromptPath : void 0;
      await this.setAgentModeFromChatData(chatData.agentMode);
      this.chatFontSize = chatData.chatFontSize || this.plugin.settings.chatFontSize || "medium";
      setTimeout(() => {
        if (this.chatContainer) {
          this.chatContainer.classList.remove("systemsculpt-chat-small", "systemsculpt-chat-medium", "systemsculpt-chat-large");
          this.chatContainer.classList.add(`systemsculpt-chat-${this.chatFontSize}`);
        }
      }, 100);
      if (chatData.context_files && this.contextManager) {
        const contextFiles = chatData.context_files.filter(Boolean);
        if (contextFiles.length > 0) {
          await this.contextManager.setContextFiles(contextFiles);
        } else {
          await this.contextManager.clearContext();
        }
      } else if (this.contextManager) {
        await this.contextManager.clearContext();
      }
      if (this.contextManager) {
        if (chatData.includeVaultStructure) {
          if (!this.contextManager.isVaultStructureIncluded()) {
            await this.contextManager.toggleVaultStructure();
          }
        } else if (!chatData.includeVaultStructure && this.contextManager.isVaultStructureIncluded()) {
          await this.contextManager.toggleVaultStructure();
        }
      }
      this.chatContainer.empty();
      if (this.messages.length > 0) {
        await this.renderMessagesInChunks();
      }
      this.isFullyLoaded = true;
      await this.updateModelIndicator();
      await this.updateSystemPromptIndicator();
      if (this.inputHandler) {
        this.inputHandler.onModelChange();
        if (this.inputHandler.updateAgentModeButtonState) {
          this.inputHandler.updateAgentModeButtonState();
        }
      }
      await this.contextManager.validateAndCleanContextFiles();
      this.updateViewState();
      this.app.workspace.trigger("systemsculpt:chat-loaded", this.chatId);
    } catch (error) {
      console.error("Failed to load chat:", error);
      this.handleError(`Failed to load chat: ${error.message}`);
      this.isFullyLoaded = true;
    }
  }
  async renderMessagesInChunks() {
    var _a;
    if (!this.chatContainer)
      return;
    const renderStart = performance.now();
    const total = this.messages.length;
    if (total === 0) {
      this.chatContainer.empty();
      return;
    }
    if (this.virtualStartIndex < 0)
      this.virtualStartIndex = 0;
    if (this.virtualStartIndex >= total)
      this.virtualStartIndex = Math.max(0, total - this.VIRTUAL_BATCH_SIZE);
    if (!this.hasAdjustedInitialWindow) {
      if (this.virtualStartIndex === 0 && total > this.VIRTUAL_BATCH_SIZE) {
        this.virtualStartIndex = total - this.VIRTUAL_BATCH_SIZE;
      }
      this.hasAdjustedInitialWindow = true;
    }
    this.chatContainer.empty();
    if (this.virtualStartIndex > 0) {
      const placeholder = this.createLoadMoreButton();
      this.chatContainer.appendChild(placeholder);
    }
    for (let i = this.virtualStartIndex; i < total; i++) {
      const msg = this.messages[i];
      await messageHandling.addMessage(this, msg.role, msg.content, msg.message_id, msg);
    }
    if ((_a = this.scrollManager) == null ? void 0 : _a.isAutoScrollEnabled()) {
      setTimeout(() => {
        var _a2;
        (_a2 = this.scrollManager) == null ? void 0 : _a2.forceScrollToBottom();
      }, 0);
    }
    const duration = performance.now() - renderStart;
    const renderedCount = total - this.virtualStartIndex;
    if (duration > 16) {
      console.debug(`[SystemSculpt] Virtual render (${renderedCount} msgs, start=${this.virtualStartIndex}) took ${duration.toFixed(1)}ms`);
    }
  }
  createLoadMoreButton() {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "systemsculpt-load-more";
    const remaining = this.virtualStartIndex;
    btn.textContent = `Load earlier messages (${remaining})`;
    btn.tabIndex = 0;
    const load = async () => {
      await this.loadMoreMessages();
    };
    btn.addEventListener("click", load);
    btn.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        load();
      }
    });
    this.register(() => {
      btn.removeEventListener("click", load);
    });
    return btn;
  }
  async loadMoreMessages() {
    if (!this.chatContainer || this.virtualStartIndex === 0)
      return;
    const placeholder = this.chatContainer.querySelector(".systemsculpt-load-more");
    const setLoadingState = (isLoading) => {
      if (!placeholder)
        return;
      if (isLoading) {
        placeholder.dataset.loading = "true";
        placeholder.textContent = "Loading...";
        placeholder.setAttribute("aria-busy", "true");
        placeholder.setAttribute("aria-disabled", "true");
      } else {
        placeholder.dataset.loading = "false";
        placeholder.removeAttribute("aria-busy");
        placeholder.removeAttribute("aria-disabled");
        if (this.virtualStartIndex > 0) {
          placeholder.textContent = `Load earlier messages (${this.virtualStartIndex})`;
        } else {
          placeholder.remove();
        }
      }
    };
    try {
      setLoadingState(true);
      const { scrollTop, scrollHeight } = this.chatContainer;
      const wasAtTop = scrollTop <= 50;
      this.virtualStartIndex = Math.max(0, this.virtualStartIndex - this.VIRTUAL_BATCH_SIZE);
      await this.renderMessagesInChunks();
      const newScrollHeight = this.chatContainer.scrollHeight;
      if (wasAtTop) {
        this.chatContainer.scrollTop = 0;
      } else {
        this.chatContainer.scrollTop = newScrollHeight - scrollHeight + scrollTop;
      }
    } catch (err) {
      console.error("[SystemSculpt] Failed to load older messages", err);
      new import_obsidian80.Notice("Failed to load older messages", 4e3);
    } finally {
      setLoadingState(false);
    }
  }
  manageDomSize() {
    if (!this.chatContainer)
      return;
    const maxElements = this.VIRTUAL_BATCH_SIZE * 2 + 1;
    const messageGroups = Array.from(this.chatContainer.children).filter((el) => !el.classList.contains("systemsculpt-load-more"));
    if (messageGroups.length > maxElements) {
      const removeCount = messageGroups.length - maxElements;
      for (let i = 0; i < removeCount; i++) {
        const el = messageGroups[i];
        el.remove();
      }
      this.virtualStartIndex = Math.min(this.virtualStartIndex + removeCount, this.messages.length);
      const placeholder = this.chatContainer.querySelector(".systemsculpt-load-more");
      if (placeholder) {
        const remaining = this.virtualStartIndex;
        placeholder.textContent = `Load earlier messages (${remaining})`;
      }
    }
  }
  async addFileToContext(file) {
    await this.contextManager.addFileToContext(file);
  }
  async copyToClipboard() {
    try {
      const content = await this.getMarkdown();
      await navigator.clipboard.writeText(content);
      new import_obsidian80.Notice("Chat copied to clipboard", 4e3);
    } catch (error) {
      new import_obsidian80.Notice("Failed to copy chat to clipboard", 4e3);
    }
  }
  focusInput() {
    if (this.inputHandler)
      this.inputHandler.focus();
  }
  getSelectedModelId() {
    return this.selectedModelId;
  }
  async setSelectedModelId(modelId) {
    const canonicalId = ensureCanonicalId(modelId);
    this.selectedModelId = canonicalId;
    try {
      const model = await this.plugin.modelService.getModelById(canonicalId);
      if (model) {
        console.log("[SystemSculpt] Found model for ID:", {
          modelId: canonicalId,
          model: {
            id: model.id,
            name: model.name,
            provider: model.provider,
            identifier: model.identifier
          }
        });
        const customProvider = this.plugin.settings.customProviders.find((p) => p.name.toLowerCase() === model.provider.toLowerCase());
        if (customProvider) {
          await this.plugin.getSettingsManager().updateSettings({
            activeProvider: {
              id: customProvider.id,
              name: customProvider.name,
              type: "custom"
            }
          });
        } else {
          await this.plugin.getSettingsManager().updateSettings({
            activeProvider: {
              id: "systemsculpt",
              name: "SystemSculpt",
              type: "native"
            }
          });
        }
      } else {
        console.warn("[SystemSculpt] Could not find model for ID:", canonicalId);
      }
    } catch (error) {
      console.error("[SystemSculpt] Error getting model details:", error);
    }
    await this.saveChat();
    await this.updateModelIndicator();
    this.inputHandler.onModelChange();
    this.focusInput();
  }
  async exportChatAsMarkdown() {
    return this.getMarkdown();
  }
  escapeHtml(unsafe) {
    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  async getMarkdown() {
    let chatContent = "";
    if (this.systemPromptType) {
      let systemPromptContent = "";
      if (this.systemPromptType === "custom" && this.systemPromptPath) {
        const file = this.app.vault.getAbstractFileByPath(this.systemPromptPath + ".md");
        if (file instanceof import_obsidian80.TFile)
          systemPromptContent = await this.app.vault.read(file);
      } else {
        try {
          systemPromptContent = await SystemPromptService.getInstance(this.app, () => this.plugin.settings).getSystemPromptContent(this.systemPromptType);
        } catch (error) {
          console.error("Failed to fetch system prompt:", error);
        }
      }
      if (systemPromptContent) {
        chatContent += `> [!abstract] System Prompt
`;
        systemPromptContent.split("\n").forEach((line) => {
          chatContent += `> ${line}
`;
        });
        chatContent += `
`;
      }
    }
    const contextFiles = this.contextManager.getContextFiles();
    if (contextFiles.size > 0) {
      chatContent += "## Context Files\n\n";
      for (const filePath of contextFiles) {
        if (!filePath.startsWith("doc:")) {
          const cleanPath = filePath.replace(/^\[\[(.*?)\]\]$/, "$1").replace(/\$begin:math:display\$\[(.*?)\$end:math:display\$]/g, "$1");
          const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(cleanPath, "");
          if (resolvedFile instanceof import_obsidian80.TFile && !resolvedFile.extension.match(/^(png|jpe?g|gif|webp|bmp|svg|mp3|wav|flac|ogg|mp4|m4a|mov|pdf|zip|tar|gz)$/i)) {
            const content = await this.app.vault.read(resolvedFile);
            chatContent += `> [!info] File: ${cleanPath}
`;
            content.split("\n").forEach((line) => {
              chatContent += `> ${line}
`;
            });
            chatContent += `
`;
          }
        }
      }
    }
    chatContent += "## Chat History\n\n";
    for (const message of this.messages) {
      if (typeof message.content === "string") {
        const escapedContent = this.escapeHtml(message.content);
        if (message.role === "assistant") {
          chatContent += `> [!ai] Assistant
`;
          escapedContent.split("\n").forEach((line) => {
            chatContent += `> ${line}
`;
          });
        } else {
          chatContent += `> [!question] User
`;
          escapedContent.split("\n").forEach((line) => {
            chatContent += `> ${line}
`;
          });
        }
        chatContent += `
`;
      }
    }
    return chatContent;
  }
  getMessages() {
    return [...this.messages];
  }
  getChatTitle() {
    return this.chatTitle;
  }
  initializeChatTitle(initialTitle) {
    this.chatTitle = initialTitle || generateDefaultChatTitle();
  }
  async setTitle(newTitle, shouldSave = true) {
    if (newTitle === this.chatTitle)
      return;
    this.chatTitle = newTitle;
    this.updateViewState();
    if (shouldSave) {
      await this.saveChat();
      this.app.workspace.requestSaveLayout();
    }
  }
  updateViewState() {
    if (this.leaf) {
      const currentState = this.getState();
      this.leaf.setViewState({
        type: CHAT_VIEW_TYPE,
        state: currentState
      }, { focus: true });
    }
  }
  async setChatFontSize(size) {
    this.chatFontSize = size;
    if (this.chatContainer) {
      this.chatContainer.classList.remove("systemsculpt-chat-small", "systemsculpt-chat-medium", "systemsculpt-chat-large");
      this.chatContainer.classList.add(`systemsculpt-chat-${size}`);
    }
    this.updateViewState();
    if (this.chatId && this.isFullyLoaded) {
      await this.saveChat();
    }
  }
  async addContextFile(file) {
    if (this.contextManager) {
      await this.contextManager.addFileToContext(file);
    }
  }
  async onClose() {
    var _a;
    if (this.inputHandler && typeof this.inputHandler.abortCurrentGeneration === "function") {
      this.inputHandler.abortCurrentGeneration();
    }
    if (this.dragDropCleanup) {
      this.dragDropCleanup();
      this.dragDropCleanup = null;
    }
    if (this.scrollManager) {
      if (typeof this.scrollManager.destroy === "function") {
        this.scrollManager.destroy();
      }
      this.scrollManager = null;
    }
    if (this.contextManager) {
      if (typeof this.contextManager.destroy === "function") {
        this.contextManager.destroy();
      }
      this.contextManager = null;
    }
    if (this.messageRenderer) {
      if (typeof this.messageRenderer.destroy === "function") {
        this.messageRenderer.destroy();
      }
      this.messageRenderer = null;
    }
    if (this.toolCallManager) {
      if (typeof this.toolCallManager.destroy === "function") {
        this.toolCallManager.destroy();
      }
      this.toolCallManager = null;
    }
    if (this.inputHandler) {
      if (typeof this.inputHandler.destroy === "function") {
        this.inputHandler.destroy();
      }
      this.inputHandler = null;
    }
    this.messages = [];
    if (this.chatContainer) {
      this.chatContainer = null;
    }
    this.modelIndicator = null;
    this.systemPromptIndicator = null;
    this.manageAgentToolingButton = null;
    this.aiService = null;
    this.chatStorage = null;
    this.systemPromptService = null;
    await ((_a = super.onClose) == null ? void 0 : _a.call(this));
  }
};

// src/services/RecorderService.ts
init_MobileDetection();
var MicrophoneRecorder = class {
  constructor(mimeType, extension, onError, onStatus, onComplete, preferredMicrophoneId) {
    this.mediaStream = null;
    this.mediaRecorder = null;
    this.chunks = [];
    this.isRecording = false;
    this.preferredMicrophoneId = null;
    this.mimeType = mimeType;
    this.extension = extension;
    this.onError = onError;
    this.onStatus = onStatus;
    this.onComplete = onComplete;
    this.preferredMicrophoneId = preferredMicrophoneId || null;
  }
  async start(app, outputPath) {
    var _a;
    if (this.isRecording) {
      this.onStatus("Already recording");
      return;
    }
    this.chunks = [];
    try {
      this.onStatus("Requesting microphone access...");
      const audioConstraints = {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      };
      if (this.preferredMicrophoneId) {
        this.onStatus("Using preferred microphone...");
        audioConstraints.deviceId = {
          exact: this.preferredMicrophoneId
        };
      }
      let streamPromise = navigator.mediaDevices.getUserMedia({
        audio: audioConstraints
      });
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Browser took too long to grant microphone access. Please check your browser permissions.")), 1e4);
      });
      try {
        this.mediaStream = await Promise.race([streamPromise, timeoutPromise]);
      } catch (error) {
        console.warn("First microphone access attempt failed:", error);
        if (this.preferredMicrophoneId && (error instanceof Error && (error.message.includes("NotFoundError") || error.message.includes("not found") || error.message.includes("OverconstrainedError")))) {
          this.onStatus("Preferred microphone not available, using default...");
          const fallbackPromise = navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });
          this.mediaStream = await Promise.race([fallbackPromise, timeoutPromise]);
        } else {
          this.onStatus("Retrying with basic settings...");
          const fallbackPromise = navigator.mediaDevices.getUserMedia({
            audio: true
          });
          this.mediaStream = await Promise.race([fallbackPromise, timeoutPromise]);
        }
      }
      const micLabel = ((_a = this.mediaStream.getAudioTracks()[0]) == null ? void 0 : _a.label) || "Default Microphone";
      this.onStatus(`Recording with: ${micLabel}`);
      const mimeType = this.mimeType;
      try {
        this.mediaRecorder = new MediaRecorder(this.mediaStream, {
          mimeType
        });
      } catch (error) {
        console.warn(`Failed to create MediaRecorder with ${mimeType}, trying without mime type specification:`, error);
        this.mediaRecorder = new MediaRecorder(this.mediaStream);
      }
      this.mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          this.chunks.push(e.data);
        }
      };
      this.mediaRecorder.onstop = async () => {
        try {
          if (this.chunks.length === 0) {
            throw new Error("No audio data recorded");
          }
          const blob = new Blob(this.chunks, { type: this.mimeType });
          const arrayBuffer = await blob.arrayBuffer();
          await app.vault.adapter.writeBinary(outputPath, arrayBuffer);
          this.onStatus("Recording saved");
          this.onComplete(outputPath, blob);
        } catch (error) {
          console.error("Error saving recording:", error);
          this.onError(new Error(`Save failed: ${error instanceof Error ? error.message : String(error)}`));
        } finally {
          this.release();
        }
      };
      this.mediaRecorder.start(1e3);
      this.isRecording = true;
    } catch (error) {
      this.release();
      console.error("Recording start failed:", error);
      let errorMessage = "Failed to start recording";
      if (error instanceof Error) {
        if (error.message.includes("Permission denied") || error.message.includes("permission") || error.message.includes("NotAllowedError")) {
          errorMessage = "Microphone access denied. Please check your browser permissions and try again.";
        } else if (error.message.includes("not found") || error.message.includes("NotFoundError")) {
          errorMessage = "No microphone detected. Please connect a microphone and try again.";
        } else if (error.message.includes("timeout")) {
          errorMessage = "Browser took too long to respond. Try refreshing the page or check microphone permissions.";
        } else {
          errorMessage = `Recording failed: ${error.message}`;
        }
      }
      this.onError(new Error(errorMessage));
    }
  }
  stop() {
    if (!this.isRecording || !this.mediaRecorder) {
      return;
    }
    try {
      if (this.mediaRecorder.state !== "inactive") {
        this.mediaRecorder.stop();
      }
      this.onStatus("Processing recording...");
    } catch (error) {
      console.error("Error stopping recording:", error);
      this.onError(new Error(`Stop failed: ${error instanceof Error ? error.message : String(error)}`));
      this.release();
    }
  }
  release() {
    if (this.mediaRecorder) {
      try {
        if (this.mediaRecorder.state !== "inactive") {
          this.mediaRecorder.stop();
        }
      } catch (e) {
        console.warn("Error stopping media recorder:", e);
      }
      this.mediaRecorder = null;
    }
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => track.stop());
      this.mediaStream = null;
    }
    this.isRecording = false;
  }
  cleanup() {
    this.release();
  }
  get recording() {
    return this.isRecording;
  }
  getMediaStream() {
    return this.mediaStream;
  }
};
var _RecorderService = class {
  constructor(app, plugin, options = {}) {
    this.recorder = null;
    this.isRecording = false;
    this.lastRecordingPath = null;
    this.recordingStartTime = 0;
    this.isInChat = false;
    this.onTranscriptionDone = null;
    this.recordingModal = null;
    this.nativeModal = null;
    this.statusEl = null;
    this.timerEl = null;
    this.timerInterval = null;
    this.visualizerCanvas = null;
    this.visualizerCtx = null;
    this.audioContext = null;
    this.analyser = null;
    this.animationId = null;
    this.listeners = new Set();
    this.offlineRecordings = new Map();
    var _a, _b;
    this.app = app;
    this.plugin = plugin;
    this.isInChat = (_a = options.isInChat) != null ? _a : false;
    this.onTranscriptionDone = (_b = options.onTranscriptionComplete) != null ? _b : null;
    this.mobileDetection = MobileDetection.getInstance();
  }
  static getInstance(app, plugin, options = {}) {
    var _a, _b;
    if (!_RecorderService.instance && app && plugin) {
      _RecorderService.instance = new _RecorderService(app, plugin, options);
    } else if (_RecorderService.instance && (options.isInChat !== void 0 || options.onTranscriptionComplete)) {
      _RecorderService.instance.isInChat = (_a = options.isInChat) != null ? _a : _RecorderService.instance.isInChat;
      _RecorderService.instance.onTranscriptionDone = (_b = options.onTranscriptionComplete) != null ? _b : _RecorderService.instance.onTranscriptionDone;
    }
    return _RecorderService.instance;
  }
  async toggleRecording() {
    if (this.isRecording) {
      await this.stopRecording();
    } else {
      await this.startRecording();
    }
  }
  async startRecording() {
    if (this.isRecording) {
      return;
    }
    try {
      this.showRecordingModal();
      this.updateStatus("Preparing recorder...");
      const dirPath = this.plugin.settings.recordingsDirectory || "SystemSculpt/Recordings";
      try {
        await this.plugin.directoryManager.ensureDirectoryByPath(dirPath);
        const dirExists = await this.app.vault.adapter.exists(dirPath);
        if (!dirExists) {
          throw new Error(`Failed to create recordings directory: ${dirPath}`);
        }
        console.log(`[SystemSculpt] Recording to directory: ${dirPath}`);
      } catch (error) {
        console.error(`[SystemSculpt] Error preparing recording directory:`, error);
        this.updateStatus(`Error with directory: ${dirPath}`);
        throw new Error(`Cannot access recordings directory. Please check settings and permissions.`);
      }
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-").replace("T", "_").split(".")[0];
      const mimeType = this.getSupportedMimeType();
      const extension = this.getExtensionForMimeType(mimeType);
      const outputPath = `${dirPath}/${timestamp}.${extension}`;
      this.startTimer();
      this.recorder = new MicrophoneRecorder(mimeType, extension, this.handleError.bind(this), this.updateStatus.bind(this), this.handleRecordingComplete.bind(this), this.plugin.settings.preferredMicrophoneId);
      await this.recorder.start(this.app, outputPath);
      this.isRecording = true;
      this.notifyListeners();
      setTimeout(() => {
        if (this.recorder) {
          const mediaStream = this.recorder.getMediaStream();
          if (mediaStream) {
            this.startVisualization(mediaStream);
          }
        }
      }, 100);
    } catch (error) {
      this.handleError(error instanceof Error ? error : new Error(String(error)));
    }
  }
  async stopRecording() {
    if (!this.isRecording || !this.recorder) {
      return;
    }
    try {
      this.updateStatus("Stopping recording...");
      this.recorder.stop();
      this.isRecording = false;
      this.notifyListeners();
      this.stopTimer();
    } catch (error) {
      this.handleError(error instanceof Error ? error : new Error(String(error)));
      this.cleanup(true);
    }
  }
  async handleRecordingComplete(filePath, audioBlob) {
    this.lastRecordingPath = filePath;
    this.storeRecordingInMemory(filePath, audioBlob);
    const isMobile = this.mobileDetection.isMobileDevice();
    const successMessage = isMobile ? "\u{1F399}\uFE0F Recording saved securely! Transcription starting..." : `\u{1F399}\uFE0F Recording saved to ${filePath.split("/").pop()}`;
    new import_obsidian81.Notice(successMessage);
    this.hideRecordingModal();
    if (this.plugin.settings.autoTranscribeRecordings) {
      await this.transcribeRecording(filePath);
    } else {
      new import_obsidian81.Notice(`\u{1F399}\uFE0F Recording saved to ${filePath.split("/").pop()}`);
    }
  }
  async transcribeRecording(filePath) {
    var _a;
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian81.TFile)) {
        throw new Error("Recording file not found");
      }
      const activeLeaf = this.app.workspace.activeLeaf;
      const isCurrentlyInChat = ((_a = activeLeaf == null ? void 0 : activeLeaf.view) == null ? void 0 : _a.getViewType()) === CHAT_VIEW_TYPE;
      const modal = new AudioTranscriptionModal(this.app, {
        file,
        isChat: isCurrentlyInChat,
        onTranscriptionComplete: (text) => {
          this.handleTranscriptionComplete(text, file);
        },
        plugin: this.plugin
      });
      modal.open();
    } catch (error) {
      console.error("Transcription failed:", error);
      const isMobile = this.mobileDetection.isMobileDevice();
      const fileName = filePath.split("/").pop();
      const errorMessage = isMobile ? `\u26A0\uFE0F Transcription failed, but your recording "${fileName}" is safely saved` : `\u274C Transcription failed: ${error instanceof Error ? error.message : String(error)}`;
      new import_obsidian81.Notice(errorMessage);
      if (isMobile) {
        setTimeout(() => {
          new import_obsidian81.Notice("\u{1F4A1} You can manually transcribe the recording later from your recordings folder.", 8e3);
        }, 1500);
      }
    }
  }
  handleTranscriptionComplete(text, file) {
    try {
      if (this.onTranscriptionDone) {
        this.onTranscriptionDone(text);
      } else {
        new import_obsidian81.Notice("\u2713 Transcription complete. Check the transcription modal for results.");
      }
      if (!this.plugin.settings.keepRecordingsAfterTranscription) {
        this.app.vault.delete(file).catch((error) => {
          console.warn("Failed to delete recording file:", error);
        });
      }
    } catch (error) {
      console.error("Error handling transcription:", error);
      new import_obsidian81.Notice(`\u274C Failed to process transcription: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  storeRecordingInMemory(filePath, audioBlob) {
    try {
      this.offlineRecordings.set(filePath, audioBlob);
      console.log(`[RecorderService] Recording backed up in memory: ${filePath}`);
    } catch (error) {
      console.warn("[RecorderService] Failed to store recording in memory:", error);
    }
  }
  showRecordingModal() {
    this.hideRecordingModal();
    const isMobile = this.mobileDetection.isMobileDevice();
    if (isMobile) {
      this.showNativeRecordingModal();
    } else {
      this.showDesktopRecordingWidget();
    }
  }
  showNativeRecordingModal() {
    this.nativeModal = new RecordingModal(this.app, this.plugin, {
      onStop: () => {
        this.stopRecording();
      },
      onStatusUpdate: (status) => {
      }
    });
    this.nativeModal.open();
  }
  showDesktopRecordingWidget() {
    this.recordingModal = document.createElement("div");
    this.recordingModal.className = "systemsculpt-recording-modal systemsculpt-recording-modal-desktop";
    this.createDesktopRecordingUI();
    document.body.appendChild(this.recordingModal);
    this.recordingModal.classList.add("recording");
    setTimeout(() => {
      if (this.recordingModal) {
        this.recordingModal.classList.add("visible");
      }
    }, 10);
  }
  createDesktopRecordingUI() {
    if (!this.recordingModal)
      return;
    const titleBar = document.createElement("div");
    titleBar.className = "systemsculpt-recording-title";
    titleBar.innerHTML = `
      <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"
           stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
        <line x1="12" y1="19" x2="12" y2="23"></line>
        <line x1="8" y1="23" x2="16" y2="23"></line>
      </svg>
      Recording
    `;
    this.makeDraggable(this.recordingModal, titleBar);
    this.recordingModal.appendChild(titleBar);
    this.statusEl = document.createElement("div");
    this.statusEl.className = "systemsculpt-recording-status";
    this.statusEl.textContent = "Initializing...";
    this.recordingModal.appendChild(this.statusEl);
    this.timerEl = document.createElement("div");
    this.timerEl.className = "systemsculpt-recording-timer";
    this.timerEl.textContent = "00:00";
    this.recordingModal.appendChild(this.timerEl);
    this.visualizerCanvas = document.createElement("canvas");
    this.visualizerCanvas.className = "systemsculpt-recording-visualizer";
    this.visualizerCanvas.width = 270;
    this.visualizerCanvas.height = 60;
    this.recordingModal.appendChild(this.visualizerCanvas);
    this.visualizerCtx = this.visualizerCanvas.getContext("2d");
    if (this.visualizerCtx) {
      this.visualizerCtx.fillStyle = "var(--background-secondary)";
      this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
    }
    const stopButton = document.createElement("button");
    stopButton.className = "systemsculpt-recording-stop";
    stopButton.innerHTML = `
      <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2"
           fill="none" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
      </svg>
      Stop Recording
    `;
    stopButton.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.stopRecording();
    };
    this.recordingModal.appendChild(stopButton);
  }
  hideRecordingModal() {
    this.stopVisualization();
    if (this.nativeModal) {
      this.nativeModal.close();
      this.nativeModal = null;
    }
    if (this.recordingModal) {
      this.recordingModal.remove();
      this.recordingModal = null;
      this.statusEl = null;
      this.timerEl = null;
      this.visualizerCanvas = null;
      this.visualizerCtx = null;
    }
    this.stopTimer();
  }
  makeDraggable(element, handle) {
    let isDragging = false;
    let offsetX = 0, offsetY = 0;
    const onMouseDown = (e) => {
      isDragging = true;
      offsetX = e.clientX - element.getBoundingClientRect().left;
      offsetY = e.clientY - element.getBoundingClientRect().top;
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    const onMouseMove = (e) => {
      if (!isDragging)
        return;
      const x = Math.max(0, Math.min(e.clientX - offsetX, window.innerWidth - element.offsetWidth));
      const y = Math.max(0, Math.min(e.clientY - offsetY, window.innerHeight - element.offsetHeight));
      element.style.left = `${x}px`;
      element.style.top = `${y}px`;
    };
    const onMouseUp = () => {
      isDragging = false;
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };
    handle.addEventListener("mousedown", onMouseDown);
  }
  updateStatus(status) {
    if (this.nativeModal) {
      this.nativeModal.updateStatus(status);
    }
    if (this.statusEl) {
      this.statusEl.textContent = status;
    }
  }
  startTimer() {
    this.recordingStartTime = Date.now();
    this.stopTimer();
    this.timerInterval = window.setInterval(() => {
      if (!this.timerEl)
        return;
      const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1e3);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      this.timerEl.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
    }, 1e3);
  }
  stopTimer() {
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
  }
  async startVisualization(mediaStream) {
    try {
      if (this.nativeModal) {
        await this.nativeModal.startVisualization(mediaStream);
        return;
      }
      if (!this.visualizerCanvas || !this.visualizerCtx)
        return;
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.analyser = this.audioContext.createAnalyser();
      this.analyser.fftSize = 256;
      this.analyser.smoothingTimeConstant = 0.8;
      const source = this.audioContext.createMediaStreamSource(mediaStream);
      source.connect(this.analyser);
      this.drawVisualization();
    } catch (error) {
      console.error("Failed to start visualization:", error);
    }
  }
  drawVisualization() {
    if (!this.analyser || !this.visualizerCtx || !this.visualizerCanvas) {
      return;
    }
    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    this.analyser.getByteFrequencyData(dataArray);
    this.visualizerCtx.fillStyle = getComputedStyle(document.body).getPropertyValue("--background-secondary");
    this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
    const barWidth = this.visualizerCanvas.width / bufferLength * 2.5;
    const barSpacing = 1;
    let x = 0;
    const accentColor = getComputedStyle(document.body).getPropertyValue("--text-accent");
    const mutedAccent = getComputedStyle(document.body).getPropertyValue("--text-muted");
    for (let i = 0; i < bufferLength; i++) {
      const barHeight = dataArray[i] / 255 * this.visualizerCanvas.height * 0.8;
      const gradient = this.visualizerCtx.createLinearGradient(0, this.visualizerCanvas.height - barHeight, 0, this.visualizerCanvas.height);
      gradient.addColorStop(0, accentColor);
      gradient.addColorStop(1, mutedAccent);
      this.visualizerCtx.fillStyle = gradient;
      this.visualizerCtx.fillRect(x, this.visualizerCanvas.height - barHeight, barWidth - barSpacing, barHeight);
      x += barWidth;
      if (x > this.visualizerCanvas.width)
        break;
    }
    this.animationId = requestAnimationFrame(() => this.drawVisualization());
  }
  stopVisualization() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    if (this.audioContext) {
      this.audioContext.close().catch(console.error);
      this.audioContext = null;
    }
    this.analyser = null;
  }
  handleError(error) {
    var _a;
    console.error("Recorder error:", error);
    const isMobile = this.mobileDetection.isMobileDevice();
    const hasBackup = this.lastRecordingPath && this.offlineRecordings.has(this.lastRecordingPath);
    let errorMessage;
    if (hasBackup) {
      errorMessage = isMobile ? "\u26A0\uFE0F Recording saved, but processing failed. Your audio is safe!" : `\u26A0\uFE0F Recording saved to ${(_a = this.lastRecordingPath) == null ? void 0 : _a.split("/").pop()}, but processing failed`;
    } else {
      errorMessage = `\u274C Recording error: ${error.message}`;
    }
    new import_obsidian81.Notice(errorMessage);
    const statusMessage = hasBackup ? "Recording saved, processing failed" : `Error: ${error.message}`;
    this.updateStatus(statusMessage);
    if (isMobile && hasBackup) {
      setTimeout(() => {
        new import_obsidian81.Notice("\u{1F4BE} Your recording is saved offline and can be transcribed later.", 5e3);
      }, 1e3);
    }
    setTimeout(() => {
      this.cleanup(true);
    }, hasBackup ? 3e3 : 2e3);
  }
  onToggle(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }
  notifyListeners() {
    for (const listener of this.listeners) {
      try {
        listener(this.isRecording);
      } catch (error) {
        console.error("Error in recording listener:", error);
      }
    }
  }
  getSupportedMimeType() {
    const formats = [
      "audio/webm;codecs=opus",
      "audio/webm",
      "audio/ogg;codecs=opus",
      "audio/wav"
    ];
    for (const format of formats) {
      try {
        if (MediaRecorder.isTypeSupported(format)) {
          return format;
        }
      } catch (e) {
        console.warn(`Format check failed for ${format}:`, e);
      }
    }
    return "audio/webm";
  }
  getExtensionForMimeType(mimeType) {
    if (mimeType.includes("webm"))
      return "webm";
    if (mimeType.includes("ogg"))
      return "ogg";
    if (mimeType.includes("wav"))
      return "wav";
    return "audio";
  }
  cleanup(hideUI = false) {
    if (this.recorder) {
      this.recorder.cleanup();
      this.recorder = null;
    }
    this.isRecording = false;
    this.stopTimer();
    this.stopVisualization();
    this.notifyListeners();
    if (hideUI) {
      this.hideRecordingModal();
    }
  }
  unload() {
    if (this.isRecording) {
      this.stopRecording().catch((e) => {
        console.error("Error stopping recording during cleanup:", e);
      });
    }
    this.cleanup(true);
    this.listeners.clear();
  }
};
var RecorderService = _RecorderService;
RecorderService.instance = null;

// src/components/SystemSculptContextMenu.ts
var import_obsidian82 = __toModule(require("obsidian"));
init_DocumentProcessingService();
init_ui();
init_types();
init_helpers();
var SystemSculptContextMenu = class {
  constructor(app, _sculptService, plugin) {
    this.statusBarItem = null;
    this.progressModal = null;
    this.progressBar = null;
    this.progressStatus = null;
    this.progressButtons = null;
    this.progressDetails = null;
    this.progressDetailsText = null;
    this.progressTimeout = null;
    this.maxProgressDuration = 6e5;
    this.lastProgress = null;
    this.handleVisibilityChange = () => {
      if (document.hidden && this.progressModal) {
        this.closeProgressModal();
        new import_obsidian82.Notice("Progress modal closed due to tab change");
      }
    };
    this.handleClickOutside = (event) => {
      if (this.progressModal && !this.progressModal.contains(event.target)) {
        return;
      }
    };
    this.handleProgressTimeout = () => {
      if (this.progressModal) {
        this.updateProgressModal(0, "Operation timed out", "alert-circle", "The operation took longer than expected and has timed out.\nThe process will continue in the background until completion.\nYou can check the console for more information.");
        new import_obsidian82.Notice("Operation timed out after 10 minutes, but continues in the background");
        setTimeout(() => this.closeProgressModal(), 5e3);
      }
    };
    this.app = app;
    this.plugin = plugin;
    this.documentProcessingService = DocumentProcessingService.getInstance(app, plugin);
    this.registerContextMenu();
  }
  showCompactProgressModal() {
    if (this.lastProgress && !this.progressModal) {
      this.createProgressModal();
      this.updateProgressModal(this.lastProgress.progress, this.lastProgress.status, this.lastProgress.icon, this.lastProgress.details);
    }
  }
  initializeStatusBar() {
    this.statusBarItem = this.app.workspace.containerEl.createDiv({
      cls: "systemsculpt-status-bar"
    });
    this.statusBarItem.style.display = "none";
  }
  registerContextMenu() {
    this.app.workspace.on("editor-menu", (_menu, editor, view) => {
      if (!(view instanceof import_obsidian82.MarkdownView))
        return;
      const selection = editor.getSelection();
      if (!selection)
        return;
    });
    this.app.workspace.on("file-menu", (menu, file) => {
      var _a, _b;
      if (!(file instanceof import_obsidian82.TFile))
        return;
      const extension = file.extension.toLowerCase();
      if (["md", "txt", "markdown"].includes(extension) || ["pdf", "doc", "docx", "ppt", "pptx", "xls", "xlsx"].includes(extension) || ["mp3", "wav", "m4a", "ogg", "webm"].includes(extension) || ["jpg", "jpeg", "png", "gif", "webp", "svg"].includes(extension)) {
        menu.addItem((item) => {
          item.setTitle("SystemSculpt - Chat with File").setIcon("message-square").onClick(async () => {
            try {
              const leaf = this.app.workspace.getLeaf("tab");
              const view = new ChatView(leaf, this.plugin);
              await leaf.open(view);
              await new Promise((resolve) => setTimeout(resolve, 50));
              this.app.workspace.setActiveLeaf(leaf, { focus: true });
              await view.addFileToContext(file);
            } catch (error) {
              new import_obsidian82.Notice("Failed to open chat with file");
              console.error("Chat open error:", error);
            }
          });
        });
      }
      if (file.extension === "pdf" || file.extension === "docx" || file.extension === "doc") {
        const hasValidLicense = ((_a = this.plugin.settings.licenseKey) == null ? void 0 : _a.trim()) && this.plugin.settings.licenseValid;
        menu.addItem((item) => {
          item.setTitle("SystemSculpt - Convert to Markdown" + (!hasValidLicense ? " (Pro)" : "")).setIcon("file-text").onClick(async () => {
            try {
              await this.handleDocumentConversion(file);
            } catch (error) {
              new import_obsidian82.Notice("Failed to convert document");
              console.error("Document conversion error:", error);
            }
          });
        });
      }
      if (["mp3", "wav", "m4a", "ogg", "webm"].includes(file.extension)) {
        const hasValidLicense = ((_b = this.plugin.settings.licenseKey) == null ? void 0 : _b.trim()) && this.plugin.settings.licenseValid;
        menu.addItem((item) => {
          item.setTitle("SystemSculpt - Convert to Markdown" + (!hasValidLicense ? " (Pro)" : "")).setIcon("file-audio").onClick(async () => {
            try {
              await this.handleAudioConversion(file);
            } catch (error) {
              new import_obsidian82.Notice("Failed to convert audio file");
              console.error("Audio conversion error:", error);
            }
          });
        });
      }
    });
  }
  async handleDocumentConversion(file) {
    var _a;
    try {
      this.createProgressModal();
      const extractionPath = await this.documentProcessingService.processDocument(file, {
        onProgress: (progress, status, icon) => {
          this.updateProgressModal(progress, status, icon);
        },
        showNotices: false
      });
      this.closeProgressModal();
      this.showCompletionButtons(extractionPath);
    } catch (error) {
      console.error("[SystemSculpt] Document conversion error:", error);
      if ((_a = error.message) == null ? void 0 : _a.includes("license")) {
        const result = await showPopup(this.app, "Support SystemSculpt's development and unlock powerful document processing features. Upgrade to Pro to process PDFs, Word documents, and audio files.", {
          title: "Pro Feature Required",
          primaryButton: "Get License",
          secondaryButton: "Maybe Later",
          icon: "sparkles"
        });
        if (result == null ? void 0 : result.confirmed) {
          window.open(LICENSE_URL, "_blank");
        }
      } else {
        this.updateProgressModal(0, `Error: ${error instanceof Error ? error.message : String(error)}`, "x-circle");
        await sleep(3e3);
        this.closeProgressModal();
        new import_obsidian82.Notice("Document conversion failed. Please try again later.");
      }
    }
  }
  async handleAudioConversion(file) {
    var _a, _b;
    try {
      this.createProgressModal();
      const header = (_a = this.progressModal) == null ? void 0 : _a.querySelector(".systemsculpt-progress-header");
      if (header) {
        const title = header.querySelector(".systemsculpt-progress-title");
        if (title) {
          title.textContent = "Converting Audio to Markdown";
        }
      }
      const transcriptionContext = {
        type: "note",
        timestamped: true,
        onProgress: (progress, status) => {
          let icon = "audio-lines";
          if (progress === 0)
            icon = "x-circle";
          else if (progress === 100)
            icon = "check-circle";
          let details = "";
          if (status.includes("Chunk")) {
            const chunkMatch = status.match(/Chunk (\d+)\/(\d+)/);
            if (chunkMatch) {
              const currentChunk = parseInt(chunkMatch[1]);
              const totalChunks = parseInt(chunkMatch[2]);
              details = `Processing chunk ${currentChunk} of ${totalChunks}
`;
              details += `File: ${file.path}
`;
              details += `Size: ${Math.round(file.stat.size / 1024)} KB
`;
              details += `Estimated time remaining: ${Math.round((totalChunks - currentChunk) * 30)} seconds`;
            }
          } else if (status.includes("Starting")) {
            details = `Starting transcription of ${file.name}
`;
            details += `File size: ${Math.round(file.stat.size / 1024)} KB
`;
            details += `Format: ${file.extension.toUpperCase()}
`;
            details += `Timestamps: Enabled`;
          } else if (status.includes("Post-processing")) {
            details = `Applying post-processing to improve transcription quality
`;
            details += `Formatting timestamps and adjusting text for readability`;
          } else if (progress === 100) {
            details = `Transcription completed successfully
`;
            details += `File: ${file.path}
`;
            details += `Size: ${Math.round(file.stat.size / 1024)} KB
`;
            details += `Transcription saved to: ${file.path.substring(0, file.path.lastIndexOf("."))}.md`;
          }
          this.updateProgressModal(progress, status, icon, details);
        }
      };
      const transcriptionService = TranscriptionService.getInstance(this.plugin);
      this.updateProgressModal(0, "Starting audio transcription...", "audio-lines");
      const transcriptionText = await transcriptionService.transcribeFile(file, transcriptionContext);
      const basePath = file.path.substring(0, file.path.lastIndexOf("."));
      const markdownPath = `${basePath}.md`;
      const markdownContent = this.formatAudioTranscription(file, transcriptionText);
      const existingFile = this.app.vault.getAbstractFileByPath(markdownPath);
      if (existingFile instanceof import_obsidian82.TFile) {
        await this.app.vault.modify(existingFile, markdownContent);
      } else {
        await this.app.vault.create(markdownPath, markdownContent);
      }
      this.closeProgressModal();
      this.showCompletionButtons(markdownPath);
    } catch (error) {
      console.error("[SystemSculpt] Audio conversion error:", error);
      if ((_b = error.message) == null ? void 0 : _b.includes("license")) {
        const result = await showPopup(this.app, "Support SystemSculpt's development and unlock powerful audio processing features. Upgrade to Pro to transcribe audio files.", {
          title: "Pro Feature Required",
          primaryButton: "Get License",
          secondaryButton: "Maybe Later",
          icon: "sparkles"
        });
        if (result == null ? void 0 : result.confirmed) {
          window.open(LICENSE_URL, "_blank");
        }
      } else {
        this.updateProgressModal(0, `Error: ${error instanceof Error ? error.message : String(error)}`, "x-circle");
        await sleep(3e3);
        this.closeProgressModal();
        new import_obsidian82.Notice("Audio conversion failed. Please try again later.");
      }
    }
  }
  formatAudioTranscription(file, transcriptionText) {
    if (this.plugin.settings.cleanTranscriptionOutput) {
      return transcriptionText;
    }
    const now = new Date();
    const formattedDate = now.toISOString().split("T")[0];
    const formattedTime = now.toTimeString().split(" ")[0];
    const audioLink = `![[${file.path}]]`;
    return `# Audio Transcription: ${file.basename}

## Source Information
- **File:** ${file.name}
- **Transcribed:** ${formattedDate} at ${formattedTime}
- **Duration:** [Auto-detected during playback]

## Audio Recording
${audioLink}

## Transcription
${transcriptionText}
`;
  }
  async handleAudioTranscription(file, timestamped) {
    try {
      await showAudioTranscriptionModal(this.app, {
        file,
        timestamped,
        plugin: this.plugin,
        onTranscriptionComplete: async (text) => {
          var _a;
          const baseName = file.basename;
          const fileExtension = timestamped ? "srt" : "md";
          const outputPath = `${((_a = file.parent) == null ? void 0 : _a.path) || ""}/${baseName}.${fileExtension}`;
          const content = timestamped ? text : text;
          let transcriptionFile;
          const existingFile = this.app.vault.getAbstractFileByPath(outputPath);
          if (existingFile instanceof import_obsidian82.TFile) {
            await this.app.vault.modify(existingFile, content);
            transcriptionFile = existingFile;
          } else {
            transcriptionFile = await this.app.vault.create(outputPath, content);
          }
          const leaf = this.app.workspace.getLeaf("tab");
          await leaf.openFile(transcriptionFile);
          this.app.workspace.setActiveLeaf(leaf, { focus: true });
        }
      });
    } catch (error) {
      console.error("Audio transcription error:", error);
      throw error;
    }
  }
  createProgressModal() {
    if (this.progressModal)
      return;
    this.progressModal = document.createElement("div");
    this.progressModal.className = "systemsculpt-progress-modal";
    const header = this.progressModal.createDiv("systemsculpt-progress-header");
    const titleContainer = header.createDiv("systemsculpt-progress-title-container");
    titleContainer.createEl("h3", {
      text: "Converting Document",
      cls: "systemsculpt-progress-title"
    });
    const controlsContainer = header.createDiv("systemsculpt-progress-controls");
    this.progressBar = this.progressModal.createDiv("systemsculpt-progress-bar");
    this.progressStatus = this.progressModal.createDiv("systemsculpt-progress-status");
    this.progressButtons = this.progressModal.createDiv("systemsculpt-progress-buttons");
    const cancelButton = this.progressButtons.createEl("button", {
      text: "Cancel",
      cls: "systemsculpt-progress-button"
    });
    this.plugin.registerDomEvent(cancelButton, "click", () => {
      this.closeProgressModal();
      new import_obsidian82.Notice("Document conversion cancelled");
    });
    this.progressDetails = this.progressModal.createDiv("systemsculpt-progress-details");
    this.progressDetails.style.display = "none";
    this.progressDetailsText = this.progressDetails.createDiv("systemsculpt-progress-details-text");
    document.addEventListener("visibilitychange", this.handleVisibilityChange);
    document.addEventListener("click", this.handleClickOutside);
    this.progressTimeout = setTimeout(() => {
      this.handleProgressTimeout();
    }, this.maxProgressDuration);
    document.body.appendChild(this.progressModal);
    this.addExpandedModalStyles();
  }
  addExpandedModalStyles() {
    const styleId = "systemsculpt-expanded-modal-styles";
    if (document.getElementById(styleId))
      return;
    const style = document.createElement("style");
    style.id = styleId;
    style.textContent = `
      .systemsculpt-progress-modal {
        transition: all 0.3s ease;
      }

      .systemsculpt-progress-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .systemsculpt-progress-title-container {
        flex: 1;
      }

      .systemsculpt-progress-controls {
        display: flex;
        gap: 8px;
      }

      .systemsculpt-progress-details {
        margin-top: 12px;
        padding: 10px;
        background-color: var(--background-secondary);
        border-radius: 6px;
        max-height: 300px;
        overflow-y: auto;
      }

      .systemsculpt-progress-details-text {
        font-family: var(--font-monospace);
        font-size: 12px;
        white-space: pre-wrap;
        color: var(--text-muted);
      }
    `;
    document.head.appendChild(style);
  }
  updateProgressModal(progress, status, icon, details) {
    this.lastProgress = { progress, status, icon, details };
    if (this.progressModal && this.progressBar && this.progressStatus) {
      this.progressBar.style.width = `${progress}%`;
      this.progressStatus.empty();
      const iconContainer = this.progressStatus.createDiv("systemsculpt-progress-status-icon");
      (0, import_obsidian82.setIcon)(iconContainer, icon);
      this.progressStatus.createSpan({
        text: status,
        cls: "systemsculpt-progress-status-text"
      });
      if (details && this.progressDetailsText) {
        const timestamp = new Date().toLocaleTimeString();
        let detailsText = this.progressDetailsText.getText() || "";
        const newEntry = `[${timestamp}] ${status} (${progress}%)
`;
        if (details) {
          detailsText += `${newEntry}${details}

`;
        } else {
          detailsText += newEntry;
        }
        this.progressDetailsText.setText(detailsText);
        if (this.progressDetails) {
          this.progressDetails.scrollTop = this.progressDetails.scrollHeight;
        }
      }
    }
    if (this.progressModal) {
      const header = this.progressModal.querySelector(".systemsculpt-progress-header");
      if (header) {
        const title = header.querySelector(".systemsculpt-progress-title");
        if (title && progress >= 100) {
          title.textContent = "Conversion Complete";
        }
      }
    }
  }
  isAudioFile(path) {
    return ["mp3", "wav", "m4a", "ogg", "webm"].some((ext) => path.toLowerCase().endsWith(`.${ext}`));
  }
  isAudioMarkdown(markdownPath) {
    if (!markdownPath.endsWith(".md"))
      return false;
    const basePath = markdownPath.replace(".md", "");
    return ["mp3", "wav", "m4a", "ogg", "webm"].some((ext) => basePath.toLowerCase().endsWith(`.${ext}`));
  }
  showCompletionButtons(extractionPath) {
    const completionDialog = document.createElement("div");
    completionDialog.className = "systemsculpt-completion-dialog";
    const header = completionDialog.createDiv("systemsculpt-completion-header");
    const iconContainer = header.createDiv("systemsculpt-completion-icon");
    (0, import_obsidian82.setIcon)(iconContainer, "check-circle");
    header.createEl("h4", {
      text: "Conversion Complete",
      cls: "systemsculpt-completion-title"
    });
    const isAudioMarkdown = this.isAudioMarkdown(extractionPath);
    const messageText = isAudioMarkdown ? `Your audio file has been successfully transcribed to markdown.` : `Your document has been successfully converted to markdown.`;
    completionDialog.createDiv({
      text: messageText,
      cls: "systemsculpt-completion-message"
    });
    const buttonsContainer = completionDialog.createDiv("systemsculpt-completion-buttons");
    const viewButton = buttonsContainer.createEl("button", {
      text: "View Result",
      cls: "systemsculpt-progress-button primary"
    });
    this.plugin.registerDomEvent(viewButton, "click", async () => {
      const file = this.app.vault.getAbstractFileByPath(extractionPath);
      if (file instanceof import_obsidian82.TFile) {
        await this.app.workspace.getLeaf().openFile(file);
      }
      completionDialog.remove();
    });
    const closeButton = buttonsContainer.createEl("button", {
      text: "Close",
      cls: "systemsculpt-progress-button"
    });
    this.plugin.registerDomEvent(closeButton, "click", () => {
      completionDialog.remove();
    });
    document.body.appendChild(completionDialog);
    const isAudioTranscription = this.isAudioMarkdown(extractionPath);
    new import_obsidian82.Notice(isAudioTranscription ? "Audio successfully transcribed to markdown" : "Document successfully converted to markdown");
  }
  closeProgressModal() {
    document.removeEventListener("visibilitychange", this.handleVisibilityChange);
    document.removeEventListener("click", this.handleClickOutside);
    if (this.progressTimeout) {
      clearTimeout(this.progressTimeout);
      this.progressTimeout = null;
    }
    if (this.progressModal && this.progressModal.parentNode) {
      this.progressModal.parentNode.removeChild(this.progressModal);
    }
    this.progressModal = null;
    this.progressBar = null;
    this.progressStatus = null;
    this.progressButtons = null;
    this.progressDetails = null;
    this.progressDetailsText = null;
    this.lastProgress = null;
  }
};

// src/core/settings/SettingsManager.ts
init_types();

// src/core/settings/AutomaticBackupService.ts
var import_obsidian83 = __toModule(require("obsidian"));
var AutomaticBackupService = class {
  constructor(plugin) {
    this.backupTimer = null;
    this.CHECK_INTERVAL_MS = 60 * 60 * 1e3;
    this.plugin = plugin;
  }
  start() {
    this.stop();
    this.backupTimer = setInterval(() => {
      this.checkAndCreateBackup();
    }, this.CHECK_INTERVAL_MS);
    this.checkAndCreateBackup();
  }
  stop() {
    if (this.backupTimer) {
      clearInterval(this.backupTimer);
      this.backupTimer = null;
    }
  }
  async checkAndCreateBackup() {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      if (!settings.automaticBackupsEnabled) {
        return;
      }
      const now = Date.now();
      const intervalMs = settings.automaticBackupInterval * 60 * 60 * 1e3;
      const lastBackup = settings.lastAutomaticBackup;
      if (now - lastBackup >= intervalMs) {
        await this.createAutomaticBackup();
      }
    } catch (error) {
      console.error("[SystemSculpt] Error in automatic backup check:", error);
    }
  }
  async createAutomaticBackup() {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const backupData = {
        ...settings,
        _backupMeta: {
          type: "automatic",
          timestamp: Date.now(),
          createdAt: new Date().toISOString(),
          version: "1.0"
        }
      };
      const dateStr = new Date().toISOString().split("T")[0];
      const fileName = `settings-backup-${dateStr}.json`;
      await this.saveBackupToMultipleLocations(fileName, backupData);
      await this.plugin.getSettingsManager().updateSettings({
        lastAutomaticBackup: Date.now()
      });
      await this.cleanupOldBackups();
      console.log(`[SystemSculpt] Automatic backup created: ${fileName}`);
      return true;
    } catch (error) {
      console.error("[SystemSculpt] Error creating automatic backup:", error);
      new import_obsidian83.Notice("Failed to create automatic settings backup", 3e3);
      return false;
    }
  }
  async saveBackupToMultipleLocations(fileName, backupData) {
    const backupJson = JSON.stringify(backupData, null, 2);
    const errors = [];
    try {
      const backupDir = ".systemsculpt/settings-backups";
      try {
        await this.plugin.app.vault.createFolder(backupDir);
      } catch (e) {
      }
      const backupPath = `.systemsculpt/settings-backups/${fileName}`;
      await this.plugin.app.vault.adapter.write(backupPath, backupJson);
    } catch (error) {
      errors.push(`Vault backup directory: ${error}`);
    }
    try {
      if (this.plugin.storage) {
        await this.plugin.storage.writeFile("settings", `backups/${fileName}`, backupData);
      }
    } catch (error) {
      errors.push(`Vault storage: ${error}`);
    }
    if (errors.length === 2) {
      throw new Error(`Failed to save backup to any location: ${errors.join(", ")}`);
    }
  }
  async cleanupOldBackups() {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const retentionMs = settings.automaticBackupRetentionDays * 24 * 60 * 60 * 1e3;
      const cutoffTime = Date.now() - retentionMs;
      await this.cleanupVaultRootBackups(cutoffTime);
      await this.cleanupVaultStorageBackups(cutoffTime);
    } catch (error) {
      console.error("[SystemSculpt] Error cleaning up old backups:", error);
    }
  }
  async cleanupVaultRootBackups(cutoffTime) {
    try {
      const backupDir = ".systemsculpt/settings-backups";
      const exists = await this.plugin.app.vault.adapter.exists(backupDir);
      if (!exists) {
        return;
      }
      const files = await this.plugin.app.vault.adapter.list(backupDir);
      const automaticBackupFiles = files.files.filter((f) => f.includes("settings-backup-") && f.endsWith(".json") && !f.includes("latest") && !f.includes("manual") && !f.includes("emergency") && f.match(/settings-backup-\d{4}-\d{2}-\d{2}\.json$/));
      for (const filePath of automaticBackupFiles) {
        try {
          const stats = await this.plugin.app.vault.adapter.stat(filePath);
          if (stats && stats.mtime < cutoffTime) {
            await this.plugin.app.vault.adapter.remove(filePath);
            console.log(`[SystemSculpt] Cleaned up old backup: ${filePath}`);
          }
        } catch (error) {
          console.warn(`[SystemSculpt] Failed to clean up backup ${filePath}:`, error);
        }
      }
    } catch (error) {
      console.warn("[SystemSculpt] Error cleaning up vault root backups:", error);
    }
  }
  async cleanupVaultStorageBackups(cutoffTime) {
    try {
      if (!this.plugin.storage) {
        return;
      }
      const backupFiles = await this.plugin.storage.listFiles("settings", "backups");
      const automaticBackupFiles = backupFiles.filter((f) => f.startsWith("settings-backup-") && f.endsWith(".json") && !f.includes("latest") && !f.includes("manual") && !f.includes("emergency"));
      for (const fileName of automaticBackupFiles) {
        try {
          const dateMatch = fileName.match(/settings-backup-(\d{4}-\d{2}-\d{2})\.json/);
          if (dateMatch) {
            const backupDate = new Date(dateMatch[1]).getTime();
            if (backupDate < cutoffTime) {
              await this.plugin.storage.deleteFile("settings", `backups/${fileName}`);
              console.log(`[SystemSculpt] Cleaned up old vault backup: ${fileName}`);
            }
          }
        } catch (error) {
          console.warn(`[SystemSculpt] Failed to clean up vault backup ${fileName}:`, error);
        }
      }
    } catch (error) {
      console.warn("[SystemSculpt] Error cleaning up vault storage backups:", error);
    }
  }
  getBackupStatus() {
    const settings = this.plugin.getSettingsManager().getSettings();
    const nextBackup = settings.lastAutomaticBackup + settings.automaticBackupInterval * 60 * 60 * 1e3;
    return {
      enabled: settings.automaticBackupsEnabled,
      lastBackup: settings.lastAutomaticBackup,
      nextBackup,
      intervalHours: settings.automaticBackupInterval,
      retentionDays: settings.automaticBackupRetentionDays
    };
  }
};

// src/core/settings/SettingsManager.ts
var SettingsManager = class {
  constructor(plugin) {
    this.isInitialized = false;
    this.ongoingBackup = null;
    this.backupQueue = [];
    this.isProcessingBackupQueue = false;
    this.plugin = plugin;
    this.settings = DEFAULT_SETTINGS;
    this.automaticBackupService = new AutomaticBackupService(plugin);
  }
  migrateSettings(settingsToMigrate) {
    const migratedSettings = { ...settingsToMigrate };
    if ("cachedEmbeddingStats" in migratedSettings) {
      delete migratedSettings.cachedEmbeddingStats;
    }
    if (!migratedSettings.favoritesFilterSettings) {
      migratedSettings.favoritesFilterSettings = DEFAULT_SETTINGS.favoritesFilterSettings;
    }
    if (!migratedSettings.modelFilterSettings) {
      migratedSettings.modelFilterSettings = DEFAULT_SETTINGS.modelFilterSettings;
    }
    if (!migratedSettings.activeProvider) {
      migratedSettings.activeProvider = DEFAULT_SETTINGS.activeProvider;
    }
    if (!Array.isArray(migratedSettings.customProviders)) {
      migratedSettings.customProviders = DEFAULT_SETTINGS.customProviders;
    }
    if (!Array.isArray(migratedSettings.favoriteModels)) {
      migratedSettings.favoriteModels = DEFAULT_SETTINGS.favoriteModels;
    }
    if (!Array.isArray(migratedSettings.mcpEnabledTools)) {
      migratedSettings.mcpEnabledTools = DEFAULT_SETTINGS.mcpEnabledTools;
    } else {
      const searchSimilarNotesKey = "mcp-filesystem:search_similar_notes";
      if (migratedSettings.embeddingsEnabled && !migratedSettings.mcpEnabledTools.includes(searchSimilarNotesKey)) {
        migratedSettings.mcpEnabledTools.push(searchSimilarNotesKey);
        console.log("[SystemSculpt] Added search_similar_notes to enabled tools for embeddings user");
      }
    }
    if (!Array.isArray(migratedSettings.mcpAutoAcceptTools)) {
      migratedSettings.mcpAutoAcceptTools = DEFAULT_SETTINGS.mcpAutoAcceptTools;
    }
    if (!Array.isArray(migratedSettings.mcpServers)) {
      migratedSettings.mcpServers = DEFAULT_SETTINGS.mcpServers;
    }
    if ("excludedFolders" in migratedSettings) {
      delete migratedSettings.excludedFolders;
    }
    if ("excludedFiles" in migratedSettings) {
      delete migratedSettings.excludedFiles;
    }
    if (!Array.isArray(migratedSettings.favoriteChats)) {
      migratedSettings.favoriteChats = DEFAULT_SETTINGS.favoriteChats;
    }
    if (Array.isArray(migratedSettings.mcpEnabledTools) && !migratedSettings.mcpEnabledTools.includes("mcp-filesystem:search_similar_notes")) {
      migratedSettings.mcpEnabledTools.push("mcp-filesystem:search_similar_notes");
    }
    if (typeof migratedSettings.automaticBackupsEnabled !== "boolean") {
      migratedSettings.automaticBackupsEnabled = DEFAULT_SETTINGS.automaticBackupsEnabled;
    }
    if (typeof migratedSettings.automaticBackupInterval !== "number") {
      migratedSettings.automaticBackupInterval = DEFAULT_SETTINGS.automaticBackupInterval;
    }
    if (typeof migratedSettings.automaticBackupRetentionDays !== "number") {
      migratedSettings.automaticBackupRetentionDays = DEFAULT_SETTINGS.automaticBackupRetentionDays;
    }
    if (typeof migratedSettings.lastAutomaticBackup !== "number") {
      migratedSettings.lastAutomaticBackup = DEFAULT_SETTINGS.lastAutomaticBackup;
    }
    if (!Array.isArray(migratedSettings.selectedModelProviders)) {
      migratedSettings.selectedModelProviders = DEFAULT_SETTINGS.selectedModelProviders;
    }
    return migratedSettings;
  }
  async restoreFromBackup() {
    try {
      if (this.plugin.storage) {
        try {
          const latestBackup = await this.plugin.storage.readFile("settings", "backups/settings-backup-latest.json", true);
          if (latestBackup) {
            console.log("[SystemSculpt] Successfully restored settings from vault storage latest backup");
            return latestBackup;
          }
          const backupFiles = await this.plugin.storage.listFiles("settings", "backups");
          const dailyBackups = backupFiles.filter((f) => f.match(/settings-backup-\d{4}-\d{2}-\d{2}\.json$/)).sort().reverse();
          if (dailyBackups.length > 0) {
            const newestBackup = await this.plugin.storage.readFile("settings", `backups/${dailyBackups[0]}`, true);
            if (newestBackup) {
              console.log(`[SystemSculpt] Restored settings from vault backup: ${dailyBackups[0]}`);
              return newestBackup;
            }
          }
        } catch (e) {
          console.warn("[SystemSculpt] Failed to restore from vault storage backups:", e);
        }
      }
      const backupDir = ".systemsculpt/settings-backups";
      const latestBackupPath = ".systemsculpt/settings-backups/settings-backup-latest.json";
      const exists = await this.plugin.app.vault.adapter.exists(latestBackupPath);
      if (exists) {
        const backupData = await this.plugin.app.vault.adapter.read(latestBackupPath);
        const backupSettings = JSON.parse(backupData);
        console.log("[SystemSculpt] Successfully restored settings from plugin directory backup");
        return backupSettings;
      }
      try {
        const files = await this.plugin.app.vault.adapter.list(backupDir);
        const backupFiles = files.files.filter((f) => f.match(/settings-backup-\d{4}-\d{2}-\d{2}\.json$/)).sort().reverse();
        if (backupFiles.length > 0) {
          const newestBackup = backupFiles[0];
          const backupData = await this.plugin.app.vault.adapter.read(newestBackup);
          const backupSettings = JSON.parse(backupData);
          console.log(`[SystemSculpt] Restored settings from plugin directory backup: ${newestBackup}`);
          return backupSettings;
        }
      } catch (e) {
        console.warn("[SystemSculpt] Failed to find any daily backups in plugin directory:", e);
      }
      console.log("[SystemSculpt] No backup files found to restore from");
      return null;
    } catch (error) {
      console.error("[SystemSculpt] Failed to restore settings from backup:", error);
      return null;
    }
  }
  async loadSettings() {
    let loadedData = null;
    try {
      loadedData = await this.plugin.loadData();
      if (!loadedData) {
        console.log("[SystemSculpt] No saved settings found, using defaults and saving.");
        this.settings = { ...DEFAULT_SETTINGS };
        this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
        this.isInitialized = true;
        await this.saveSettings();
      } else {
        let mergedSettings = { ...DEFAULT_SETTINGS, ...loadedData };
        mergedSettings = this.migrateSettings(mergedSettings);
        this.settings = await this.validateSettingsAsync(mergedSettings);
        this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
        this.isInitialized = true;
        await this.saveSettings();
      }
    } catch (loadError) {
      console.error("[SystemSculpt] Error loading settings data:", loadError);
      const backupSettings = await this.restoreFromBackup();
      if (backupSettings) {
        let restored = this.migrateSettings(backupSettings);
        this.settings = await this.validateSettingsAsync(restored);
        this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
        this.isInitialized = true;
        await this.saveSettings();
      } else {
        this.settings = { ...DEFAULT_SETTINGS };
        this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
        this.isInitialized = true;
        await this.saveSettings();
      }
    }
    this.plugin.app.workspace.trigger("systemsculpt:settings-loaded", this.settings);
    this.automaticBackupService.start();
  }
  validateSettings(settings) {
    const validatedSettings = { ...settings };
    const defaultSettings = DEFAULT_SETTINGS;
    if (!Array.isArray(validatedSettings.customProviders)) {
      console.warn("[SystemSculpt] customProviders is not an array, resetting to empty array");
      validatedSettings.customProviders = [];
    }
    if (!Array.isArray(validatedSettings.favoriteModels)) {
      console.warn("[SystemSculpt] favoriteModels is not an array, resetting to empty array");
      validatedSettings.favoriteModels = [];
    }
    if (!Array.isArray(validatedSettings.mcpEnabledTools)) {
      console.warn("[SystemSculpt] mcpEnabledTools is not an array, resetting to default");
      validatedSettings.mcpEnabledTools = defaultSettings.mcpEnabledTools;
    } else {
      const originalLength = validatedSettings.mcpEnabledTools.length;
      validatedSettings.mcpEnabledTools = [...new Set(validatedSettings.mcpEnabledTools)];
      const deduplicatedLength = validatedSettings.mcpEnabledTools.length;
      if (originalLength !== deduplicatedLength) {
        console.log(`[SystemSculpt] Deduplicated mcpEnabledTools: ${originalLength} -> ${deduplicatedLength} tools`);
        console.log("- Original array:", [...validatedSettings.mcpEnabledTools, ...Array(originalLength - deduplicatedLength).fill("[DUPLICATE]")]);
        console.log("- Deduplicated array:", validatedSettings.mcpEnabledTools);
      }
    }
    if (!Array.isArray(validatedSettings.mcpAutoAcceptTools)) {
      console.warn("[SystemSculpt] mcpAutoAcceptTools is not an array, resetting to default");
      validatedSettings.mcpAutoAcceptTools = defaultSettings.mcpAutoAcceptTools;
    } else {
      const originalLength = validatedSettings.mcpAutoAcceptTools.length;
      validatedSettings.mcpAutoAcceptTools = [...new Set(validatedSettings.mcpAutoAcceptTools)];
      const deduplicatedLength = validatedSettings.mcpAutoAcceptTools.length;
      if (originalLength !== deduplicatedLength) {
        console.log(`[SystemSculpt] Deduplicated mcpAutoAcceptTools: ${originalLength} -> ${deduplicatedLength} tools`);
        console.log("- Original array:", [...validatedSettings.mcpAutoAcceptTools, ...Array(originalLength - deduplicatedLength).fill("[DUPLICATE]")]);
        console.log("- Deduplicated array:", validatedSettings.mcpAutoAcceptTools);
      }
    }
    if (typeof validatedSettings.chatsDirectory !== "string") {
      console.warn("[SystemSculpt] chatsDirectory is invalid, resetting to default");
      validatedSettings.chatsDirectory = defaultSettings.chatsDirectory;
    }
    if (typeof validatedSettings.recordingsDirectory !== "string") {
      console.warn("[SystemSculpt] recordingsDirectory is invalid, resetting to default");
      validatedSettings.recordingsDirectory = defaultSettings.recordingsDirectory;
    }
    if (typeof validatedSettings.attachmentsDirectory !== "string") {
      console.warn("[SystemSculpt] attachmentsDirectory is invalid, resetting to default");
      validatedSettings.attachmentsDirectory = defaultSettings.attachmentsDirectory;
    }
    if (typeof validatedSettings.extractionsDirectory !== "string") {
      console.warn("[SystemSculpt] extractionsDirectory is invalid, resetting to default");
      validatedSettings.extractionsDirectory = defaultSettings.extractionsDirectory;
    }
    if (typeof validatedSettings.systemPromptsDirectory !== "string") {
      console.warn("[SystemSculpt] systemPromptsDirectory is invalid, resetting to default");
      validatedSettings.systemPromptsDirectory = defaultSettings.systemPromptsDirectory;
    }
    if (typeof validatedSettings.savedChatsDirectory !== "string") {
      console.warn("[SystemSculpt] savedChatsDirectory is invalid, resetting to default");
      validatedSettings.savedChatsDirectory = defaultSettings.savedChatsDirectory;
    }
    if (typeof validatedSettings.licenseValid !== "boolean") {
      console.warn("[SystemSculpt] licenseValid is not a boolean, resetting to default");
      validatedSettings.licenseValid = defaultSettings.licenseValid;
    }
    if (typeof validatedSettings.autoTranscribeRecordings !== "boolean") {
      console.warn("[SystemSculpt] autoTranscribeRecordings is not a boolean, resetting to default");
      validatedSettings.autoTranscribeRecordings = defaultSettings.autoTranscribeRecordings;
    }
    if (typeof validatedSettings.autoPasteTranscription !== "boolean") {
      console.warn("[SystemSculpt] autoPasteTranscription is not a boolean, resetting to default");
      validatedSettings.autoPasteTranscription = defaultSettings.autoPasteTranscription;
    }
    if (typeof validatedSettings.keepRecordingsAfterTranscription !== "boolean") {
      console.warn("[SystemSculpt] keepRecordingsAfterTranscription is not a boolean, resetting to default");
      validatedSettings.keepRecordingsAfterTranscription = defaultSettings.keepRecordingsAfterTranscription;
    }
    if (typeof validatedSettings.postProcessingEnabled !== "boolean") {
      console.warn("[SystemSculpt] postProcessingEnabled is not a boolean, resetting to default");
      validatedSettings.postProcessingEnabled = defaultSettings.postProcessingEnabled;
    }
    if (typeof validatedSettings.cleanTranscriptionOutput !== "boolean") {
      console.warn("[SystemSculpt] cleanTranscriptionOutput is not a boolean, resetting to default");
      validatedSettings.cleanTranscriptionOutput = defaultSettings.cleanTranscriptionOutput;
    }
    if (typeof validatedSettings.skipEmptyNoteWarning !== "boolean") {
      console.warn("[SystemSculpt] skipEmptyNoteWarning is not a boolean, resetting to default");
      validatedSettings.skipEmptyNoteWarning = defaultSettings.skipEmptyNoteWarning;
    }
    if (typeof validatedSettings.automaticTitleGeneration !== "boolean") {
      console.warn("[SystemSculpt] automaticTitleGeneration is not a boolean, resetting to default");
      validatedSettings.automaticTitleGeneration = defaultSettings.automaticTitleGeneration;
    }
    if (typeof validatedSettings.enableTemplateHotkey !== "boolean") {
      console.warn("[SystemSculpt] enableTemplateHotkey is not a boolean, resetting to default");
      validatedSettings.enableTemplateHotkey = defaultSettings.enableTemplateHotkey;
    }
    if ("autoUpdateSimilarNotes" in validatedSettings) {
      delete validatedSettings.autoUpdateSimilarNotes;
    }
    if ("hideSimilarNotesAlreadyInContext" in validatedSettings) {
      delete validatedSettings.hideSimilarNotesAlreadyInContext;
    }
    if ("backgroundEmbeddingUpdates" in validatedSettings) {
      delete validatedSettings.backgroundEmbeddingUpdates;
    }
    if (typeof validatedSettings.embeddingsEnabled !== "boolean") {
      console.warn("[SystemSculpt] embeddingsEnabled is not a boolean, resetting to default");
      validatedSettings.embeddingsEnabled = defaultSettings.embeddingsEnabled;
    }
    if (typeof validatedSettings.selectedModelId !== "string") {
      console.warn("[SystemSculpt] selectedModelId is not a string, resetting to default");
      validatedSettings.selectedModelId = defaultSettings.selectedModelId;
    }
    if (typeof validatedSettings.titleGenerationModelId !== "string") {
      console.warn("[SystemSculpt] titleGenerationModelId is not a string, resetting to default");
      validatedSettings.titleGenerationModelId = defaultSettings.titleGenerationModelId;
    }
    if (typeof validatedSettings.licenseKey !== "string") {
      console.warn("[SystemSculpt] licenseKey is not a string, resetting to default");
      validatedSettings.licenseKey = defaultSettings.licenseKey;
    }
    if (!validatedSettings.openAiApiKey) {
      validatedSettings.openAiApiKey = "";
    }
    if (typeof validatedSettings.systemPromptType !== "string") {
      console.warn("[SystemSculpt] systemPromptType is not a string, resetting to default");
      validatedSettings.systemPromptType = defaultSettings.systemPromptType;
    }
    if (validatedSettings.systemPromptType === "agent") {
      console.warn("[SystemSculpt] systemPromptType cannot be 'agent' as default. Agent Mode is per-chat only. Switching to 'general-use'.");
      validatedSettings.systemPromptType = "general-use";
      validatedSettings.systemPromptPath = "";
    }
    if (!validatedSettings.activeProvider || typeof validatedSettings.activeProvider !== "object" || !validatedSettings.activeProvider.id || !validatedSettings.activeProvider.name || !validatedSettings.activeProvider.type) {
      console.warn("[SystemSculpt] activeProvider is invalid, resetting to default");
      validatedSettings.activeProvider = { ...defaultSettings.activeProvider };
    }
    if (!validatedSettings.favoritesFilterSettings || typeof validatedSettings.favoritesFilterSettings !== "object") {
      console.warn("[SystemSculpt] favoritesFilterSettings is invalid, resetting to default");
      validatedSettings.favoritesFilterSettings = { ...defaultSettings.favoritesFilterSettings };
    } else {
      if (typeof validatedSettings.favoritesFilterSettings.showFavoritesOnly !== "boolean") {
        console.warn("[SystemSculpt] favoritesFilterSettings.showFavoritesOnly is not a boolean, resetting to default");
        validatedSettings.favoritesFilterSettings.showFavoritesOnly = defaultSettings.favoritesFilterSettings.showFavoritesOnly;
      }
      if (typeof validatedSettings.favoritesFilterSettings.favoritesFirst !== "boolean") {
        console.warn("[SystemSculpt] favoritesFilterSettings.favoritesFirst is not a boolean, resetting to default");
        validatedSettings.favoritesFilterSettings.favoritesFirst = defaultSettings.favoritesFilterSettings.favoritesFirst;
      }
      if (typeof validatedSettings.favoritesFilterSettings.modelSortOrder !== "string") {
        console.warn("[SystemSculpt] favoritesFilterSettings.modelSortOrder is not a string, resetting to default");
        validatedSettings.favoritesFilterSettings.modelSortOrder = defaultSettings.favoritesFilterSettings.modelSortOrder;
      }
    }
    if ("cachedEmbeddingStats" in validatedSettings) {
      delete validatedSettings.cachedEmbeddingStats;
    }
    const currentServerUrl = validatedSettings.serverUrl;
    const { API_BASE_URL: API_BASE_URL2 } = (init_api(), api_exports);
    const correctUrl = API_BASE_URL2.replace("/api/v1", "");
    if (typeof currentServerUrl !== "string" || currentServerUrl.trim() === "") {
      console.warn(`[SystemSculpt] serverUrl "${currentServerUrl}" is invalid or empty. Setting to development mode aware default: ${correctUrl}`);
      validatedSettings.serverUrl = correctUrl;
    } else if (currentServerUrl.includes("localhost") && correctUrl.includes("api.systemsculpt.com")) {
      console.log(`[SystemSculpt] Settings validation: Localhost serverUrl detected in PRODUCTION mode, updating to: ${correctUrl}`);
      validatedSettings.serverUrl = correctUrl;
    } else if (currentServerUrl.includes("api.systemsculpt.com") && correctUrl.includes("localhost")) {
      console.log(`[SystemSculpt] Settings validation: Production serverUrl detected in DEVELOPMENT mode, updating to: ${correctUrl}`);
      validatedSettings.serverUrl = correctUrl;
    } else {
    }
    return validatedSettings;
  }
  async backupSettings() {
    if (!this.isInitialized || !this.settings)
      return;
    try {
      const backupData = JSON.stringify(this.settings, null, 2);
      const backupDir = ".systemsculpt/settings-backups";
      const backupPath = ".systemsculpt/settings-backups/settings-backup-latest.json";
      const dirExists = await this.plugin.app.vault.adapter.exists(backupDir);
      if (!dirExists) {
        await this.plugin.app.vault.createFolder(backupDir);
      }
      await this.plugin.app.vault.adapter.write(backupPath, backupData);
    } catch (error) {
      console.error("[SystemSculpt] Failed to create settings backup:", error);
    }
  }
  async saveSettings() {
    if (!this.isInitialized) {
      console.warn("[SystemSculpt] Attempted to save settings before initialization, skipping.");
      return;
    }
    try {
      const oldSettings = { ...this.plugin._internal_settings_systemsculpt_plugin || DEFAULT_SETTINGS };
      this.settings = { ...this.plugin._internal_settings_systemsculpt_plugin };
      await this.plugin.saveData(this.plugin._internal_settings_systemsculpt_plugin);
      this.plugin.app.workspace.trigger("systemsculpt:settings-updated", oldSettings, this.plugin._internal_settings_systemsculpt_plugin);
      this.plugin.notifySettingsUpdate(oldSettings, this.plugin._internal_settings_systemsculpt_plugin);
      await this.backupSettings();
    } catch (error) {
      console.error("[SystemSculpt] Error saving settings via saveSettings:", error);
    }
  }
  getSettings() {
    if (!this.isInitialized) {
      console.warn("[SystemSculpt] Settings accessed before initialization, returning defaults.");
      return { ...DEFAULT_SETTINGS };
    }
    return { ...this.settings };
  }
  async updateSettings(newSettings) {
    if (!this.isInitialized) {
      await this.loadSettings();
    }
    const oldSettingsState = { ...this.settings };
    let updatedSettings = { ...this.settings, ...newSettings };
    if (updatedSettings.mcpEnabledTools && Array.isArray(updatedSettings.mcpEnabledTools)) {
      const originalLength = updatedSettings.mcpEnabledTools.length;
      updatedSettings.mcpEnabledTools = [...new Set(updatedSettings.mcpEnabledTools)];
      const deduplicatedLength = updatedSettings.mcpEnabledTools.length;
      if (originalLength !== deduplicatedLength) {
        console.log(`[SystemSculpt] updateSettings - Deduplicated mcpEnabledTools: ${originalLength} -> ${deduplicatedLength} tools`);
      }
    }
    if (updatedSettings.mcpAutoAcceptTools && Array.isArray(updatedSettings.mcpAutoAcceptTools)) {
      const originalLength = updatedSettings.mcpAutoAcceptTools.length;
      updatedSettings.mcpAutoAcceptTools = [...new Set(updatedSettings.mcpAutoAcceptTools)];
      const deduplicatedLength = updatedSettings.mcpAutoAcceptTools.length;
      if (originalLength !== deduplicatedLength) {
        console.log(`[SystemSculpt] updateSettings - Deduplicated mcpAutoAcceptTools: ${originalLength} -> ${deduplicatedLength} tools`);
      }
    }
    this.settings = await this.validateSettingsAsync(updatedSettings);
    this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
    await this.saveSettings();
  }
  async validateLicenseKey(key) {
    const currentSettings = this.getSettings();
    const isValid = key === "valid-license";
    if (currentSettings.licenseKey !== key || currentSettings.licenseValid !== isValid) {
      await this.updateSettings({ licenseKey: key, licenseValid: isValid });
    }
    return isValid;
  }
  getLicenseKey() {
    return this.getSettings().licenseKey;
  }
  isLicenseValid() {
    return this.getSettings().licenseValid;
  }
  async setLicenseKey(key) {
    await this.updateSettings({ licenseKey: key });
  }
  getServerUrl() {
    return this.getSettings().serverUrl;
  }
  async setServerUrl(url) {
    await this.updateSettings({ serverUrl: url });
  }
  async cleanupPhantomTools(settings) {
    try {
      const validToolKeys = new Set();
      if (settings.mcpEnabled) {
        const { MCPFilesystemServer: MCPFilesystemServer2 } = await Promise.resolve().then(() => (init_MCPFilesystemServer(), MCPFilesystemServer_exports));
        const filesystemServer = new MCPFilesystemServer2(this.plugin, this.plugin.app);
        const filesystemTools = await filesystemServer.getTools();
        for (const tool of filesystemTools) {
          validToolKeys.add(`mcp-filesystem:${tool.name}`);
        }
        if (settings.embeddingsEnabled) {
          validToolKeys.add("mcp-filesystem:search_similar_notes");
        }
        const { MCPService: MCPService2 } = await Promise.resolve().then(() => (init_MCPService(), MCPService_exports));
        const mcpService = new MCPService2(this.plugin, this.plugin.app);
        for (const server of settings.mcpServers || []) {
          if (!server.isEnabled || server.id === "mcp-filesystem") {
            continue;
          }
          try {
            const result = await mcpService.testConnection(server);
            if (result.success && result.tools) {
              for (const tool of result.tools) {
                validToolKeys.add(`${server.id}:${tool.name}`);
              }
            }
          } catch (error) {
            console.warn(`[SystemSculpt] Failed to get tools from server ${server.name} during phantom cleanup:`, error);
          }
        }
      }
      const originalEnabledTools = settings.mcpEnabledTools || [];
      const cleanedEnabledTools = originalEnabledTools.filter((toolKey) => {
        const isValid = validToolKeys.has(toolKey);
        if (!isValid) {
          console.log(`[SystemSculpt] Removing phantom enabled tool: ${toolKey}`);
        }
        return isValid;
      });
      const originalAutoAcceptTools = settings.mcpAutoAcceptTools || [];
      const cleanedAutoAcceptTools = originalAutoAcceptTools.filter((toolKey) => {
        const isValid = validToolKeys.has(toolKey);
        if (!isValid) {
          console.log(`[SystemSculpt] Removing phantom auto-accept tool: ${toolKey}`);
        }
        return isValid;
      });
      const removedEnabledCount = originalEnabledTools.length - cleanedEnabledTools.length;
      const removedAutoAcceptCount = originalAutoAcceptTools.length - cleanedAutoAcceptTools.length;
      if (removedEnabledCount > 0 || removedAutoAcceptCount > 0) {
        console.log(`[SystemSculpt] Cleaned up phantom tools:`);
        console.log(`- Valid tools found: ${validToolKeys.size}`);
        console.log(`- Removed ${removedEnabledCount} phantom enabled tools`);
        console.log(`- Removed ${removedAutoAcceptCount} phantom auto-accept tools`);
        console.log(`- Enabled tools: ${originalEnabledTools.length} -> ${cleanedEnabledTools.length}`);
        console.log(`- Auto-accept tools: ${originalAutoAcceptTools.length} -> ${cleanedAutoAcceptTools.length}`);
      }
      return {
        ...settings,
        mcpEnabledTools: cleanedEnabledTools,
        mcpAutoAcceptTools: cleanedAutoAcceptTools
      };
    } catch (error) {
      console.error("[SystemSculpt] Error during phantom tool cleanup:", error);
      return settings;
    }
  }
  async validateSettingsAsync(settings) {
    const syncValidatedSettings = this.validateSettings(settings);
    const asyncValidatedSettings = await this.cleanupPhantomTools(syncValidatedSettings);
    return asyncValidatedSettings;
  }
  async cleanupPhantomToolsManually() {
    if (!this.isInitialized) {
      await this.loadSettings();
    }
    console.log("[SystemSculpt] Starting manual phantom tool cleanup...");
    const cleanedSettings = await this.cleanupPhantomTools(this.settings);
    if (cleanedSettings.mcpEnabledTools.length !== this.settings.mcpEnabledTools.length || cleanedSettings.mcpAutoAcceptTools.length !== this.settings.mcpAutoAcceptTools.length) {
      this.settings = cleanedSettings;
      await this.saveSettings();
      console.log("[SystemSculpt] Manual phantom tool cleanup completed and settings saved.");
    } else {
      console.log("[SystemSculpt] No phantom tools found, no cleanup needed.");
    }
  }
  destroy() {
    if (this.automaticBackupService) {
      this.automaticBackupService.stop();
    }
  }
  getAutomaticBackupService() {
    return this.automaticBackupService;
  }
};

// src/core/license/LicenseManager.ts
var import_obsidian84 = __toModule(require("obsidian"));
var LicenseManager = class {
  constructor(plugin, app) {
    this.lastValidationTime = 0;
    this.plugin = plugin;
    this.app = app;
  }
  async initializeLicense() {
    var _a;
    const licenseKey = (_a = this.plugin.settings.licenseKey) == null ? void 0 : _a.trim();
    const SPath = "licenseValid";
    const previousLicenseValidState = this.plugin.settings.licenseValid;
    if (!licenseKey) {
      if (previousLicenseValidState === true) {
        await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
        new import_obsidian84.Notice("SystemSculpt license key is empty. Pro features disabled.", 5e3);
      } else if (typeof previousLicenseValidState === "undefined") {
        await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
      }
      return;
    }
    let isValidNow = false;
    try {
      isValidNow = await this.validateLicenseKey(true, false);
    } catch (error) {
      console.warn("[SystemSculpt] Initial license validation failed on load:", error);
      isValidNow = false;
    }
    if (previousLicenseValidState === true && !isValidNow) {
      new import_obsidian84.Notice("Your SystemSculpt Pro license is no longer valid or failed to validate. Pro features may be unavailable.", 7e3);
    }
  }
  async validateLicenseKey(force = false, showReloadPrompt = true) {
    if (!this.plugin.settings.licenseKey) {
      await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
      return false;
    }
    try {
      const isValid = await this.plugin.aiService.validateLicense(force);
      await this.plugin.getSettingsManager().updateSettings({ licenseValid: isValid });
      if (isValid) {
        this.lastValidationTime = Date.now();
      }
      return isValid;
    } catch (error) {
      console.error("License validation error:", error);
      await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
      return false;
    }
  }
};
LicenseManager.VALIDATION_INTERVAL = 24 * 60 * 60 * 1e3;

// src/core/plugin/views.ts
var import_obsidian89 = __toModule(require("obsidian"));

// src/modals/JanitorModal.ts
var import_obsidian85 = __toModule(require("obsidian"));
init_ui();
init_StandardModal();
var JanitorModal = class extends StandardModal {
  constructor(app, plugin) {
    super(app);
    this.cachedData = null;
    this.isScanning = false;
    this.plugin = plugin;
    this.setSize("large");
  }
  onOpen() {
    super.onOpen();
    this.modalEl.addClass("ss-janitor-modal");
    this.addTitle("\u{1F9F9} SystemSculpt Janitor", "Clean up and optimize your SystemSculpt workspace. Review items before deletion.");
    this.createMainContainer();
    this.addActionButton("Refresh", () => this.refreshData(), false, "refresh-cw");
    this.addActionButton("Close", () => this.close(), false);
    this.loadJanitorData();
  }
  createMainContainer() {
    this.mainContainer = this.contentEl.createDiv({ cls: "ss-janitor-main" });
    this.loadingOverlay = this.contentEl.createDiv({ cls: "ss-janitor-loading-overlay" });
    const loadingContent = this.loadingOverlay.createDiv({ cls: "ss-janitor-loading-content" });
    const loadingIcon = loadingContent.createDiv({ cls: "ss-janitor-loading-icon" });
    (0, import_obsidian85.setIcon)(loadingIcon, "loader-2");
    const loadingText = loadingContent.createDiv({ cls: "ss-janitor-loading-text" });
    loadingText.createDiv({ text: "Scanning Vault", cls: "ss-janitor-loading-title" });
    loadingText.createDiv({ text: "Analyzing files and folders...", cls: "ss-janitor-loading-subtitle" });
    this.showLoading(true);
  }
  async scanVault() {
    const emptyFiles = [];
    const emptyFolders = [];
    const chatFiles = [];
    const extractionFiles = [];
    const recordingFiles = [];
    const allFiles = this.app.vault.getFiles();
    const allFolders = this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian85.TFolder);
    for (const file of allFiles) {
      if (file.path.startsWith(this.plugin.settings.chatsDirectory)) {
        chatFiles.push(file);
      } else if (file.path.startsWith(this.plugin.settings.extractionsDirectory)) {
        extractionFiles.push(file);
      } else if (file.path.startsWith(this.plugin.settings.recordingsDirectory)) {
        recordingFiles.push(file);
      }
      if (await this.isEmptyFile(file)) {
        emptyFiles.push(file);
      }
    }
    for (const folder of allFolders) {
      if (this.isEmptyFolder(folder)) {
        emptyFolders.push(folder);
      }
    }
    const sizes = {
      empty: this.calculateSize(emptyFiles),
      chat: this.calculateSize(chatFiles),
      extraction: this.calculateSize(extractionFiles),
      recording: this.calculateSize(recordingFiles)
    };
    return {
      emptyFiles,
      emptyFolders,
      chatFiles,
      extractionFiles,
      recordingFiles,
      sizes,
      stats: {
        emptyFileCount: emptyFiles.length,
        emptyFolderCount: emptyFolders.length,
        totalEmptyCount: emptyFiles.length + emptyFolders.length
      }
    };
  }
  async loadJanitorData() {
    if (this.isScanning)
      return;
    try {
      this.isScanning = true;
      this.showLoading(true);
      const data = await this.scanVault();
      this.cachedData = data;
      this.showLoading(false);
      this.populateAllSections(data);
    } catch (error) {
      console.error("Error loading janitor data:", error);
      this.showError("Failed to scan vault. Please try refreshing.");
    } finally {
      this.isScanning = false;
    }
  }
  populateAllSections(data) {
    this.mainContainer.empty();
    const sectionsContainer = this.mainContainer.createDiv({ cls: "ss-janitor-sections" });
    this.createEmptyContentSection(sectionsContainer, data);
    this.createChatHistorySection(sectionsContainer, data);
    this.createExtractionsSection(sectionsContainer, data);
    this.createRecordingsSection(sectionsContainer, data);
  }
  createEmptyContentSection(container, data) {
    const section = this.createModernSection(container, "\u{1F4C4} Empty Content", "Remove empty files and folders that are taking up space");
    const statsContainer = section.content.createDiv({ cls: "ss-janitor-stats" });
    const actionContainer = section.content.createDiv({ cls: "ss-janitor-actions" });
    const { emptyFiles, emptyFolders, stats } = data;
    this.createStatCard(statsContainer, "Files", stats.emptyFileCount, "file-text");
    this.createStatCard(statsContainer, "Folders", stats.emptyFolderCount, "folder");
    this.createStatCard(statsContainer, "Total", stats.totalEmptyCount, "trash-2", stats.totalEmptyCount > 0 ? "warning" : "muted");
    const clearButton = actionContainer.createEl("button", {
      cls: stats.totalEmptyCount > 0 ? "ss-button ss-button--danger" : "ss-button",
      text: stats.totalEmptyCount > 0 ? `Clear ${stats.totalEmptyCount} Empty Items` : "No Empty Content"
    });
    if (stats.totalEmptyCount === 0) {
      clearButton.disabled = true;
      clearButton.addClass("ss-disabled");
    } else {
      this.registerDomEvent(clearButton, "click", async () => {
        await this.showEmptyContentConfirmation(emptyFiles, emptyFolders, () => {
          this.refreshData();
        });
      });
    }
  }
  createChatHistorySection(container, data) {
    const section = this.createModernSection(container, "\u{1F4AC} Chat History", "Delete all saved chat conversations and message history");
    const statsContainer = section.content.createDiv({ cls: "ss-janitor-stats" });
    const actionContainer = section.content.createDiv({ cls: "ss-janitor-actions" });
    const { chatFiles, sizes } = data;
    const hasChatFiles = chatFiles.length > 0;
    this.createStatCard(statsContainer, "Chats", chatFiles.length, "message-circle");
    this.createStatCard(statsContainer, "Size", sizes.chat, "hard-drive");
    this.createStatCard(statsContainer, "Status", hasChatFiles ? "Active" : "Empty", "activity", hasChatFiles ? "success" : "muted");
    const clearButton = actionContainer.createEl("button", {
      cls: hasChatFiles ? "ss-button ss-button--danger" : "ss-button",
      text: hasChatFiles ? `Clear All Chat History (${sizes.chat})` : "No Chat History"
    });
    if (!hasChatFiles) {
      clearButton.disabled = true;
      clearButton.addClass("ss-disabled");
    } else {
      this.registerDomEvent(clearButton, "click", async () => {
        await this.showConfirmationDialog(chatFiles, "Chat History", this.plugin.settings.chatsDirectory, () => this.refreshData());
      });
    }
  }
  createExtractionsSection(container, data) {
    const section = this.createModernSection(container, "\u{1F4C4} Document Extractions", "Delete extracted content from PDFs, documents, and other processed files");
    const statsContainer = section.content.createDiv({ cls: "ss-janitor-stats" });
    const actionContainer = section.content.createDiv({ cls: "ss-janitor-actions" });
    const { extractionFiles, sizes } = data;
    const hasExtractionFiles = extractionFiles.length > 0;
    this.createStatCard(statsContainer, "Files", extractionFiles.length, "file-text");
    this.createStatCard(statsContainer, "Size", sizes.extraction, "hard-drive");
    this.createStatCard(statsContainer, "Status", hasExtractionFiles ? "Active" : "Empty", "activity", hasExtractionFiles ? "success" : "muted");
    const clearButton = actionContainer.createEl("button", {
      cls: hasExtractionFiles ? "ss-button ss-button--danger" : "ss-button",
      text: hasExtractionFiles ? `Clear All Extractions (${sizes.extraction})` : "No Extractions"
    });
    if (!hasExtractionFiles) {
      clearButton.disabled = true;
      clearButton.addClass("ss-disabled");
    } else {
      this.registerDomEvent(clearButton, "click", async () => {
        await this.showConfirmationDialog(extractionFiles, "Extractions", this.plugin.settings.extractionsDirectory, () => this.refreshData());
      });
    }
  }
  createRecordingsSection(container, data) {
    const section = this.createModernSection(container, "\u{1F399}\uFE0F Audio Recordings", "Delete audio recording files (transcribed text files will remain intact)");
    const statsContainer = section.content.createDiv({ cls: "ss-janitor-stats" });
    const actionContainer = section.content.createDiv({ cls: "ss-janitor-actions" });
    const { recordingFiles, sizes } = data;
    const hasRecordingFiles = recordingFiles.length > 0;
    this.createStatCard(statsContainer, "Files", recordingFiles.length, "audio-lines");
    this.createStatCard(statsContainer, "Size", sizes.recording, "hard-drive");
    this.createStatCard(statsContainer, "Status", hasRecordingFiles ? "Active" : "Empty", "activity", hasRecordingFiles ? "success" : "muted");
    const clearButton = actionContainer.createEl("button", {
      cls: hasRecordingFiles ? "ss-button ss-button--danger" : "ss-button",
      text: hasRecordingFiles ? `Clear All Recordings (${sizes.recording})` : "No Recordings"
    });
    if (!hasRecordingFiles) {
      clearButton.disabled = true;
      clearButton.addClass("ss-disabled");
    } else {
      this.registerDomEvent(clearButton, "click", async () => {
        await this.showConfirmationDialog(recordingFiles, "Recordings", this.plugin.settings.recordingsDirectory, () => this.refreshData());
      });
    }
  }
  createModernSection(container, title, description) {
    const section = container.createDiv({ cls: "ss-janitor-section" });
    const header = section.createDiv({ cls: "ss-janitor-section-header" });
    const titleEl = header.createDiv({ cls: "ss-janitor-section-title", text: title });
    const descEl = header.createDiv({ cls: "ss-janitor-section-description", text: description });
    const content = section.createDiv({ cls: "ss-janitor-section-content" });
    return {
      section,
      header,
      content
    };
  }
  createStatCard(container, label, value, icon, variant = "normal") {
    const card = container.createDiv({ cls: `ss-janitor-stat-card ss-janitor-stat-card--${variant}` });
    const iconEl = card.createDiv({ cls: "ss-janitor-stat-icon" });
    (0, import_obsidian85.setIcon)(iconEl, icon);
    const content = card.createDiv({ cls: "ss-janitor-stat-content" });
    content.createDiv({ cls: "ss-janitor-stat-value", text: value.toString() });
    content.createDiv({ cls: "ss-janitor-stat-label", text: label });
    return card;
  }
  refreshData() {
    this.cachedData = null;
    this.loadJanitorData();
  }
  showLoading(show) {
    this.loadingOverlay.style.display = show ? "flex" : "none";
    this.mainContainer.style.display = show ? "none" : "block";
  }
  showError(message) {
    this.showLoading(false);
    this.mainContainer.empty();
    const errorContainer = this.mainContainer.createDiv({ cls: "ss-janitor-error" });
    const errorIcon = errorContainer.createDiv({ cls: "ss-janitor-error-icon" });
    (0, import_obsidian85.setIcon)(errorIcon, "alert-circle");
    const errorText = errorContainer.createDiv({ cls: "ss-janitor-error-text" });
    errorText.createDiv({ text: "Error", cls: "ss-janitor-error-title" });
    errorText.createDiv({ text: message, cls: "ss-janitor-error-message" });
    const retryButton = errorContainer.createEl("button", {
      cls: "ss-button ss-button--primary",
      text: "Retry"
    });
    this.registerDomEvent(retryButton, "click", () => {
      this.refreshData();
    });
  }
  calculateSize(files) {
    const totalBytes = files.reduce((acc, file) => acc + file.stat.size, 0);
    if (totalBytes === 0)
      return "empty";
    if (totalBytes < 1024)
      return `${totalBytes} bytes`;
    if (totalBytes < 1024 * 1024)
      return `${(totalBytes / 1024).toFixed(1)} KB`;
    if (totalBytes < 1024 * 1024 * 1024)
      return `${(totalBytes / (1024 * 1024)).toFixed(1)} MB`;
    return `${(totalBytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }
  async cleanDirectory(directory) {
    if (!directory || directory === "/" || directory === "." || directory === "..") {
      throw new Error("Cannot delete root or system directories");
    }
    const files = this.app.vault.getFiles().filter((file) => file.path.startsWith(directory));
    for (const file of files) {
      await this.app.vault.trash(file, true);
    }
    const folder = this.app.vault.getAbstractFileByPath(directory);
    if (folder instanceof import_obsidian85.TFolder) {
      const subdirs = folder.children.filter((child) => child instanceof import_obsidian85.TFolder).sort((a, b) => b.path.length - a.path.length);
      for (const subdir of subdirs) {
        if (subdir.children.length === 0) {
          await this.app.vault.trash(subdir, true);
        }
      }
      if (folder.children.length === 0) {
        await this.app.vault.trash(folder, true);
      }
    }
  }
  async showConfirmationDialog(files, type, directory, onSuccess) {
    const confirmModal = new ConfirmationModal(this.app, `Clear ${type}`, `\u26A0\uFE0F The following ${files.length} ${type.toLowerCase()} files will be moved to the Obsidian trash. You can restore them from the trash if needed.`, files, type);
    const result = await confirmModal.open();
    if (result) {
      try {
        await this.cleanDirectory(directory);
        showPopup(this.app, `Successfully moved ${files.length} ${type.toLowerCase()} files (${this.calculateSize(files)}) to trash`, { title: "Success" });
        onSuccess();
      } catch (error) {
        console.error(`Error clearing ${type.toLowerCase()}:`, error);
        showPopup(this.app, `Failed to clear ${type.toLowerCase()}`, {
          title: "Error"
        });
      }
    }
  }
  async showEmptyContentConfirmation(emptyFiles, emptyFolders, onSuccess) {
    const confirmModal = new EmptyContentConfirmationModal(this.app, emptyFiles, emptyFolders);
    const result = await confirmModal.open();
    if (result) {
      try {
        for (const file of emptyFiles) {
          await this.app.vault.trash(file, true);
        }
        const sortedFolders = emptyFolders.sort((a, b) => b.path.length - a.path.length);
        for (const folder of sortedFolders) {
          await this.app.vault.trash(folder, true);
        }
        const totalEmpty = emptyFiles.length + emptyFolders.length;
        showPopup(this.app, `Successfully moved ${totalEmpty} empty items to trash`, { title: "Success" });
        onSuccess();
      } catch (error) {
        console.error("Error clearing empty content:", error);
        showPopup(this.app, "Failed to clear empty content", {
          title: "Error"
        });
      }
    }
  }
  async isEmptyFile(file) {
    if (file.stat.size === 0)
      return true;
    if (file.stat.size < 1024) {
      const extension = file.extension.toLowerCase();
      if (["md", "txt", "markdown"].includes(extension)) {
        try {
          const content = await this.app.vault.read(file);
          const contentWithoutFrontmatter = content.replace(/^---[\s\S]*?---/, "").trim();
          return !contentWithoutFrontmatter;
        } catch (e) {
          return false;
        }
      }
    }
    return false;
  }
  isEmptyFolder(folder) {
    return folder.children.length === 0;
  }
  onClose() {
    this.cachedData = null;
    this.isScanning = false;
    super.onClose();
  }
};
var ConfirmationModal = class extends StandardModal {
  constructor(app, title, description, files, type) {
    super(app);
    this.resolvePromise = null;
    this.files = files;
    this.type = type;
    this.title = title;
    this.description = description;
    this.setSize("medium");
  }
  onOpen() {
    super.onOpen();
    this.addTitle(this.title, this.description);
    this.createFilePreview();
    this.createFooterButtons();
  }
  createFilePreview() {
    if (this.files.length === 0)
      return;
    const previewContainer = this.contentEl.createDiv({ cls: "ss-janitor-preview" });
    const headerEl = previewContainer.createDiv({ cls: "ss-janitor-preview-header" });
    headerEl.createSpan({ text: `${this.files.length} files (${this.calculateSize(this.files)})`, cls: "ss-janitor-preview-count" });
    const listContainer = previewContainer.createDiv({ cls: "ss-janitor-preview-list" });
    const filesToShow = this.files.slice(0, 10);
    for (const file of filesToShow) {
      const fileItem = listContainer.createDiv({ cls: "ss-janitor-preview-item" });
      const iconEl = fileItem.createDiv({ cls: "ss-janitor-preview-icon" });
      (0, import_obsidian85.setIcon)(iconEl, this.getFileIcon(file));
      const pathEl = fileItem.createDiv({ cls: "ss-janitor-preview-path", text: file.path });
      const sizeEl = fileItem.createDiv({ cls: "ss-janitor-preview-size", text: this.calculateSize([file]) });
    }
    if (this.files.length > 10) {
      const moreEl = listContainer.createDiv({ cls: "ss-janitor-preview-more" });
      moreEl.createSpan({ text: `... and ${this.files.length - 10} more files` });
    }
  }
  getFileIcon(file) {
    const extension = file.extension.toLowerCase();
    if (["md", "txt", "markdown"].includes(extension))
      return "file-text";
    if (["jpg", "jpeg", "png", "gif", "webp", "svg"].includes(extension))
      return "image";
    if (["mp3", "wav", "ogg", "m4a"].includes(extension))
      return "audio-lines";
    if (["pdf"].includes(extension))
      return "file-text";
    return "file";
  }
  calculateSize(files) {
    const totalBytes = files.reduce((acc, file) => acc + file.stat.size, 0);
    if (totalBytes === 0)
      return "empty";
    if (totalBytes < 1024)
      return `${totalBytes} bytes`;
    if (totalBytes < 1024 * 1024)
      return `${(totalBytes / 1024).toFixed(1)} KB`;
    if (totalBytes < 1024 * 1024 * 1024)
      return `${(totalBytes / (1024 * 1024)).toFixed(1)} MB`;
    return `${(totalBytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }
  createFooterButtons() {
    this.addActionButton("Cancel", () => this.resolve(false), false);
    this.addActionButton("Move to Trash", () => this.resolve(true), true, "trash-2");
  }
  resolve(value) {
    if (this.resolvePromise) {
      this.resolvePromise(value);
      this.resolvePromise = null;
    }
    this.close();
  }
  async open() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      super.open();
    });
  }
  onClose() {
    if (this.resolvePromise) {
      this.resolvePromise(false);
      this.resolvePromise = null;
    }
    super.onClose();
  }
};
var EmptyContentConfirmationModal = class extends StandardModal {
  constructor(app, emptyFiles, emptyFolders) {
    super(app);
    this.resolvePromise = null;
    this.emptyFiles = emptyFiles;
    this.emptyFolders = emptyFolders;
    this.totalEmpty = emptyFiles.length + emptyFolders.length;
    this.setSize("medium");
  }
  onOpen() {
    super.onOpen();
    this.addTitle("Clear Empty Content", `\u26A0\uFE0F The following ${this.totalEmpty} empty items will be moved to the Obsidian trash. You can restore them from the trash if needed.`);
    this.createEmptyContentPreview();
    this.createFooterButtons();
  }
  createEmptyContentPreview() {
    const previewContainer = this.contentEl.createDiv({ cls: "ss-janitor-preview" });
    if (this.emptyFiles.length > 0) {
      const filesSection = previewContainer.createDiv({ cls: "ss-janitor-preview-section" });
      const filesHeader = filesSection.createDiv({ cls: "ss-janitor-preview-section-header" });
      const filesHeaderIcon = filesHeader.createDiv({ cls: "ss-janitor-preview-section-icon" });
      (0, import_obsidian85.setIcon)(filesHeaderIcon, "file-text");
      filesHeader.createSpan({ text: `Empty Files (${this.emptyFiles.length})`, cls: "ss-janitor-preview-section-title" });
      const filesList = filesSection.createDiv({ cls: "ss-janitor-preview-list" });
      const filesToShow = this.emptyFiles.slice(0, 5);
      for (const file of filesToShow) {
        const item = filesList.createDiv({ cls: "ss-janitor-preview-item" });
        const icon = item.createDiv({ cls: "ss-janitor-preview-icon" });
        (0, import_obsidian85.setIcon)(icon, "file-text");
        item.createSpan({ text: file.path, cls: "ss-janitor-preview-path" });
      }
      if (this.emptyFiles.length > 5) {
        filesList.createDiv({ cls: "ss-janitor-preview-more", text: `... and ${this.emptyFiles.length - 5} more files` });
      }
    }
    if (this.emptyFolders.length > 0) {
      const foldersSection = previewContainer.createDiv({ cls: "ss-janitor-preview-section" });
      const foldersHeader = foldersSection.createDiv({ cls: "ss-janitor-preview-section-header" });
      const foldersHeaderIcon = foldersHeader.createDiv({ cls: "ss-janitor-preview-section-icon" });
      (0, import_obsidian85.setIcon)(foldersHeaderIcon, "folder");
      foldersHeader.createSpan({ text: `Empty Folders (${this.emptyFolders.length})`, cls: "ss-janitor-preview-section-title" });
      const foldersList = foldersSection.createDiv({ cls: "ss-janitor-preview-list" });
      const foldersToShow = this.emptyFolders.slice(0, 5);
      for (const folder of foldersToShow) {
        const item = foldersList.createDiv({ cls: "ss-janitor-preview-item" });
        const icon = item.createDiv({ cls: "ss-janitor-preview-icon" });
        (0, import_obsidian85.setIcon)(icon, "folder");
        item.createSpan({ text: folder.path, cls: "ss-janitor-preview-path" });
      }
      if (this.emptyFolders.length > 5) {
        foldersList.createDiv({ cls: "ss-janitor-preview-more", text: `... and ${this.emptyFolders.length - 5} more folders` });
      }
    }
  }
  createFooterButtons() {
    this.addActionButton("Cancel", () => this.resolve(false), false);
    this.addActionButton("Move to Trash", () => this.resolve(true), true, "trash-2");
  }
  resolve(value) {
    if (this.resolvePromise) {
      this.resolvePromise(value);
      this.resolvePromise = null;
    }
    this.close();
  }
  async open() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      super.open();
    });
  }
  onClose() {
    if (this.resolvePromise) {
      this.resolvePromise(false);
      this.resolvePromise = null;
    }
    super.onClose();
  }
};

// src/views/chatview/LoadChatModal.ts
var import_obsidian87 = __toModule(require("obsidian"));
init_ui();
init_SearchService();
init_StandardModal();
init_FavoritesService();

// src/views/chatview/ChatFavoritesService.ts
var ChatFavoritesService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  static getInstance(plugin) {
    if (!ChatFavoritesService.instance) {
      ChatFavoritesService.instance = new ChatFavoritesService(plugin);
    }
    return ChatFavoritesService.instance;
  }
  async addFavorite(chatId) {
    if (this.plugin.settings.favoriteChats.includes(chatId))
      return;
    const updated = [...this.plugin.settings.favoriteChats, chatId];
    await this.plugin.getSettingsManager().updateSettings({ favoriteChats: updated });
    this.emitFavoritesChanged();
  }
  async removeFavorite(chatId) {
    const updated = this.plugin.settings.favoriteChats.filter((id) => id !== chatId);
    await this.plugin.getSettingsManager().updateSettings({ favoriteChats: updated });
    this.emitFavoritesChanged();
  }
  async toggleFavorite(chatId) {
    if (this.isFavorite(chatId)) {
      await this.removeFavorite(chatId);
    } else {
      await this.addFavorite(chatId);
    }
  }
  isFavorite(chatId) {
    return this.plugin.settings.favoriteChats.includes(chatId);
  }
  getFavorites() {
    return [...this.plugin.settings.favoriteChats];
  }
  emitFavoritesChanged() {
    document.dispatchEvent(new CustomEvent("systemsculpt:chat-favorites-changed", {
      detail: { favorites: this.plugin.settings.favoriteChats }
    }));
  }
};

// src/views/chatview/LoadChatModal.ts
init_FavoritesFilter();

// src/views/chatview/ChatFavoriteToggle.ts
var import_obsidian86 = __toModule(require("obsidian"));
var ChatFavoriteToggle = class {
  constructor(container, chatId, service, callback) {
    this.chatId = chatId;
    this.service = service;
    this.callback = callback;
    this.element = container.createDiv({
      cls: "systemsculpt-favorite-toggle",
      attr: { role: "button", tabindex: "0" }
    });
    this.updateAppearance();
    this.addEventListeners();
  }
  updateAppearance() {
    this.element.empty();
    const isFav = this.service.isFavorite(this.chatId);
    const icon = this.element.createSpan();
    (0, import_obsidian86.setIcon)(icon, "star");
    if (isFav)
      this.element.addClass("is-favorite");
    else
      this.element.removeClass("is-favorite");
    this.element.setAttribute("aria-pressed", isFav ? "true" : "false");
  }
  addEventListeners() {
    this.element.addEventListener("click", this.handleClick.bind(this));
    this.element.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        this.handleClick(e);
      }
    });
  }
  handleClick(e) {
    e.preventDefault();
    e.stopPropagation();
    this.service.toggleFavorite(this.chatId).then(() => {
      const isFav = this.service.isFavorite(this.chatId);
      this.updateAppearance();
      if (this.callback)
        this.callback(this.chatId, isFav);
    });
  }
};

// src/views/chatview/LoadChatModal.ts
var LoadChatModal = class extends StandardModal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.chatItems = [];
    this.isLoading = false;
    this.modelNameCache = new Map();
    this.allChats = [];
    this.filteredChats = [];
    this.favoritesFilter = null;
    this.keyboardSelectedIndex = -1;
    this.chatItemElements = [];
    this.isOpening = false;
    this.searchService = new SearchService();
    this.chatStorage = new ChatStorageService(plugin.app, plugin.settings.chatsDirectory || "SystemSculpt/Chats");
    this.favoritesService = FavoritesService.getInstance(plugin);
    this.chatFavoritesService = ChatFavoritesService.getInstance(plugin);
    this.setSize("large");
    this.modalEl.addClass("systemsculpt-load-chat-modal");
  }
  async onOpen() {
    super.onOpen();
    this.addTitle("Load Chat", "Select a chat to continue your conversation");
    this.createSearchBar();
    this.chatListContainer = this.contentEl.createDiv("systemsculpt-chat-list");
    this.chatListContainer.style.height = "400px";
    this.chatListContainer.style.overflow = "auto";
    this.emptyStateEl = this.contentEl.createDiv("systemsculpt-empty-state");
    this.emptyStateEl.style.display = "none";
    this.emptyStateEl.style.textAlign = "center";
    this.emptyStateEl.style.padding = "20px";
    this.emptyStateEl.style.color = "var(--text-muted)";
    (0, import_obsidian87.setIcon)(this.emptyStateEl.createDiv(), "message-square");
    this.emptyStateEl.createDiv().setText("No chats found");
    const cancelButton = this.addActionButton("Cancel", () => {
      this.close();
    }, false);
    const newChatButton = this.addActionButton("Open New Chat Instead", () => {
      this.openNewChat();
    }, false);
    newChatButton.style.marginRight = "auto";
    this.modalEl.addEventListener("keydown", (e) => {
      this.handleModalKeydown(e);
    });
    this.isLoading = true;
    await this.loadAndDisplayChats();
  }
  createSearchBar() {
    const searchContainer = this.contentEl.createDiv("systemsculpt-search-container");
    searchContainer.style.marginBottom = "16px";
    searchContainer.style.display = "flex";
    searchContainer.style.gap = "8px";
    this.searchInput = new import_obsidian87.SearchComponent(searchContainer);
    this.searchInput.setPlaceholder("Search chats by title & content...");
    this.searchInput.inputEl.style.flexGrow = "1";
    const favContainer = searchContainer.createDiv();
    this.favoritesFilter = new FavoritesFilter(favContainer, this.favoritesService, async () => {
      await this.filterAndDisplayChats();
    });
    this.searchInput.onChange(async (value) => {
      this.keyboardSelectedIndex = -1;
      await this.filterAndDisplayChats();
    });
    this.searchInput.inputEl.addEventListener("keydown", (e) => {
      this.handleSearchKeydown(e);
    });
  }
  async loadAndDisplayChats() {
    this.emptyStateEl.setText("Loading chats...");
    this.emptyStateEl.style.display = "block";
    this.chatListContainer.empty();
    this.chatListContainer.appendChild(this.emptyStateEl);
    try {
      const allSummaries = await this.chatStorage.loadChats();
      this.allChats = allSummaries.map((summary) => ({
        id: summary.id,
        title: summary.title || `Chat from ${this.formatRelativeDate(summary.lastModified)}`,
        lastModified: summary.lastModified,
        selectedModelId: summary.selectedModelId || this.plugin.settings.selectedModelId,
        messages: summary.messages || [],
        isFavorite: this.chatFavoritesService.isFavorite(summary.id)
      }));
      const favoritesFirst = this.favoritesService.getFavoritesFirst();
      this.allChats.sort((a, b) => {
        if (favoritesFirst) {
          if (a.isFavorite && !b.isFavorite)
            return -1;
          if (!a.isFavorite && b.isFavorite)
            return 1;
        }
        return b.lastModified - a.lastModified;
      });
    } catch (error) {
      console.error("Failed to load chats:", error);
      this.emptyStateEl.setText("Failed to load chats.");
      this.allChats = [];
    }
    this.filterAndDisplayChats();
  }
  async filterAndDisplayChats() {
    const searchTerm = this.searchInput.getValue().trim();
    const showFavoritesOnly = this.favoritesService.getShowFavoritesOnly();
    let baseList = showFavoritesOnly ? this.allChats.filter((c) => c.isFavorite) : [...this.allChats];
    if (!searchTerm) {
      this.filteredChats = baseList;
      this.displayChats();
      return;
    }
    const searchTerms = searchTerm.toLowerCase().split(/\s+/).filter((t) => t.length > 0);
    if (searchTerms.length === 0) {
      this.filteredChats = [...this.allChats];
      this.displayChats();
      return;
    }
    this.filteredChats = baseList.filter((chat) => {
      if (chat.title && searchTerms.some((term) => chat.title.toLowerCase().includes(term))) {
        return true;
      }
      if (chat.messages && chat.messages.length > 0) {
        return chat.messages.some((msg) => {
          if (typeof msg.content !== "string")
            return false;
          const content = msg.content.toLowerCase();
          return searchTerms.some((term) => content.includes(term));
        });
      }
      return false;
    });
    const favoritesFirst = this.favoritesService.getFavoritesFirst();
    this.filteredChats.sort((a, b) => {
      if (favoritesFirst) {
        if (a.isFavorite && !b.isFavorite)
          return -1;
        if (!a.isFavorite && b.isFavorite)
          return 1;
      }
      return b.lastModified - a.lastModified;
    });
    this.displayChats(searchTerms);
  }
  displayChats(searchTerms = []) {
    this.chatListContainer.empty();
    this.chatItemElements = [];
    this.keyboardSelectedIndex = -1;
    if (this.filteredChats.length === 0) {
      const searchTerm = this.searchInput.getValue().trim();
      this.emptyStateEl.setText(searchTerm ? "No chats match your search." : "No chats found.");
      this.emptyStateEl.style.display = "block";
      this.chatListContainer.appendChild(this.emptyStateEl);
      return;
    }
    this.emptyStateEl.style.display = "none";
    if (searchTerms.length > 0) {
      const headerEl = this.chatListContainer.createEl("h3", {
        text: `Search Results (${this.filteredChats.length})`,
        cls: "systemsculpt-section-header"
      });
    }
    this.filteredChats.forEach((chat) => {
      const chatItemEl = this.chatListContainer.createDiv("systemsculpt-modal-list-item");
      chatItemEl.dataset.chatId = chat.id;
      chatItemEl.dataset.favorite = chat.isFavorite ? "true" : "false";
      const favContainer = chatItemEl.createDiv("systemsculpt-chat-favorite");
      new ChatFavoriteToggle(favContainer, chat.id, this.chatFavoritesService, async (chatId, isFavorite) => {
        chat.isFavorite = isFavorite;
        chatItemEl.dataset.favorite = isFavorite ? "true" : "false";
        if (this.favoritesService.getFavoritesFirst()) {
          await this.filterAndDisplayChats();
        }
      });
      const contentEl = chatItemEl.createDiv("systemsculpt-modal-list-item-content");
      this.chatItemElements.push(chatItemEl);
      const titleEl = contentEl.createDiv("systemsculpt-modal-list-item-title");
      if (searchTerms.length > 0) {
        const { html: highlightedTitle } = this.highlightText(chat.title, searchTerms);
        titleEl.appendChild(highlightedTitle);
      } else {
        titleEl.textContent = chat.title;
      }
      const previewEl = contentEl.createDiv("systemsculpt-modal-list-item-preview");
      if (searchTerms.length > 0) {
        let foundMatchContext = false;
        const allContent = chat.messages.map((m) => typeof m.content === "string" ? m.content : "").join(" ");
        if (allContent) {
          const matchContext = this.getMatchContext(allContent, searchTerms);
          if (matchContext !== allContent) {
            foundMatchContext = true;
            const { html } = this.highlightText(matchContext, searchTerms);
            previewEl.appendChild(html);
          }
        }
        if (!foundMatchContext) {
          this.renderLastMessages(previewEl, chat);
        }
      } else {
        this.renderLastMessages(previewEl, chat);
      }
      const metadataEl = contentEl.createDiv("systemsculpt-modal-list-item-meta");
      const dateEl = metadataEl.createDiv("systemsculpt-modal-list-item-date");
      dateEl.textContent = this.formatRelativeDate(chat.lastModified);
      const countEl = metadataEl.createDiv("systemsculpt-modal-list-item-count");
      countEl.textContent = `${chat.messages.length} messages`;
      chatItemEl.addEventListener("click", () => {
        this.openChat(chat.id, chat.selectedModelId);
      });
    });
  }
  renderLastMessages(container, chat) {
    if (!chat.messages || chat.messages.length === 0) {
      container.textContent = "Empty chat";
      return;
    }
    const lastMessages = this.getRecentMessages(chat);
    lastMessages.forEach((msg) => {
      const msgEl = document.createElement("div");
      msgEl.className = "systemsculpt-modal-message";
      let content = typeof msg.content === "string" ? msg.content : "Complex message with images or attachments";
      if (content.length > 200) {
        content = content.substring(0, 200) + "...";
      }
      msgEl.textContent = content;
      container.appendChild(msgEl);
    });
  }
  getRecentMessages(chat) {
    const messages = chat.messages;
    if (!messages || messages.length === 0)
      return [];
    if (messages.length === 1)
      return [messages[0]];
    let lastUserIndex = -1;
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].role === "user") {
        lastUserIndex = i;
        break;
      }
    }
    if (lastUserIndex === -1) {
      return [messages[messages.length - 1]];
    }
    const userMessage = messages[lastUserIndex];
    const assistantMessage = lastUserIndex + 1 < messages.length ? messages[lastUserIndex + 1] : null;
    return assistantMessage ? [userMessage, assistantMessage] : [userMessage];
  }
  formatRelativeDate(timestamp) {
    const now = Date.now();
    const diffSeconds = Math.round((now - timestamp) / 1e3);
    const diffMinutes = Math.round(diffSeconds / 60);
    const diffHours = Math.round(diffMinutes / 60);
    const diffDays = Math.round(diffHours / 24);
    const diffWeeks = Math.round(diffDays / 7);
    if (diffSeconds < 60)
      return `${diffSeconds}s ago`;
    if (diffMinutes < 60)
      return `${diffMinutes}m ago`;
    if (diffHours < 24)
      return `${diffHours}h ago`;
    if (diffDays < 7)
      return `${diffDays}d ago`;
    if (diffWeeks < 5)
      return `${diffWeeks}w ago`;
    const date = new Date(timestamp);
    return date.toLocaleDateString();
  }
  async getModelName(modelId) {
    if (this.modelNameCache.has(modelId)) {
      return this.modelNameCache.get(modelId) || "Unknown Model";
    }
    try {
      const models = await this.plugin.modelService.getModels();
      const model = models.find((m) => m.id === modelId);
      const name = model ? model.name : "Unknown Model";
      this.modelNameCache.set(modelId, name);
      return name;
    } catch (error) {
      console.error("Failed to get model name:", error);
      return "Unknown Model";
    }
  }
  highlightText(text, searchTerms) {
    const container = document.createElement("div");
    if (!searchTerms || searchTerms.length === 0 || !text) {
      container.textContent = text || "";
      return { html: container, hasMatches: false };
    }
    const lowerText = text.toLowerCase();
    let lastIndex = 0;
    let hasMatches = false;
    const allMatches = [];
    searchTerms.forEach((term) => {
      if (!term)
        return;
      let index = 0;
      while ((index = lowerText.indexOf(term, index)) > -1) {
        allMatches.push({ term, index });
        index += term.length;
      }
    });
    if (allMatches.length === 0) {
      container.textContent = text;
      return { html: container, hasMatches: false };
    }
    allMatches.sort((a, b) => a.index - b.index);
    allMatches.forEach((match) => {
      const { term, index } = match;
      if (index < lastIndex)
        return;
      if (index > lastIndex) {
        container.appendChild(document.createTextNode(text.substring(lastIndex, index)));
      }
      const highlight = document.createElement("span");
      highlight.className = "systemsculpt-search-highlight";
      highlight.textContent = text.substr(index, term.length);
      container.appendChild(highlight);
      lastIndex = index + term.length;
      hasMatches = true;
    });
    if (lastIndex < text.length) {
      container.appendChild(document.createTextNode(text.substring(lastIndex)));
    }
    return { html: container, hasMatches };
  }
  getMatchContext(text, searchTerms) {
    if (!searchTerms || searchTerms.length === 0 || !text) {
      return text;
    }
    const lowerText = text.toLowerCase();
    const matches = [];
    searchTerms.forEach((term) => {
      if (!term)
        return;
      let index = 0;
      while ((index = lowerText.indexOf(term, index)) > -1) {
        matches.push({ term, index });
        index += term.length;
      }
    });
    if (matches.length === 0)
      return text;
    matches.sort((a, b) => a.index - b.index);
    const CONTEXT_SIZE = 75;
    let bestStart = matches[0].index;
    let bestEnd = matches[0].index + matches[0].term.length;
    for (let i = 0; i < matches.length; i++) {
      let windowStart = matches[i].index;
      let windowEnd = matches[i].index + matches[i].term.length;
      let matchCount = 1;
      for (let j = i + 1; j < matches.length; j++) {
        if (matches[j].index - windowEnd > CONTEXT_SIZE)
          break;
        windowEnd = matches[j].index + matches[j].term.length;
        matchCount++;
      }
      if (matchCount > 1 && windowEnd - windowStart < bestEnd - bestStart) {
        bestStart = windowStart;
        bestEnd = windowEnd;
      }
    }
    const contextStart = Math.max(0, bestStart - CONTEXT_SIZE);
    const contextEnd = Math.min(text.length, bestEnd + CONTEXT_SIZE);
    let previewStart = contextStart;
    while (previewStart > 0 && !/[\s.!?\n]/.test(text[previewStart - 1])) {
      previewStart--;
    }
    let previewEnd = contextEnd;
    while (previewEnd < text.length && !/[\s.!?\n]/.test(text[previewEnd])) {
      previewEnd++;
    }
    let preview = text.slice(previewStart, previewEnd).trim();
    if (previewStart > 0)
      preview = "..." + preview;
    if (previewEnd < text.length)
      preview = preview + "...";
    return preview;
  }
  async openChat(chatId, selectedModelId) {
    if (this.isOpening) {
      console.log("[SystemSculpt] Preventing duplicate chat open");
      return;
    }
    this.isOpening = true;
    this.close();
    try {
      const fullChatData = await this.chatStorage.loadChat(chatId);
      const { workspace } = this.app;
      const leaf = workspace.getLeaf("tab");
      const state = {
        chatId,
        selectedModelId
      };
      if (fullChatData) {
        state.systemPromptType = fullChatData.systemPromptType;
        state.systemPromptPath = fullChatData.systemPromptPath;
        state.agentMode = fullChatData.agentMode;
        state.includeVaultStructure = fullChatData.includeVaultStructure;
        state.chatFontSize = fullChatData.chatFontSize;
        state.chatTitle = fullChatData.title;
        state.version = fullChatData.version;
        console.log("[SystemSculpt] LoadChatModal: Setting state with agentMode:", state.agentMode);
      }
      leaf.setViewState({
        type: CHAT_VIEW_TYPE,
        state
      }).then(() => {
        workspace.setActiveLeaf(leaf, { focus: true });
      });
    } catch (e) {
      console.error("[SystemSculpt] Failed to open chat view:", e);
      new import_obsidian87.Notice("Error opening chat. Please try again.");
      this.openChatFile(chatId);
    }
  }
  openNewChat() {
    if (this.isOpening) {
      console.log("[SystemSculpt] Preventing duplicate new chat open");
      return;
    }
    this.isOpening = true;
    this.close();
    try {
      const { workspace } = this.app;
      const leaf = workspace.getLeaf("tab");
      leaf.setViewState({
        type: CHAT_VIEW_TYPE,
        state: {
          chatId: "",
          selectedModelId: this.plugin.settings.selectedModelId,
          includeVaultStructure: this.plugin.settings.defaultIncludeVaultStructure || false
        }
      }).then(() => {
        workspace.setActiveLeaf(leaf, { focus: true });
      });
    } catch (e) {
      console.error("[SystemSculpt] Failed to open new chat view:", e);
      new import_obsidian87.Notice("Unable to open new chat.");
    }
  }
  async openChatFile(chatId) {
    if (this.isOpening) {
      console.log("[SystemSculpt] Preventing duplicate chat file open");
      return;
    }
    try {
      const filePath = `${this.plugin.settings.chatsDirectory || "SystemSculpt/Chats"}/${chatId}.json`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian87.TFile) {
        await this.app.workspace.getLeaf(true).openFile(file);
        this.close();
      } else {
        throw new Error("Chat file not found");
      }
    } catch (error) {
      console.error("Failed to open chat file:", error);
      showPopup(this.app, "", {
        title: "Error",
        description: "Failed to open chat file",
        primaryButton: "OK"
      });
    }
  }
  onClose() {
    this.isOpening = false;
  }
  handleModalKeydown(e) {
    if (document.activeElement === this.searchInput.inputEl && e.key !== "Escape" && e.key !== "Tab") {
      return;
    }
    switch (e.key) {
      case "ArrowUp":
        e.preventDefault();
        this.selectPreviousItem();
        break;
      case "ArrowDown":
        e.preventDefault();
        this.selectNextItem();
        break;
      case "Enter":
        e.preventDefault();
        if (this.keyboardSelectedIndex >= 0 && this.keyboardSelectedIndex < this.filteredChats.length) {
          const chat = this.filteredChats[this.keyboardSelectedIndex];
          this.openChat(chat.id, chat.selectedModelId);
        }
        break;
      case "Escape":
        e.preventDefault();
        this.close();
        break;
      case "Tab":
        e.preventDefault();
        if (e.shiftKey) {
          this.selectPreviousItem();
        } else {
          this.selectNextItem();
        }
        break;
    }
  }
  selectNextItem() {
    if (this.chatItemElements.length === 0)
      return;
    if (this.keyboardSelectedIndex < 0) {
      this.keyboardSelectedIndex = 0;
    } else {
      this.keyboardSelectedIndex = (this.keyboardSelectedIndex + 1) % this.chatItemElements.length;
    }
    this.updateSelectedItemFromKeyboard();
  }
  selectPreviousItem() {
    if (this.chatItemElements.length === 0)
      return;
    if (this.keyboardSelectedIndex < 0) {
      this.keyboardSelectedIndex = this.chatItemElements.length - 1;
    } else {
      this.keyboardSelectedIndex = (this.keyboardSelectedIndex - 1 + this.chatItemElements.length) % this.chatItemElements.length;
    }
    this.updateSelectedItemFromKeyboard();
  }
  updateSelectedItemFromKeyboard() {
    if (this.keyboardSelectedIndex < 0 || this.keyboardSelectedIndex >= this.chatItemElements.length) {
      return;
    }
    this.chatItemElements.forEach((el) => {
      el.classList.remove("is-selected");
    });
    const selectedEl = this.chatItemElements[this.keyboardSelectedIndex];
    selectedEl.classList.add("is-selected");
    selectedEl.scrollIntoView({ block: "nearest", behavior: "smooth" });
  }
  handleSearchKeydown(e) {
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        this.selectNextItem();
        break;
      case "Enter":
        if (this.keyboardSelectedIndex >= 0 && this.keyboardSelectedIndex < this.filteredChats.length) {
          e.preventDefault();
          e.stopPropagation();
          const chat = this.filteredChats[this.keyboardSelectedIndex];
          this.openChat(chat.id, chat.selectedModelId);
        }
        break;
    }
  }
};

// src/core/plugin/ribbons.ts
init_titleUtils();
var RibbonManager = class {
  constructor(plugin, app) {
    this.plugin = plugin;
    this.app = app;
    this.chatStorage = new ChatStorageService(app, plugin.settings.chatsDirectory);
  }
  initialize() {
    this.registerRibbonIcons();
  }
  registerRibbonIcons() {
    this.plugin.addRibbonIcon("message-square", "Open SystemSculpt Chat", async () => {
      await this.openChatView();
    });
    this.plugin.addRibbonIcon("history", "Open SystemSculpt Chat History", () => {
      this.openChatHistoryModal();
    });
    this.plugin.addRibbonIcon("trash", "Open SystemSculpt Janitor", () => {
      this.openJanitorModal();
    });
    this.plugin.addRibbonIcon("network", "Open Similar Notes Panel", async () => {
      try {
        await this.plugin.getViewManager().activateEmbeddingsView();
      } catch (error) {
        console.error("[SystemSculpt] Error opening embeddings view:", error);
      }
    });
  }
  async openChatView() {
    const { workspace } = this.app;
    const leaf = workspace.getLeaf("tab");
    await leaf.setViewState({
      type: CHAT_VIEW_TYPE,
      state: {
        chatId: "",
        selectedModelId: this.plugin.settings.selectedModelId,
        chatTitle: generateDefaultChatTitle(),
        includeVaultStructure: this.plugin.settings.defaultIncludeVaultStructure || false
      }
    });
    const view = new ChatView(leaf, this.plugin);
    await leaf.open(view);
    workspace.setActiveLeaf(leaf, { focus: true });
  }
  openChatHistoryModal() {
    const modal = new LoadChatModal(this.plugin);
    modal.open();
  }
  openJanitorModal() {
    new JanitorModal(this.app, this.plugin).open();
  }
};

// src/views/EmbeddingsView.ts
var import_obsidian88 = __toModule(require("obsidian"));
var EMBEDDINGS_VIEW_TYPE = "systemsculpt-embeddings-view";
var EmbeddingsView = class extends import_obsidian88.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentFile = null;
    this.currentChatView = null;
    this.currentResults = [];
    this.isLoading = false;
    this.lastSearchContent = "";
    this.lastFileHash = "";
    this.fileExists = false;
    this.isDragging = false;
    this.dragTimeout = null;
    this.searchTimeout = null;
    this.SEARCH_DELAY = 300;
    this.plugin = plugin;
  }
  getViewType() {
    return EMBEDDINGS_VIEW_TYPE;
  }
  getDisplayText() {
    return "Similar Notes";
  }
  getIcon() {
    return "network";
  }
  async onOpen() {
    this.contentEl = this.containerEl.children[1];
    this.contentEl.empty();
    this.contentEl.addClass("systemsculpt-embeddings-view");
    this.setupUI();
    this.registerEvents();
    this.checkActiveFile();
  }
  setupUI() {
    this.headerEl = this.contentEl.createDiv({ cls: "embeddings-view-header" });
    this.titleEl = this.headerEl.createDiv({ cls: "embeddings-view-title" });
    const titleRowEl = this.titleEl.createDiv({ cls: "embeddings-view-title-row" });
    const iconEl = titleRowEl.createDiv({ cls: "embeddings-view-icon" });
    (0, import_obsidian88.setIcon)(iconEl, "network");
    titleRowEl.createSpan({ text: "Similar Notes" });
    this.fileNameEl = this.titleEl.createDiv({ cls: "embeddings-view-file-name" });
    this.fileNameEl.style.display = "none";
    this.statusEl = this.contentEl.createDiv({ cls: "embeddings-view-status", attr: { style: "display: none;" } });
    this.resultsEl = this.contentEl.createDiv({ cls: "embeddings-view-results" });
    this.showEmptyState();
  }
  registerEvents() {
    this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
      this.debouncedCheckActiveFile();
    }));
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian88.TFile && file === this.currentFile) {
        this.debouncedSearchCurrentFile();
      }
    }));
    this.registerEvent(this.app.workspace.on("systemsculpt:chat-loaded", (chatId) => {
      if (this.currentChatView && this.currentChatView.chatId === chatId) {
        this.debouncedSearchCurrentChat();
      }
    }));
    this.registerEvent(this.app.workspace.on("systemsculpt:chat-message-added", (chatId) => {
      if (this.currentChatView && this.currentChatView.chatId === chatId) {
        this.debouncedSearchCurrentChat();
      }
    }));
    this.contextChangeHandler = () => {
      if (this.currentChatView && this.currentResults.length > 0) {
        this.updateContextIndicators();
      }
    };
    document.addEventListener("systemsculpt:context-changed", this.contextChangeHandler);
  }
  debouncedCheckActiveFile() {
    if (this.searchTimeout) {
      window.clearTimeout(this.searchTimeout);
    }
    this.searchTimeout = window.setTimeout(() => {
      this.checkActiveFile();
    }, this.SEARCH_DELAY);
  }
  debouncedSearchCurrentFile() {
    if (this.searchTimeout) {
      window.clearTimeout(this.searchTimeout);
    }
    this.searchTimeout = window.setTimeout(() => {
      if (this.currentFile) {
        this.searchForSimilar(this.currentFile);
      }
    }, this.SEARCH_DELAY * 2);
  }
  debouncedSearchCurrentChat() {
    if (this.searchTimeout) {
      window.clearTimeout(this.searchTimeout);
    }
    this.searchTimeout = window.setTimeout(() => {
      if (this.currentChatView) {
        this.searchForSimilarFromChat(this.currentChatView);
      }
    }, this.SEARCH_DELAY * 2);
  }
  startRefreshAnimation() {
    this.titleEl.addClass("refreshing");
  }
  stopRefreshAnimation() {
    this.titleEl.removeClass("refreshing");
  }
  updateFileName(fileName) {
    this.fileNameEl.textContent = fileName;
    this.fileNameEl.style.display = "block";
  }
  hideFileName() {
    this.fileNameEl.style.display = "none";
  }
  checkActiveFile() {
    var _a, _b;
    if (this.isDragging) {
      return;
    }
    if (!this.plugin.settings.embeddingsEnabled) {
      this.showDisabledState();
      return;
    }
    const activeMarkdownView = this.app.workspace.getActiveViewOfType(import_obsidian88.MarkdownView);
    const activeChatView = this.app.workspace.getActiveViewOfType(ChatView);
    const activeFile = (activeMarkdownView == null ? void 0 : activeMarkdownView.file) || null;
    const hasNewFile = activeFile && activeFile !== this.currentFile;
    const hasNewChat = activeChatView && activeChatView !== this.currentChatView;
    const isRefocusingOnChat = activeChatView && activeChatView === this.currentChatView && !activeFile;
    const switchingFromNonContentView = !this.currentFile && !this.currentChatView && (activeFile || activeChatView);
    if (hasNewFile) {
      if (((_a = this.currentFile) == null ? void 0 : _a.path) !== activeFile.path) {
      }
      this.currentFile = activeFile;
      this.currentChatView = null;
      this.updateFileName(activeFile.basename);
      this.searchForSimilar(activeFile);
    } else if (hasNewChat) {
      const chatTitle = activeChatView.getChatTitle();
      if (((_b = this.currentChatView) == null ? void 0 : _b.chatId) !== activeChatView.chatId) {
      }
      this.currentChatView = activeChatView;
      this.currentFile = null;
      this.updateFileName(chatTitle || "Chat");
      this.searchForSimilarFromChat(activeChatView);
    } else if (isRefocusingOnChat) {
      const chatContent = this.extractChatContent(activeChatView);
      const contentHash = this.hashContent(chatContent);
      if (contentHash !== this.lastFileHash) {
        this.searchForSimilarFromChat(activeChatView);
      }
    } else if (switchingFromNonContentView) {
      if (activeFile) {
        this.currentFile = activeFile;
        this.currentChatView = null;
        this.updateFileName(activeFile.basename);
        this.searchForSimilar(activeFile);
      } else if (activeChatView) {
        this.currentChatView = activeChatView;
        this.currentFile = null;
        this.updateFileName(activeChatView.getChatTitle() || "Chat");
        this.searchForSimilarFromChat(activeChatView);
      }
    }
  }
  async searchForSimilar(file) {
    try {
      const manager = this.plugin.getOrCreateEmbeddingsManager();
      const isEmpty = await manager.isEmpty();
      if (isEmpty) {
        this.showProcessingPrompt();
        return;
      }
      const fileContent = await this.app.vault.read(file);
      const contentHash = this.hashContent(fileContent);
      const fileInEmbeddings = await this.checkFileExists(file.path, manager);
      if (!fileInEmbeddings || contentHash !== this.lastFileHash) {
        this.showSmartLoading(file.basename, !fileInEmbeddings);
        this.lastFileHash = contentHash;
        this.fileExists = fileInEmbeddings;
      } else {
        this.showQuickLoading(file.basename);
      }
      this.lastSearchContent = file.path;
      const results = await manager.findSimilar(file.path, 15);
      await this.updateResults(results, file);
    } catch (error) {
      console.error("[EmbeddingsView] Error searching for similar notes:", error);
      this.showError(`Failed to find similar notes: ${error.message}`);
    }
  }
  async searchForSimilarFromChat(chatView) {
    try {
      const manager = this.plugin.getOrCreateEmbeddingsManager();
      const isEmpty = await manager.isEmpty();
      if (isEmpty) {
        this.showProcessingPrompt();
        return;
      }
      const chatContent = this.extractChatContent(chatView);
      if (!chatContent.trim()) {
        this.showEmptyContent();
        return;
      }
      const contentHash = this.hashContent(chatContent);
      if (contentHash !== this.lastFileHash) {
        this.showSmartLoading(chatView.getChatTitle() || "Chat", false);
        this.lastFileHash = contentHash;
      } else {
        this.showQuickLoading(chatView.getChatTitle() || "Chat");
      }
      this.lastSearchContent = `chat:${chatView.chatId}`;
      const results = await manager.searchByQuery(chatContent, 15);
      await this.updateResults(results, null, chatView.getChatTitle() || "Chat");
    } catch (error) {
      console.error("[EmbeddingsView] Error searching for similar notes from chat:", error);
      this.showError(`Failed to find similar notes: ${error.message}`);
    }
  }
  extractChatContent(chatView) {
    const messages = chatView.getMessages();
    if (!messages || messages.length === 0) {
      return "";
    }
    const selectedMessages = [];
    for (let i = 0; i < Math.min(3, messages.length); i++) {
      selectedMessages.push(messages[i]);
    }
    if (messages.length > 3) {
      const latestStart = Math.max(3, messages.length - 2);
      for (let i = latestStart; i < messages.length; i++) {
        if (!selectedMessages.find((m) => m.message_id === messages[i].message_id)) {
          selectedMessages.push(messages[i]);
        }
      }
    }
    const extractedContent = selectedMessages.map((message) => {
      if (typeof message.content === "string") {
        return message.content;
      } else if (Array.isArray(message.content)) {
        return message.content.map((part) => {
          if (part.type === "text") {
            return part.text;
          }
          return "";
        }).join(" ");
      }
      return "";
    }).filter((content) => content.trim().length > 0).join("\n\n");
    return extractedContent;
  }
  isNoteInContext(notePath) {
    if (!this.currentChatView || !this.currentChatView.contextManager) {
      return false;
    }
    const contextFiles = this.currentChatView.contextManager.getContextFiles();
    const wikiLink = `[[${notePath}]]`;
    const fileName = notePath.split("/").pop() || notePath;
    const fileNameWikiLink = `[[${fileName}]]`;
    return contextFiles.has(notePath) || contextFiles.has(wikiLink) || contextFiles.has(fileName) || contextFiles.has(fileNameWikiLink);
  }
  updateContextIndicators() {
    const resultElements = this.resultsEl.querySelectorAll(".similar-note-item");
    resultElements.forEach((el, index) => {
      if (index < this.currentResults.length) {
        const result = this.currentResults[index];
        const isInContext = this.isNoteInContext(result.path);
        el.classList.toggle("similar-note-in-context", isInContext);
      }
    });
  }
  showSmartLoading(fileName, needsProcessing) {
    this.isLoading = true;
    this.startRefreshAnimation();
  }
  showQuickLoading(fileName) {
    this.isLoading = true;
    this.startRefreshAnimation();
  }
  showEmptyState() {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.hideFileName();
    this.statusEl.empty();
    this.resultsEl.empty();
    this.currentFile = null;
    this.currentChatView = null;
    this.lastSearchContent = "";
    const emptyEl = this.resultsEl.createDiv({ cls: "embeddings-view-empty" });
    const iconEl = emptyEl.createDiv({ cls: "empty-icon" });
    (0, import_obsidian88.setIcon)(iconEl, "file-text");
    emptyEl.createDiv({
      text: "Open a note or chat to see similar content",
      cls: "empty-title"
    });
    emptyEl.createDiv({
      text: "Switch to any markdown note or chat view and this panel will automatically show related notes from your vault.",
      cls: "empty-description"
    });
  }
  showEmptyContent() {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.statusEl.empty();
    this.resultsEl.empty();
    const emptyEl = this.resultsEl.createDiv({ cls: "embeddings-view-empty" });
    const iconEl = emptyEl.createDiv({ cls: "empty-icon" });
    (0, import_obsidian88.setIcon)(iconEl, "file-x");
    emptyEl.createDiv({
      text: "Note is empty",
      cls: "empty-title"
    });
    emptyEl.createDiv({
      text: "Add some content to this note or chat to find similar notes.",
      cls: "empty-description"
    });
  }
  showError(message) {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.statusEl.empty();
    this.resultsEl.empty();
    const errorEl = this.resultsEl.createDiv({ cls: "embeddings-view-error" });
    const iconEl = errorEl.createDiv({ cls: "error-icon" });
    (0, import_obsidian88.setIcon)(iconEl, "alert-circle");
    errorEl.createDiv({
      text: "Error finding similar notes",
      cls: "error-title"
    });
    errorEl.createDiv({
      text: message,
      cls: "error-message"
    });
  }
  showDisabledState() {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.hideFileName();
    this.statusEl.empty();
    this.resultsEl.empty();
    this.currentFile = null;
    this.currentChatView = null;
    this.lastSearchContent = "";
    const disabledEl = this.resultsEl.createDiv({ cls: "embeddings-view-disabled" });
    const iconEl = disabledEl.createDiv({ cls: "disabled-icon" });
    (0, import_obsidian88.setIcon)(iconEl, "power");
    disabledEl.createDiv({
      text: "Embeddings Disabled",
      cls: "disabled-title"
    });
    disabledEl.createDiv({
      text: "Enable embeddings in Settings > SystemSculpt AI > Embeddings to find similar notes.",
      cls: "disabled-description"
    });
  }
  async updateResults(results, sourceFile, sourceName) {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.currentResults = results;
    const displayName = sourceName || (sourceFile == null ? void 0 : sourceFile.basename) || "Unknown";
    this.statusEl.empty();
    if (results.length > 0) {
      this.statusEl.createSpan({
        text: `${results.length} similar notes found for "${displayName}"`,
        cls: "systemsculpt-status-text"
      });
    } else {
      this.statusEl.createSpan({
        text: `No similar notes found for "${displayName}"`,
        cls: "systemsculpt-status-text muted"
      });
    }
    this.resultsEl.empty();
    if (results.length === 0) {
      const noResultsEl = this.resultsEl.createDiv({ cls: "embeddings-view-no-results" });
      const iconEl = noResultsEl.createDiv({ cls: "no-results-icon" });
      (0, import_obsidian88.setIcon)(iconEl, "search-x");
      noResultsEl.createDiv({
        text: "No similar notes found",
        cls: "no-results-title"
      });
      noResultsEl.createDiv({
        text: "This note doesn't have similar content in your vault yet.",
        cls: "no-results-description"
      });
      return;
    }
    const resultsContainer = this.resultsEl.createDiv({ cls: "results-container" });
    for (const result of results) {
      await this.renderResult(resultsContainer, result);
    }
  }
  async renderResult(container, result) {
    const resultEl = container.createDiv({ cls: "similar-note-item cursor-pointer" });
    const isDraggableForChat = this.currentChatView !== null;
    if (isDraggableForChat) {
      const isInContext = this.isNoteInContext(result.path);
      if (isInContext) {
        resultEl.addClass("similar-note-in-context");
      }
    }
    if (isDraggableForChat) {
      resultEl.setAttribute("draggable", "true");
      resultEl.addClass("similar-note-draggable");
      resultEl.addEventListener("dragstart", (e) => {
        if (!e.dataTransfer)
          return;
        this.isDragging = true;
        if (this.dragTimeout) {
          window.clearTimeout(this.dragTimeout);
        }
        this.dragTimeout = window.setTimeout(() => {
          this.isDragging = false;
          this.dragTimeout = null;
        }, 5e3);
        e.dataTransfer.setData("text/plain", result.path);
        e.dataTransfer.setData("application/x-systemsculpt-similar-note", JSON.stringify({
          path: result.path,
          title: result.metadata.title || result.path.split("/").pop() || result.path,
          score: result.score,
          source: "similar-notes"
        }));
        e.dataTransfer.effectAllowed = "copy";
        resultEl.addClass("similar-note-dragging");
      });
      resultEl.addEventListener("dragend", (e) => {
        this.isDragging = false;
        if (this.dragTimeout) {
          window.clearTimeout(this.dragTimeout);
          this.dragTimeout = null;
        }
        resultEl.removeClass("similar-note-dragging");
        setTimeout(() => {
          this.debouncedCheckActiveFile();
        }, 100);
      });
    }
    resultEl.addEventListener("click", async (e) => {
      if (e.target.closest(".internal-link")) {
        return;
      }
      if (isDraggableForChat && e.defaultPrevented) {
        return;
      }
      e.preventDefault();
      await this.openFile(result.path);
    });
    const scorePercent = Math.round(result.score * 100);
    const scoreClass = scorePercent >= 75 ? "score-high" : scorePercent >= 50 ? "score-medium" : "score-low";
    const scoreEl = resultEl.createDiv({ cls: `note-score ${scoreClass}` });
    scoreEl.createSpan({ text: `${scorePercent}%` });
    const contentEl = resultEl.createDiv({ cls: "note-content" });
    const titleEl = contentEl.createDiv({ cls: "note-title" });
    const linkEl = titleEl.createEl("a", {
      cls: "internal-link",
      text: result.metadata.title || result.path.split("/").pop() || result.path,
      href: result.path
    });
    linkEl.addEventListener("click", async (e) => {
      e.preventDefault();
      await this.openFile(result.path);
    });
    if (result.metadata.excerpt) {
      const excerptEl = contentEl.createDiv({ cls: "note-excerpt" });
      excerptEl.textContent = result.metadata.excerpt;
    }
    const metaEl = contentEl.createDiv({ cls: "note-metadata" });
    const pathParts = result.path.split("/");
    if (pathParts.length > 1) {
      const pathEl = metaEl.createSpan({ cls: "note-path" });
      pathEl.textContent = pathParts.slice(0, -1).join("/");
    }
    if (result.metadata.tags && result.metadata.tags.length > 0) {
      const tagsEl = metaEl.createSpan({ cls: "note-tags" });
      for (const tag of result.metadata.tags.slice(0, 3)) {
        tagsEl.createSpan({
          cls: "tag",
          text: tag.startsWith("#") ? tag : `#${tag}`
        });
      }
    }
    if (result.metadata.lastModified) {
      const date = new Date(result.metadata.lastModified);
      metaEl.createSpan({
        cls: "note-date",
        text: this.formatDate(date)
      });
    }
  }
  async openFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian88.TFile) {
      await this.app.workspace.getLeaf(false).openFile(file);
    }
  }
  showProcessingPrompt() {
    this.showProcessingState("No embeddings data found", "Process your vault to enable finding similar notes.");
  }
  async startProcessing() {
    try {
      const manager = this.plugin.getOrCreateEmbeddingsManager();
      if (manager.isIndexing()) {
        new import_obsidian88.Notice("Processing already in progress");
        return;
      }
      this.showProcessingStatus();
      await manager.enableAutoProcessing();
      await manager.processVault((progress) => {
        this.updateProcessingStatus(progress);
      });
      if (this.currentFile) {
        await this.searchForSimilar(this.currentFile);
      }
    } catch (error) {
      console.error("[EmbeddingsView] Failed to process embeddings:", error);
      this.showError(`Failed to process embeddings: ${error.message}`);
    }
  }
  showProcessingStatus() {
    this.showProcessingState("Processing vault...", "Building embeddings for your notes. This may take a few minutes.", false);
    const processingEl = this.resultsEl.querySelector(".embeddings-view-processing");
    if (processingEl) {
      const progressEl = processingEl.createDiv({ cls: "processing-progress" });
      progressEl.createDiv({
        text: "Starting...",
        cls: "systemsculpt-progress-text"
      });
      const progressBar = progressEl.createDiv({ cls: "systemsculpt-progress-bar" });
      progressBar.createDiv({ cls: "systemsculpt-progress-fill" });
    }
  }
  updateProcessingStatus(progress) {
    const progressEl = this.resultsEl.querySelector(".processing-progress");
    if (!progressEl)
      return;
    const progressText = progressEl.querySelector(".systemsculpt-progress-text");
    const progressFill = progressEl.querySelector(".systemsculpt-progress-fill");
    if (progressText) {
      progressText.textContent = progress.currentFile ? `Processing: ${progress.currentFile} (${progress.current}/${progress.total})` : `Processing: ${progress.current}/${progress.total} files`;
    }
    if (progressFill && progress.total > 0) {
      const percentage = progress.current / progress.total * 100;
      progressFill.style.width = `${percentage}%`;
      progressFill.classList.add("processing");
    }
  }
  formatDate(date) {
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    if (diff < 36e5) {
      const minutes = Math.floor(diff / 6e4);
      return `${minutes}min ago`;
    }
    if (diff < 864e5) {
      const hours = Math.floor(diff / 36e5);
      return `${hours}h ago`;
    }
    if (diff < 6048e5) {
      const days = Math.floor(diff / 864e5);
      return `${days}d ago`;
    }
    return date.toLocaleDateString();
  }
  async onClose() {
    if (this.searchTimeout) {
      window.clearTimeout(this.searchTimeout);
    }
    if (this.dragTimeout) {
      window.clearTimeout(this.dragTimeout);
    }
    if (this.contextChangeHandler) {
      document.removeEventListener("systemsculpt:context-changed", this.contextChangeHandler);
    }
  }
  hashContent(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString();
  }
  async checkFileExists(filePath, manager) {
    try {
      await manager.initialize();
      if (!manager.data)
        return false;
      return filePath in manager.data.files;
    } catch (error) {
      console.error("[EmbeddingsView] Error checking file existence:", error);
      return false;
    }
  }
  showProcessingState(title, description, showActions = true) {
    this.statusEl.empty();
    this.resultsEl.empty();
    const processingEl = this.resultsEl.createDiv({ cls: "embeddings-view-processing" });
    const iconEl = processingEl.createDiv({ cls: "processing-icon" });
    (0, import_obsidian88.setIcon)(iconEl, "database");
    processingEl.createDiv({
      text: title,
      cls: "processing-title"
    });
    processingEl.createDiv({
      text: description,
      cls: "processing-description"
    });
    if (showActions) {
      const actionsEl = processingEl.createDiv({ cls: "processing-actions" });
      const startBtn = actionsEl.createEl("button", {
        text: "Start Processing",
        cls: "mod-cta"
      });
      startBtn.addEventListener("click", async () => {
        await this.startProcessing();
      });
      const settingsBtn = actionsEl.createEl("button", {
        text: "Settings",
        cls: "mod-muted"
      });
      settingsBtn.addEventListener("click", () => {
        this.app.setting.open();
        this.app.setting.openTabById(this.plugin.manifest.id);
      });
    }
  }
};

// src/core/plugin/views.ts
var ViewManager = class {
  constructor(plugin, app) {
    this.isInitialized = false;
    this.isInitializing = false;
    this.initPromise = null;
    this.deferredViews = new Map();
    this.initializationTimeout = 1e4;
    this.plugin = plugin;
    this.app = app;
    this.ribbonManager = new RibbonManager(plugin, app);
  }
  initialize() {
    this.registerView();
    setTimeout(() => this.ribbonManager.initialize(), 0);
    this.app.workspace.onLayoutReady(() => {
      this.initializeInBackground().catch((error) => {
        console.warn("[SystemSculpt] View initialization error:", error);
      });
    });
  }
  async initializeInBackground() {
    if (this.isInitializing || this.isInitialized)
      return;
    this.isInitializing = true;
    const startTime = performance.now();
    try {
      const leaves = this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE);
      const visibleLeaves = leaves.filter((leaf) => !leaf.view.containerEl.hidden);
      for (const leaf of visibleLeaves) {
        const view = leaf.view;
        const state = leaf.getViewState();
        if (this.isValidChatState(state)) {
          await this.restoreView(view, state.state);
        }
      }
      if (visibleLeaves.length > 0) {
        await Promise.race([
          this.initializeModels(),
          new Promise((_, reject) => setTimeout(() => reject(new Error("Models init timeout")), this.initializationTimeout))
        ]).catch((error) => {
          console.warn("[SystemSculpt] Models initialization failed:", error);
        });
      }
      this.isInitialized = true;
      for (const [id, initFn] of this.deferredViews) {
        try {
          initFn();
        } catch (error) {
          console.error(`[SystemSculpt] Failed to initialize deferred view ${id}:`, error);
        }
      }
      this.deferredViews.clear();
      const hiddenLeaves = leaves.filter((leaf) => leaf.view.containerEl.hidden);
      if (hiddenLeaves.length > 0) {
        setTimeout(() => {
          for (const leaf of hiddenLeaves) {
            const view = leaf.view;
            const state = leaf.getViewState();
            if (this.isValidChatState(state)) {
              this.restoreView(view, state.state).catch((error) => {
                console.error("[SystemSculpt] Failed to restore hidden view:", error);
              });
            }
          }
        }, 0);
      }
    } catch (error) {
      console.error("[SystemSculpt] Background initialization failed:", error);
    } finally {
      this.isInitializing = false;
    }
  }
  async restoreView(view, state) {
    var _a;
    try {
      await view.setState(state);
    } catch (error) {
      console.warn(`[SystemSculpt] Failed to restore chat ${state.chatId}:`, error);
      try {
        console.log("[SystemSculpt] Attempting fallback restoration with minimal state");
        const minimalState = {
          chatId: state.chatId,
          selectedModelId: state.selectedModelId || this.plugin.settings.selectedModelId,
          chatTitle: state.chatTitle || "Recovered Chat"
        };
        await view.setState(minimalState);
        new import_obsidian89.Notice("Chat was partially recovered due to an error", 5e3);
      } catch (fallbackError) {
        console.error("[SystemSculpt] Even fallback restoration failed:", fallbackError);
        (_a = view.leaf) == null ? void 0 : _a.detach();
      }
    }
  }
  async initializeModels() {
    try {
      const models = await this.plugin.modelService.getModels();
      return models;
    } catch (error) {
      console.warn("[SystemSculpt] Model preload failed:", error);
      return [];
    }
  }
  deferViewInitialization(id, initFn) {
    if (this.isInitialized) {
      initFn();
    } else {
      this.deferredViews.set(id, initFn);
    }
  }
  async restoreChatViews() {
    const leaves = this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE);
    if (leaves.length === 0) {
      return;
    }
    for (const leaf of leaves) {
      const view = leaf.view;
      const state = leaf.getViewState();
      if (!this.isValidChatState(state)) {
        console.warn("[SystemSculpt] Invalid chat state, skipping:", state);
        continue;
      }
      const chatState = state.state;
      try {
        await this.retrySetState(view, chatState);
      } catch (error) {
        console.warn(`[SystemSculpt] Failed to restore chat ${chatState.chatId}:`, error);
        leaf.detach();
      }
    }
  }
  isValidChatState(state) {
    var _a, _b;
    if (!((_a = state == null ? void 0 : state.state) == null ? void 0 : _a.chatId)) {
      return false;
    }
    const chatId = state.state.chatId;
    if ("messages" in state.state) {
      if (!Array.isArray(state.state.messages)) {
        state.state.messages = [];
      }
    }
    if ("systemPromptType" in state.state) {
      const validTypes = ["general-use", "concise", "agent", "custom"];
      if (!validTypes.includes((_b = state.state.systemPromptType) == null ? void 0 : _b.toLowerCase())) {
        console.warn(`[SystemSculpt] Invalid systemPromptType "${state.state.systemPromptType}" for chat ${chatId}, resetting to default`);
        state.state.systemPromptType = "general-use";
      } else {
        const normalizedType = state.state.systemPromptType.toLowerCase();
        if (normalizedType !== state.state.systemPromptType) {
          console.log(`[SystemSculpt] Normalizing systemPromptType from "${state.state.systemPromptType}" to "${normalizedType}"`);
          state.state.systemPromptType = normalizedType;
        }
      }
    }
    if (!("messages" in state.state)) {
      state.state.messages = [];
    }
    return true;
  }
  async retrySetState(view, state, maxRetries = 3) {
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 1) {
          await new Promise((resolve) => setTimeout(resolve, Math.pow(2, attempt - 1) * 1e3));
        }
        await view.setState(state);
        if (attempt > 1) {
        }
        return;
      } catch (error) {
        lastError = error;
      }
    }
    throw new Error(`Failed to restore chat after ${maxRetries} attempts: ${lastError == null ? void 0 : lastError.message}`);
  }
  registerView() {
    this.plugin.registerView(CHAT_VIEW_TYPE, (leaf) => new ChatView(leaf, this.plugin));
    this.plugin.registerView(EMBEDDINGS_VIEW_TYPE, (leaf) => new EmbeddingsView(leaf, this.plugin));
  }
  async activateEmbeddingsView() {
    const existingLeaves = this.app.workspace.getLeavesOfType(EMBEDDINGS_VIEW_TYPE);
    if (existingLeaves.length > 0) {
      this.app.workspace.revealLeaf(existingLeaves[0]);
      return existingLeaves[0].view;
    }
    const rightLeaf = this.app.workspace.getRightLeaf(false);
    if (!rightLeaf) {
      throw new Error("Failed to create right sidebar leaf");
    }
    await rightLeaf.setViewState({
      type: EMBEDDINGS_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(rightLeaf);
    return rightLeaf.view;
  }
  unloadViews() {
    this.app.workspace.detachLeavesOfType(CHAT_VIEW_TYPE);
    this.app.workspace.detachLeavesOfType(EMBEDDINGS_VIEW_TYPE);
  }
};

// src/core/plugin/commands.ts
var import_obsidian93 = __toModule(require("obsidian"));
init_StandardModelSelectionModal();
init_TitleGenerationService();

// src/modals/TemplateSelectionModal.ts
var import_obsidian90 = __toModule(require("obsidian"));
var TemplateSelectionModal = class extends import_obsidian90.Modal {
  constructor(app, plugin, onTemplateSelected) {
    super(app);
    this.templateFiles = [];
    this.isLoading = true;
    this.templatePreviews = new Map();
    this.selectedCardIndex = -1;
    this.templateCards = [];
    this.currentSearchResults = [];
    this.listeners = [];
    this.plugin = plugin;
    this.onTemplateSelected = onTemplateSelected;
  }
  registerListener(element, type, listener) {
    element.addEventListener(type, listener);
    this.listeners.push({ element, type, listener });
  }
  removeAllListeners() {
    this.listeners.forEach(({ element, type, listener }) => {
      element.removeEventListener(type, listener);
    });
    this.listeners = [];
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("systemsculpt-template-modal");
    const loadingContainer = contentEl.createDiv({
      cls: "systemsculpt-progress-overlay"
    });
    const statusContainer = loadingContainer.createDiv({
      cls: "systemsculpt-progress-status"
    });
    const statusIcon = statusContainer.createDiv({
      cls: "systemsculpt-progress-status-icon"
    });
    (0, import_obsidian90.setIcon)(statusIcon, "loader-2");
    const progressText = statusContainer.createSpan({
      text: "Loading templates..."
    });
    this.isLoading = true;
    const searchContainer = contentEl.createDiv({
      cls: "systemsculpt-search-container"
    });
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search templates...",
      cls: "systemsculpt-search-input"
    });
    this.templateGrid = contentEl.createDiv({
      cls: "systemsculpt-template-grid"
    });
    try {
      await this.loadTemplateFiles();
      if (this.templateFiles.length > 0) {
        this.isLoading = false;
        this.renderTemplates(this.templateFiles);
      }
      this.setupEventListeners();
    } catch (error) {
      console.error("[SystemSculpt] Error loading templates:", error);
      new import_obsidian90.Notice("Error loading templates", 3e3);
    } finally {
      loadingContainer.remove();
      this.searchInput.focus();
    }
  }
  async loadTemplateFiles() {
    const systemPromptsDir = this.plugin.settings.systemPromptsDirectory;
    try {
      if (this.plugin.directoryManager) {
        await this.plugin.directoryManager.ensureDirectoryByPath(systemPromptsDir);
      } else {
        await this.app.vault.createFolder(systemPromptsDir).catch(() => {
        });
      }
      const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(systemPromptsDir));
      if (files.length > 0) {
        this.templateFiles = files.sort((a, b) => a.basename.toLowerCase().localeCompare(b.basename.toLowerCase()));
        await this.loadTemplatePreviews();
        this.currentSearchResults = [...this.templateFiles];
        console.log(`[SystemSculpt] Loaded ${this.templateFiles.length} template files from ${systemPromptsDir}`);
      } else {
        new import_obsidian90.Notice("No templates found in your system prompts directory", 3e3);
        throw new Error("No templates found");
      }
    } catch (error) {
      console.error("[SystemSculpt] Error loading system prompt files:", error);
      throw error;
    }
  }
  async loadTemplatePreviews() {
    this.templatePreviews.clear();
    for (const file of this.templateFiles) {
      try {
        const content = await this.app.vault.read(file);
        const preview = content.replace(/\n/g, " ").trim().slice(0, 100);
        const previewText = preview.length < content.length ? preview + "..." : preview;
        this.templatePreviews.set(file.path, previewText);
      } catch (error) {
        console.error(`[SystemSculpt] Error loading preview for ${file.path}:`, error);
        this.templatePreviews.set(file.path, "Error loading preview");
      }
    }
  }
  setupEventListeners() {
    this.registerListener(this.searchInput, "input", () => {
      const query = this.searchInput.value.toLowerCase();
      if (!query) {
        this.currentSearchResults = [...this.templateFiles];
        this.selectedCardIndex = -1;
        this.renderTemplates(this.currentSearchResults);
        return;
      }
      const results = this.templateFiles.filter((file) => file.basename.toLowerCase().includes(query) || (this.templatePreviews.get(file.path) || "").toLowerCase().includes(query));
      this.currentSearchResults = results;
      this.selectedCardIndex = -1;
      this.renderTemplates(results);
    });
    this.registerListener(this.contentEl, "keydown", (e) => {
      if (e.key === "Tab") {
        e.preventDefault();
        if (this.templateCards.length === 0)
          return;
        if (e.shiftKey) {
          this.selectedCardIndex = this.selectedCardIndex <= 0 ? this.templateCards.length - 1 : this.selectedCardIndex - 1;
        } else {
          this.selectedCardIndex = this.selectedCardIndex >= this.templateCards.length - 1 ? 0 : this.selectedCardIndex + 1;
        }
        this.templateCards.forEach((card, i) => {
          const isSelected = i === this.selectedCardIndex;
          card.classList.toggle("systemsculpt-keyboard-selected", isSelected);
          if (isSelected) {
            card.scrollIntoView({ behavior: "smooth", block: "nearest" });
          }
        });
      } else if (e.key === "Enter" && this.selectedCardIndex >= 0 && this.templateCards.length > 0) {
        e.preventDefault();
        const selectedCard = this.templateCards[this.selectedCardIndex];
        if (selectedCard == null ? void 0 : selectedCard.dataset.filePath) {
          const file = this.templateFiles.find((f) => f.path === selectedCard.dataset.filePath);
          if (file) {
            this.handleTemplateSelection(file);
          }
        }
      }
    });
  }
  renderTemplates(templates) {
    if (!this.templateGrid)
      return;
    this.templateGrid.empty();
    this.templateCards = [];
    if (templates.length === 0) {
      const emptyState = this.templateGrid.createDiv({
        cls: "systemsculpt-template-empty"
      });
      const searchIcon = emptyState.createDiv();
      (0, import_obsidian90.setIcon)(searchIcon, "search");
      emptyState.createDiv({
        text: this.searchInput.value ? "No templates found matching your search" : "No templates found in the system prompts directory",
        cls: "systemsculpt-empty-message"
      });
      return;
    }
    const header = this.templateGrid.createDiv({
      cls: "systemsculpt-provider-header"
    });
    header.createSpan({ text: "Available Templates" });
    templates.forEach((file) => {
      const card = this.renderTemplateCard(file);
      this.templateGrid.appendChild(card);
      this.templateCards.push(card);
    });
  }
  renderTemplateCard(file) {
    var _a;
    const card = document.createElement("div");
    card.className = "systemsculpt-template-card";
    card.dataset.filePath = file.path;
    const cardContent = card.createDiv({ cls: "systemsculpt-card-content" });
    const iconContainer = cardContent.createDiv({ cls: "systemsculpt-template-icon" });
    (0, import_obsidian90.setIcon)(iconContainer, "file-text");
    const textContainer = cardContent.createDiv({ cls: "systemsculpt-card-text" });
    textContainer.createDiv({
      cls: "systemsculpt-template-title",
      text: file.basename
    });
    const preview = this.templatePreviews.get(file.path) || "Preview not available";
    textContainer.createDiv({
      cls: "systemsculpt-template-preview",
      text: preview
    });
    const meta = textContainer.createDiv({ cls: "systemsculpt-template-meta" });
    const pathInfo = meta.createDiv({ cls: "systemsculpt-template-info" });
    (0, import_obsidian90.setIcon)(pathInfo, "folder");
    pathInfo.createSpan({ text: ((_a = file.parent) == null ? void 0 : _a.path) || "Unknown location" });
    const dateInfo = meta.createDiv({ cls: "systemsculpt-template-info" });
    (0, import_obsidian90.setIcon)(dateInfo, "calendar");
    dateInfo.createSpan({
      text: file.stat ? new Date(file.stat.mtime).toLocaleString() : "Unknown date"
    });
    this.registerListener(card, "click", () => {
      this.handleTemplateSelection(file);
    });
    return card;
  }
  async handleTemplateSelection(file) {
    await this.onTemplateSelected(file);
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.removeAllListeners();
  }
};

// src/core/plugin/commands.ts
init_modelUtils();
init_debugLogger();
var CommandManager = class {
  constructor(plugin, app) {
    this.plugin = plugin;
    this.app = app;
    this.ribbonManager = new RibbonManager(plugin, app);
  }
  registerCommands() {
    this.registerToggleAudioRecorder();
    this.registerOpenChat();
    this.registerOpenChatHistory();
    this.registerOpenJanitor();
    this.registerReloadObsidian();
    this.registerOpenSettings();
    this.registerChangeChatModel();
    this.registerSetDefaultChatModel();
    this.registerChatWithFile();
    this.registerResumeChat();
    this.registerChangeChatTitle();
    this.registerOpenTemplateModal();
    this.registerOpenEmbeddingsView();
    this.registerCleanupPhantomTools();
    this.registerDebugCommands();
    this.registerEmbeddingsDatabaseCommands();
  }
  registerToggleAudioRecorder() {
    this.plugin.addCommand({
      id: "toggle-audio-recorder",
      name: "Toggle Audio Recorder",
      callback: () => {
        this.plugin.getRecorderService().toggleRecording();
      },
      hotkeys: [{ modifiers: ["Mod"], key: "r" }]
    });
  }
  registerOpenChat() {
    this.plugin.addCommand({
      id: "open-systemsculpt-chat",
      name: "Open SystemSculpt Chat",
      callback: async () => {
        await this.ribbonManager.openChatView();
      }
    });
  }
  registerOpenChatHistory() {
    this.plugin.addCommand({
      id: "open-chat-history",
      name: "Open SystemSculpt Chat History",
      callback: () => {
        this.ribbonManager.openChatHistoryModal();
      }
    });
  }
  registerOpenJanitor() {
    this.plugin.addCommand({
      id: "open-systemsculpt-janitor",
      name: "Open SystemSculpt Janitor",
      callback: () => {
        this.ribbonManager.openJanitorModal();
      }
    });
  }
  registerReloadObsidian() {
    this.plugin.addCommand({
      id: "reload-obsidian",
      name: "Reload Obsidian",
      callback: () => {
        window.location.reload();
      }
    });
  }
  registerOpenSettings() {
    this.plugin.addCommand({
      id: "open-systemsculpt-settings",
      name: "Open SystemSculpt AI Settings",
      callback: () => {
        this.app.setting.open();
        this.app.setting.openTabById(this.plugin.manifest.id);
      }
    });
  }
  registerChangeChatModel() {
    this.plugin.addCommand({
      id: "change-chat-model",
      name: "Change Chat Model (Current Chat)",
      checkCallback: (checking) => {
        const chatView = this.app.workspace.getActiveViewOfType(ChatView);
        if (!chatView) {
          if (!checking) {
            new import_obsidian93.Notice("You need to be in an active SystemSculpt chat view to use this command.", 5e3);
          }
          return false;
        }
        if (!checking) {
          (async () => {
            try {
              await this.plugin.modelService.getModels();
              const modal = new StandardModelSelectionModal({
                app: this.app,
                plugin: this.plugin,
                currentModelId: chatView.getSelectedModelId() || "",
                onSelect: async (result) => {
                  const canonicalId = ensureCanonicalId(result.modelId);
                  await chatView.setSelectedModelId(canonicalId);
                  new import_obsidian93.Notice("Model updated for this chat.", 2e3);
                }
              });
              modal.open();
            } catch (err) {
              console.error("Failed to open model selection:", err);
              new import_obsidian93.Notice("Failed to fetch available models", 1e4);
            }
          })();
        }
        return true;
      }
    });
  }
  registerSetDefaultChatModel() {
    this.plugin.addCommand({
      id: "set-default-chat-model",
      name: "Set Default Chat Model",
      callback: async () => {
        if (!this.plugin) {
          new import_obsidian93.Notice("SystemSculpt plugin not available.", 1e4);
          return;
        }
        try {
          await this.plugin.modelService.getModels();
          const modal = new StandardModelSelectionModal({
            app: this.app,
            plugin: this.plugin,
            currentModelId: this.plugin.settings.selectedModelId || "",
            onSelect: async (result) => {
              try {
                const canonicalId = ensureCanonicalId(result.modelId);
                await this.plugin.getSettingsManager().updateSettings({ selectedModelId: canonicalId });
                new import_obsidian93.Notice("Default model for new chats updated.", 3e3);
              } catch (saveError) {
                console.error("[SystemSculpt] Failed to save default model setting:", saveError);
                new import_obsidian93.Notice("Failed to save default model setting.", 1e4);
              }
            }
          });
          modal.open();
        } catch (err) {
          console.error("Failed to open default model selection:", err);
          new import_obsidian93.Notice("Failed to fetch available models", 1e4);
        }
      }
    });
  }
  registerChatWithFile() {
    this.plugin.addCommand({
      id: "chat-with-file",
      name: "Chat with File",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile)
          return false;
        const extension = activeFile.extension.toLowerCase();
        const supportedExtensions = [
          "md",
          "txt",
          "markdown",
          "pdf",
          "doc",
          "docx",
          "ppt",
          "pptx",
          "xls",
          "xlsx",
          "mp3",
          "wav",
          "m4a",
          "ogg",
          "webm",
          "jpg",
          "jpeg",
          "png",
          "gif",
          "webp",
          "svg"
        ];
        if (!supportedExtensions.includes(extension))
          return false;
        if (!checking) {
          const leaf = this.app.workspace.getLeaf("tab");
          const view = new ChatView(leaf, this.plugin);
          leaf.open(view).then(async () => {
            await new Promise((resolve) => setTimeout(resolve, 50));
            this.app.workspace.setActiveLeaf(leaf, { focus: true });
            await view.addFileToContext(activeFile);
            view.focusInput();
          });
        }
        return true;
      }
    });
  }
  registerResumeChat() {
    this.plugin.addCommand({
      id: "resume-chat-from-history",
      name: "Resume Chat from Current History File",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile || !this.plugin.resumeChatService)
          return false;
        const isChatHistory = this.plugin.resumeChatService.isChatHistoryFile(activeFile);
        if (!checking && isChatHistory) {
          const chatId = this.plugin.resumeChatService.extractChatId(activeFile);
          const modelId = this.plugin.resumeChatService.getModelFromFile(activeFile);
          if (chatId) {
            this.plugin.resumeChatService.openChat(chatId, modelId);
          } else {
            new import_obsidian93.Notice("Could not extract chat ID from this file.", 5e3);
          }
        }
        return isChatHistory;
      }
    });
  }
  registerChangeChatTitle() {
    this.plugin.addCommand({
      id: "change-chat-title",
      name: "Change/Generate Title",
      checkCallback: (checking) => {
        const chatView = this.app.workspace.getActiveViewOfType(ChatView);
        if (chatView) {
          if (chatView.messages.length === 0)
            return false;
          if (!checking) {
            (async () => {
              if (this.plugin.settings.automaticTitleGeneration) {
                const { TitleGenerationNotice: TitleGenerationNotice2 } = await Promise.resolve().then(() => (init_TitleGenerationModal(), TitleGenerationModal_exports));
                const notice = new TitleGenerationNotice2();
                notice.updateProgress(0, "Analyzing content...");
                try {
                  const titleService = TitleGenerationService.getInstance(this.plugin);
                  const title = await titleService.generateTitle(chatView.getMessages(), (title2) => {
                  }, (progress, status) => {
                    notice.updateProgress(progress, status);
                  });
                  if (title && title !== chatView.getChatTitle()) {
                    await chatView.setTitle(title);
                    notice.showCompletion("Chat title updated successfully!");
                  } else {
                    notice.hide();
                  }
                } catch (error) {
                  console.error("Error generating title:", error);
                  const errorMessage = error instanceof Error ? error.message : String(error);
                  notice.showError(`Failed to generate title: ${errorMessage}`);
                }
              } else {
                const { showTitleGenerationModal: showTitleGenerationModal2 } = await Promise.resolve().then(() => (init_TitleGenerationModal(), TitleGenerationModal_exports));
                const newTitle = await showTitleGenerationModal2(this.app, this.plugin, chatView.getChatTitle(), chatView.getMessages());
                if (newTitle !== null && newTitle !== chatView.getChatTitle()) {
                  await chatView.setTitle(newTitle);
                  new import_obsidian93.Notice("Chat title updated", 3e3);
                }
              }
            })();
          }
          return true;
        }
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          if (!checking) {
            new import_obsidian93.Notice("You need to be within a note or chat view to change the title.", 5e3);
          }
          return false;
        }
        if (activeFile.extension !== "md") {
          if (!checking) {
            new import_obsidian93.Notice("Title generation is only available for markdown files.", 5e3);
          }
          return false;
        }
        if (!checking) {
          (async () => {
            if (this.plugin.settings.automaticTitleGeneration) {
              const { TitleGenerationNotice: TitleGenerationNotice2 } = await Promise.resolve().then(() => (init_TitleGenerationModal(), TitleGenerationModal_exports));
              const notice = new TitleGenerationNotice2();
              notice.updateProgress(0, "Analyzing content...");
              try {
                const titleService = TitleGenerationService.getInstance(this.plugin);
                const title = await titleService.generateTitle(activeFile, (title2) => {
                }, (progress, status) => {
                  notice.updateProgress(progress, status);
                });
                if (title && title !== activeFile.basename) {
                  const newPath = activeFile.path.replace(activeFile.basename, title);
                  try {
                    await this.app.fileManager.renameFile(activeFile, newPath);
                    notice.showCompletion("Note title updated successfully!");
                  } catch (error) {
                    console.error("Failed to rename file:", error);
                    const errorMessage = error instanceof Error ? error.message : String(error);
                    notice.showError(`Failed to rename file: ${errorMessage}`);
                  }
                } else {
                  notice.hide();
                }
              } catch (error) {
                console.error("Error generating title:", error);
                const errorMessage = error instanceof Error ? error.message : String(error);
                notice.showError(`Failed to generate title: ${errorMessage}`);
              }
            } else {
              const { showTitleGenerationModal: showTitleGenerationModal2 } = await Promise.resolve().then(() => (init_TitleGenerationModal(), TitleGenerationModal_exports));
              const newTitle = await showTitleGenerationModal2(this.app, this.plugin, activeFile.basename, activeFile);
              if (newTitle !== null && newTitle !== activeFile.basename) {
                const newPath = activeFile.path.replace(activeFile.basename, newTitle);
                try {
                  await this.app.fileManager.renameFile(activeFile, newPath);
                  new import_obsidian93.Notice("Note title updated", 3e3);
                } catch (error) {
                  console.error("Failed to rename file:", error);
                  new import_obsidian93.Notice(`Failed to rename file: ${error}`, 1e4);
                }
              }
            }
          })();
        }
        return true;
      },
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "t" }]
    });
  }
  registerOpenTemplateModal() {
    this.plugin.addCommand({
      id: "open-template-modal",
      name: "Open Template Selection",
      checkCallback: (checking) => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian93.MarkdownView);
        if (!activeView)
          return false;
        if (!checking) {
          const editor = activeView.editor;
          const modal = new TemplateSelectionModal(this.app, this.plugin, async (file) => {
            var _a;
            try {
              const templateContent = await this.app.vault.read(file);
              const cursor = editor.getCursor();
              editor.replaceRange(templateContent, cursor);
              const lines = templateContent.split("\n");
              const endPosition = {
                line: cursor.line + lines.length - 1,
                ch: ((_a = lines[lines.length - 1]) == null ? void 0 : _a.length) || 0
              };
              editor.setCursor(endPosition);
              activeView.editor.focus();
              new import_obsidian93.Notice(`Template "${file.basename}" inserted`, 3e3);
            } catch (error) {
              console.error("[SystemSculpt] Error inserting template:", error);
              new import_obsidian93.Notice("Error inserting template", 1e4);
            }
          });
          modal.open();
        }
        return true;
      }
    });
  }
  registerOpenEmbeddingsView() {
    this.plugin.addCommand({
      id: "open-embeddings-view",
      name: "Open Similar Notes Panel",
      callback: async () => {
        try {
          await this.plugin.getViewManager().activateEmbeddingsView();
        } catch (error) {
          console.error("[SystemSculpt] Error opening embeddings view:", error);
          new import_obsidian93.Notice(`Error opening similar notes panel: ${error.message}`);
        }
      }
    });
  }
  registerCleanupPhantomTools() {
    this.plugin.addCommand({
      id: "cleanup-phantom-tools",
      name: "Clean Up Phantom MCP Tools",
      callback: async () => {
        try {
          new import_obsidian93.Notice("Cleaning up phantom MCP tools...", 3e3);
          await this.plugin.getSettingsManager().cleanupPhantomToolsManually();
          new import_obsidian93.Notice("Phantom tool cleanup completed! Check console for details.", 5e3);
        } catch (error) {
          console.error("[SystemSculpt] Error during phantom tool cleanup:", error);
          new import_obsidian93.Notice("Failed to clean up phantom tools. Check console for details.", 1e4);
        }
      }
    });
  }
  registerDebugCommands() {
    this.plugin.addCommand({
      id: "clear-debug-log",
      name: "Clear SystemSculpt Debug Log",
      callback: async () => {
        const logger = DebugLogger.getInstance();
        if (logger) {
          await logger.clearLog();
          new import_obsidian93.Notice("Debug log cleared");
        } else {
          new import_obsidian93.Notice("Debug logger not initialized");
        }
      }
    });
    this.plugin.addCommand({
      id: "toggle-debug-logging",
      name: "Toggle SystemSculpt Debug Logging",
      callback: () => {
        const logger = DebugLogger.getInstance();
        if (logger) {
          const currentEnabled = true;
          logger.setEnabled(!currentEnabled);
          new import_obsidian93.Notice(`Debug logging ${!currentEnabled ? "enabled" : "disabled"}`);
        } else {
          new import_obsidian93.Notice("Debug logger not initialized");
        }
      }
    });
    this.plugin.addCommand({
      id: "export-mobile-debug-logs",
      name: "Export Mobile Debug Logs",
      callback: async () => {
        const logger = DebugLogger.getInstance();
        if (logger) {
          try {
            const exportPath = await logger.exportMobileLogs();
            new import_obsidian93.Notice(`Debug logs exported to: ${exportPath}`, 8e3);
            if (this.app.isMobile) {
              const file = this.app.vault.getAbstractFileByPath(exportPath);
              if (file) {
                await this.app.workspace.openLinkText(exportPath, "", true);
                new import_obsidian93.Notice("Export file opened. Use Share button to send logs.", 5e3);
              }
            }
          } catch (error) {
            console.error("[SystemSculpt] Error exporting mobile logs:", error);
            new import_obsidian93.Notice(`Error exporting logs: ${error}`, 1e4);
          }
        } else {
          new import_obsidian93.Notice("Debug logger not initialized");
        }
      }
    });
    this.plugin.addCommand({
      id: "open-mobile-debugging-guide",
      name: "Open Mobile Debugging Guide",
      callback: async () => {
        try {
          const guidePath = "docs/mobile-debugging.md";
          const file = this.app.vault.getAbstractFileByPath(guidePath);
          if (file) {
            await this.app.workspace.openLinkText(guidePath, "", true);
          } else {
            const guideContent = this.getDebuggingGuideContent();
            await this.app.vault.create(guidePath, guideContent);
            await this.app.workspace.openLinkText(guidePath, "", true);
            new import_obsidian93.Notice("Mobile debugging guide created and opened", 4e3);
          }
        } catch (error) {
          console.error("[SystemSculpt] Error opening mobile debugging guide:", error);
          new import_obsidian93.Notice(`Error opening guide: ${error}`, 1e4);
        }
      }
    });
  }
  getDebuggingGuideContent() {
    return `# SystemSculpt Mobile Debugging Guide

## Quick Start for Mobile Debugging

### 1. Export Logs on Mobile
1. Open Command Palette (\`Cmd/Ctrl + P\`)
2. Type "Export Mobile Debug Logs"
3. Run the command
4. A new file will be created and opened automatically
5. Use the Share button in Obsidian to send the file

### 2. Alternative Ways to Access Logs

#### Method A: Direct File Access
- Log file location: \`systemsculpt-debug.md\` (in vault root)
- Export files: \`systemsculpt-mobile-export-[timestamp].md\`

#### Method B: Console Logs (Development Mode)
- If you have Obsidian in developer mode, console logs are captured automatically
- Use "Export Mobile Debug Logs" to get all console output in a sharable format

## Debugging Commands Available

### Export Mobile Debug Logs
- **Command:** "Export Mobile Debug Logs"
- **Purpose:** Creates a comprehensive export file with all debug information
- **Mobile-friendly:** Automatically opens the file and shows sharing instructions

### Test Mobile Error Logging
- **Command:** "Test Mobile Error Logging" 
- **Purpose:** Creates a test error to verify logging is working
- **Use when:** Setting up debugging or testing the logging system

### Clear Debug Logs
- **Command:** "Clear SystemSculpt Debug Log"
- **Purpose:** Clears all debug logs to start fresh
- **Use when:** Logs are getting too large or you want to focus on new issues

### Open Mobile Debugging Guide
- **Command:** "Open Mobile Debugging Guide"
- **Purpose:** Opens this guide
- **Use when:** You need reference for debugging on mobile

## How to Share Logs with Developer

### From Mobile Device
1. Run "Export Mobile Debug Logs" command
2. File opens automatically
3. Tap Share button in Obsidian
4. Send via email, messaging app, or copy to clipboard

### From Desktop (Synced)
1. Logs sync automatically to all devices
2. Open the export file on desktop
3. Copy contents or share file directly

---

*This guide is specifically for SystemSculpt plugin mobile debugging. For complete documentation, see the full guide in the docs folder.*`;
  }
  registerEmbeddingsDatabaseCommands() {
    this.plugin.addCommand({
      id: "embeddings-database-stats",
      name: "Show Embeddings Database Statistics (Debug)",
      checkCallback: (checking) => {
        const embeddingsEnabled = this.plugin.settings.embeddingsEnabled;
        if (!embeddingsEnabled)
          return false;
        if (!checking) {
          this.showEmbeddingsDatabaseStats();
        }
        return true;
      }
    });
  }
  async showEmbeddingsDatabaseStats() {
    try {
      const { Notice: Notice65 } = require("obsidian");
      const embeddingsManager = this.plugin.getOrCreateEmbeddingsManager();
      if (!embeddingsManager) {
        new Notice65("Embeddings manager not available", 5e3);
        return;
      }
      const isIndexing = embeddingsManager.isIndexing();
      const progress = embeddingsManager.getProgress();
      const isEmpty = await embeddingsManager.isEmpty();
      const statsText = [
        `Embeddings System Statistics:`,
        `Status: ${isIndexing ? "Indexing" : "Idle"}`,
        `Progress: ${progress.current}/${progress.total}`,
        `Current File: ${progress.currentFile || "None"}`,
        `Data: ${isEmpty ? "Empty" : "Contains embeddings"}`
      ].filter(Boolean).join("\n");
      console.log("[EmbeddingsStats]", { isIndexing, progress, isEmpty });
      new Notice65(statsText, 8e3);
    } catch (error) {
      console.error("[Embeddings] Error getting database stats:", error);
      const { Notice: Notice65 } = require("obsidian");
      new Notice65(`Error getting database stats: ${error.message}`, 5e3);
    }
  }
};

// src/services/providers/adapters/BaseProviderAdapter.ts
var import_obsidian94 = __toModule(require("obsidian"));
var BaseProviderAdapter = class {
  constructor(provider) {
    this.provider = provider;
  }
  async makeRequest(url, options) {
    const result = await (0, import_obsidian94.requestUrl)({
      url,
      method: options.method,
      headers: options.headers,
      body: options.body,
      throw: false
    });
    if (!result.status || result.status >= 400) {
      throw {
        status: result.status || 500,
        data: result.json || {},
        text: result.text
      };
    }
    return result;
  }
};

// src/services/providers/adapters/OpenAICompatibleAdapter.ts
init_modelUtils();
init_debugLogger();
var OpenAICompatibleAdapter = class extends BaseProviderAdapter {
  getCapabilities() {
    return {
      supportsModelsEndpoint: true,
      supportsStreaming: true,
      supportsTools: true
    };
  }
  async getModels() {
    const headers = this.getHeaders();
    const endpoint = this.getModelsEndpoint();
    try {
      const result = await this.makeRequest(endpoint, {
        method: "GET",
        headers
      });
      const models = (result.json.data || []).filter((model) => !model.id.toLowerCase().includes("whisper")).map((model) => ({
        id: model.id,
        name: model.id,
        contextWindow: model.context_window,
        supportsStreaming: true,
        supportsTools: model.id.includes("gpt") || model.id.includes("claude")
      }));
      return models;
    } catch (error) {
      throw this.handleError(error);
    }
  }
  async validateApiKey() {
    if (this.provider.endpoint.includes("openrouter.ai")) {
      await this.validateOpenRouterKey();
      return;
    }
    try {
      await this.getModels();
    } catch (error) {
      if (error.message.includes("401") || error.message.includes("Invalid API key")) {
        throw new Error("Invalid API key. Please check your API key and try again.");
      }
      throw error;
    }
  }
  async validateOpenRouterKey() {
    var _a, _b, _c, _d, _e;
    const headers = this.getHeaders();
    try {
      const result = await this.makeRequest("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers,
        body: JSON.stringify({
          messages: [{ role: "user", content: "Test" }],
          model: "mistralai/mistral-7b-instruct",
          max_tokens: 1
        })
      });
    } catch (error) {
      if (error.status === 401) {
        throw new Error("Invalid API key. Please check your OpenRouter API key and try again.");
      } else if (error.status === 402 && ((_c = (_b = (_a = error.data) == null ? void 0 : _a.error) == null ? void 0 : _b.message) == null ? void 0 : _c.includes("credit"))) {
        throw new Error("Insufficient credits. Please add credits to your OpenRouter account.");
      } else if (error.status === 429) {
        throw new Error("Rate limit exceeded. Please try again in a few minutes.");
      }
      throw new Error(`API key validation failed: ${((_e = (_d = error.data) == null ? void 0 : _d.error) == null ? void 0 : _e.message) || `HTTP ${error.status}`}`);
    }
  }
  getHeaders() {
    const headers = {
      "Content-Type": "application/json"
    };
    if (this.provider.endpoint.includes("openrouter.ai")) {
      headers["Authorization"] = `Bearer ${this.provider.apiKey}`;
      headers["HTTP-Referer"] = "https://systemsculpt.com";
      headers["X-Title"] = "SystemSculpt AI";
    } else if (this.provider.endpoint.includes("openai.com")) {
      headers["Authorization"] = `Bearer ${this.provider.apiKey}`;
    } else {
      headers["Authorization"] = `Bearer ${this.provider.apiKey}`;
    }
    return headers;
  }
  transformMessages(messages) {
    const transformedMessages = messages.map((msg) => {
      const mappedMessage = {
        role: msg.role,
        ...msg.tool_call_id && { tool_call_id: msg.tool_call_id },
        ...msg.name && { name: msg.name },
        ...msg.tool_calls && { tool_calls: msg.tool_calls }
      };
      if (msg.content !== null) {
        mappedMessage.content = msg.content;
      }
      return mappedMessage;
    });
    return { messages: transformedMessages };
  }
  buildRequestBody(messages, modelId, temperature, mcpTools, streaming = true) {
    const { messages: transformedMessages } = this.transformMessages(messages);
    const requestBody = {
      model: modelId,
      messages: transformedMessages,
      stream: streaming
    };
    if (!isReasoningModel(modelId)) {
      requestBody.temperature = temperature;
    } else {
      const logger = DebugLogger.getInstance();
      logger == null ? void 0 : logger.log(`[SystemSculpt] Excluding temperature parameter for reasoning model: ${modelId}`);
    }
    if (mcpTools && mcpTools.length > 0) {
      const validTools = this.validateTools(mcpTools);
      if (validTools.length > 0) {
        const isO4Mini = modelId.toLowerCase().includes("o4-mini") || modelId.toLowerCase().includes("o4 mini");
        if (isO4Mini && this.provider.endpoint.includes("openrouter.ai")) {
          requestBody.tools = validTools.map((tool) => ({
            type: tool.type || "function",
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters || {}
          }));
        } else {
          requestBody.tools = validTools;
        }
      }
    }
    if (this.provider.endpoint.includes("openrouter.ai")) {
      requestBody.include_reasoning = true;
    }
    return requestBody;
  }
  validateTools(mcpTools) {
    return mcpTools.filter((tool) => {
      if (!tool || typeof tool !== "object") {
        console.warn("[SystemSculpt] Invalid tool object:", tool);
        return false;
      }
      if (!tool.function || typeof tool.function !== "object") {
        console.warn("[SystemSculpt] Tool missing function property:", tool);
        return false;
      }
      if (!tool.function.name || typeof tool.function.name !== "string") {
        console.warn("[SystemSculpt] Tool missing or invalid function.name:", tool);
        return false;
      }
      return true;
    });
  }
  getChatEndpoint() {
    const baseUrl = this.provider.endpoint.trim().replace(/\/$/, "");
    if (baseUrl.endsWith("/v1")) {
      return `${baseUrl}/chat/completions`;
    } else if (baseUrl.endsWith("/chat/completions")) {
      return baseUrl;
    } else {
      return `${baseUrl}/v1/chat/completions`;
    }
  }
  getModelsEndpoint() {
    const baseUrl = this.provider.endpoint.trim().replace(/\/$/, "");
    if (baseUrl.endsWith("/v1")) {
      return `${baseUrl}/models`;
    } else {
      return `${baseUrl}/v1/models`;
    }
  }
  async transformStreamResponse(response, isMobile) {
    return {
      stream: response.body,
      headers: {
        "Content-Type": "text/event-stream"
      }
    };
  }
  handleError(error) {
    var _a, _b;
    if (error.status === 401) {
      return new Error("Invalid API key. Please check your API key and try again.");
    } else if (error.status === 403) {
      return new Error("Access denied. Please verify your API key has the correct permissions.");
    } else if (error.status === 404) {
      return new Error("API endpoint not found. Please check the URL and try again.");
    } else if (error.status === 429) {
      return new Error("Rate limit exceeded. Please try again later.");
    }
    return new Error(((_b = (_a = error.data) == null ? void 0 : _a.error) == null ? void 0 : _b.message) || error.message || `HTTP error: ${error.status || "unknown"}`);
  }
};

// src/constants/anthropic.ts
var ANTHROPIC_API_BASE_URL = "https://api.anthropic.com";
var ANTHROPIC_API_VERSION = "2023-06-01";
var ANTHROPIC_MODELS = [
  {
    id: "claude-opus-4-20250514",
    name: "Claude Opus 4",
    contextWindow: 2e5,
    capabilities: ["text", "vision", "tools", "extended-thinking"],
    supportsStreaming: true,
    supportsTools: true
  },
  {
    id: "claude-sonnet-4-20250514",
    name: "Claude Sonnet 4",
    contextWindow: 2e5,
    capabilities: ["text", "vision", "tools", "extended-thinking"],
    supportsStreaming: true,
    supportsTools: true
  },
  {
    id: "claude-3-7-sonnet-20250219",
    name: "Claude Sonnet 3.7",
    contextWindow: 2e5,
    capabilities: ["text", "vision", "tools", "early-extended-thinking"],
    supportsStreaming: true,
    supportsTools: true
  },
  {
    id: "claude-3-5-haiku-20241022",
    name: "Claude Haiku 3.5",
    contextWindow: 2e5,
    capabilities: ["text", "vision", "tools"],
    supportsStreaming: true,
    supportsTools: true
  },
  {
    id: "claude-3-5-sonnet-20241022",
    name: "Claude Sonnet 3.5",
    contextWindow: 2e5,
    capabilities: ["text", "vision", "tools"],
    supportsStreaming: true,
    supportsTools: true
  },
  {
    id: "claude-3-opus-20240229",
    name: "Claude 3 Opus",
    contextWindow: 2e5,
    capabilities: ["text", "vision", "tools"],
    supportsStreaming: true,
    supportsTools: true
  },
  {
    id: "claude-3-sonnet-20240229",
    name: "Claude 3 Sonnet",
    contextWindow: 2e5,
    capabilities: ["text", "vision", "tools"],
    supportsStreaming: true,
    supportsTools: true
  },
  {
    id: "claude-3-haiku-20240307",
    name: "Claude 3 Haiku",
    contextWindow: 2e5,
    capabilities: ["text", "vision", "tools"],
    supportsStreaming: true,
    supportsTools: true
  }
];
var ANTHROPIC_STREAM_EVENTS = {
  MESSAGE_START: "message_start",
  CONTENT_BLOCK_START: "content_block_start",
  CONTENT_BLOCK_DELTA: "content_block_delta",
  CONTENT_BLOCK_STOP: "content_block_stop",
  MESSAGE_DELTA: "message_delta",
  MESSAGE_STOP: "message_stop",
  PING: "ping",
  ERROR: "error"
};
function isAnthropicEndpoint(endpoint) {
  return endpoint.toLowerCase().includes("anthropic.com") || endpoint.toLowerCase().includes("claude.ai");
}
function correctAnthropicEndpoint(endpoint) {
  const original = endpoint.trim();
  const lower = original.toLowerCase();
  if (lower.includes("api.anthropic.com")) {
    if (original === ANTHROPIC_API_BASE_URL || original === `${ANTHROPIC_API_BASE_URL}/v1` || original === `${ANTHROPIC_API_BASE_URL}/`) {
      return {
        correctedEndpoint: original,
        wasCorrected: false,
        originalEndpoint: original
      };
    }
    return {
      correctedEndpoint: ANTHROPIC_API_BASE_URL,
      wasCorrected: true,
      originalEndpoint: original
    };
  }
  return {
    correctedEndpoint: original,
    wasCorrected: false,
    originalEndpoint: original
  };
}
function isCorrectableAnthropicEndpoint(endpoint) {
  return endpoint.toLowerCase().includes("api.anthropic.com");
}

// src/services/providers/adapters/AnthropicAdapter.ts
var AnthropicAdapter = class extends BaseProviderAdapter {
  constructor(provider, plugin) {
    super(provider);
    this.plugin = plugin;
  }
  getCapabilities() {
    return {
      supportsModelsEndpoint: false,
      supportsStreaming: true,
      supportsTools: true,
      requiresApiVersion: ANTHROPIC_API_VERSION
    };
  }
  async getModels() {
    return ANTHROPIC_MODELS.map((model) => ({
      id: model.id,
      name: model.name,
      contextWindow: model.contextWindow,
      capabilities: model.capabilities,
      supportsStreaming: model.supportsStreaming,
      supportsTools: model.supportsTools
    }));
  }
  async validateApiKey() {
    const headers = this.getHeaders();
    try {
      await this.makeRequest(this.getChatEndpoint(), {
        method: "POST",
        headers,
        body: JSON.stringify({
          model: "claude-3-haiku-20240307",
          messages: [{ role: "user", content: "Hi" }],
          max_tokens: 1
        })
      });
    } catch (error) {
      throw this.handleError(error);
    }
  }
  getHeaders() {
    return {
      "Content-Type": "application/json",
      "x-api-key": this.provider.apiKey,
      "anthropic-version": ANTHROPIC_API_VERSION
    };
  }
  transformMessages(messages) {
    let systemPrompt = "";
    const anthropicMessages = [];
    for (const msg of messages) {
      if (msg.role === "system") {
        systemPrompt = typeof msg.content === "string" ? msg.content : "";
      } else if (msg.role === "tool") {
        let toolContent;
        if (typeof msg.content === "string") {
          toolContent = msg.content;
        } else if (Array.isArray(msg.content)) {
          toolContent = JSON.stringify(msg.content);
        } else {
          toolContent = "";
        }
        if (!toolContent || toolContent.trim() === "") {
          toolContent = JSON.stringify({
            result: "Tool executed successfully but returned no content",
            status: "completed"
          });
          console.warn(`[AnthropicAdapter] Tool message had empty content for tool_call_id: ${msg.tool_call_id}, using default response`);
        }
        anthropicMessages.push({
          role: "user",
          content: [
            {
              type: "tool_result",
              tool_use_id: msg.tool_call_id,
              content: toolContent
            }
          ]
        });
      } else if (msg.role === "assistant" && msg.tool_calls && msg.tool_calls.length > 0) {
        const toolUseBlocks = msg.tool_calls.map((toolCall) => {
          var _a, _b;
          return {
            type: "tool_use",
            id: toolCall.id,
            name: ((_a = toolCall.function) == null ? void 0 : _a.name) || toolCall.name,
            input: ((_b = toolCall.function) == null ? void 0 : _b.arguments) ? JSON.parse(toolCall.function.arguments) : {}
          };
        });
        const content = [];
        if (msg.content) {
          content.push({ type: "text", text: msg.content });
        }
        content.push(...toolUseBlocks);
        anthropicMessages.push({
          role: "assistant",
          content
        });
      } else {
        const messageContent = msg.content || "";
        if (!messageContent && msg.role !== "assistant") {
          console.warn(`[AnthropicAdapter] ${msg.role} message has empty content, this may cause API errors`);
        }
        anthropicMessages.push({
          role: msg.role,
          content: messageContent
        });
      }
    }
    return { messages: anthropicMessages, systemPrompt };
  }
  buildRequestBody(messages, modelId, temperature, mcpTools, streaming = true) {
    const { messages: anthropicMessages, systemPrompt } = this.transformMessages(messages);
    const requestBody = {
      model: modelId,
      messages: anthropicMessages,
      stream: streaming,
      temperature,
      max_tokens: 4096
    };
    if (systemPrompt) {
      requestBody.system = systemPrompt;
    }
    if (mcpTools && mcpTools.length > 0) {
      requestBody.tools = mcpTools.map((tool) => ({
        name: tool.function.name,
        description: tool.function.description || "",
        input_schema: tool.function.parameters || {}
      }));
    }
    return requestBody;
  }
  getChatEndpoint() {
    const { correctedEndpoint, wasCorrected, originalEndpoint } = correctAnthropicEndpoint(this.provider.endpoint);
    if (wasCorrected) {
      console.log(`[SystemSculpt] Auto-corrected Anthropic endpoint: "${originalEndpoint}" \u2192 "${correctedEndpoint}"`);
      this.showEndpointCorrectionNotice(originalEndpoint, correctedEndpoint);
      this.updateProviderEndpointInSettings(correctedEndpoint);
    }
    const baseEndpoint = correctedEndpoint.trim().replace(/\/$/, "").replace(/\/v1\/?$/, "");
    return `${baseEndpoint}/v1/messages`;
  }
  async updateProviderEndpointInSettings(correctedEndpoint) {
    if (!this.plugin) {
      console.warn("[SystemSculpt] Cannot update provider settings - plugin instance not available");
      return;
    }
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const providerIndex = settings.customProviders.findIndex((p) => p.id === this.provider.id);
      if (providerIndex !== -1) {
        const updatedProviders = [...settings.customProviders];
        updatedProviders[providerIndex] = {
          ...updatedProviders[providerIndex],
          endpoint: correctedEndpoint
        };
        await this.plugin.getSettingsManager().updateSettings({
          customProviders: updatedProviders
        });
        console.log(`[SystemSculpt] Successfully updated provider '${this.provider.name}' endpoint in settings to: ${correctedEndpoint}`);
      } else {
        console.warn(`[SystemSculpt] Could not find provider '${this.provider.id}' in settings to update endpoint`);
      }
    } catch (error) {
      console.error("[SystemSculpt] Failed to update provider endpoint in settings:", error);
    }
  }
  async showEndpointCorrectionNotice(originalEndpoint, correctedEndpoint) {
    var _a;
    try {
      const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
      const message = `\u2705 Auto-corrected Anthropic endpoint and updated your settings:

"${originalEndpoint}" \u2192 "${correctedEndpoint}"

Your connection should now work properly!`;
      if ((_a = this.plugin) == null ? void 0 : _a.app) {
        showNoticeWhenReady2(this.plugin.app, message, { type: "info", duration: 8e3 });
      } else {
        console.info(`[SystemSculpt] Endpoint correction notice: ${message}`);
      }
    } catch (error) {
      console.info(`[SystemSculpt] Auto-corrected Anthropic endpoint: "${originalEndpoint}" \u2192 "${correctedEndpoint}"`);
    }
  }
  async transformStreamResponse(response, isMobile) {
    return this.transformNonStreamingResponse(response);
  }
  async transformNonStreamingResponse(response) {
    const responseData = await response.json();
    const stream = new ReadableStream({
      start(controller) {
        const messageId = responseData.id || `chatcmpl-${Date.now()}`;
        const model = responseData.model || "anthropic-model";
        const created = Math.floor(Date.now() / 1e3);
        if (responseData.content && responseData.content.length > 0) {
          for (const block of responseData.content) {
            if (block.type === "text") {
              const textChunk = {
                id: messageId,
                object: "chat.completion.chunk",
                created,
                model,
                choices: [{
                  index: 0,
                  delta: { content: block.text },
                  finish_reason: null
                }]
              };
              controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(textChunk)}

`));
            } else if (block.type === "tool_use") {
              const toolChunk = {
                id: messageId,
                object: "chat.completion.chunk",
                created,
                model,
                choices: [{
                  index: 0,
                  delta: {
                    tool_calls: [{
                      index: 0,
                      id: block.id,
                      type: "function",
                      function: {
                        name: block.name,
                        arguments: JSON.stringify(block.input || {})
                      }
                    }]
                  },
                  finish_reason: null
                }]
              };
              controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(toolChunk)}

`));
            }
          }
          let finishReason = "stop";
          if (responseData.stop_reason === "tool_use") {
            finishReason = "tool_calls";
          } else if (responseData.stop_reason === "max_tokens") {
            finishReason = "length";
          }
          const doneChunk = {
            id: messageId,
            object: "chat.completion.chunk",
            created,
            model,
            choices: [{
              index: 0,
              delta: {},
              finish_reason: finishReason
            }]
          };
          controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(doneChunk)}

`));
        }
        controller.enqueue(new TextEncoder().encode("data: [DONE]\n\n"));
        controller.close();
      }
    });
    return {
      stream,
      headers: {
        "Content-Type": "text/event-stream"
      }
    };
  }
  createTransformedStream(originalBody) {
    return new ReadableStream({
      async start(controller) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        const reader = originalBody.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let messageId = "";
        let modelName = "";
        let currentToolCallId = "";
        let currentToolName = "";
        let accumulatedToolInput = "";
        let isInToolUse = false;
        let isInThinking = false;
        let accumulatedThinkingText = "";
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done)
              break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.trim() === "")
                continue;
              if (line.startsWith("event: ")) {
                continue;
              } else if (line.startsWith("data: ")) {
                const data = line.substring(6).trim();
                if (!data)
                  continue;
                try {
                  const parsed = JSON.parse(data);
                  switch (parsed.type) {
                    case ANTHROPIC_STREAM_EVENTS.MESSAGE_START:
                      messageId = ((_a = parsed.message) == null ? void 0 : _a.id) || `chatcmpl-${Date.now()}`;
                      modelName = ((_b = parsed.message) == null ? void 0 : _b.model) || "anthropic-model";
                      break;
                    case ANTHROPIC_STREAM_EVENTS.CONTENT_BLOCK_START:
                      if (((_c = parsed.content_block) == null ? void 0 : _c.type) === "tool_use") {
                        isInToolUse = true;
                        currentToolCallId = parsed.content_block.id;
                        currentToolName = parsed.content_block.name;
                        accumulatedToolInput = "";
                        const toolStartChunk = {
                          id: messageId,
                          object: "chat.completion.chunk",
                          created: Math.floor(Date.now() / 1e3),
                          model: modelName,
                          choices: [{
                            index: 0,
                            delta: {
                              tool_calls: [{
                                index: 0,
                                id: currentToolCallId,
                                type: "function",
                                function: {
                                  name: currentToolName,
                                  arguments: ""
                                }
                              }]
                            },
                            finish_reason: null
                          }]
                        };
                        controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(toolStartChunk)}

`));
                      } else if (((_d = parsed.content_block) == null ? void 0 : _d.type) === "thinking") {
                        isInThinking = true;
                        accumulatedThinkingText = "";
                      }
                      break;
                    case ANTHROPIC_STREAM_EVENTS.CONTENT_BLOCK_DELTA:
                      if (isInToolUse && ((_e = parsed.delta) == null ? void 0 : _e.type) === "input_json_delta") {
                        accumulatedToolInput += parsed.delta.partial_json || "";
                        const toolDeltaChunk = {
                          id: messageId,
                          object: "chat.completion.chunk",
                          created: Math.floor(Date.now() / 1e3),
                          model: modelName,
                          choices: [{
                            index: 0,
                            delta: {
                              tool_calls: [{
                                index: 0,
                                function: {
                                  arguments: parsed.delta.partial_json || ""
                                }
                              }]
                            },
                            finish_reason: null
                          }]
                        };
                        controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(toolDeltaChunk)}

`));
                      } else if (isInThinking && ((_f = parsed.delta) == null ? void 0 : _f.type) === "thinking_delta") {
                        accumulatedThinkingText += parsed.delta.text || "";
                      } else if (((_g = parsed.delta) == null ? void 0 : _g.type) === "text_delta") {
                        const chunk = {
                          id: messageId,
                          object: "chat.completion.chunk",
                          created: Math.floor(Date.now() / 1e3),
                          model: modelName,
                          choices: [{
                            index: 0,
                            delta: {
                              content: parsed.delta.text || ""
                            },
                            finish_reason: null
                          }]
                        };
                        controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(chunk)}

`));
                      }
                      break;
                    case ANTHROPIC_STREAM_EVENTS.CONTENT_BLOCK_STOP:
                      if (isInToolUse) {
                        isInToolUse = false;
                        currentToolCallId = "";
                        currentToolName = "";
                        accumulatedToolInput = "";
                      } else if (isInThinking) {
                        isInThinking = false;
                        console.log("[Anthropic] Extended thinking:", accumulatedThinkingText);
                        accumulatedThinkingText = "";
                      }
                      break;
                    case ANTHROPIC_STREAM_EVENTS.MESSAGE_DELTA:
                      if (parsed.usage) {
                        console.log("[Anthropic] Token usage:", parsed.usage);
                      }
                      break;
                    case ANTHROPIC_STREAM_EVENTS.MESSAGE_STOP:
                      let finishReason = "stop";
                      if (((_h = parsed.message) == null ? void 0 : _h.stop_reason) === "tool_use") {
                        finishReason = "tool_calls";
                      } else if (((_i = parsed.message) == null ? void 0 : _i.stop_reason) === "max_tokens") {
                        finishReason = "length";
                      }
                      const finalChunk = {
                        id: messageId,
                        object: "chat.completion.chunk",
                        created: Math.floor(Date.now() / 1e3),
                        model: modelName,
                        choices: [{
                          index: 0,
                          delta: {},
                          finish_reason: finishReason
                        }]
                      };
                      controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(finalChunk)}

`));
                      break;
                    case "error":
                      console.error("[Anthropic] Stream error:", parsed.error);
                      const errorChunk = {
                        error: {
                          message: ((_j = parsed.error) == null ? void 0 : _j.message) || "Stream error",
                          type: ((_k = parsed.error) == null ? void 0 : _k.type) || "stream_error"
                        }
                      };
                      controller.enqueue(new TextEncoder().encode(`data: ${JSON.stringify(errorChunk)}

`));
                      break;
                    case "ping":
                      break;
                    default:
                      console.log("[Anthropic] Unknown event type:", parsed.type);
                  }
                } catch (error) {
                  console.error("[Anthropic] Error parsing SSE data:", error, "Raw data:", data);
                }
              }
            }
          }
          controller.enqueue(new TextEncoder().encode("data: [DONE]\n\n"));
        } catch (error) {
          console.error("[Anthropic] Stream transformation error:", error);
          controller.error(error);
        } finally {
          controller.close();
        }
      }
    });
  }
  handleError(error) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (error.status) {
      switch (error.status) {
        case 401:
          return new Error("\u26A0\uFE0F Invalid Anthropic API key. Please check your API key in Settings > Custom Endpoints.");
        case 400:
          if ((_c = (_b = (_a = error.data) == null ? void 0 : _a.error) == null ? void 0 : _b.message) == null ? void 0 : _c.includes("credit")) {
            return new Error("\u{1F4B3} Insufficient credits. Please add credits to your Anthropic account.");
          }
          return new Error(`Invalid request: ${((_e = (_d = error.data) == null ? void 0 : _d.error) == null ? void 0 : _e.message) || "Please check your input and try again."}`);
        case 429:
          return new Error("\u23F1\uFE0F Rate limit exceeded. Please wait a moment and try again.");
        case 404:
          return new Error("\u274C Model not found. Please check that the model ID is correct.");
        case 500:
        case 502:
        case 503:
          return new Error("\u{1F527} Anthropic API is temporarily unavailable. Please try again later.");
      }
    }
    if ((_f = error.message) == null ? void 0 : _f.includes("Failed to fetch")) {
      return new Error("\u{1F310} Network error: Unable to connect to Anthropic. Please check your internet connection.");
    }
    return new Error(((_h = (_g = error.data) == null ? void 0 : _g.error) == null ? void 0 : _h.message) || error.message || `Anthropic API error: ${error.status || "unknown"}`);
  }
};

// src/services/providers/adapters/ProviderAdapterFactory.ts
var ProviderAdapterFactory = class {
  static createAdapter(provider, plugin) {
    if (isAnthropicEndpoint(provider.endpoint) || isCorrectableAnthropicEndpoint(provider.endpoint)) {
      return new AnthropicAdapter(provider, plugin);
    }
    return new OpenAICompatibleAdapter(provider);
  }
  static getProviderType(endpoint) {
    if (isAnthropicEndpoint(endpoint) || isCorrectableAnthropicEndpoint(endpoint)) {
      return "anthropic";
    }
    return "openai-compatible";
  }
};

// src/services/CustomProviderService.ts
var _CustomProviderService = class {
  constructor(plugin, app) {
    this.CACHE_DURATION = 30 * 60 * 1e3;
    this.plugin = plugin;
    this.app = app;
    this.logger = console;
  }
  clearCache() {
    _CustomProviderService.customProviderConnectionCache.clear();
    _CustomProviderService.customProviderTestPromises.clear();
  }
  static clearStaticCaches() {
    _CustomProviderService.customProviderConnectionCache.clear();
    _CustomProviderService.customProviderTestPromises.clear();
  }
  async testConnection(provider) {
    const cached = _CustomProviderService.customProviderConnectionCache.get(provider.id);
    if (cached && Date.now() - cached.result.timestamp < this.CACHE_DURATION) {
      return cached.result;
    }
    const existingPromise = _CustomProviderService.customProviderTestPromises.get(provider.id);
    if (existingPromise) {
      return existingPromise;
    }
    const testPromise = this.performConnectionTest(provider);
    _CustomProviderService.customProviderTestPromises.set(provider.id, testPromise);
    try {
      const result = await testPromise;
      if (result.success) {
        _CustomProviderService.customProviderConnectionCache.set(provider.id, {
          result,
          timestamp: Date.now()
        });
      }
      return result;
    } finally {
      _CustomProviderService.customProviderTestPromises.delete(provider.id);
    }
  }
  async performConnectionTest(provider) {
    try {
      const adapter = ProviderAdapterFactory.createAdapter(provider, this.plugin);
      const models = await adapter.getModels();
      await adapter.validateApiKey();
      return {
        success: true,
        models: models.map((m) => m.id),
        timestamp: Date.now()
      };
    } catch (error) {
      this.logger.error("Connection test failed:", error);
      return {
        success: false,
        error: this.getErrorMessage(error),
        timestamp: Date.now()
      };
    }
  }
  getProviderAdapter(provider) {
    return ProviderAdapterFactory.createAdapter(provider, this.plugin);
  }
  getErrorMessage(error) {
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        return "Connection timed out. Please check your internet connection and try again.";
      }
      return error.message;
    }
    return "An unexpected error occurred. Please try again or contact support if the issue persists.";
  }
};
var CustomProviderService = _CustomProviderService;
CustomProviderService.customProviderConnectionCache = new Map();
CustomProviderService.customProviderTestPromises = new Map();

// src/main.ts
init_errorHandling();

// src/services/providers/BaseProviderService.ts
var BaseProviderService = class {
  constructor(plugin) {
    this.models = null;
    this.lastFetchTime = 0;
    this.CACHE_DURATION = 30 * 60 * 1e3;
    this.loadingPromise = null;
    this.plugin = plugin;
  }
  clearCache() {
    this.models = null;
    this.lastFetchTime = 0;
    this.loadingPromise = null;
  }
  isCacheExpired() {
    return Date.now() - this.lastFetchTime >= this.CACHE_DURATION;
  }
  getCachedModels() {
    if (this.models && !this.isCacheExpired()) {
      return this.models;
    }
    return null;
  }
  cacheModels(models) {
    this.models = models;
    this.lastFetchTime = Date.now();
  }
};

// src/services/providers/SystemSculptProviderService.ts
init_modelUtils();
init_agent2();

// src/services/providers/ProviderErrorManager.ts
var ProviderErrorManager = class {
  constructor(plugin, app) {
    this.systemSculptErrors = new Map();
    this.customProviderErrors = new Map();
    this.MAX_ERROR_HISTORY = 10;
    this.ERROR_CLEANUP_INTERVAL = 24 * 60 * 60 * 1e3;
    this.plugin = plugin;
    this.app = app;
  }
  reportSystemSculptError(error) {
    const fullError = {
      ...error,
      providerType: "systemsculpt",
      timestamp: Date.now()
    };
    const providerId = error.providerId;
    const errors = this.systemSculptErrors.get(providerId) || [];
    errors.push(fullError);
    if (errors.length > this.MAX_ERROR_HISTORY) {
      errors.shift();
    }
    this.systemSculptErrors.set(providerId, errors);
    console.error(`[SystemSculpt Provider] Error in ${providerId}:`, {
      code: error.errorCode,
      message: error.message,
      licenseRelated: error.licenseRelated,
      apiEndpoint: error.apiEndpoint,
      context: error.context
    });
    this.plugin.emitter.emitWithProvider("providerError", "systemsculpt", fullError);
    if (fullError.licenseRelated) {
      this.handleLicenseError(fullError);
    }
  }
  reportCustomProviderError(error) {
    const fullError = {
      ...error,
      providerType: "custom",
      timestamp: Date.now()
    };
    const providerId = error.providerId;
    const errors = this.customProviderErrors.get(providerId) || [];
    errors.push(fullError);
    if (errors.length > this.MAX_ERROR_HISTORY) {
      errors.shift();
    }
    this.customProviderErrors.set(providerId, errors);
    console.error(`[Custom Provider] Error in ${error.providerName} (${providerId}):`, {
      code: error.errorCode,
      message: error.message,
      endpoint: error.endpoint,
      authRelated: error.authRelated,
      context: error.context
    });
    this.plugin.emitter.emitWithProvider("providerError", "custom", fullError);
    if (fullError.authRelated) {
      this.handleAuthError(fullError);
    }
  }
  getSystemSculptErrors(providerId) {
    return this.systemSculptErrors.get(providerId) || [];
  }
  getCustomProviderErrors(providerId) {
    return this.customProviderErrors.get(providerId) || [];
  }
  getErrorSummary() {
    const systemsculpt = Array.from(this.systemSculptErrors.entries()).map(([providerId, errors]) => ({
      providerId,
      errorCount: errors.length,
      lastError: errors[errors.length - 1]
    }));
    const custom = Array.from(this.customProviderErrors.entries()).map(([providerId, errors]) => ({
      providerId,
      errorCount: errors.length,
      lastError: errors[errors.length - 1]
    }));
    return { systemsculpt, custom };
  }
  handleLicenseError(error) {
    const recentLicenseErrors = this.getSystemSculptErrors(error.providerId).filter((e) => e.licenseRelated && Date.now() - e.timestamp < 5 * 60 * 1e3).length;
    if (recentLicenseErrors <= 1) {
      this.showLicenseErrorNotification(error);
    }
  }
  handleAuthError(error) {
    const recentAuthErrors = this.getCustomProviderErrors(error.providerId).filter((e) => e.authRelated && Date.now() - e.timestamp < 5 * 60 * 1e3).length;
    if (recentAuthErrors <= 1) {
      this.showAuthErrorNotification(error);
    }
  }
  async showLicenseErrorNotification(error) {
    try {
      const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
      const message = `SystemSculpt license issue: ${error.message}. Please check your license in settings.`;
      showNoticeWhenReady2(this.app, message, {
        type: "error",
        duration: 8e3
      });
    } catch (notificationError) {
      console.error("[SystemSculpt] Failed to show license error notification:", notificationError);
    }
  }
  async showAuthErrorNotification(error) {
    try {
      const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
      const message = `Authentication failed for ${error.providerName}: ${error.message}. Please check your API key.`;
      showNoticeWhenReady2(this.app, message, {
        type: "warning",
        duration: 8e3
      });
    } catch (notificationError) {
      console.error("[SystemSculpt] Failed to show auth error notification:", notificationError);
    }
  }
  clearProviderErrors(providerId, providerType) {
    if (providerType === "systemsculpt") {
      this.systemSculptErrors.delete(providerId);
    } else {
      this.customProviderErrors.delete(providerId);
    }
  }
  cleanupOldErrors() {
    const cutoffTime = Date.now() - this.ERROR_CLEANUP_INTERVAL;
    for (const [providerId, errors] of this.systemSculptErrors.entries()) {
      const recentErrors = errors.filter((error) => error.timestamp > cutoffTime);
      if (recentErrors.length === 0) {
        this.systemSculptErrors.delete(providerId);
      } else {
        this.systemSculptErrors.set(providerId, recentErrors);
      }
    }
    for (const [providerId, errors] of this.customProviderErrors.entries()) {
      const recentErrors = errors.filter((error) => error.timestamp > cutoffTime);
      if (recentErrors.length === 0) {
        this.customProviderErrors.delete(providerId);
      } else {
        this.customProviderErrors.set(providerId, recentErrors);
      }
    }
  }
  getProviderHealth(providerId, providerType) {
    if (providerType === "systemsculpt") {
      const errors = this.getSystemSculptErrors(providerId);
      const recentErrors = errors.filter((error) => Date.now() - error.timestamp < 15 * 60 * 1e3);
      let status = "healthy";
      if (recentErrors.length >= 3) {
        status = "error";
      } else if (recentErrors.length >= 1) {
        status = "warning";
      }
      return {
        status,
        recentErrorCount: recentErrors.length,
        lastErrorTime: errors.length > 0 ? errors[errors.length - 1].timestamp : void 0
      };
    } else {
      const errors = this.getCustomProviderErrors(providerId);
      const recentErrors = errors.filter((error) => Date.now() - error.timestamp < 15 * 60 * 1e3);
      let status = "healthy";
      if (recentErrors.length >= 3) {
        status = "error";
      } else if (recentErrors.length >= 1) {
        status = "warning";
      }
      return {
        status,
        recentErrorCount: recentErrors.length,
        lastErrorTime: errors.length > 0 ? errors[errors.length - 1].timestamp : void 0
      };
    }
  }
  clearAllErrors() {
    this.systemSculptErrors.clear();
    this.customProviderErrors.clear();
  }
};

// src/services/providers/SystemSculptProviderService.ts
var _SystemSculptProviderService = class extends BaseProviderService {
  constructor(plugin) {
    super(plugin);
    this.modelDetailsCache = new Map();
    this.errorManager = new ProviderErrorManager(plugin, plugin.app);
  }
  static getInstance(plugin) {
    if (!this.instance) {
      this.instance = new _SystemSculptProviderService(plugin);
    }
    return this.instance;
  }
  static clearInstance() {
    if (this.instance) {
      this.instance.clearCache();
      this.instance.modelDetailsCache.clear();
      this.instance = null;
    }
  }
  getProviderType() {
    return "systemsculpt";
  }
  async testConnection() {
    try {
      if (!this.plugin.settings.enableSystemSculptProvider) {
        return false;
      }
      const models = await this.getModels();
      return models.length > 0;
    } catch (error) {
      console.error("[SystemSculpt] SystemSculpt provider connection test failed:", error);
      return false;
    }
  }
  async getModels() {
    if (!this.plugin.settings.enableSystemSculptProvider) {
      console.log("[SystemSculpt] SystemSculpt provider is disabled in settings.");
      return [];
    }
    const cachedModels = this.getCachedModels();
    if (cachedModels) {
      return cachedModels;
    }
    if (this.loadingPromise) {
      return this.loadingPromise;
    }
    this.loadingPromise = this.loadSystemSculptModels().then((models) => {
      models.forEach((model) => {
        this.modelDetailsCache.set(model.id, model);
      });
      this.cacheModels(models);
      this.loadingPromise = null;
      this.plugin.emitter.emitWithProvider("modelsUpdated", "systemsculpt", models);
      return models;
    }).catch((error) => {
      console.error("[SystemSculpt] Failed to load SystemSculpt models:", error);
      this.loadingPromise = null;
      return [];
    });
    return this.loadingPromise;
  }
  async loadSystemSculptModels() {
    var _a, _b;
    try {
      const systemModels = await this.loadWithRetry(() => this.plugin.aiService.getModels(), 3, 1e3);
      return systemModels;
    } catch (error) {
      this.errorManager.reportSystemSculptError({
        providerId: "systemsculpt-api",
        errorCode: "MODEL_LOAD_FAILED",
        message: error instanceof Error ? error.message : "Unknown error loading models",
        licenseRelated: ((_a = error.message) == null ? void 0 : _a.includes("license")) || ((_b = error.message) == null ? void 0 : _b.includes("unauthorized")),
        apiEndpoint: "models",
        context: {
          licenseValid: this.plugin.settings.licenseValid,
          hasLicenseKey: !!this.plugin.settings.licenseKey
        }
      });
      console.warn("[SystemSculpt] SystemSculpt API unavailable, returning empty model list");
      return [];
    }
  }
  async loadWithRetry(fn, maxRetries, delay) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await Promise.race([
          fn(),
          new Promise((_, reject) => setTimeout(() => reject(new Error("Operation timeout")), 5e3))
        ]);
      } catch (error) {
        if (i === maxRetries - 1)
          throw error;
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    throw new Error("Max retries exceeded");
  }
  findBestAlternativeModel(unavailableModelId) {
    if (!this.models || this.models.length === 0) {
      return void 0;
    }
    try {
      const chatModels = filterChatModels(this.models).filter((m) => m.id !== unavailableModelId);
      if (chatModels.length === 0) {
        return void 0;
      }
      const isLicenseHolder = this.plugin.settings.licenseValid === true;
      if (isLicenseHolder) {
        const agentModel = chatModels.find((m) => m.id === AGENT_CONFIG.MODEL_ID);
        if (agentModel) {
          return agentModel;
        }
      }
      return chatModels[0];
    } catch (error) {
      console.error("[SystemSculpt] Error finding SystemSculpt alternative model:", error);
      return void 0;
    }
  }
  getCachedModelById(modelId) {
    return this.modelDetailsCache.get(modelId);
  }
  getProviderHealth() {
    return this.errorManager.getProviderHealth("systemsculpt-api", "systemsculpt");
  }
  clearCache() {
    super.clearCache();
    this.modelDetailsCache.clear();
  }
};
var SystemSculptProviderService = _SystemSculptProviderService;
SystemSculptProviderService.instance = null;

// src/services/providers/CustomProviderModelService.ts
init_modelUtils();
var _CustomProviderModelService = class extends BaseProviderService {
  constructor(plugin) {
    super(plugin);
    this.providerCaches = new Map();
    this.modelDetailsCache = new Map();
    this.customProviderService = plugin.customProviderService;
    this.errorManager = new ProviderErrorManager(plugin, plugin.app);
  }
  static getInstance(plugin) {
    if (!this.instance) {
      this.instance = new _CustomProviderModelService(plugin);
    }
    return this.instance;
  }
  static clearInstance() {
    if (this.instance) {
      this.instance.clearCache();
      this.instance.providerCaches.clear();
      this.instance.modelDetailsCache.clear();
      this.instance = null;
    }
  }
  getProviderType() {
    return "custom";
  }
  async testConnection() {
    try {
      const { customProviders } = this.plugin.settings;
      const enabledProviders = customProviders.filter((p) => p.isEnabled);
      if (enabledProviders.length === 0) {
        return true;
      }
      for (const provider of enabledProviders) {
        try {
          const result = await this.customProviderService.testConnection(provider);
          if (result.success) {
            return true;
          }
        } catch (error) {
        }
      }
      return false;
    } catch (error) {
      console.error("[SystemSculpt] Custom provider connection test failed:", error);
      return false;
    }
  }
  async getModels() {
    const cachedModels = this.getCachedModels();
    if (cachedModels) {
      return cachedModels;
    }
    if (this.loadingPromise) {
      return this.loadingPromise;
    }
    this.loadingPromise = this.loadCustomProviderModels().then((models) => {
      models.forEach((model) => {
        this.modelDetailsCache.set(model.id, model);
      });
      this.cacheModels(models);
      this.loadingPromise = null;
      this.plugin.emitter.emitWithProvider("modelsUpdated", "custom", models);
      return models;
    }).catch((error) => {
      console.error("[SystemSculpt] Failed to load custom provider models:", error);
      this.loadingPromise = null;
      return [];
    });
    return this.loadingPromise;
  }
  async getModelsFromProvider(provider) {
    var _a, _b, _c;
    const cached = this.providerCaches.get(provider.id);
    if (cached && !this.isProviderCacheExpired(cached.timestamp)) {
      return cached.models;
    }
    try {
      const result = await this.customProviderService.testConnection(provider);
      if (result.success && result.models) {
        await this.resetProviderFailureCount(provider.id);
        const models = this.createCustomModels(provider, result.models);
        this.providerCaches.set(provider.id, {
          models,
          timestamp: Date.now()
        });
        return models;
      } else {
        await this.handleProviderFailure(provider.id, provider.name, result.error);
        return [];
      }
    } catch (error) {
      console.error(`[SystemSculpt] Failed to load models from ${provider.name}:`, error);
      this.errorManager.reportCustomProviderError({
        providerId: provider.id,
        providerName: provider.name,
        errorCode: "MODEL_LOAD_FAILED",
        message: error instanceof Error ? error.message : "Unknown error loading models",
        endpoint: provider.endpoint,
        authRelated: ((_a = error.message) == null ? void 0 : _a.includes("401")) || ((_b = error.message) == null ? void 0 : _b.includes("unauthorized")) || ((_c = error.message) == null ? void 0 : _c.includes("api key")),
        context: {
          hasApiKey: !!provider.apiKey,
          endpoint: provider.endpoint
        }
      });
      await this.handleProviderFailure(provider.id, provider.name, error instanceof Error ? error.message : "Unknown error");
      return [];
    }
  }
  async loadCustomProviderModels() {
    const { customProviders } = this.plugin.settings;
    const enabledProviders = customProviders.filter((p) => p.isEnabled);
    if (enabledProviders.length === 0) {
      return [];
    }
    const fetches = enabledProviders.map((provider) => this.getModelsFromProvider(provider));
    const results = await Promise.all(fetches);
    return results.flat();
  }
  isProviderCacheExpired(timestamp) {
    return Date.now() - timestamp >= this.CACHE_DURATION;
  }
  async handleProviderFailure(providerId, providerName, errorMessage) {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const provider = settings.customProviders.find((p) => p.id === providerId);
      if (!provider)
        return;
      if (!provider.failureCount) {
        provider.failureCount = 0;
      }
      provider.failureCount++;
      provider.lastFailureTime = Date.now();
      const FAILURE_THRESHOLD = 3;
      if (provider.failureCount >= FAILURE_THRESHOLD && provider.isEnabled) {
        provider.isEnabled = false;
        console.warn(`[SystemSculpt] Auto-disabling custom provider '${providerName}' after ${provider.failureCount} consecutive failures.`);
        const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
        const message = `Custom provider '${providerName}' has been automatically disabled after ${provider.failureCount} consecutive connection failures. You can re-enable it in settings when the server is available.`;
        showNoticeWhenReady2(this.plugin.app, message, { type: "warning", duration: 12e3 });
      } else {
        console.warn(`[SystemSculpt] Custom provider '${providerName}' failed to connect (${provider.failureCount}/${FAILURE_THRESHOLD} failures).`);
        const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
        const remainingAttempts = FAILURE_THRESHOLD - provider.failureCount;
        const message = `Connection to custom provider '${providerName}' failed (attempt ${provider.failureCount} of ${FAILURE_THRESHOLD}). We'll try again when you reload Obsidian. After ${remainingAttempts} more failure${remainingAttempts === 1 ? "" : "s"}, this provider will be automatically disabled.`;
        showNoticeWhenReady2(this.plugin.app, message, { type: "warning", duration: 8e3 });
      }
      await this.plugin.getSettingsManager().saveSettings();
    } catch (error) {
      console.error("[SystemSculpt] Failed to handle custom provider failure:", error);
    }
  }
  async resetProviderFailureCount(providerId) {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const provider = settings.customProviders.find((p) => p.id === providerId);
      if (provider && (provider.failureCount || 0) > 0) {
        provider.failureCount = 0;
        delete provider.lastFailureTime;
        await this.plugin.getSettingsManager().saveSettings();
        console.log(`[SystemSculpt] Reset failure count for custom provider '${provider.name}' after successful connection.`);
      }
    } catch (error) {
      console.error("[SystemSculpt] Failed to reset custom provider failure count:", error);
    }
  }
  createCustomModels(provider, modelIds) {
    const isAnthropic = isAnthropicEndpoint(provider.endpoint);
    return modelIds.map((modelId) => {
      const providerId = provider.name.toLowerCase();
      const canonicalId = createCanonicalId(providerId, modelId);
      if (isAnthropic) {
        const anthropicModel = ANTHROPIC_MODELS.find((m) => m.id === modelId);
        if (anthropicModel) {
          return {
            id: canonicalId,
            name: anthropicModel.name,
            provider: providerId,
            isFavorite: false,
            context_length: anthropicModel.contextWindow,
            capabilities: anthropicModel.capabilities,
            pricing: {
              prompt: "0",
              completion: "0",
              image: "0",
              request: "0"
            },
            architecture: {
              modality: anthropicModel.capabilities.includes("vision") ? "text+image->text" : "text->text",
              tokenizer: "claude",
              instruct_type: null
            },
            description: `${anthropicModel.name} - ${anthropicModel.contextWindow.toLocaleString()} token context`,
            identifier: {
              providerId,
              modelId,
              displayName: anthropicModel.name
            },
            supported_parameters: anthropicModel.supportsTools ? ["tools", "temperature", "max_tokens", "stream"] : ["temperature", "max_tokens", "stream"]
          };
        }
      }
      return {
        id: canonicalId,
        name: modelId,
        provider: providerId,
        isFavorite: false,
        context_length: 0,
        capabilities: [],
        pricing: {
          prompt: "0",
          completion: "0",
          image: "0",
          request: "0"
        },
        architecture: {
          modality: "text->text",
          tokenizer: "",
          instruct_type: null
        },
        description: `${provider.name} custom model`,
        identifier: {
          providerId,
          modelId,
          displayName: modelId
        }
      };
    });
  }
  findBestAlternativeModel(unavailableModelId) {
    if (!this.models || this.models.length === 0) {
      return void 0;
    }
    try {
      const chatModels = filterChatModels(this.models).filter((m) => m.id !== unavailableModelId);
      if (chatModels.length === 0) {
        return void 0;
      }
      const unavailableModel = this.modelDetailsCache.get(unavailableModelId);
      if (unavailableModel) {
        const sameProviderModels = chatModels.filter((m) => m.provider === unavailableModel.provider);
        if (sameProviderModels.length > 0) {
          return sameProviderModels[0];
        }
      }
      return chatModels[0];
    } catch (error) {
      console.error("[SystemSculpt] Error finding custom provider alternative model:", error);
      return void 0;
    }
  }
  getCachedModelById(modelId) {
    return this.modelDetailsCache.get(modelId);
  }
  clearCache() {
    super.clearCache();
    this.providerCaches.clear();
    this.modelDetailsCache.clear();
  }
  getProviderHealth(providerId) {
    return this.errorManager.getProviderHealth(providerId, "custom");
  }
  clearProviderCache(providerId) {
    this.providerCaches.delete(providerId);
  }
};
var CustomProviderModelService = _CustomProviderModelService;
CustomProviderModelService.instance = null;

// src/services/providers/UnifiedModelService.ts
init_FavoritesService();
init_modelUtils();
init_agent2();
var _UnifiedModelService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.lastDemandTime = 0;
    this.DEMAND_THRESHOLD = 5 * 60 * 1e3;
    this.isBackgroundRefreshScheduled = false;
    this.isInitialLoadDone = false;
    this.systemSculptService = SystemSculptProviderService.getInstance(plugin);
    this.customProviderService = CustomProviderModelService.getInstance(plugin);
    this.favoritesService = FavoritesService.getInstance(plugin);
  }
  static getInstance(plugin) {
    if (!this.instance) {
      this.instance = new _UnifiedModelService(plugin);
    }
    return this.instance;
  }
  static clearInstance() {
    if (this.instance) {
      SystemSculptProviderService.clearInstance();
      CustomProviderModelService.clearInstance();
      this.instance = null;
    }
  }
  async getModels(forceRefresh = false) {
    const now = Date.now();
    this.lastDemandTime = now;
    try {
      const [systemModels, customModels] = await Promise.allSettled([
        forceRefresh ? (this.systemSculptService.clearCache(), this.systemSculptService.getModels()) : this.systemSculptService.getModels(),
        forceRefresh ? (this.customProviderService.clearCache(), this.customProviderService.getModels()) : this.customProviderService.getModels()
      ]);
      const systemModelList = systemModels.status === "fulfilled" ? systemModels.value : [];
      const customModelList = customModels.status === "fulfilled" ? customModels.value : [];
      if (systemModels.status === "rejected") {
        console.warn("[SystemSculpt] SystemSculpt provider failed:", systemModels.reason);
      }
      if (customModels.status === "rejected") {
        console.warn("[SystemSculpt] Custom providers failed:", customModels.reason);
      }
      const allModels = [...systemModelList, ...customModelList];
      const canonicalModels = allModels.map((model) => {
        model.id = getCanonicalId(model);
        return model;
      });
      this.favoritesService.processFavorites(canonicalModels);
      if (!this.isInitialLoadDone) {
        await this.validateSelectedModel(canonicalModels);
        this.isInitialLoadDone = true;
      }
      return canonicalModels;
    } catch (error) {
      console.error("[SystemSculpt] Failed to load unified models:", error);
      throw error;
    }
  }
  async getModelById(modelId) {
    const systemModel = this.systemSculptService.getCachedModelById(modelId);
    if (systemModel) {
      return systemModel;
    }
    const customModel = this.customProviderService.getCachedModelById(modelId);
    if (customModel) {
      return customModel;
    }
    const models = await this.getModels();
    return findModelById(models, modelId);
  }
  findBestAlternativeModel(unavailableModelId, models) {
    if (!models || models.length === 0) {
      return void 0;
    }
    try {
      const chatModels = filterChatModels(models).filter((m) => m.id !== unavailableModelId);
      if (chatModels.length === 0) {
        console.warn("[SystemSculpt] No alternative chat models available");
        return void 0;
      }
      const isLicenseHolder = this.plugin.settings.licenseValid === true;
      if (isLicenseHolder) {
        const agentModel = chatModels.find((m) => m.id === AGENT_CONFIG.MODEL_ID);
        if (agentModel) {
          console.log("[SystemSculpt] License holder detected - switching to SystemSculpt Agent Model");
          return agentModel;
        }
      }
      const systemAlternative = this.systemSculptService.findBestAlternativeModel(unavailableModelId);
      if (systemAlternative) {
        return systemAlternative;
      }
      const customAlternative = this.customProviderService.findBestAlternativeModel(unavailableModelId);
      if (customAlternative) {
        return customAlternative;
      }
      return chatModels[0];
    } catch (error) {
      console.error("[SystemSculpt] Error finding alternative model:", error);
      const chatModels = filterChatModels(models);
      return chatModels[0];
    }
  }
  async validateSelectedModel(models) {
    const result = {
      wasReplaced: false,
      oldModelId: void 0,
      newModel: void 0,
      forDefault: true
    };
    try {
      const modelList = models || await this.getModels();
      const savedId = this.plugin.settings.selectedModelId;
      const found = modelList == null ? void 0 : modelList.find((m) => m.id === savedId);
      if (!found) {
        if (modelList && modelList.length > 0) {
          const fallbackModel = this.findBestAlternativeModel(savedId, modelList);
          if (fallbackModel) {
            console.warn("[SystemSculpt] Saved selectedModelId invalid or missing, falling back to alternative model:", fallbackModel.id);
            result.wasReplaced = true;
            result.oldModelId = savedId;
            result.newModel = fallbackModel;
            await this.plugin.getSettingsManager().updateSettings({ selectedModelId: fallbackModel.id });
          }
        } else {
          console.warn("[SystemSculpt] No models available. Clearing selectedModelId and disabling AI features.");
          await this.plugin.getSettingsManager().updateSettings({ selectedModelId: "" });
        }
      }
    } catch (error) {
      console.error("[SystemSculpt] Failed to validate selected model:", error);
    }
    return result;
  }
  async validateSpecificModel(modelId, models) {
    try {
      const modelList = models || await this.getModels();
      const found = modelList == null ? void 0 : modelList.find((m) => m.id === modelId);
      if (!found && modelList && modelList.length > 0) {
        const alternativeModel = this.findBestAlternativeModel(modelId, modelList);
        return {
          isAvailable: false,
          alternativeModel
        };
      }
      return {
        isAvailable: !!found
      };
    } catch (error) {
      console.error("[SystemSculpt] Failed to validate specific model:", error);
      return { isAvailable: false };
    }
  }
  async toggleFavorite(model) {
    await this.favoritesService.toggleFavorite(model);
  }
  async refreshModels() {
    return this.getModels(true);
  }
  async checkToolCompatibility(modelId) {
    try {
      const model = await this.getModelById(modelId);
      if (!model) {
        return {
          isCompatible: false,
          reason: "Model not found",
          confidence: "high"
        };
      }
      return getToolCompatibilityInfo(model);
    } catch (error) {
      console.error("[SystemSculpt] Error checking tool compatibility:", error);
      return {
        isCompatible: false,
        reason: "Error checking compatibility",
        confidence: "low"
      };
    }
  }
  async getToolCompatibleModels() {
    try {
      const models = await this.getModels();
      return models.filter((model) => supportsTools(model));
    } catch (error) {
      console.error("[SystemSculpt] Error getting tool-compatible models:", error);
      return [];
    }
  }
  async testAllConnections() {
    const [systemResult, customResult] = await Promise.allSettled([
      this.systemSculptService.testConnection(),
      this.customProviderService.testConnection()
    ]);
    return {
      systemSculpt: systemResult.status === "fulfilled" ? systemResult.value : false,
      customProviders: customResult.status === "fulfilled" ? customResult.value : false
    };
  }
  getCachedModels() {
    return [];
  }
  clearAllCaches() {
    this.systemSculptService.clearCache();
    this.customProviderService.clearCache();
  }
};
var UnifiedModelService = _UnifiedModelService;
UnifiedModelService.instance = null;

// src/templates/TemplateManager.ts
var import_obsidian99 = __toModule(require("obsidian"));
var TemplateSuggestProvider = class extends import_obsidian99.EditorSuggest {
  constructor(app, plugin) {
    super(app);
    this.templateFiles = [];
    this.listeners = [];
    this.plugin = plugin;
    this.limit = 50;
    this.preloadTemplates();
  }
  async preloadTemplates() {
    await this.loadTemplateFiles();
    if (this.templateFiles.length === 0 || this.templateFiles.length === 1 && this.templateFiles[0].path === "no-templates") {
      setTimeout(async () => {
        await this.loadTemplateFiles();
      }, 500);
    }
  }
  onTrigger(cursor, editor) {
    if (!this.plugin.settings.enableTemplateHotkey)
      return null;
    const line = editor.getLine(cursor.line);
    const textBeforeCursor = line.slice(0, cursor.ch);
    const hotkey = this.plugin.settings.templateHotkey;
    const hotkeyIndex = textBeforeCursor.lastIndexOf(hotkey);
    if (hotkeyIndex >= 0) {
      const textBeforeHotkey = textBeforeCursor.slice(0, hotkeyIndex);
      const hasTextBeforeHotkey = textBeforeHotkey.trim().length > 0;
      if (hasTextBeforeHotkey) {
        return null;
      }
      const textAfterHotkey = textBeforeCursor.slice(hotkeyIndex + hotkey.length);
      const hasClosingChar = /[\]\}\)>]/.test(textAfterHotkey);
      if (hasClosingChar) {
        return null;
      }
      this.loadTemplateFiles();
      const query = textBeforeCursor.slice(hotkeyIndex + hotkey.length);
      return {
        start: {
          line: cursor.line,
          ch: hotkeyIndex
        },
        end: cursor,
        query
      };
    }
    return null;
  }
  createTemporaryLoadingFile() {
    return {
      basename: "Loading templates...",
      extension: "md",
      path: "loading",
      name: "Loading templates...",
      parent: null,
      vault: this.app.vault,
      stat: null
    };
  }
  async loadTemplateFiles() {
    const systemPromptsDir = this.plugin.settings.systemPromptsDirectory;
    if (!systemPromptsDir || systemPromptsDir.trim() === "") {
      console.error("[SystemSculpt] System prompts directory path is empty");
      this.templateFiles = [this.createNoTemplatesFoundFile()];
      return;
    }
    try {
      if (!this.plugin.directoryManager) {
        console.error("[SystemSculpt] Directory manager not available when trying to load templates");
        this.templateFiles = [this.createNoTemplatesFoundFile()];
        return;
      }
      await this.plugin.directoryManager.ensureDirectoryByKey("systemPromptsDirectory");
      const files = this.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(systemPromptsDir));
      if (files.length > 0) {
        this.templateFiles = files;
      } else if (this.templateFiles.length === 0 || this.templateFiles.length === 1 && (this.templateFiles[0].path === "loading" || this.templateFiles[0].path === "no-templates")) {
        this.templateFiles = [this.createNoTemplatesFoundFile()];
      }
    } catch (error) {
      console.error("[SystemSculpt] Error loading system prompt files:", error);
      this.templateFiles = [this.createNoTemplatesFoundFile()];
    }
  }
  createNoTemplatesFoundFile() {
    return {
      basename: "No templates found - Click to create one",
      extension: "md",
      path: "no-templates",
      name: "No templates found - Click to create one",
      parent: null,
      vault: this.app.vault,
      stat: null
    };
  }
  getSuggestions(context) {
    const query = context.query.toLowerCase();
    if (!query) {
      return this.templateFiles;
    }
    const queryParts = query.split(/\s+/).filter((part) => part.length > 0);
    const scoredResults = this.templateFiles.map((file) => {
      const basename = file.basename.toLowerCase();
      const path = file.path.toLowerCase();
      let score = 0;
      if (basename === query) {
        score += 100;
      }
      if (basename.startsWith(query)) {
        score += 80;
      }
      const wordBoundaryMatches = basename.split(/[-_\s]/).filter((word) => word.startsWith(query)).length;
      if (wordBoundaryMatches > 0) {
        score += 60 * wordBoundaryMatches;
      }
      if (path.includes(query)) {
        score += 30;
      }
      const allPartsMatch = queryParts.every((part) => basename.includes(part));
      if (allPartsMatch) {
        score += 40;
      }
      let wordBoundaryPartMatches = 0;
      for (const part of queryParts) {
        const words = basename.split(/[-_\s]/);
        for (const word of words) {
          if (word.startsWith(part)) {
            wordBoundaryPartMatches++;
            break;
          }
        }
      }
      if (wordBoundaryPartMatches > 0) {
        score += 50 * (wordBoundaryPartMatches / queryParts.length);
      }
      let lastIndex = -1;
      let consecutiveMatches = 0;
      for (const char of query) {
        const index = basename.indexOf(char, lastIndex + 1);
        if (index > lastIndex) {
          lastIndex = index;
          consecutiveMatches++;
        }
      }
      if (consecutiveMatches === query.length) {
        score += 20 * (consecutiveMatches / basename.length);
      }
      return { file, score };
    });
    const suggestions = scoredResults.filter((result) => result.score > 0).sort((a, b) => b.score - a.score).map((result) => result.file);
    console.log(`[SystemSculpt] Returning ${suggestions.length} template suggestions for query "${query}"`);
    return suggestions;
  }
  renderSuggestion(file, el) {
    var _a, _b;
    const suggestionEl = el.createEl("div", {
      cls: "suggestion-content"
    });
    const iconEl = suggestionEl.createEl("div", {
      cls: "suggestion-icon"
    });
    iconEl.innerHTML = `<svg viewBox="0 0 100 100" class="document" width="17" height="17"><path fill="currentColor" stroke="currentColor" d="M14,4v92h72V29.2l-0.6-0.6l-24-24L60.8,4H14z M18,8h40v24h24v60H18V8z M62,10.9L79.1,28H62V10.9z"></path></svg>`;
    const contentEl = suggestionEl.createEl("div", {
      cls: "suggestion-content-inner"
    });
    const query = ((_b = (_a = this.context) == null ? void 0 : _a.query) == null ? void 0 : _b.toLowerCase()) || "";
    const basename = file.basename;
    const titleEl = contentEl.createEl("div", {
      cls: "suggestion-title"
    });
    if (query) {
      this.renderHighlightedText(titleEl, basename, query);
    } else {
      titleEl.setText(basename);
    }
    this.getTemplatePreview(file).then((preview) => {
      contentEl.createEl("div", {
        text: preview,
        cls: "suggestion-note"
      });
    }).catch((error) => {
      console.error("[SystemSculpt] Error getting template preview:", error);
      contentEl.createEl("div", {
        text: file.path,
        cls: "suggestion-note"
      });
    });
    suggestionEl.style.display = "flex";
    suggestionEl.style.alignItems = "center";
    suggestionEl.style.gap = "8px";
    const mouseEnterHandler = () => {
      el.addClass("is-selected");
    };
    const mouseLeaveHandler = () => {
      if (!el.hasClass("mod-complex-selected")) {
        el.removeClass("is-selected");
      }
    };
    this.registerListener(el, "mouseenter", mouseEnterHandler);
    this.registerListener(el, "mouseleave", mouseLeaveHandler);
  }
  renderHighlightedText(element, text, query) {
    if (!query) {
      element.setText(text);
      return;
    }
    const lowerText = text.toLowerCase();
    const queryParts = query.split(/\s+/).filter((part) => part.length > 0);
    const highlightMap = new Array(text.length).fill(false);
    for (const part of queryParts) {
      let index = lowerText.indexOf(part);
      while (index !== -1) {
        for (let i = 0; i < part.length; i++) {
          highlightMap[index + i] = true;
        }
        index = lowerText.indexOf(part, index + 1);
      }
    }
    if (!highlightMap.some((h) => h) && query.length > 0) {
      let lastIndex = -1;
      for (const char of query.toLowerCase()) {
        const index = lowerText.indexOf(char, lastIndex + 1);
        if (index > lastIndex) {
          highlightMap[index] = true;
          lastIndex = index;
        }
      }
    }
    let currentSpan = null;
    let isHighlighted = false;
    for (let i = 0; i < text.length; i++) {
      if (highlightMap[i] !== isHighlighted || currentSpan === null) {
        isHighlighted = highlightMap[i];
        currentSpan = element.createEl("span");
        if (isHighlighted) {
          currentSpan.addClass("suggestion-highlight");
        }
      }
      currentSpan.textContent += text[i];
    }
  }
  async getTemplatePreview(file) {
    try {
      if (file.path === "loading") {
        return "Loading your templates, please wait...";
      }
      if (file.path === "no-templates") {
        return `Create templates in ${this.plugin.settings.systemPromptsDirectory}`;
      }
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      let preview = "";
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed) {
          preview = trimmed.substring(0, 50);
          if (trimmed.length > 50) {
            preview += "...";
          }
          break;
        }
      }
      return preview || "Empty template";
    } catch (error) {
      console.error("[SystemSculpt] Error reading template file:", error);
      return "Error reading template";
    }
  }
  async selectSuggestion(file, evt) {
    try {
      if (file.path === "loading") {
        new import_obsidian99.Notice("Templates are still loading, please try again in a moment.");
        return;
      }
      if (file.path === "no-templates") {
        const systemPromptsDir = this.plugin.settings.systemPromptsDirectory;
        new import_obsidian99.Notice(`Create template files in ${systemPromptsDir} to use this feature.`);
        const folderExists = await this.app.vault.adapter.exists(systemPromptsDir);
        if (!folderExists) {
          if (this.plugin.directoryManager) {
            await this.plugin.directoryManager.ensureDirectoryByPath(systemPromptsDir);
          } else {
            try {
              await this.app.vault.createFolder(systemPromptsDir);
            } catch (error) {
              console.error(`[SystemSculpt] Error creating system prompts directory: ${systemPromptsDir}`, error);
              if (!(error instanceof Error) || !error.message.includes("already exists")) {
                throw error;
              }
            }
          }
        }
        try {
          const folder = this.app.vault.getAbstractFileByPath(systemPromptsDir);
          if (folder) {
            const fileExplorer = this.app.workspace.getLeavesOfType("file-explorer")[0];
            if (fileExplorer) {
              this.app.workspace.revealLeaf(fileExplorer);
              new import_obsidian99.Notice(`Look for the "${systemPromptsDir}" folder in your file explorer.`);
            }
          }
        } catch (e) {
          console.error("[SystemSculpt] Error revealing folder:", e);
        }
        return;
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian99.MarkdownView);
      if (!activeView)
        return;
      const editor = activeView.editor;
      const content = await this.app.vault.read(file);
      if (this.context) {
        const commandText = editor.getRange(this.context.start, this.context.end);
        const { showStandardTemplateModal: showStandardTemplateModal2 } = await Promise.resolve().then(() => (init_StandardTemplateModal(), StandardTemplateModal_exports));
        const result = await showStandardTemplateModal2(this.app, file.basename, content, {
          plugin: this.plugin,
          commandText
        });
        if (result) {
          editor.replaceRange(result, this.context.start, this.context.end);
          console.log(`[SystemSculpt] Inserted template: ${file.basename}`);
        }
      }
    } catch (error) {
      console.error("[SystemSculpt] Error handling template:", error);
      new import_obsidian99.Notice("Failed to process template content.");
    }
  }
  registerListener(element, type, listener) {
    element.addEventListener(type, listener);
    this.listeners.push({ element, type, listener });
  }
  removeAllListeners() {
    this.listeners.forEach(({ element, type, listener }) => {
      element.removeEventListener(type, listener);
    });
    this.listeners = [];
  }
};
var TemplateManager = class {
  constructor(plugin, app) {
    this.templateSuggestProvider = null;
    var _a;
    this.plugin = plugin;
    this.app = app;
    try {
      if (!plugin.directoryManager || !plugin.directoryManager.isInitialized()) {
        console.warn("[SystemSculpt] Directory manager not initialized when creating template manager");
        (_a = plugin.directoryManager) == null ? void 0 : _a.initialize().catch((e) => {
          console.error("[SystemSculpt] Failed to initialize directory manager:", e);
        });
      }
      this.templateSuggestProvider = new TemplateSuggestProvider(app, plugin);
      plugin.registerEditorSuggest(this.templateSuggestProvider);
    } catch (error) {
      console.error("[SystemSculpt] Template manager initialization failed:", error);
      this.templateSuggestProvider = null;
    }
  }
  unload() {
    if (this.templateSuggestProvider) {
      this.templateSuggestProvider.removeAllListeners();
    }
  }
};

// src/core/EventEmitter.ts
var EventEmitter = class {
  constructor() {
    this.events = {};
    this.namespaceListeners = {};
  }
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    this.trackNamespace(event);
    return () => {
      this.events[event] = this.events[event].filter((l) => l !== listener);
      this.cleanupNamespace(event);
    };
  }
  once(event, listener) {
    const remove = this.on(event, (...args) => {
      remove();
      listener(...args);
    });
    return remove;
  }
  emit(event, ...args) {
    const callbacks = this.events[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback(...args));
    }
  }
  off(event) {
    delete this.events[event];
  }
  clear() {
    this.events = {};
    this.namespaceListeners = {};
  }
  trackNamespace(event) {
    const namespace = this.getNamespace(event);
    if (namespace) {
      if (!this.namespaceListeners[namespace]) {
        this.namespaceListeners[namespace] = new Set();
      }
      this.namespaceListeners[namespace].add(event);
    }
  }
  cleanupNamespace(event) {
    const namespace = this.getNamespace(event);
    if (namespace && this.namespaceListeners[namespace]) {
      if (!this.events[event] || this.events[event].length === 0) {
        this.namespaceListeners[namespace].delete(event);
        if (this.namespaceListeners[namespace].size === 0) {
          delete this.namespaceListeners[namespace];
        }
      }
    }
  }
  getNamespace(event) {
    const parts = event.split(":");
    return parts.length > 1 ? parts[0] : null;
  }
  clearNamespace(namespace) {
    if (this.namespaceListeners[namespace]) {
      const events = Array.from(this.namespaceListeners[namespace]);
      events.forEach((event) => {
        delete this.events[event];
      });
      delete this.namespaceListeners[namespace];
    }
  }
  getNamespaceEvents(namespace) {
    return this.namespaceListeners[namespace] ? Array.from(this.namespaceListeners[namespace]) : [];
  }
  emitWithProvider(event, providerType, ...args) {
    this.emit(event, ...args);
    const namespacedEvent = `${providerType}:${event}`;
    this.emit(namespacedEvent, ...args);
  }
  onProvider(event, providerType, listener) {
    const namespacedEvent = `${providerType}:${event}`;
    return this.on(namespacedEvent, listener);
  }
};

// src/core/DirectoryManager.ts
var import_obsidian100 = __toModule(require("obsidian"));
var DirectoryManager = class {
  constructor(app, plugin) {
    this.directories = new Map();
    this.initialized = false;
    this.initializationPromise = null;
    this.app = app;
    this.plugin = plugin;
  }
  isInitialized() {
    return this.initialized;
  }
  async initialize(timeoutMs = 1e4) {
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    if (this.initialized) {
      return;
    }
    const initPromise = this._initialize();
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Directory initialization timed out after ${timeoutMs}ms`));
      }, timeoutMs);
    });
    this.initializationPromise = Promise.race([initPromise, timeoutPromise]);
    try {
      await this.initializationPromise;
      this.initialized = true;
      this.initializationPromise = null;
    } catch (error) {
      this.initializationPromise = null;
      console.error("[SystemSculpt] Directory initialization failed with timeout:", error);
      throw error;
    }
  }
  async _initialize() {
    try {
      const settings = this.plugin.settings;
      const directories = [
        settings.chatsDirectory,
        settings.savedChatsDirectory,
        settings.recordingsDirectory,
        settings.systemPromptsDirectory,
        settings.attachmentsDirectory,
        settings.extractionsDirectory
      ];
      const needsSystemSculptDir = directories.some((dir) => dir && dir.trim() !== "" && dir.startsWith("SystemSculpt/"));
      if (needsSystemSculptDir) {
        await this.createDirectory("SystemSculpt", true);
      }
      for (const dir of directories) {
        if (dir && dir.trim() !== "") {
          try {
            await this.createDirectory(dir);
          } catch (error) {
            console.error(`[SystemSculpt] Failed to create directory ${dir}:`, error);
          }
        }
      }
      this.notifyDirectoriesReady();
    } catch (error) {
      if (!(error instanceof Error) || !error.message.includes("already exists")) {
        console.error("[SystemSculpt] Directory initialization failed:", error);
        throw error;
      } else {
        this.notifyDirectoriesReady();
      }
    }
  }
  notifyDirectoriesReady() {
    if (this.plugin.emitter && typeof this.plugin.emitter.emit === "function") {
      this.plugin.emitter.emit("directory-structure-ready");
    } else {
      const event = new CustomEvent("systemsculpt:directory-structure-ready", {
        detail: { plugin: this.plugin }
      });
      window.dispatchEvent(event);
      console.log("[SystemSculpt] Using window events for directory notifications (emitter not available)");
    }
  }
  getDirectory(key) {
    if (!this.initialized) {
      throw new Error("Directory manager not initialized. Wait for initialization to complete.");
    }
    const path = this.plugin.settings[key];
    if (!path || !this.directories.get(path)) {
      throw new Error(`Directory not available: ${key}`);
    }
    return path;
  }
  async ensureDirectoryByKey(key) {
    if (!this.initialized) {
      await this.initialize();
    }
    const path = this.plugin.settings[key];
    if (!path || path.trim() === "") {
      throw new Error(`No path configured for: ${key}`);
    }
    await this.createDirectory(path);
    return path;
  }
  async ensureDirectoryByPath(dirPath) {
    if (!this.initialized) {
      await this.initialize();
    }
    if (!dirPath || dirPath.trim() === "") {
      throw new Error("Cannot create directory: empty path provided");
    }
    await this.createDirectory(dirPath);
  }
  async handleDirectorySettingChange(key, newPath) {
    if (!this.initialized) {
      await this.initialize();
    }
    if (newPath && newPath.trim() !== "") {
      await this.createDirectory(newPath);
    }
  }
  async createDirectory(dirPath, createMarker = false, timeoutMs = 3e3, retryCount = 0) {
    if (!dirPath || dirPath.trim() === "") {
      console.error(`[SystemSculpt] Invalid directory path: "${dirPath}"`);
      throw new Error("Cannot create directory: empty or invalid path");
    }
    const normalizedPath = this.normalizePath(dirPath);
    const directoryPromise = (async () => {
      try {
        const pathParts = normalizedPath.split("/");
        if (pathParts.length > 1) {
          const parentPath = pathParts.slice(0, -1).join("/");
          await this.createDirectory(parentPath);
        }
        const exists = await this.app.vault.adapter.exists(normalizedPath);
        const folderExists = this.app.vault.getAbstractFileByPath(normalizedPath) instanceof import_obsidian100.TFolder;
        if (!exists || !folderExists) {
          await this.app.vault.createFolder(normalizedPath);
        } else {
        }
        if (createMarker) {
          const markerPath = `${normalizedPath}/.folder`;
          const markerExists = await this.app.vault.adapter.exists(markerPath);
          if (!markerExists) {
            await this.app.vault.adapter.write(markerPath, "This file helps Obsidian recognize the directory.");
          }
        }
        this.directories.set(normalizedPath, true);
      } catch (error) {
        if (!(error instanceof Error) || !error.message.includes("already exists")) {
          console.error(`[SystemSculpt] Failed to create directory: ${normalizedPath}`, error);
          throw error;
        } else {
          this.directories.set(normalizedPath, true);
        }
      }
    })();
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Directory operation timed out after ${timeoutMs}ms: ${normalizedPath}`));
      }, timeoutMs);
    });
    try {
      await Promise.race([directoryPromise, timeoutPromise]);
    } catch (error) {
      const isTimeout = error instanceof Error && error.message.includes("timed out");
      if (isTimeout && retryCount < 2) {
        const backoffMs = 1e3 * Math.pow(2, retryCount);
        console.warn(`[SystemSculpt] Directory operation timed out for ${normalizedPath}, retrying in ${backoffMs}ms (attempt ${retryCount + 1}/2)`);
        await new Promise((resolve) => setTimeout(resolve, backoffMs));
        return this.createDirectory(dirPath, createMarker, timeoutMs * 1.5, retryCount + 1);
      }
      console.error(`[SystemSculpt] Directory operation failed for ${normalizedPath}:`, error);
      if (isTimeout) {
        try {
          const exists = await this.app.vault.adapter.exists(normalizedPath);
          if (exists) {
            console.log(`[SystemSculpt] Directory ${normalizedPath} exists despite timeout, marking as available`);
            this.directories.set(normalizedPath, true);
            return;
          }
        } catch (checkError) {
          console.error(`[SystemSculpt] Failed to check directory existence:`, checkError);
        }
      }
      this.directories.set(normalizedPath, false);
      if (!dirPath.includes("System Prompts")) {
        throw error;
      } else {
        console.warn(`[SystemSculpt] Continuing without ${normalizedPath} directory`);
      }
    }
  }
  normalizePath(dirPath) {
    let path = dirPath.trim();
    path = path.replace(/^\/+|\/+$/g, "");
    path = path.replace(/\/+/g, "/");
    if (path === "") {
      return "/";
    }
    return path;
  }
  async verifyDirectories() {
    const issues = [];
    try {
      const settings = this.plugin.settings;
      const directories = [
        settings.chatsDirectory,
        settings.savedChatsDirectory,
        settings.recordingsDirectory,
        settings.systemPromptsDirectory,
        settings.attachmentsDirectory,
        settings.extractionsDirectory
      ];
      const needsSystemSculptDir = directories.some((dir) => dir && dir.trim() !== "" && dir.startsWith("SystemSculpt/"));
      if (needsSystemSculptDir) {
        const mainPath = "SystemSculpt";
        const mainExists = await this.app.vault.adapter.exists(mainPath);
        const mainFolder = this.app.vault.getAbstractFileByPath(mainPath) instanceof import_obsidian100.TFolder;
        if (!mainExists || !mainFolder) {
          issues.push(`Main directory "${mainPath}" does not exist`);
        }
      }
      for (const dir of directories) {
        if (!dir || dir.trim() === "")
          continue;
        const exists = await this.app.vault.adapter.exists(dir);
        const folder = this.app.vault.getAbstractFileByPath(dir) instanceof import_obsidian100.TFolder;
        if (!exists || !folder) {
          issues.push(`Directory "${dir}" does not exist or is not accessible`);
        }
      }
    } catch (error) {
      issues.push(`Error verifying directories: ${error.message}`);
    }
    return {
      valid: issues.length === 0,
      issues
    };
  }
  async repair() {
    try {
      this.initialized = false;
      this.initializationPromise = null;
      this.directories.clear();
      const settings = this.plugin.settings;
      const directories = [
        settings.chatsDirectory,
        settings.savedChatsDirectory,
        settings.recordingsDirectory,
        settings.systemPromptsDirectory,
        settings.attachmentsDirectory,
        settings.extractionsDirectory
      ];
      const needsSystemSculptDir = directories.some((dir) => dir && dir.trim() !== "" && dir.startsWith("SystemSculpt/"));
      if (needsSystemSculptDir) {
        await this.createDirectory("SystemSculpt", true);
      }
      await this.initialize();
      return true;
    } catch (error) {
      console.error("[SystemSculpt] Failed to repair directory structure:", error);
      return false;
    }
  }
};

// src/services/VersionCheckerService.ts
var import_obsidian101 = __toModule(require("obsidian"));
var _VersionCheckerService = class {
  constructor(currentVersion, app, plugin) {
    this.githubRepo = "systemsculpt/obsidian-systemsculpt-ai";
    this.pluginId = "systemsculpt-ai";
    this.cachedVersionInfo = null;
    this.lastChecked = 0;
    this.cacheTimeMs = 1e3 * 60 * 10;
    this.updateDrawerEl = null;
    this.periodicCheckIntervalMs = 1e3 * 60 * 10;
    this.periodicCheckTimeout = null;
    this.currentVersion = currentVersion;
    this.app = app;
    this.plugin = plugin;
  }
  static getInstance(currentVersion, app, plugin) {
    if (!_VersionCheckerService.instance) {
      if (!app || !plugin) {
        throw new Error("App and plugin must be provided when initializing VersionCheckerService");
      }
      _VersionCheckerService.instance = new _VersionCheckerService(currentVersion, app, plugin);
    }
    return _VersionCheckerService.instance;
  }
  startPeriodicUpdateCheck() {
    if (!this.plugin.settings.showUpdateNotifications) {
      return;
    }
    this.stopPeriodicUpdateCheck();
    this.periodicCheckTimeout = setInterval(() => {
      this.checkForUpdatesQuietly();
    }, this.periodicCheckIntervalMs);
  }
  stopPeriodicUpdateCheck() {
    if (this.periodicCheckTimeout) {
      clearInterval(this.periodicCheckTimeout);
      this.periodicCheckTimeout = null;
    }
  }
  async checkForUpdatesQuietly() {
    if (!this.plugin.settings.showUpdateNotifications) {
      return;
    }
    try {
      const versionInfo = await this.checkVersion(true);
      if (!versionInfo.isLatest) {
        this.showUpdateDrawer(versionInfo);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("403")) {
        console.warn("[SystemSculpt] GitHub API rate limit exceeded during periodic update check. Will retry later.");
      } else {
        console.error("[SystemSculpt] Periodic update check failed:", error);
      }
    }
  }
  async checkVersion(forceRefresh = false) {
    const now = Date.now();
    if (!forceRefresh && this.cachedVersionInfo && now - this.lastChecked < this.cacheTimeMs) {
      return this.cachedVersionInfo;
    }
    try {
      const latestVersion = await this.fetchLatestVersion();
      let isLatest = this.compareVersions(this.currentVersion, latestVersion) >= 0;
      this.cachedVersionInfo = {
        currentVersion: this.currentVersion,
        latestVersion,
        isLatest,
        releaseUrl: `https://github.com/${this.githubRepo}/releases/latest`,
        updateUrl: `obsidian://show-plugin?id=${this.pluginId}`
      };
      this.lastChecked = now;
      return this.cachedVersionInfo;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("403")) {
        console.warn("[SystemSculpt] GitHub API rate limit exceeded when checking for updates. Will retry later.");
      } else {
        console.error("[SystemSculpt] Failed to check for updates:", error);
      }
      return {
        currentVersion: this.currentVersion,
        latestVersion: "unknown",
        isLatest: true,
        releaseUrl: `https://github.com/${this.githubRepo}/releases/latest`,
        updateUrl: `obsidian://show-plugin?id=${this.pluginId}`
      };
    }
  }
  async checkForUpdatesOnStartup(delayMs = 3e3) {
    if (!this.plugin.settings.showUpdateNotifications) {
      return;
    }
    try {
      await new Promise((resolve) => setTimeout(resolve, delayMs));
      const versionInfo = await this.checkVersion();
      if (!versionInfo.isLatest) {
        this.showUpdateDrawer(versionInfo);
      }
      this.startPeriodicUpdateCheck();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("403")) {
        console.warn("[SystemSculpt] GitHub API rate limit exceeded during startup update check. Will retry later.");
      } else {
        console.error("[SystemSculpt] Failed to check for updates on startup:", error);
      }
      this.startPeriodicUpdateCheck();
    }
  }
  showUpdateDrawer(versionInfo) {
    this.removeUpdateDrawer();
    this.updateDrawerEl = document.createElement("div");
    this.updateDrawerEl.classList.add("systemsculpt-update-drawer");
    this.updateDrawerEl.setAttribute("role", "dialog");
    this.updateDrawerEl.setAttribute("aria-labelledby", "update-drawer-title");
    this.updateDrawerEl.setAttribute("aria-describedby", "update-drawer-message");
    this.updateDrawerEl.innerHTML = `
      <div class="systemsculpt-update-drawer-header">
        <div id="update-drawer-title" class="systemsculpt-update-drawer-title">SystemSculpt AI Update</div>
        <button class="systemsculpt-update-drawer-close" aria-label="Close" type="button"></button>
      </div>
      <div class="systemsculpt-update-drawer-content">
        <div id="update-drawer-message" class="systemsculpt-update-drawer-message">
          Version ${versionInfo.latestVersion} is available.
        </div>
        <div class="systemsculpt-update-drawer-versions" aria-label="Version information">
          <span class="systemsculpt-update-drawer-current">v${versionInfo.currentVersion}</span>
          <span class="systemsculpt-update-drawer-arrow">\u2192</span>
          <span class="systemsculpt-update-drawer-latest">v${versionInfo.latestVersion}</span>
        </div>
        <button class="systemsculpt-update-drawer-button" type="button">Update</button>
      </div>
    `;
    document.body.appendChild(this.updateDrawerEl);
    const closeButton = this.updateDrawerEl.querySelector(".systemsculpt-update-drawer-close");
    if (closeButton) {
      closeButton.addEventListener("click", () => {
        this.removeUpdateDrawer();
      });
      closeButton.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          this.removeUpdateDrawer();
        }
      });
    }
    const updateButton = this.updateDrawerEl.querySelector(".systemsculpt-update-drawer-button");
    if (updateButton) {
      updateButton.addEventListener("click", () => {
        this.handleUpdateButtonClick(versionInfo);
      });
      updateButton.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          this.handleUpdateButtonClick(versionInfo);
        }
      });
    }
    const handleEscape = (e) => {
      if (e.key === "Escape") {
        this.removeUpdateDrawer();
        document.removeEventListener("keydown", handleEscape);
      }
    };
    document.addEventListener("keydown", handleEscape);
    setTimeout(() => {
      if (this.updateDrawerEl) {
        this.updateDrawerEl.classList.add("visible");
      }
    }, 100);
    setTimeout(() => {
      this.removeUpdateDrawer();
    }, 2e4);
  }
  handleUpdateButtonClick(versionInfo) {
    window.open(versionInfo.updateUrl, "_blank");
    new import_obsidian101.Notice("Opening SystemSculpt AI in Community Plugins...\n\nIf nothing happens, please update manually via Settings \u2192 Community plugins", 1e4);
    this.removeUpdateDrawer();
  }
  removeUpdateDrawer() {
    if (this.updateDrawerEl) {
      this.updateDrawerEl.classList.remove("visible");
      setTimeout(() => {
        if (this.updateDrawerEl && this.updateDrawerEl.parentNode) {
          this.updateDrawerEl.parentNode.removeChild(this.updateDrawerEl);
          this.updateDrawerEl = null;
        }
      }, 300);
    }
  }
  async fetchLatestVersion() {
    const apiUrl = `https://api.github.com/repos/${this.githubRepo}/releases/latest`;
    const response = await (0, import_obsidian101.requestUrl)({
      url: apiUrl,
      method: "GET",
      headers: {
        "Accept": "application/vnd.github.v3+json",
        "User-Agent": "Obsidian-SystemSculpt"
      }
    });
    if (response.status === 403) {
      console.warn("[SystemSculpt] GitHub API rate limit exceeded (403) when checking for updates. Using current version as latest.");
      return this.currentVersion;
    }
    if (response.status !== 200) {
      throw new Error(`Failed to fetch latest version: ${response.status}`);
    }
    const data = response.json;
    let version = data.tag_name || data.name;
    if (version.startsWith("v")) {
      version = version.substring(1);
    }
    return version;
  }
  compareVersions(versionA, versionB) {
    const partsA = versionA.split(".").map((part) => parseInt(part, 10));
    const partsB = versionB.split(".").map((part) => parseInt(part, 10));
    for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
      const partA = i < partsA.length ? partsA[i] : 0;
      const partB = i < partsB.length ? partsB[i] : 0;
      if (partA > partB)
        return 1;
      if (partA < partB)
        return -1;
    }
    return 0;
  }
  onUpdateNotificationsEnabled() {
    if (this.plugin.settings.showUpdateNotifications) {
      this.startPeriodicUpdateCheck();
      this.checkForUpdatesOnStartup(1e3);
    }
  }
  onUpdateNotificationsDisabled() {
    this.stopPeriodicUpdateCheck();
    this.removeUpdateDrawer();
  }
  unload() {
    this.stopPeriodicUpdateCheck();
    this.removeUpdateDrawer();
  }
  static clearInstance() {
    if (_VersionCheckerService.instance) {
      _VersionCheckerService.instance.unload();
      _VersionCheckerService.instance = null;
    }
  }
};
var VersionCheckerService = _VersionCheckerService;
VersionCheckerService.instance = null;

// src/main.ts
init_FavoritesService();

// src/core/storage/StorageManager.ts
var import_obsidian102 = __toModule(require("obsidian"));
var StorageManager = class {
  constructor(app, plugin) {
    this.hiddenBasePath = ".systemsculpt";
    this.initialized = false;
    this.initializationPromise = null;
    this.createdDirectories = new Set();
    this.app = app;
    this.plugin = plugin;
  }
  async initialize() {
    if (this.initialized) {
      return;
    }
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    this.initializationPromise = this._initialize();
    try {
      await this.initializationPromise;
      this.initialized = true;
    } catch (error) {
      console.error("[SystemSculpt] Storage initialization failed:", error);
      throw error;
    } finally {
      this.initializationPromise = null;
    }
  }
  async _initialize() {
    try {
      await this.ensureDirectory(this.hiddenBasePath);
      await Promise.all([
        this.ensureDirectory(this.getPath("settings")),
        this.ensureDirectory(this.getPath("settings", "backups")),
        this.ensureDirectory(this.getPath("settings", "emergency")),
        this.ensureDirectory(this.getPath("embeddings")),
        this.ensureDirectory(this.getPath("cache")),
        this.ensureDirectory(this.getPath("temp"))
      ]);
    } catch (error) {
      console.error("[SystemSculpt] Failed to initialize storage system:", error);
      throw error;
    }
  }
  isInitialized() {
    return this.initialized;
  }
  getPath(type, ...subPath) {
    const basePath = `${this.hiddenBasePath}/${type}`;
    return subPath.length > 0 ? `${basePath}/${subPath.join("/")}` : basePath;
  }
  async ensureDirectory(path, createMarker = false) {
    const normalizedPath = path.replace(/\\/g, "/");
    if (this.createdDirectories.has(normalizedPath)) {
      return;
    }
    try {
      const pathParts = normalizedPath.split("/");
      if (pathParts.length > 1) {
        const parentPath = pathParts.slice(0, -1).join("/");
        if (parentPath) {
          await this.ensureDirectory(parentPath);
        }
      }
      const exists = await this.app.vault.adapter.exists(normalizedPath);
      const folderExists = this.app.vault.getAbstractFileByPath(normalizedPath) instanceof import_obsidian102.TFolder;
      if (!exists || !folderExists) {
        await this.app.vault.createFolder(normalizedPath);
      }
      if (createMarker) {
        const markerPath = `${normalizedPath}/.folder`;
        const markerExists = await this.app.vault.adapter.exists(markerPath);
        if (!markerExists) {
          await this.app.vault.adapter.write(markerPath, "This file helps Obsidian recognize the directory.");
        }
      }
      this.createdDirectories.add(normalizedPath);
    } catch (error) {
      if (!(error instanceof Error) || !error.message.includes("already exists")) {
        console.error(`[SystemSculpt] Failed to create directory: ${normalizedPath}`, error);
        throw error;
      } else {
        this.createdDirectories.add(normalizedPath);
      }
    }
  }
  async writeFile(type, fileName, data) {
    try {
      await this.initialize();
      const path = this.getPath(type, fileName);
      const content = typeof data === "string" ? data : JSON.stringify(data, null, 2);
      await this.app.vault.adapter.write(path, content);
      return { success: true, path };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`[SystemSculpt] Failed to write file: ${type}/${fileName}`, error);
      return { success: false, error: errorMessage };
    }
  }
  async readFile(type, fileName, parseJson = false) {
    try {
      const path = this.getPath(type, fileName);
      const exists = await this.app.vault.adapter.exists(path);
      if (!exists) {
        return null;
      }
      const content = await this.app.vault.adapter.read(path);
      if (parseJson) {
        return JSON.parse(content);
      }
      return content;
    } catch (error) {
      console.error(`[SystemSculpt] Failed to read file: ${type}/${fileName}`, error);
      return null;
    }
  }
  async deleteFile(type, fileName) {
    try {
      const path = this.getPath(type, fileName);
      const exists = await this.app.vault.adapter.exists(path);
      if (!exists) {
        return { success: true, path };
      }
      await this.app.vault.adapter.remove(path);
      return { success: true, path };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`[SystemSculpt] Failed to delete file: ${type}/${fileName}`, error);
      return { success: false, error: errorMessage };
    }
  }
  async listFiles(type, subPath = "") {
    try {
      const path = subPath ? this.getPath(type, subPath) : this.getPath(type);
      const exists = await this.app.vault.adapter.exists(path);
      if (!exists) {
        return [];
      }
      const files = await this.app.vault.adapter.list(path);
      return files.files.map((f) => f.split("/").pop() || "");
    } catch (error) {
      console.error(`[SystemSculpt] Failed to list files in: ${type}/${subPath}`, error);
      return [];
    }
  }
};

// src/views/chatview/ResumeChatService.ts
var import_obsidian103 = __toModule(require("obsidian"));
var ResumeChatService = class {
  constructor(plugin) {
    this.listeners = [];
    this.plugin = plugin;
    this.app = plugin.app;
    this.settings = plugin.settings;
    this.registerWorkspaceEvents();
  }
  registerWorkspaceEvents() {
    this.plugin.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
      if (leaf) {
        this.handleLeafChange(leaf);
      }
    }));
    this.plugin.registerEvent(this.app.workspace.on("layout-change", () => {
      this.app.workspace.iterateAllLeaves((leaf) => {
        this.handleLeafChange(leaf);
      });
    }));
    this.plugin.registerEvent(this.app.metadataCache.on("changed", (file) => {
      if (this.isChatHistoryFile(file)) {
        this.app.workspace.iterateAllLeaves((leaf) => {
          var _a;
          if (leaf.view instanceof import_obsidian103.MarkdownView && ((_a = leaf.view.file) == null ? void 0 : _a.path) === file.path) {
            this.handleLeafChange(leaf);
          }
        });
      }
    }));
  }
  async handleLeafChange(leaf) {
    const view = leaf.view;
    if (!(view instanceof import_obsidian103.MarkdownView))
      return;
    const file = view.file;
    const editorContainer = view.contentEl.querySelector(".cm-editor");
    const readerContainer = view.contentEl;
    if (editorContainer) {
      editorContainer.querySelectorAll(".systemsculpt-resume-chat-button").forEach((el) => el.remove());
    }
    if (readerContainer) {
      readerContainer.querySelectorAll(".systemsculpt-resume-chat-button").forEach((el) => el.remove());
    }
    if (!file || !this.isChatHistoryFile(file))
      return;
    const contentContainer = view.getMode() === "source" ? editorContainer : readerContainer;
    if (!contentContainer)
      return;
    const chatId = this.extractChatId(file);
    if (!chatId)
      return;
    const buttonContainer = this.createResumeChatButton(chatId, file);
    contentContainer.insertBefore(buttonContainer, contentContainer.firstChild);
    console.log("[SystemSculpt] Resume chat button added for chat:", chatId);
  }
  isChatHistoryFile(file) {
    const chatsDirectory = this.settings.chatsDirectory || "SystemSculpt/Chats";
    if (!file.path.startsWith(chatsDirectory))
      return false;
    if (!file.path.endsWith(".md"))
      return false;
    const cache = this.app.metadataCache.getCache(file.path);
    if (!(cache == null ? void 0 : cache.frontmatter))
      return false;
    const metadata = cache.frontmatter;
    return !!(metadata.id && metadata.model && (metadata.created || metadata.lastModified));
  }
  extractChatId(file) {
    var _a;
    const cache = this.app.metadataCache.getCache(file.path);
    if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.id) {
      return cache.frontmatter.id;
    }
    const filename = file.basename;
    return filename || null;
  }
  getModelFromFile(file) {
    var _a;
    const cache = this.app.metadataCache.getCache(file.path);
    return ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.model) || this.plugin.settings.selectedModelId;
  }
  createResumeChatButton(chatId, file) {
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "systemsculpt-resume-chat-button";
    const button = document.createElement("button");
    button.className = "systemsculpt-resume-chat-btn";
    button.textContent = "Resume this chat";
    const selectedModelId = this.getModelFromFile(file);
    const clickHandler = async () => {
      await this.openChat(chatId, selectedModelId);
    };
    this.registerListener(button, "click", clickHandler);
    buttonContainer.appendChild(button);
    return buttonContainer;
  }
  async openChat(chatId, selectedModelId) {
    try {
      const { workspace } = this.app;
      const leaf = workspace.getLeaf("tab");
      await leaf.setViewState({
        type: CHAT_VIEW_TYPE,
        state: {
          chatId,
          selectedModelId
        }
      });
      workspace.setActiveLeaf(leaf, { focus: true });
    } catch (e) {
      console.error("[SystemSculpt] Failed to open chat view:", e);
      new import_obsidian103.Notice("Error opening chat. Please try again.");
    }
  }
  registerListener(element, type, listener) {
    element.addEventListener(type, listener);
    this.listeners.push({ element, type, listener });
  }
  cleanup() {
    this.listeners.forEach(({ element, type, listener }) => {
      element.removeEventListener(type, listener);
    });
    this.listeners = [];
  }
};

// src/services/SystemSculptEmbeddings/EmbeddingsManager.ts
var import_obsidian104 = __toModule(require("obsidian"));

// src/services/PerformanceIntegrationService.ts
init_AdaptivePerformanceManager();
init_MemoryPressureMonitor();

// src/services/DeviceCapabilityDetector.ts
var _DeviceCapabilityDetector = class {
  constructor() {
    this.deviceProfile = null;
    this.benchmarkCache = new Map();
    this.isTestRunning = false;
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _DeviceCapabilityDetector();
    }
    return this.instance;
  }
  async getDeviceProfile(forceRefresh = false) {
    if (this.deviceProfile && !forceRefresh) {
      return this.deviceProfile;
    }
    const specs = await this.detectDeviceSpecs();
    const benchmarks = await this.runBenchmarks();
    this.deviceProfile = this.createDeviceProfile(specs, benchmarks);
    return this.deviceProfile;
  }
  async detectDeviceSpecs() {
    var _a, _b, _c;
    const userAgent = navigator.userAgent.toLowerCase();
    const isMobile = this.detectMobile();
    const isTablet = this.detectTablet();
    const cpuCores = navigator.hardwareConcurrency || this.estimateCpuCores();
    const memoryEstimateMB = this.estimateMemory();
    const gpuInfo = this.detectGPU();
    const browserEngine = this.detectBrowserEngine();
    const supportsWorkers = typeof Worker !== "undefined";
    const supportsOffscreenCanvas = typeof OffscreenCanvas !== "undefined";
    const supportsWebAssembly = typeof WebAssembly !== "undefined";
    const supportsSharedArrayBuffer = typeof SharedArrayBuffer !== "undefined";
    const connectionType = this.detectConnectionType();
    const isOnline = navigator.onLine;
    const screenWidth = ((_a = window.screen) == null ? void 0 : _a.width) || window.innerWidth;
    const screenHeight = ((_b = window.screen) == null ? void 0 : _b.height) || window.innerHeight;
    const pixelRatio = window.devicePixelRatio || 1;
    const colorDepth = ((_c = window.screen) == null ? void 0 : _c.colorDepth) || 24;
    const renderingCapability = this.estimateRenderingCapability(isMobile, cpuCores, memoryEstimateMB);
    const computationSpeed = this.estimateComputationSpeed(cpuCores, memoryEstimateMB);
    const memoryEfficiency = this.estimateMemoryEfficiency(memoryEstimateMB, isMobile);
    return {
      cpuCores,
      memoryEstimateMB,
      gpuInfo,
      isMobile,
      isTablet,
      renderingCapability,
      computationSpeed,
      memoryEfficiency,
      browserEngine,
      supportsWorkers,
      supportsOffscreenCanvas,
      supportsWebAssembly,
      supportsSharedArrayBuffer,
      connectionType,
      isOnline,
      screenWidth,
      screenHeight,
      pixelRatio,
      colorDepth
    };
  }
  async runBenchmarks() {
    if (this.isTestRunning) {
      throw new Error("Benchmark already running");
    }
    this.isTestRunning = true;
    const startTime = Date.now();
    try {
      const [
        cpuSingleCore,
        memoryAllocation,
        memoryAccess,
        canvasRendering,
        domManipulation
      ] = await Promise.all([
        this.benchmarkCPUSingleCore(),
        this.benchmarkMemoryAllocation(),
        this.benchmarkMemoryAccess(),
        this.benchmarkCanvasRendering(),
        this.benchmarkDOMManipulation()
      ]);
      let cpuMultiCore;
      try {
        if (typeof Worker !== "undefined" && navigator.hardwareConcurrency > 1) {
          cpuMultiCore = await this.benchmarkCPUMultiCore();
        }
      } catch (error) {
        console.warn("[DeviceCapabilityDetector] Multi-core test failed:", error);
      }
      const testDuration = Date.now() - startTime;
      const overallScore = this.calculateOverallScore({
        cpuSingleCore,
        cpuMultiCore,
        memoryAllocation,
        memoryAccess,
        canvasRendering,
        domManipulation
      });
      const responsiveness = this.calculateResponsiveness(canvasRendering, domManipulation);
      const testReliability = this.calculateTestReliability(testDuration);
      const results = {
        cpuSingleCore,
        cpuMultiCore,
        memoryAllocation,
        memoryAccess,
        canvasRendering,
        domManipulation,
        overallScore,
        responsiveness,
        testDuration,
        testReliability
      };
      const cacheKey = this.generateCacheKey();
      this.benchmarkCache.set(cacheKey, results);
      return results;
    } finally {
      this.isTestRunning = false;
    }
  }
  async benchmarkCPUSingleCore() {
    return new Promise((resolve) => {
      const startTime = performance.now();
      const testDuration = 100;
      let operations = 0;
      const doWork = () => {
        const batchSize = 1e3;
        for (let i = 0; i < batchSize; i++) {
          Math.sqrt(Math.random() * 1e6);
          operations++;
        }
        if (performance.now() - startTime < testDuration) {
          setTimeout(doWork, 0);
        } else {
          const actualDuration = performance.now() - startTime;
          const operationsPerSecond = operations / actualDuration * 1e3;
          resolve(operationsPerSecond);
        }
      };
      doWork();
    });
  }
  async benchmarkCPUMultiCore() {
    const workerCount = Math.min(navigator.hardwareConcurrency, 4);
    const testDuration = 150;
    return new Promise((resolve, reject) => {
      const workers = [];
      const results = [];
      let completedWorkers = 0;
      const workerCode = `
        self.onmessage = function(e) {
          const testDuration = e.data;
          const startTime = performance.now();
          let operations = 0;
          
          while (performance.now() - startTime < testDuration) {
            for (let i = 0; i < 1000; i++) {
              Math.sqrt(Math.random() * 1000000);
              operations++;
            }
          }
          
          const actualDuration = performance.now() - startTime;
          const operationsPerSecond = (operations / actualDuration) * 1000;
          self.postMessage(operationsPerSecond);
        };
      `;
      try {
        for (let i = 0; i < workerCount; i++) {
          const blob = new Blob([workerCode], { type: "application/javascript" });
          const worker = new Worker(URL.createObjectURL(blob));
          worker.onmessage = (e) => {
            results[i] = e.data;
            completedWorkers++;
            if (completedWorkers === workerCount) {
              workers.forEach((w) => w.terminate());
              const totalOps = results.reduce((sum, ops) => sum + ops, 0);
              resolve(totalOps);
            }
          };
          worker.onerror = (error) => {
            console.warn("[DeviceCapabilityDetector] Worker error:", error);
            workers.forEach((w) => w.terminate());
            reject(error);
          };
          workers.push(worker);
          worker.postMessage(testDuration);
        }
        setTimeout(() => {
          if (completedWorkers < workerCount) {
            workers.forEach((w) => w.terminate());
            reject(new Error("Worker benchmark timeout"));
          }
        }, testDuration + 1e3);
      } catch (error) {
        reject(error);
      }
    });
  }
  async benchmarkMemoryAllocation() {
    const startTime = performance.now();
    const arrays = [];
    const targetDuration = 50;
    let totalBytes = 0;
    while (performance.now() - startTime < targetDuration) {
      const arraySize = 1e4;
      const array = new Array(arraySize).fill(Math.random());
      arrays.push(array);
      totalBytes += arraySize * 8;
      if (arrays.length % 10 === 0) {
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
    }
    const actualDuration = performance.now() - startTime;
    const mbPerSecond = totalBytes / 1024 / 1024 / (actualDuration / 1e3);
    arrays.length = 0;
    return mbPerSecond;
  }
  async benchmarkMemoryAccess() {
    const arraySize = 1e5;
    const array = new Array(arraySize);
    for (let i = 0; i < arraySize; i++) {
      array[i] = Math.random();
    }
    const startTime = performance.now();
    const testDuration = 50;
    let operations = 0;
    while (performance.now() - startTime < testDuration) {
      for (let i = 0; i < 1e3; i++) {
        const index = Math.floor(Math.random() * arraySize);
        array[index] = Math.random();
        operations++;
      }
      if (operations % 1e4 === 0) {
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
    }
    const actualDuration = performance.now() - startTime;
    const mbPerSecond = operations * 8 / 1024 / 1024 / (actualDuration / 1e3);
    return mbPerSecond;
  }
  async benchmarkCanvasRendering() {
    const canvas = document.createElement("canvas");
    canvas.width = 200;
    canvas.height = 200;
    const ctx = canvas.getContext("2d");
    if (!ctx)
      return 0;
    const startTime = performance.now();
    const testDuration = 100;
    let frames = 0;
    const renderFrame = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < 10; i++) {
        ctx.fillStyle = `hsl(${Math.random() * 360}, 50%, 50%)`;
        ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 20, 20);
      }
      frames++;
      if (performance.now() - startTime < testDuration) {
        requestAnimationFrame(renderFrame);
      }
    };
    return new Promise((resolve) => {
      renderFrame();
      setTimeout(() => {
        const actualDuration = performance.now() - startTime;
        const fps = frames / actualDuration * 1e3;
        resolve(fps);
      }, testDuration + 10);
    });
  }
  async benchmarkDOMManipulation() {
    const container = document.createElement("div");
    container.style.position = "absolute";
    container.style.top = "-9999px";
    document.body.appendChild(container);
    const startTime = performance.now();
    const testDuration = 50;
    let operations = 0;
    try {
      while (performance.now() - startTime < testDuration) {
        for (let i = 0; i < 10; i++) {
          const div = document.createElement("div");
          div.textContent = `Test ${operations}`;
          div.className = "test-element";
          container.appendChild(div);
          operations++;
        }
        const children = container.children;
        for (let i = 0; i < Math.min(children.length, 5); i++) {
          const child = children[i];
          child.style.background = `hsl(${Math.random() * 360}, 50%, 50%)`;
          operations++;
        }
        while (container.children.length > 50) {
          container.removeChild(container.firstChild);
          operations++;
        }
        if (operations % 50 === 0) {
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
      }
      const actualDuration = performance.now() - startTime;
      const operationsPerSecond = operations / actualDuration * 1e3;
      return operationsPerSecond;
    } finally {
      document.body.removeChild(container);
    }
  }
  calculateOverallScore(results) {
    const weights = {
      cpuSingleCore: 0.3,
      cpuMultiCore: 0.2,
      memoryAllocation: 0.15,
      memoryAccess: 0.15,
      canvasRendering: 0.1,
      domManipulation: 0.1
    };
    const normalized = {
      cpuSingleCore: Math.min((results.cpuSingleCore || 0) / 1e4, 1),
      cpuMultiCore: Math.min((results.cpuMultiCore || 0) / 4e4, 1),
      memoryAllocation: Math.min((results.memoryAllocation || 0) / 1e3, 1),
      memoryAccess: Math.min((results.memoryAccess || 0) / 500, 1),
      canvasRendering: Math.min((results.canvasRendering || 0) / 60, 1),
      domManipulation: Math.min((results.domManipulation || 0) / 5e3, 1)
    };
    let score = 0;
    let totalWeight = 0;
    Object.entries(weights).forEach(([key, weight]) => {
      const normalizedValue = normalized[key];
      if (normalizedValue !== void 0) {
        score += normalizedValue * weight * 100;
        totalWeight += weight;
      }
    });
    return totalWeight > 0 ? score / totalWeight : 0;
  }
  calculateResponsiveness(canvasRendering, domManipulation) {
    const canvasScore = Math.min(canvasRendering / 30, 1) * 50;
    const domScore = Math.min(domManipulation / 2e3, 1) * 50;
    return canvasScore + domScore;
  }
  calculateTestReliability(testDuration) {
    const minDuration = 200;
    const maxDuration = 2e3;
    if (testDuration < minDuration)
      return 0.5;
    if (testDuration > maxDuration)
      return 0.7;
    return 0.9;
  }
  createDeviceProfile(specs, benchmarks) {
    const category = this.categorizeDevice(specs, benchmarks);
    const recommendedSettings = this.generateRecommendedSettings(category, specs, benchmarks);
    const confidence = this.calculateDetectionConfidence(specs, benchmarks);
    return {
      category,
      capabilities: specs,
      benchmarks,
      recommendedSettings,
      confidence
    };
  }
  categorizeDevice(specs, benchmarks) {
    if (specs.isMobile && !specs.isTablet) {
      if (benchmarks.overallScore >= 70)
        return "low-mobile";
      return "low-mobile";
    }
    if (specs.isTablet) {
      if (benchmarks.overallScore >= 60)
        return "high-tablet";
      if (benchmarks.overallScore >= 40)
        return "mid-tablet";
      return "low-mobile";
    }
    if (benchmarks.overallScore >= 80)
      return "high-end-desktop";
    if (benchmarks.overallScore >= 50)
      return "mid-desktop";
    return "low-desktop";
  }
  generateRecommendedSettings(category, specs, benchmarks) {
    const baseSettings = {
      "high-end-desktop": {
        maxBatchSize: 32,
        yieldFrequency: 16,
        enableBackgroundProcessing: true,
        enableParallelProcessing: true,
        cacheStrategy: "aggressive",
        uiUpdateFrequency: 16
      },
      "mid-desktop": {
        maxBatchSize: 16,
        yieldFrequency: 8,
        enableBackgroundProcessing: true,
        enableParallelProcessing: true,
        cacheStrategy: "moderate",
        uiUpdateFrequency: 32
      },
      "low-desktop": {
        maxBatchSize: 8,
        yieldFrequency: 4,
        enableBackgroundProcessing: true,
        enableParallelProcessing: false,
        cacheStrategy: "conservative",
        uiUpdateFrequency: 50
      },
      "high-tablet": {
        maxBatchSize: 8,
        yieldFrequency: 4,
        enableBackgroundProcessing: true,
        enableParallelProcessing: false,
        cacheStrategy: "moderate",
        uiUpdateFrequency: 50
      },
      "mid-tablet": {
        maxBatchSize: 4,
        yieldFrequency: 2,
        enableBackgroundProcessing: false,
        enableParallelProcessing: false,
        cacheStrategy: "conservative",
        uiUpdateFrequency: 100
      },
      "low-mobile": {
        maxBatchSize: 2,
        yieldFrequency: 1,
        enableBackgroundProcessing: false,
        enableParallelProcessing: false,
        cacheStrategy: "conservative",
        uiUpdateFrequency: 200
      }
    };
    return baseSettings[category];
  }
  calculateDetectionConfidence(specs, benchmarks) {
    let confidence = 0.5;
    if (specs.cpuCores > 0)
      confidence += 0.1;
    if (specs.memoryEstimateMB > 0)
      confidence += 0.1;
    if (benchmarks.testReliability > 0.8)
      confidence += 0.2;
    if (benchmarks.testDuration > 200)
      confidence += 0.1;
    return Math.min(confidence, 1);
  }
  detectMobile() {
    var _a;
    return typeof window !== "undefined" && (((_a = window.app) == null ? void 0 : _a.isMobile) || /Android|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
  }
  detectTablet() {
    const ua = navigator.userAgent;
    const isTabletUA = /iPad|Android(?!.*Mobile)|Tablet/i.test(ua);
    const hasLargeScreen = window.screen && Math.max(window.screen.width, window.screen.height) >= 768;
    return isTabletUA || hasLargeScreen && this.detectMobile();
  }
  estimateCpuCores() {
    const ua = navigator.userAgent.toLowerCase();
    if (ua.includes("mobile") || ua.includes("android"))
      return 4;
    return 4;
  }
  estimateMemory() {
    const memory = performance.memory;
    if (memory == null ? void 0 : memory.jsHeapSizeLimit) {
      return Math.round(memory.jsHeapSizeLimit * 8 / 1024 / 1024);
    }
    if (this.detectMobile())
      return 2e3;
    return 8e3;
  }
  detectGPU() {
    try {
      const canvas = document.createElement("canvas");
      const gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
      if (gl) {
        const webglCtx = gl;
        const debugInfo = webglCtx.getExtension("WEBGL_debug_renderer_info");
        if (debugInfo) {
          return webglCtx.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
        }
      }
    } catch (error) {
    }
    return void 0;
  }
  detectBrowserEngine() {
    const ua = navigator.userAgent.toLowerCase();
    if (ua.includes("webkit") && ua.includes("chrome"))
      return "chromium";
    if (ua.includes("webkit"))
      return "webkit";
    if (ua.includes("gecko"))
      return "gecko";
    return "unknown";
  }
  detectConnectionType() {
    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    if (connection == null ? void 0 : connection.effectiveType) {
      return connection.effectiveType;
    }
    return "unknown";
  }
  estimateRenderingCapability(isMobile, cpuCores, memoryMB) {
    if (isMobile)
      return "low";
    if (cpuCores >= 8 && memoryMB >= 8e3)
      return "very-high";
    if (cpuCores >= 4 && memoryMB >= 4e3)
      return "high";
    if (cpuCores >= 2 && memoryMB >= 2e3)
      return "medium";
    return "low";
  }
  estimateComputationSpeed(cpuCores, memoryMB) {
    const score = cpuCores * 2 + memoryMB / 1e3;
    if (score >= 20)
      return "very-fast";
    if (score >= 12)
      return "fast";
    if (score >= 6)
      return "normal";
    return "slow";
  }
  estimateMemoryEfficiency(memoryMB, isMobile) {
    if (isMobile) {
      return memoryMB >= 4e3 ? "good" : "poor";
    } else {
      if (memoryMB >= 16e3)
        return "excellent";
      if (memoryMB >= 8e3)
        return "good";
      return "poor";
    }
  }
  generateCacheKey() {
    const ua = navigator.userAgent;
    const cores = navigator.hardwareConcurrency || 0;
    return `device-${btoa(ua).slice(0, 10)}-${cores}`;
  }
  getQuickAssessment() {
    const isMobile = this.detectMobile();
    const cpuCores = navigator.hardwareConcurrency || this.estimateCpuCores();
    const memoryEstimateMB = this.estimateMemory();
    const category = isMobile ? "low-mobile" : cpuCores >= 4 && memoryEstimateMB >= 8e3 ? "mid-desktop" : "low-desktop";
    return {
      category,
      capabilities: {
        cpuCores,
        memoryEstimateMB,
        isMobile,
        isTablet: this.detectTablet()
      },
      confidence: 0.6
    };
  }
  getCachedBenchmarks() {
    const cacheKey = this.generateCacheKey();
    return this.benchmarkCache.get(cacheKey) || null;
  }
  clearCache() {
    this.benchmarkCache.clear();
    this.deviceProfile = null;
  }
};
var DeviceCapabilityDetector = _DeviceCapabilityDetector;
DeviceCapabilityDetector.instance = null;

// src/services/NetworkAwareProcessor.ts
var _NetworkAwareProcessor = class {
  constructor() {
    this.networkProfile = null;
    this.requestQueue = new Map();
    this.activeRequests = new Set();
    this.retryQueue = new Map();
    this.batchingQueues = new Map();
    this.connectionMonitor = null;
    this.networkHistory = [];
    this.maxHistorySize = 20;
    this.metrics = {
      requestsInFlight: 0,
      averageResponseTime: 0,
      successRate: 1,
      errorRate: 0,
      retryRate: 0,
      bandwidthUtilization: 0,
      lastUpdate: Date.now()
    };
    this.startNetworkMonitoring();
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _NetworkAwareProcessor();
    }
    return this.instance;
  }
  async getNetworkProfile(forceRefresh = false) {
    if (this.networkProfile && !forceRefresh) {
      return this.networkProfile;
    }
    const conditions = await this.detectNetworkConditions();
    this.networkProfile = this.createNetworkProfile(conditions);
    return this.networkProfile;
  }
  async detectNetworkConditions() {
    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    let connectionType = "unknown";
    let effectiveType = "4g";
    let downlink = 1;
    let rtt = 100;
    if (connection) {
      connectionType = connection.type || connection.effectiveType || "unknown";
      effectiveType = connection.effectiveType || "4g";
      downlink = connection.downlink || 1;
      rtt = connection.rtt || 100;
    }
    if (connectionType === "unknown") {
      connectionType = this.fallbackConnectionDetection();
    }
    const measuredRtt = await this.measureNetworkLatency();
    if (measuredRtt > 0) {
      rtt = measuredRtt;
    }
    const conditions = {
      connectionType,
      effectiveType,
      downlink,
      rtt,
      isOnline: navigator.onLine,
      saveData: (connection == null ? void 0 : connection.saveData) || false,
      timestamp: Date.now()
    };
    this.recordNetworkConditions(conditions);
    return conditions;
  }
  fallbackConnectionDetection() {
    const ua = navigator.userAgent.toLowerCase();
    if (/mobile|android|iphone|ipad/.test(ua)) {
      return "4g";
    }
    return "wifi";
  }
  async measureNetworkLatency() {
    try {
      const start = performance.now();
      const testUrl = "data:text/plain;base64,dGVzdA==";
      try {
        await fetch(testUrl, {
          method: "HEAD",
          cache: "no-cache"
        });
      } catch (error) {
      }
      const end = performance.now();
      const baselineTime = end - start;
      return baselineTime < 10 ? 50 : 100;
    } catch (error) {
      return 50;
    }
  }
  recordNetworkConditions(conditions) {
    this.networkHistory.push(conditions);
    if (this.networkHistory.length > this.maxHistorySize) {
      this.networkHistory.shift();
    }
  }
  createNetworkProfile(conditions) {
    const quality = this.assessNetworkQuality(conditions);
    const reliability = this.calculateNetworkReliability();
    const latency = this.classifyLatency(conditions.rtt);
    const bandwidth = this.classifyBandwidth(conditions.downlink);
    const recommendedSettings = this.generateNetworkSettings(quality, conditions);
    return {
      quality,
      reliability,
      latency,
      bandwidth,
      recommendedSettings
    };
  }
  assessNetworkQuality(conditions) {
    if (!conditions.isOnline)
      return "poor";
    let score = 0;
    const typeScores = {
      "ethernet": 100,
      "wifi": 90,
      "4g": 70,
      "3g": 40,
      "2g": 20,
      "slow-2g": 10,
      "unknown": 50
    };
    score += typeScores[conditions.connectionType] || 50;
    score += Math.min(conditions.downlink * 10, 100);
    const latencyScore = Math.max(0, 100 - conditions.rtt / 2);
    score += latencyScore;
    if (conditions.saveData) {
      score *= 0.7;
    }
    const finalScore = score / 3;
    if (finalScore >= 80)
      return "excellent";
    if (finalScore >= 60)
      return "good";
    if (finalScore >= 40)
      return "fair";
    return "poor";
  }
  calculateNetworkReliability() {
    var _a;
    if (this.networkHistory.length < 3)
      return 0.8;
    const recentHistory = this.networkHistory.slice(-10);
    let onlineCount = 0;
    let stableConnections = 0;
    let lastConnectionType = (_a = recentHistory[0]) == null ? void 0 : _a.connectionType;
    recentHistory.forEach((condition) => {
      if (condition.isOnline)
        onlineCount++;
      if (condition.connectionType === lastConnectionType)
        stableConnections++;
      lastConnectionType = condition.connectionType;
    });
    const onlineRate = onlineCount / recentHistory.length;
    const stabilityRate = stableConnections / recentHistory.length;
    return (onlineRate + stabilityRate) / 2;
  }
  classifyLatency(rtt) {
    if (rtt <= 50)
      return "low";
    if (rtt <= 150)
      return "medium";
    return "high";
  }
  classifyBandwidth(downlink) {
    if (downlink >= 10)
      return "high";
    if (downlink >= 1)
      return "moderate";
    return "limited";
  }
  generateNetworkSettings(quality, conditions) {
    const baseSettings = {
      poor: {
        maxConcurrentRequests: 1,
        requestTimeout: 3e4,
        retryDelay: 2e3,
        maxRetries: 5,
        enableRequestBatching: true,
        batchSize: 1,
        enablePrefetching: false,
        enableCaching: true
      },
      fair: {
        maxConcurrentRequests: 2,
        requestTimeout: 15e3,
        retryDelay: 1e3,
        maxRetries: 3,
        enableRequestBatching: true,
        batchSize: 3,
        enablePrefetching: false,
        enableCaching: true
      },
      good: {
        maxConcurrentRequests: 4,
        requestTimeout: 1e4,
        retryDelay: 500,
        maxRetries: 2,
        enableRequestBatching: true,
        batchSize: 5,
        enablePrefetching: true,
        enableCaching: true
      },
      excellent: {
        maxConcurrentRequests: 8,
        requestTimeout: 5e3,
        retryDelay: 200,
        maxRetries: 1,
        enableRequestBatching: false,
        batchSize: 1,
        enablePrefetching: true,
        enableCaching: true
      }
    };
    const settings = { ...baseSettings[quality] };
    if (conditions.saveData) {
      settings.maxConcurrentRequests = Math.max(1, Math.floor(settings.maxConcurrentRequests / 2));
      settings.enablePrefetching = false;
      settings.batchSize = Math.max(1, settings.batchSize * 2);
    }
    return settings;
  }
  async processRequest(requestFn, options = { priority: "normal" }) {
    var _a, _b;
    const profile = await this.getNetworkProfile();
    const requestId = this.generateRequestId();
    const timeout = options.timeout || profile.recommendedSettings.requestTimeout;
    const maxRetries = (_a = options.retries) != null ? _a : profile.recommendedSettings.maxRetries;
    const enableBatching = (_b = options.enableBatching) != null ? _b : profile.recommendedSettings.enableRequestBatching;
    if (enableBatching && options.priority !== "critical") {
      return this.addToBatch(requestFn, options, requestId);
    }
    return this.executeRequest(requestFn, requestId, timeout, maxRetries);
  }
  async executeRequest(requestFn, requestId, timeout, maxRetries) {
    this.activeRequests.add(requestId);
    this.metrics.requestsInFlight++;
    const startTime = Date.now();
    try {
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Request timeout")), timeout);
      });
      const result = await Promise.race([requestFn(), timeoutPromise]);
      const responseTime = Date.now() - startTime;
      this.updateMetrics("success", responseTime);
      return result;
    } catch (error) {
      const responseTime = Date.now() - startTime;
      this.updateMetrics("error", responseTime);
      if (maxRetries > 0 && this.shouldRetry(error)) {
        console.log(`[NetworkAwareProcessor] Retrying request ${requestId} (${maxRetries} retries left)`);
        const profile = await this.getNetworkProfile();
        await new Promise((resolve) => setTimeout(resolve, profile.recommendedSettings.retryDelay));
        return this.executeRequest(requestFn, requestId, timeout, maxRetries - 1);
      }
      throw error;
    } finally {
      this.activeRequests.delete(requestId);
      this.metrics.requestsInFlight--;
    }
  }
  async addToBatch(requestFn, options, requestId) {
    const batchKey = options.priority || "normal";
    if (!this.batchingQueues.has(batchKey)) {
      this.batchingQueues.set(batchKey, []);
    }
    return new Promise((resolve, reject) => {
      this.batchingQueues.get(batchKey).push({
        requestId,
        requestFn,
        options,
        resolve,
        reject
      });
      this.scheduleBatchProcessing(batchKey);
    });
  }
  scheduleBatchProcessing(batchKey) {
    const profile = this.networkProfile;
    if (!profile)
      return;
    const batchSize = profile.recommendedSettings.batchSize;
    const currentBatch = this.batchingQueues.get(batchKey) || [];
    if (currentBatch.length >= batchSize) {
      this.processBatch(batchKey);
      return;
    }
    setTimeout(() => {
      if (this.batchingQueues.has(batchKey) && this.batchingQueues.get(batchKey).length > 0) {
        this.processBatch(batchKey);
      }
    }, 100);
  }
  async processBatch(batchKey) {
    const batch = this.batchingQueues.get(batchKey) || [];
    if (batch.length === 0)
      return;
    this.batchingQueues.set(batchKey, []);
    console.log(`[NetworkAwareProcessor] Processing batch of ${batch.length} requests`);
    const profile = await this.getNetworkProfile();
    const maxConcurrent = Math.min(profile.recommendedSettings.maxConcurrentRequests, batch.length);
    const chunks = this.chunkArray(batch, maxConcurrent);
    for (const chunk of chunks) {
      await Promise.allSettled(chunk.map(async (item) => {
        var _a;
        try {
          const result = await this.executeRequest(item.requestFn, item.requestId, item.options.timeout || profile.recommendedSettings.requestTimeout, (_a = item.options.retries) != null ? _a : profile.recommendedSettings.maxRetries);
          item.resolve(result);
        } catch (error) {
          item.reject(error);
        }
      }));
      if (chunks.length > 1) {
        await new Promise((resolve) => setTimeout(resolve, 50));
      }
    }
  }
  shouldRetry(error) {
    const retryableErrors = [
      "NetworkError",
      "TimeoutError",
      "AbortError",
      "Request timeout",
      "Failed to fetch"
    ];
    const errorMessage = error.message.toLowerCase();
    return retryableErrors.some((retryable) => errorMessage.includes(retryable.toLowerCase()));
  }
  updateMetrics(type, responseTime) {
    const alpha = 0.1;
    this.metrics.averageResponseTime = this.metrics.averageResponseTime * (1 - alpha) + responseTime * alpha;
    if (type === "success") {
      this.metrics.successRate = this.metrics.successRate * (1 - alpha) + 1 * alpha;
      this.metrics.errorRate = this.metrics.errorRate * (1 - alpha) + 0 * alpha;
    } else {
      this.metrics.successRate = this.metrics.successRate * (1 - alpha) + 0 * alpha;
      this.metrics.errorRate = this.metrics.errorRate * (1 - alpha) + 1 * alpha;
    }
    this.metrics.lastUpdate = Date.now();
  }
  startNetworkMonitoring() {
    if (this.connectionMonitor)
      return;
    this.connectionMonitor = window.setInterval(async () => {
      await this.detectNetworkConditions();
    }, 3e4);
    window.addEventListener("online", () => {
      console.log("[NetworkAwareProcessor] Network connection restored");
      this.detectNetworkConditions();
    });
    window.addEventListener("offline", () => {
      console.log("[NetworkAwareProcessor] Network connection lost");
      this.detectNetworkConditions();
    });
    const connection = navigator.connection;
    if (connection) {
      connection.addEventListener("change", () => {
        console.log("[NetworkAwareProcessor] Network connection changed");
        this.detectNetworkConditions();
      });
    }
  }
  chunkArray(array, chunkSize) {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }
  generateRequestId() {
    return `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  getNetworkMetrics() {
    return { ...this.metrics };
  }
  getNetworkHistory() {
    return [...this.networkHistory];
  }
  isNetworkSuitableFor(operationType) {
    if (!this.networkProfile)
      return true;
    const suitability = {
      light: ["poor", "fair", "good", "excellent"],
      medium: ["fair", "good", "excellent"],
      heavy: ["good", "excellent"]
    };
    return suitability[operationType].includes(this.networkProfile.quality);
  }
  getRecommendedDelay(operationType) {
    if (!this.networkProfile)
      return 0;
    const delays = {
      poor: { light: 1e3, medium: 3e3, heavy: 1e4 },
      fair: { light: 500, medium: 1500, heavy: 5e3 },
      good: { light: 100, medium: 500, heavy: 1e3 },
      excellent: { light: 0, medium: 0, heavy: 0 }
    };
    return delays[this.networkProfile.quality][operationType];
  }
  stopMonitoring() {
    if (this.connectionMonitor) {
      clearInterval(this.connectionMonitor);
      this.connectionMonitor = null;
    }
  }
  destroy() {
    this.stopMonitoring();
    this.requestQueue.clear();
    this.activeRequests.clear();
    this.retryQueue.clear();
    this.batchingQueues.clear();
    this.networkHistory.length = 0;
    _NetworkAwareProcessor.instance = null;
    console.log("[NetworkAwareProcessor] Destroyed");
  }
};
var NetworkAwareProcessor = _NetworkAwareProcessor;
NetworkAwareProcessor.instance = null;

// src/services/BackgroundTaskQueue.ts
var _BackgroundTaskQueue = class {
  constructor() {
    this.queue = new Map();
    this.currentTask = null;
    this.isProcessing = false;
    this.isPaused = false;
    this.eventListeners = new Map();
    this.abortControllers = new Map();
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _BackgroundTaskQueue();
    }
    return this.instance;
  }
  async addTask(task) {
    const taskId = task.id || this.generateTaskId(task.name);
    const status = {
      id: taskId,
      name: task.name,
      status: "queued",
      progress: {
        completed: 0,
        total: task.data.length,
        percentage: 0
      },
      retryCount: 0
    };
    this.queue.set(taskId, status);
    this.emitEvent("started", taskId, status);
    console.log(`[BackgroundTaskQueue] Added task: ${task.name} (${task.data.length} items)`);
    if (!this.isProcessing) {
      this.startProcessing();
    }
    return taskId;
  }
  async startProcessing() {
    if (this.isProcessing)
      return;
    this.isProcessing = true;
    console.log("[BackgroundTaskQueue] Started processing queue");
    while (this.queue.size > 0 && !this.isPaused) {
      const nextTask = this.getNextTask();
      if (!nextTask)
        break;
      this.currentTask = nextTask.id;
      await this.processTask(nextTask);
      this.currentTask = null;
    }
    this.isProcessing = false;
    console.log("[BackgroundTaskQueue] Finished processing queue");
  }
  getNextTask() {
    const queuedTasks = Array.from(this.queue.values()).filter((task) => task.status === "queued");
    if (queuedTasks.length === 0)
      return null;
    queuedTasks.sort((a, b) => {
      const priorityOrder = { high: 3, normal: 2, low: 1 };
      const aTaskData = this.getTaskData(a.id);
      const bTaskData = this.getTaskData(b.id);
      const aPriority = priorityOrder[(aTaskData == null ? void 0 : aTaskData.priority) || "normal"] || 2;
      const bPriority = priorityOrder[(bTaskData == null ? void 0 : bTaskData.priority) || "normal"] || 2;
      if (aPriority !== bPriority) {
        return bPriority - aPriority;
      }
      return (a.startTime || 0) - (b.startTime || 0);
    });
    return queuedTasks[0];
  }
  async processTask(taskStatus) {
    const taskData = this.getTaskData(taskStatus.id);
    if (!taskData) {
      this.failTask(taskStatus.id, new Error("Task data not found"));
      return;
    }
    const abortController = new AbortController();
    this.abortControllers.set(taskStatus.id, abortController);
    try {
      taskStatus.status = "running";
      taskStatus.startTime = Date.now();
      this.emitEvent("started", taskStatus.id, taskStatus);
      const result = await this.processTaskData(taskData, taskStatus, abortController.signal);
      if (!abortController.signal.aborted) {
        taskStatus.status = "completed";
        taskStatus.endTime = Date.now();
        taskStatus.result = result;
        this.emitEvent("completed", taskStatus.id, taskStatus);
        console.log(`[BackgroundTaskQueue] Completed task: ${taskStatus.name}`);
      }
    } catch (error) {
      if (abortController.signal.aborted) {
        taskStatus.status = "cancelled";
        this.emitEvent("cancelled", taskStatus.id, taskStatus);
        console.log(`[BackgroundTaskQueue] Cancelled task: ${taskStatus.name}`);
      } else {
        await this.handleTaskError(taskStatus, error, taskData);
      }
    } finally {
      this.abortControllers.delete(taskStatus.id);
    }
  }
  async processTaskData(task, status, abortSignal) {
    const startTime = Date.now();
    const results = [];
    let yieldCount = 0;
    const items = task.data;
    const options = task.options || {};
    const { AdaptivePerformanceManager: AdaptivePerformanceManager2 } = await Promise.resolve().then(() => (init_AdaptivePerformanceManager(), AdaptivePerformanceManager_exports));
    const { MemoryPressureMonitor: MemoryPressureMonitor2 } = await Promise.resolve().then(() => (init_MemoryPressureMonitor(), MemoryPressureMonitor_exports));
    const perfManager = AdaptivePerformanceManager2.getInstance();
    const memoryMonitor = MemoryPressureMonitor2.getInstance();
    let currentIndex = 0;
    let consecutiveErrors = 0;
    const maxConsecutiveErrors = 3;
    while (currentIndex < items.length && !abortSignal.aborted) {
      if (memoryMonitor.isMemoryConstrained()) {
        console.log("[BackgroundTaskQueue] Pausing due to memory pressure");
        await memoryMonitor.checkNow();
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      let batchSize = perfManager.getCurrentBatchSize();
      if (options.maxBatchSize) {
        batchSize = Math.min(batchSize, options.maxBatchSize);
      }
      batchSize = memoryMonitor.getRecommendedBatchSize(batchSize);
      batchSize = Math.min(batchSize, items.length - currentIndex);
      if (batchSize <= 0)
        break;
      perfManager.startOperation();
      try {
        const batchItems = items.slice(currentIndex, currentIndex + batchSize);
        const batchResults = await task.processor(batchItems, currentIndex, batchSize);
        results.push(...batchResults);
        currentIndex += batchSize;
        consecutiveErrors = 0;
        perfManager.endOperation(batchSize);
        status.progress.completed = currentIndex;
        status.progress.percentage = currentIndex / items.length * 100;
        const elapsed = Date.now() - startTime;
        const rate = currentIndex / elapsed;
        const remaining = items.length - currentIndex;
        status.progress.estimatedTimeRemaining = remaining / rate;
        status.progress.currentOperation = `Processing ${currentIndex}/${items.length}`;
        if (options.enableProgress !== false) {
          this.emitEvent("progress", status.id, status);
        }
        await perfManager.yieldControl();
        yieldCount++;
        if (options.yieldFrequency && currentIndex % options.yieldFrequency === 0) {
          await new Promise((resolve) => setTimeout(resolve, 1));
        }
      } catch (error) {
        console.warn(`[BackgroundTaskQueue] Batch processing error:`, error);
        consecutiveErrors++;
        if (consecutiveErrors >= maxConsecutiveErrors) {
          throw new Error(`Too many consecutive errors (${maxConsecutiveErrors})`);
        }
        perfManager.reset();
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      if (this.isPaused) {
        status.status = "paused";
        this.emitEvent("paused", status.id, status);
        while (this.isPaused && !abortSignal.aborted) {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
        if (!abortSignal.aborted) {
          status.status = "running";
          this.emitEvent("resumed", status.id, status);
        }
      }
    }
    const totalTime = Date.now() - startTime;
    const metrics = {
      totalTimeMs: totalTime,
      itemsProcessed: currentIndex,
      averageTimePerItem: totalTime / currentIndex,
      yieldCount
    };
    return {
      success: !abortSignal.aborted && currentIndex === items.length,
      data: results,
      metrics
    };
  }
  async handleTaskError(status, error, task) {
    var _a, _b;
    const maxRetries = ((_a = task.options) == null ? void 0 : _a.maxRetries) || 2;
    const retryDelay = ((_b = task.options) == null ? void 0 : _b.retryDelay) || 1e3;
    status.retryCount = (status.retryCount || 0) + 1;
    if (status.retryCount <= maxRetries) {
      console.log(`[BackgroundTaskQueue] Retrying task ${status.name} (attempt ${status.retryCount}/${maxRetries})`);
      status.status = "queued";
      await new Promise((resolve) => setTimeout(resolve, retryDelay));
    } else {
      this.failTask(status.id, error);
    }
  }
  failTask(taskId, error) {
    const status = this.queue.get(taskId);
    if (status) {
      status.status = "failed";
      status.error = error;
      status.endTime = Date.now();
      this.emitEvent("failed", taskId, status);
      console.error(`[BackgroundTaskQueue] Task failed: ${status.name}`, error);
    }
  }
  cancelTask(taskId) {
    const status = this.queue.get(taskId);
    if (!status)
      return false;
    if (status.status === "running") {
      const controller = this.abortControllers.get(taskId);
      if (controller) {
        controller.abort();
      }
    } else if (status.status === "queued") {
      status.status = "cancelled";
      this.emitEvent("cancelled", taskId, status);
    }
    return true;
  }
  pauseAll() {
    this.isPaused = true;
    console.log("[BackgroundTaskQueue] Paused all task processing");
  }
  resumeAll() {
    this.isPaused = false;
    console.log("[BackgroundTaskQueue] Resumed task processing");
    if (!this.isProcessing && this.queue.size > 0) {
      this.startProcessing();
    }
  }
  getTaskStatus(taskId) {
    return this.queue.get(taskId) || null;
  }
  getAllTasks() {
    return Array.from(this.queue.values());
  }
  getQueuedCount() {
    return Array.from(this.queue.values()).filter((task) => task.status === "queued").length;
  }
  getRunningCount() {
    return Array.from(this.queue.values()).filter((task) => task.status === "running").length;
  }
  clearCompleted() {
    const completedTasks = Array.from(this.queue.entries()).filter(([_, task]) => task.status === "completed" || task.status === "failed" || task.status === "cancelled");
    completedTasks.forEach(([taskId]) => {
      this.queue.delete(taskId);
      this.abortControllers.delete(taskId);
    });
    if (completedTasks.length > 0) {
      console.log(`[BackgroundTaskQueue] Cleared ${completedTasks.length} completed tasks`);
    }
    return completedTasks.length;
  }
  addEventListener(taskId, listener) {
    if (!this.eventListeners.has(taskId)) {
      this.eventListeners.set(taskId, []);
    }
    this.eventListeners.get(taskId).push(listener);
  }
  removeEventListener(taskId, listener) {
    const listeners = this.eventListeners.get(taskId);
    if (listeners) {
      const index = listeners.indexOf(listener);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    }
  }
  emitEvent(type, taskId, status) {
    const event = {
      type,
      taskId,
      status: { ...status },
      timestamp: Date.now()
    };
    const listeners = this.eventListeners.get(taskId);
    if (listeners) {
      listeners.forEach((listener) => {
        try {
          listener(event);
        } catch (error) {
          console.warn("[BackgroundTaskQueue] Error in event listener:", error);
        }
      });
    }
    const globalListeners = this.eventListeners.get("*");
    if (globalListeners) {
      globalListeners.forEach((listener) => {
        try {
          listener(event);
        } catch (error) {
          console.warn("[BackgroundTaskQueue] Error in global event listener:", error);
        }
      });
    }
  }
  generateTaskId(taskName) {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `${taskName.replace(/\s+/g, "-").toLowerCase()}-${timestamp}-${random}`;
  }
  getTaskData(taskId) {
    return null;
  }
  getQueueSummary() {
    const queued = this.getQueuedCount();
    const running = this.getRunningCount();
    const total = this.queue.size;
    return `Queue: ${running} running, ${queued} queued, ${total} total tasks`;
  }
  destroy() {
    this.abortControllers.forEach((controller) => controller.abort());
    this.queue.clear();
    this.abortControllers.clear();
    this.eventListeners.clear();
    this.isProcessing = false;
    this.isPaused = false;
    this.currentTask = null;
    _BackgroundTaskQueue.instance = null;
    console.log("[BackgroundTaskQueue] Destroyed");
  }
};
var BackgroundTaskQueue = _BackgroundTaskQueue;
BackgroundTaskQueue.instance = null;

// src/services/PerformanceIntegrationService.ts
var _PerformanceIntegrationService = class {
  constructor(plugin) {
    this.isInitialized = false;
    this.monitoringInterval = null;
    this.plugin = plugin;
    this.performanceManager = AdaptivePerformanceManager.getInstance();
    this.memoryMonitor = MemoryPressureMonitor.getInstance();
    this.deviceDetector = DeviceCapabilityDetector.getInstance();
    this.networkProcessor = NetworkAwareProcessor.getInstance();
    this.taskQueue = BackgroundTaskQueue.getInstance();
    this.optimizationSettings = this.getDefaultSettings();
  }
  static getInstance(plugin) {
    if (!this.instance) {
      this.instance = new _PerformanceIntegrationService(plugin);
    }
    return this.instance;
  }
  async initialize() {
    if (this.isInitialized)
      return;
    try {
      const quickProfile = this.deviceDetector.getQuickAssessment();
      this.applyInitialOptimizations(quickProfile);
      await this.startBackgroundSystems();
      this.integrateWithExistingServices();
      this.startPerformanceMonitoring();
      this.runFullBenchmarksInBackground();
      this.isInitialized = true;
    } catch (error) {
      this.isInitialized = true;
    }
  }
  getDefaultSettings() {
    return {
      embeddingsBatchSize: 5,
      embeddingsYieldFrequency: 2,
      embeddingsMaxConcurrent: 2,
      embeddingsEnableBackgroundProcessing: true,
      embeddingsMemoryThreshold: 70,
      chatVirtualizationEnabled: true,
      chatMessageBatchSize: 20,
      chatRenderingThrottle: 100,
      chatAutoScrollEnabled: true,
      searchResultsBatchSize: 10,
      searchMaxResults: 50,
      searchEnableCaching: true,
      searchParallelProcessing: false,
      networkRequestBatching: true,
      networkRetryStrategy: "moderate",
      networkRequestTimeout: 1e4,
      memoryCacheSizeLimit: 50,
      memoryAutoClearEnabled: true,
      memoryPressureThreshold: 80,
      mobileOptimizationEnabled: true,
      lowPowerModeEnabled: false
    };
  }
  applyInitialOptimizations(deviceProfile) {
    var _a, _b;
    if (!deviceProfile.capabilities)
      return;
    const isMobile = deviceProfile.capabilities.isMobile;
    const isLowEnd = ((_a = deviceProfile.category) == null ? void 0 : _a.includes("low")) || ((_b = deviceProfile.category) == null ? void 0 : _b.includes("mobile"));
    if (isMobile || isLowEnd) {
      this.optimizationSettings.embeddingsBatchSize = 2;
      this.optimizationSettings.embeddingsYieldFrequency = 1;
      this.optimizationSettings.embeddingsMaxConcurrent = 1;
      this.optimizationSettings.chatMessageBatchSize = 10;
      this.optimizationSettings.chatRenderingThrottle = 200;
      this.optimizationSettings.searchResultsBatchSize = 5;
      this.optimizationSettings.searchMaxResults = 20;
      this.optimizationSettings.memoryCacheSizeLimit = 20;
      this.optimizationSettings.mobileOptimizationEnabled = true;
    }
  }
  async startBackgroundSystems() {
  }
  integrateWithExistingServices() {
  }
  startPerformanceMonitoring() {
    this.monitoringInterval = window.setInterval(async () => {
      try {
        const state = this.performanceManager.getPerformanceState();
        const recentMetrics = state.history[state.history.length - 1];
        if (recentMetrics) {
          await this.adaptToPerformance(recentMetrics);
        }
        await this.performanceCleanup();
      } catch (error) {
      }
    }, 3e4);
  }
  runFullBenchmarksInBackground() {
    setTimeout(async () => {
      try {
        const fullProfile = await this.deviceDetector.getDeviceProfile(true);
        await this.applyAdvancedOptimizations(fullProfile);
      } catch (error) {
      }
    }, 5e3);
  }
  async applyAdvancedOptimizations(deviceProfile) {
    var _a;
    const settings = deviceProfile.recommendedSettings;
    if (!settings)
      return;
    this.optimizationSettings.embeddingsBatchSize = Math.min(settings.maxBatchSize || 5, 32);
    this.optimizationSettings.embeddingsYieldFrequency = settings.yieldFrequency || 2;
    this.optimizationSettings.embeddingsEnableBackgroundProcessing = (_a = settings.enableBackgroundProcessing) != null ? _a : true;
    const networkProfile = await this.networkProcessor.getNetworkProfile();
    this.optimizationSettings.networkRequestBatching = networkProfile.recommendedSettings.enableRequestBatching;
    this.optimizationSettings.networkRequestTimeout = networkProfile.recommendedSettings.requestTimeout;
  }
  handleMemoryPressure(level, stats) {
    switch (level) {
      case "medium":
        this.optimizationSettings.memoryCacheSizeLimit *= 0.8;
        this.optimizationSettings.embeddingsBatchSize = Math.max(1, Math.floor(this.optimizationSettings.embeddingsBatchSize * 0.8));
        break;
      case "high":
        this.optimizationSettings.memoryCacheSizeLimit *= 0.6;
        this.optimizationSettings.embeddingsBatchSize = Math.max(1, Math.floor(this.optimizationSettings.embeddingsBatchSize * 0.6));
        this.optimizationSettings.chatMessageBatchSize = Math.max(5, Math.floor(this.optimizationSettings.chatMessageBatchSize * 0.7));
        break;
      case "critical":
        this.optimizationSettings.memoryCacheSizeLimit = 10;
        this.optimizationSettings.embeddingsBatchSize = 1;
        this.optimizationSettings.chatMessageBatchSize = 5;
        this.optimizationSettings.searchResultsBatchSize = 3;
        this.taskQueue.addTask({
          id: "emergency-cleanup",
          name: "emergency-cleanup",
          priority: "high",
          processor: async () => {
            await this.emergencyCleanup();
            return [];
          },
          data: []
        });
        break;
    }
  }
  async adaptToPerformance(metrics) {
    if (metrics.eventLoopLag > 100) {
      this.optimizationSettings.embeddingsBatchSize = Math.max(1, this.optimizationSettings.embeddingsBatchSize - 1);
      this.optimizationSettings.embeddingsYieldFrequency = Math.max(1, this.optimizationSettings.embeddingsYieldFrequency - 1);
      this.optimizationSettings.chatRenderingThrottle += 50;
    }
    if (metrics.memoryUsedMB > this.optimizationSettings.memoryCacheSizeLimit) {
      await this.clearCaches();
    }
  }
  async performanceCleanup() {
    this.taskQueue.clearCompleted();
  }
  async emergencyCleanup() {
    await this.clearCaches();
    this.taskQueue.pauseAll();
    if (window.gc) {
      window.gc();
    }
  }
  async clearCaches() {
  }
  getEmbeddingsOptimization() {
    return {
      batchSize: this.optimizationSettings.embeddingsBatchSize,
      yieldFrequency: this.optimizationSettings.embeddingsYieldFrequency,
      maxConcurrent: this.optimizationSettings.embeddingsMaxConcurrent,
      enableBackgroundProcessing: this.optimizationSettings.embeddingsEnableBackgroundProcessing,
      memoryThreshold: this.optimizationSettings.embeddingsMemoryThreshold
    };
  }
  getChatOptimization() {
    return {
      virtualizationEnabled: this.optimizationSettings.chatVirtualizationEnabled,
      messageBatchSize: this.optimizationSettings.chatMessageBatchSize,
      renderingThrottle: this.optimizationSettings.chatRenderingThrottle,
      autoScrollEnabled: this.optimizationSettings.chatAutoScrollEnabled
    };
  }
  getSearchOptimization() {
    return {
      resultsBatchSize: this.optimizationSettings.searchResultsBatchSize,
      maxResults: this.optimizationSettings.searchMaxResults,
      enableCaching: this.optimizationSettings.searchEnableCaching,
      parallelProcessing: this.optimizationSettings.searchParallelProcessing
    };
  }
  getNetworkOptimization() {
    return {
      requestBatching: this.optimizationSettings.networkRequestBatching,
      retryStrategy: this.optimizationSettings.networkRetryStrategy,
      requestTimeout: this.optimizationSettings.networkRequestTimeout
    };
  }
  async processWithAdaptivePerformance(operation, options) {
    const { operationType, priority = "normal", enableBackground = true } = options;
    const networkDelay = this.networkProcessor.getRecommendedDelay(operationType === "embeddings" ? "heavy" : operationType === "search" ? "medium" : "light");
    if (networkDelay > 0) {
      await new Promise((resolve) => setTimeout(resolve, networkDelay));
    }
    if (operationType === "network") {
      return this.networkProcessor.processRequest(operation, { priority });
    }
    try {
      const result = await operation();
      this.performanceManager.endOperation(1);
      return result;
    } catch (error) {
      this.performanceManager.endOperation(0);
      throw error;
    }
  }
  shouldThrottleOperation(operationType) {
    if (operationType === "network") {
      return !this.networkProcessor.isNetworkSuitableFor("heavy");
    }
    return false;
  }
  getPerformanceStatus() {
    return {
      deviceCategory: "unknown",
      memoryPressure: "normal",
      networkQuality: "unknown",
      taskQueueLoad: 0,
      optimizationLevel: this.optimizationSettings.mobileOptimizationEnabled ? "mobile" : "desktop"
    };
  }
  destroy() {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }
    this.memoryMonitor.destroy();
    this.networkProcessor.destroy();
    this.taskQueue.destroy();
    _PerformanceIntegrationService.instance = null;
  }
};
var PerformanceIntegrationService = _PerformanceIntegrationService;
PerformanceIntegrationService.instance = null;

// src/services/SystemSculptEmbeddings/EmbeddingsManager.ts
var EMBEDDINGS_CONFIG = {
  VERSION: "4.0",
  MODEL: "voyage-3-large",
  DB_NAME: "SystemSculptEmbeddings",
  DB_VERSION: 4,
  CACHE_SIZE: 50,
  FILE_SIZE_LIMIT: 5 * 1024 * 1024,
  CONTENT_SAMPLE_SIZE: 8192,
  MIN_CONTENT_LENGTH: 100,
  CHUNK_SIZE: 2048,
  CHUNK_OVERLAP: 400,
  EXCERPT_LENGTH: 200,
  TIMEOUTS: {
    MODEL_MIGRATION: 1e3,
    DB_RETRY: 1e3,
    PROCESSING_INTERVAL: 3e4,
    COOLDOWN: 3e4
  }
};
function createEmptyEmbeddingsData() {
  return {
    version: EMBEDDINGS_CONFIG.VERSION,
    model: EMBEDDINGS_CONFIG.MODEL,
    files: {}
  };
}
var EmbeddingsManager = class {
  constructor(app, provider, plugin, model = EMBEDDINGS_CONFIG.MODEL) {
    this.app = app;
    this.provider = provider;
    this.plugin = plugin;
    this.model = model;
    this.data = null;
    this.cache = new Map();
    this.maxCacheSize = EMBEDDINGS_CONFIG.CACHE_SIZE;
    this.isProcessing = false;
    this.progress = { current: 0, total: 0 };
    this.autoProcessingEnabled = false;
    this.processingCheckInterval = null;
    this.db = null;
    this.dbName = EMBEDDINGS_CONFIG.DB_NAME;
    this.dbVersion = EMBEDDINGS_CONFIG.DB_VERSION;
    this.lastProcessedFiles = new Set();
    this.processingCooldown = new Map();
    this.model = EMBEDDINGS_CONFIG.MODEL;
    this.performanceService = PerformanceIntegrationService.getInstance(plugin);
  }
  async initialize() {
    if (this.db)
      return;
    try {
      await this.performanceService.initialize();
      await this.initializeDB();
      this.data = createEmptyEmbeddingsData();
      await this.loadMetadata();
      const allFiles = this.app.vault.getMarkdownFiles();
      const validFiles = allFiles.filter((file) => !this.shouldExcludeFile(file));
      await this.cleanupStaleData(validFiles);
    } catch (error) {
      console.error("[Embeddings] Failed to initialize:", error);
      this.data = createEmptyEmbeddingsData();
    }
  }
  async initializeDB() {
    return new Promise((resolve, reject) => {
      const checkRequest = indexedDB.open(this.dbName);
      checkRequest.onerror = () => {
        this.openWithVersion().then(resolve).catch(reject);
      };
      checkRequest.onsuccess = () => {
        const checkDb = checkRequest.result;
        const currentVersion = checkDb.version;
        checkDb.close();
        if (currentVersion > this.dbVersion) {
          this.dbVersion = currentVersion;
        }
        this.openWithVersion().then(resolve).catch(reject);
      };
    });
  }
  async openWithVersion() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        if (!this.verifyDatabaseSchema()) {
          this.db.close();
          this.recreateDatabase().then(resolve).catch(reject);
          return;
        }
        resolve();
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        const oldVersion = event.oldVersion;
        for (let i = db.objectStoreNames.length - 1; i >= 0; i--) {
          const storeName = db.objectStoreNames[i];
          db.deleteObjectStore(storeName);
        }
        const filesStore = db.createObjectStore("files", { keyPath: "path" });
        filesStore.createIndex("mtime", "mtime");
        const embeddingsStore = db.createObjectStore("embeddings", { keyPath: "path" });
      };
    });
  }
  verifyDatabaseSchema() {
    if (!this.db)
      return false;
    const requiredStores = ["files", "embeddings"];
    for (const storeName of requiredStores) {
      if (!this.db.objectStoreNames.contains(storeName)) {
        return false;
      }
    }
    return true;
  }
  async recreateDatabase() {
    await this.deleteDatabase();
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        console.log("[Embeddings] Database recreated successfully");
        resolve();
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        for (let i = db.objectStoreNames.length - 1; i >= 0; i--) {
          const storeName = db.objectStoreNames[i];
          db.deleteObjectStore(storeName);
        }
        const filesStore = db.createObjectStore("files", { keyPath: "path" });
        filesStore.createIndex("mtime", "mtime");
        const embeddingsStore = db.createObjectStore("embeddings", { keyPath: "path" });
        console.log("[Embeddings] Database schema recreated with version", this.dbVersion);
      };
    });
  }
  async deleteDatabase() {
    return new Promise((resolve, reject) => {
      const deleteRequest = indexedDB.deleteDatabase(this.dbName);
      deleteRequest.onsuccess = () => resolve();
      deleteRequest.onerror = () => reject(deleteRequest.error);
      deleteRequest.onblocked = () => {
        console.warn("[Embeddings] Database deletion blocked, retrying...");
        setTimeout(() => this.deleteDatabase().then(resolve).catch(reject), EMBEDDINGS_CONFIG.TIMEOUTS.DB_RETRY);
      };
    });
  }
  async loadMetadata() {
    if (!this.db || !this.data)
      return;
    return new Promise((resolve, reject) => {
      try {
        if (!this.verifyDatabaseSchema()) {
          console.log("[Embeddings] Schema invalid during metadata load, skipping...");
          resolve();
          return;
        }
        const transaction = this.db.transaction(["files"], "readonly");
        const store = transaction.objectStore("files");
        const request = store.getAll();
        request.onsuccess = () => {
          const files = request.result;
          for (const file of files) {
            this.data.files[file.path] = {
              mtime: file.mtime,
              embedding: [],
              chunks: []
            };
          }
          resolve();
        };
        request.onerror = () => reject(request.error);
        transaction.onerror = () => {
          console.error("[Embeddings] Transaction error during metadata load:", transaction.error);
          resolve();
        };
      } catch (error) {
        console.error("[Embeddings] Error creating transaction for metadata load:", error);
        resolve();
      }
    });
  }
  async processSpecificFiles(files) {
    if (this.isProcessing) {
      return;
    }
    if (!this.plugin.settings.embeddingsEnabled || !this.autoProcessingEnabled) {
      if (files.length >= 5) {
        console.log(`[Embeddings] Processing cancelled - embeddings disabled (${files.length} files queued)`);
      }
      return;
    }
    this.isProcessing = true;
    try {
      await this.initialize();
      if (!this.data) {
        this.isProcessing = false;
        return;
      }
      const existingFiles = files.filter((file) => {
        const exists = this.app.vault.getAbstractFileByPath(file.path);
        if (!exists) {
          console.warn(`[Embeddings] Skipping non-existent file: ${file.path}`);
          if (this.data && this.data.files[file.path]) {
            delete this.data.files[file.path];
          }
          return false;
        }
        return true;
      });
      if (existingFiles.length === 0) {
        return;
      }
      const embeddingsOptimization = this.performanceService.getEmbeddingsOptimization();
      const batchSize = Math.max(2, embeddingsOptimization.batchSize - 3);
      for (let i = 0; i < existingFiles.length; i += batchSize) {
        if (!this.plugin.settings.embeddingsEnabled || !this.autoProcessingEnabled) {
          break;
        }
        const batch = existingFiles.slice(i, i + batchSize);
        await this.processBatch(batch);
      }
    } catch (error) {
      console.error("[Embeddings] Error processing specific files:", error);
    } finally {
      this.isProcessing = false;
    }
  }
  getTotalProcessableFiles() {
    const allFiles = this.app.vault.getMarkdownFiles();
    return allFiles.filter((file) => !this.shouldExcludeFile(file)).length;
  }
  async getFilesWithEmbeddingsCount() {
    await this.initialize();
    if (!this.data || !this.db)
      return 0;
    const allFiles = this.app.vault.getMarkdownFiles();
    const validPaths = new Set(allFiles.filter((file) => !this.shouldExcludeFile(file)).map((file) => file.path));
    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction(["embeddings"], "readonly");
        const store = transaction.objectStore("embeddings");
        const request = store.getAllKeys();
        request.onsuccess = () => {
          const keys = request.result;
          const count = keys.filter((key) => validPaths.has(key)).length;
          resolve(count);
        };
        request.onerror = () => reject(request.error);
        transaction.onerror = () => reject(transaction.error);
      } catch (error) {
        console.error("[Embeddings] Error in getFilesWithEmbeddingsCount:", error);
        resolve(0);
      }
    });
  }
  async hasActualEmbedding(filePath) {
    if (!this.db)
      return false;
    return new Promise((resolve) => {
      try {
        const transaction = this.db.transaction(["embeddings"], "readonly");
        const store = transaction.objectStore("embeddings");
        const request = store.get(filePath);
        request.onsuccess = () => {
          const result = request.result;
          resolve(!!(result && result.embedding && result.embedding.length > 0));
        };
        request.onerror = () => resolve(false);
      } catch (e) {
        resolve(false);
      }
    });
  }
  shouldExcludeFile(file) {
    const settings = this.plugin.settings;
    const exclusions = settings.embeddingsExclusions || {
      folders: [],
      patterns: [],
      ignoreChatHistory: true,
      respectObsidianExclusions: true
    };
    if (exclusions.ignoreChatHistory !== false) {
      const chatsDirectory = settings.chatsDirectory || "SystemSculpt/Chats";
      if (file.path.startsWith(chatsDirectory + "/") && file.extension === "md") {
        return true;
      }
    }
    if (exclusions.respectObsidianExclusions) {
      try {
        const userIgnoreFilters = this.app.vault.getConfig("userIgnoreFilters");
        if (userIgnoreFilters && Array.isArray(userIgnoreFilters)) {
          for (const pattern of userIgnoreFilters) {
            try {
              const regex = new RegExp(pattern);
              if (regex.test(file.path)) {
                return true;
              }
            } catch (e) {
            }
          }
        }
      } catch (e) {
      }
    }
    if (file.path.startsWith(".obsidian/") || file.path.includes("node_modules/")) {
      return true;
    }
    const systemDirs = [
      "SystemSculpt/Recordings",
      "SystemSculpt/System Prompts",
      "SystemSculpt/Attachments",
      "SystemSculpt/Extractions"
    ];
    for (const dir of systemDirs) {
      if (file.path.startsWith(dir + "/")) {
        return true;
      }
    }
    if (exclusions.folders) {
      for (const folder of exclusions.folders) {
        if (folder && file.path.startsWith(folder + "/")) {
          return true;
        }
      }
    }
    if (exclusions.patterns) {
      for (const pattern of exclusions.patterns) {
        try {
          const regex = new RegExp(pattern);
          if (regex.test(file.path)) {
            return true;
          }
        } catch (e) {
        }
      }
    }
    return false;
  }
  async processVault(onProgress) {
    if (this.isProcessing) {
      new import_obsidian104.Notice("Embeddings processing already in progress");
      return;
    }
    this.isProcessing = true;
    this.onProgressCallback = onProgress;
    try {
      await this.initialize();
      if (!this.data)
        return;
      const allFiles = this.app.vault.getMarkdownFiles();
      const files = allFiles.filter((file) => !this.shouldExcludeFile(file));
      const toProcess = [];
      for (const file of files) {
        const existing = this.data.files[file.path];
        if (!existing || existing.mtime < file.stat.mtime) {
          toProcess.push(file);
        }
      }
      if (toProcess.length === 0) {
        new import_obsidian104.Notice("All files are up to date");
        return;
      }
      this.progress = { current: 0, total: toProcess.length };
      this.updateProgress();
      const embeddingsOptimization = this.performanceService.getEmbeddingsOptimization();
      const batchSize = embeddingsOptimization.batchSize;
      for (let i = 0; i < toProcess.length; i += batchSize) {
        if (!this.plugin.settings.embeddingsEnabled || !this.autoProcessingEnabled) {
          console.log("[Embeddings] Processing stopped - embeddings disabled");
          break;
        }
        const batch = toProcess.slice(i, i + batchSize);
        await this.processBatch(batch);
        this.progress.current = Math.min(i + batchSize, toProcess.length);
        this.updateProgress();
        if ((i + batchSize) % 50 === 0) {
          console.log(`[Embeddings] Processed: ${this.progress.current}/${this.progress.total} files`);
        }
      }
      const currentPaths = new Set(files.map((f) => f.path));
      const deletedPaths = [];
      for (const path in this.data.files) {
        if (!currentPaths.has(path)) {
          delete this.data.files[path];
          deletedPaths.push(path);
        }
      }
      if (deletedPaths.length > 0) {
        await this.removeDeletedFilesFromIndexedDB(deletedPaths);
        console.log(`[Embeddings] Cleaned up ${deletedPaths.length} deleted files`);
      }
      new import_obsidian104.Notice(`Processed ${toProcess.length} files`);
    } finally {
      this.isProcessing = false;
      this.progress = { current: 0, total: 0 };
    }
  }
  async processBatch(files) {
    var _a;
    if (!this.plugin.settings.embeddingsEnabled || !this.autoProcessingEnabled) {
      if (files.length >= 3) {
        console.log(`[Embeddings] Batch processing cancelled - embeddings disabled (${files.length} files in batch)`);
      }
      return;
    }
    const chunks = [];
    const fileMap = new Map();
    let chunkIndex = 0;
    for (const file of files) {
      if (!this.plugin.settings.embeddingsEnabled || !this.autoProcessingEnabled) {
        console.log("[Embeddings] Batch processing stopped during file preparation - embeddings disabled");
        return;
      }
      try {
        const existsInVault = this.app.vault.getAbstractFileByPath(file.path);
        if (!existsInVault) {
          console.warn(`[Embeddings] File ${file.path} no longer exists in vault, skipping`);
          if (this.data && this.data.files[file.path]) {
            delete this.data.files[file.path];
          }
          continue;
        }
        if (file.stat.size > EMBEDDINGS_CONFIG.FILE_SIZE_LIMIT) {
          console.warn(`[Embeddings] Skipping large file ${file.path} (${(file.stat.size / 1024 / 1024).toFixed(2)}MB)`);
          console.log(`[Embeddings] Marking large file as processed with empty embedding to prevent re-processing`);
          if (this.data) {
            const skippedData = {
              mtime: file.stat.mtime,
              embedding: [],
              chunks: []
            };
            this.data.files[file.path] = skippedData;
            await this.saveFileEmbedding(file.path, skippedData);
            console.log(`[Embeddings] Large file ${file.path} marked as processed in database`);
          }
          continue;
        }
        const content = await this.app.vault.read(file);
        if (this.isBinaryContent(content)) {
          console.log(`[Embeddings] Skipping binary file ${file.path}`);
          if (this.data) {
            const skippedData = {
              mtime: file.stat.mtime,
              embedding: [],
              chunks: []
            };
            this.data.files[file.path] = skippedData;
            await this.saveFileEmbedding(file.path, skippedData);
          }
          continue;
        }
        const fileChunks = this.chunkContent(content, file.basename);
        if (fileChunks.length === 0 || fileChunks.length === 1 && !fileChunks[0]) {
          const existing = (_a = this.data) == null ? void 0 : _a.files[file.path];
          if (existing && existing.embedding.length === 0 && existing.chunks.length === 0) {
            continue;
          }
          if (this.data) {
            const emptyData = {
              mtime: file.stat.mtime,
              embedding: [],
              chunks: []
            };
            this.data.files[file.path] = emptyData;
            await this.saveFileEmbedding(file.path, emptyData);
          }
          continue;
        }
        const maxChunksPerFile = 20;
        if (fileChunks.length > maxChunksPerFile) {
          console.warn(`[Embeddings] Limiting ${file.path} to ${maxChunksPerFile} chunks (was ${fileChunks.length})`);
          fileChunks.length = maxChunksPerFile;
        }
        fileMap.set(chunkIndex, { file, chunks: fileChunks });
        chunks.push(...fileChunks);
        chunkIndex += fileChunks.length;
        this.progress.currentFile = file.path;
        this.updateProgress();
        const embeddingsOptimization = this.performanceService.getEmbeddingsOptimization();
        if (chunks.length > 0 && chunks.length % embeddingsOptimization.yieldFrequency === 0) {
          await new Promise((resolve) => setTimeout(resolve, 1));
        }
      } catch (error) {
        console.error(`[Embeddings] Failed to process ${file.path}:`, error);
        if (error.message && error.message.includes("file does not exist")) {
          console.warn(`[Embeddings] File ${file.path} does not exist, removing from tracking`);
          if (this.data && this.data.files[file.path]) {
            delete this.data.files[file.path];
          }
          try {
            await this.removeDeletedFilesFromIndexedDB([file.path]);
          } catch (removeError) {
            console.error(`[Embeddings] Failed to remove deleted file ${file.path} from IndexedDB:`, removeError);
          }
        } else {
          if (this.data) {
            const failedData = {
              mtime: file.stat.mtime,
              embedding: [],
              chunks: []
            };
            this.data.files[file.path] = failedData;
            await this.saveFileEmbedding(file.path, failedData);
          }
        }
      }
    }
    if (chunks.length === 0)
      return;
    if (!this.plugin.settings.embeddingsEnabled || !this.autoProcessingEnabled) {
      console.log("[Embeddings] Batch processing stopped before API call - embeddings disabled");
      return;
    }
    try {
      if (chunks.length > 20 || files.length > 5) {
        console.log(`[Embeddings] Processing batch of ${chunks.length} chunks from ${files.length} files`);
      }
      const embeddingResult = await this.provider.embedDocuments(chunks);
      const embeddings = embeddingResult.embeddings;
      if (embeddingResult.modelChanged) {
        console.warn("[EmbeddingsManager] Server detected legacy model usage, will trigger re-embedding after this batch");
        setTimeout(() => this.handleModelMigration(), EMBEDDINGS_CONFIG.TIMEOUTS.MODEL_MIGRATION);
      }
      if (!this.plugin.settings.embeddingsEnabled || !this.autoProcessingEnabled) {
        console.log("[Embeddings] Batch processing stopped before saving embeddings - embeddings disabled");
        return;
      }
      chunkIndex = 0;
      for (const [startIndex, { file, chunks: fileChunks }] of fileMap) {
        if (!this.plugin.settings.embeddingsEnabled || !this.autoProcessingEnabled) {
          console.log("[Embeddings] Batch processing stopped during file saving - embeddings disabled");
          return;
        }
        if (fileChunks.length === 0)
          continue;
        const fileEmbeddings = embeddings.slice(chunkIndex, chunkIndex + fileChunks.length);
        const avgEmbedding = this.averageEmbeddings(fileEmbeddings);
        if (!this.data)
          return;
        await this.saveFileEmbedding(file.path, {
          mtime: file.stat.mtime,
          embedding: avgEmbedding,
          chunks: fileChunks
        });
        this.data.files[file.path] = {
          mtime: file.stat.mtime,
          embedding: [],
          chunks: []
        };
        chunkIndex += fileChunks.length;
      }
    } catch (error) {
      console.error("[Embeddings] Failed to get embeddings:", error);
      console.error("[Embeddings] Files in failed batch:", files.map((f) => f.path));
      if (error.message && error.message.includes("400")) {
        console.warn("[Embeddings] HTTP 400 error detected - marking batch files as processed with empty embeddings");
        for (const file of files) {
          if (this.data) {
            const failedData = {
              mtime: file.stat.mtime,
              embedding: [],
              chunks: []
            };
            this.data.files[file.path] = failedData;
            try {
              await this.saveFileEmbedding(file.path, failedData);
            } catch (saveError) {
              console.error(`[Embeddings] Failed to save failed file ${file.path}:`, saveError);
            }
          }
        }
        return;
      }
      throw error;
    }
  }
  async saveFileEmbedding(path, data) {
    if (!this.db)
      return;
    return new Promise((resolve, reject) => {
      try {
        if (!this.verifyDatabaseSchema()) {
          console.error("[Embeddings] Database schema invalid, cannot save embedding");
          reject(new Error("Database schema invalid"));
          return;
        }
        const transaction = this.db.transaction(["files", "embeddings"], "readwrite");
        const filesStore = transaction.objectStore("files");
        const embeddingsStore = transaction.objectStore("embeddings");
        filesStore.put({ path, mtime: data.mtime });
        embeddingsStore.put({
          path,
          embedding: new Float32Array(data.embedding),
          chunks: data.chunks
        });
        transaction.oncomplete = () => resolve();
        transaction.onerror = () => {
          console.error("[Embeddings] Transaction error saving embedding:", transaction.error);
          reject(transaction.error);
        };
      } catch (error) {
        console.error("[Embeddings] Error creating transaction for saving embedding:", error);
        reject(error);
      }
    });
  }
  async loadEmbedding(path) {
    if (!this.db)
      return null;
    if (!this.verifyDatabaseSchema()) {
      console.error("[Embeddings] Database schema invalid, cannot load embedding");
      return null;
    }
    if (this.cache.has(path)) {
      const cached = this.cache.get(path);
      this.cache.delete(path);
      this.cache.set(path, cached);
      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db.transaction(["embeddings"], "readonly");
          const store = transaction.objectStore("embeddings");
          const request = store.get(path);
          request.onsuccess = () => {
            const result = request.result;
            if (result) {
              resolve({
                embedding: cached,
                chunks: result.chunks
              });
            } else {
              resolve(null);
            }
          };
          request.onerror = () => reject(request.error);
          transaction.onerror = () => {
            console.error("[Embeddings] Transaction error loading cached embedding:", transaction.error);
            resolve(null);
          };
        } catch (error) {
          console.error("[Embeddings] Error creating transaction for cached embedding:", error);
          resolve(null);
        }
      });
    }
    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction(["embeddings"], "readonly");
        const store = transaction.objectStore("embeddings");
        const request = store.get(path);
        request.onsuccess = () => {
          const result = request.result;
          if (result) {
            const embedding = Array.from(result.embedding);
            this.cache.set(path, embedding);
            if (this.cache.size > this.maxCacheSize) {
              const firstKey = this.cache.keys().next().value;
              this.cache.delete(firstKey);
            }
            resolve({
              embedding,
              chunks: result.chunks
            });
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
        transaction.onerror = () => {
          console.error("[Embeddings] Transaction error loading embedding:", transaction.error);
          resolve(null);
        };
      } catch (error) {
        console.error("[Embeddings] Error creating transaction for loading embedding:", error);
        resolve(null);
      }
    });
  }
  async findSimilar(filePath, limit = 10) {
    await this.initialize();
    if (!this.data || !this.db)
      return [];
    const fileData = this.data.files[filePath];
    if (!fileData) {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian104.TFile) {
        await this.processBatch([file]);
        return this.findSimilar(filePath, limit);
      }
      return [];
    }
    const sourceData = await this.loadEmbedding(filePath);
    if (!sourceData || !sourceData.embedding.length)
      return [];
    const sourceEmbedding = sourceData.embedding;
    const minHeap = [];
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(["embeddings"], "readonly");
      const store = transaction.objectStore("embeddings");
      const request = store.openCursor();
      request.onsuccess = (event) => {
        var _a;
        const cursor = event.target.result;
        if (cursor) {
          const path = cursor.key;
          if (path === filePath) {
            cursor.continue();
            return;
          }
          const file = this.app.vault.getAbstractFileByPath(path);
          if (!(file instanceof import_obsidian104.TFile) || this.shouldExcludeFile(file)) {
            cursor.continue();
            return;
          }
          const data = cursor.value;
          if (data && data.embedding && data.embedding.length > 0 && data.chunks && data.chunks.length > 0) {
            const targetEmbedding = Array.from(data.embedding);
            const score = this.cosineSimilarity(sourceEmbedding, targetEmbedding);
            if (score > 0.25) {
              const tags = this.extractTags(data.chunks.join(" "));
              const result = {
                path,
                score,
                content: data.chunks[0] || "",
                title: file.basename,
                metadata: {
                  title: file.basename,
                  excerpt: ((_a = data.chunks[0]) == null ? void 0 : _a.substring(0, EMBEDDINGS_CONFIG.EXCERPT_LENGTH)) || "",
                  tags,
                  lastModified: file.stat.mtime
                }
              };
              minHeap.push(result);
              if (minHeap.length > limit) {
                minHeap.sort((a, b) => b.score - a.score);
                minHeap.length = limit;
              }
            }
          }
          cursor.continue();
        } else {
          minHeap.sort((a, b) => b.score - a.score);
          resolve(minHeap);
        }
      };
      request.onerror = () => reject(request.error);
      transaction.onerror = () => reject(transaction.error);
    });
  }
  async searchByQuery(query, limit = 20, excludePath) {
    await this.initialize();
    if (!this.data || !this.db)
      return [];
    const queryResult = await this.provider.embedDocuments([query]);
    const queryEmbeddings = queryResult.embeddings;
    if (!queryEmbeddings || queryEmbeddings.length === 0 || queryEmbeddings[0].length === 0) {
      console.error("[EmbeddingsManager] Failed to generate query embedding");
      return [];
    }
    if (queryResult.modelChanged) {
      console.warn("[EmbeddingsManager] Server detected legacy model during search, will trigger re-embedding");
      setTimeout(() => this.handleModelMigration(), 1e3);
    }
    const queryEmbedding = queryEmbeddings[0];
    const topResults = [];
    const minHeap = [];
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(["embeddings"], "readonly");
      const store = transaction.objectStore("embeddings");
      const request = store.openCursor();
      request.onsuccess = (event) => {
        var _a;
        const cursor = event.target.result;
        if (cursor) {
          const path = cursor.key;
          if (excludePath && path === excludePath) {
            cursor.continue();
            return;
          }
          const file = this.app.vault.getAbstractFileByPath(path);
          if (!(file instanceof import_obsidian104.TFile) || this.shouldExcludeFile(file)) {
            cursor.continue();
            return;
          }
          const data = cursor.value;
          if (data && data.embedding && data.embedding.length > 0 && data.chunks && data.chunks.length > 0) {
            const targetEmbedding = Array.from(data.embedding);
            const score = this.cosineSimilarity(queryEmbedding, targetEmbedding);
            if (score > 0.25) {
              const tags = this.extractTags(data.chunks.join(" "));
              const result = {
                path,
                score,
                content: data.chunks[0] || "",
                title: file.basename,
                metadata: {
                  title: file.basename,
                  excerpt: ((_a = data.chunks[0]) == null ? void 0 : _a.substring(0, EMBEDDINGS_CONFIG.EXCERPT_LENGTH)) || "",
                  tags,
                  lastModified: file.stat.mtime
                }
              };
              minHeap.push(result);
              if (minHeap.length > limit) {
                minHeap.sort((a, b) => b.score - a.score);
                minHeap.length = limit;
              }
            }
          }
          cursor.continue();
        } else {
          minHeap.sort((a, b) => b.score - a.score);
          resolve(minHeap);
        }
      };
      request.onerror = () => reject(request.error);
      transaction.onerror = () => reject(transaction.error);
    });
  }
  isBinaryContent(content) {
    const sampleSize = Math.min(content.length, EMBEDDINGS_CONFIG.CONTENT_SAMPLE_SIZE);
    const sample = content.substring(0, sampleSize);
    let controlChars = 0;
    for (let i = 0; i < sample.length; i++) {
      const code = sample.charCodeAt(i);
      if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
        controlChars++;
      }
      if (code === 0) {
        return true;
      }
    }
    return controlChars / sample.length > 0.1;
  }
  chunkContent(content, title) {
    content = content.replace(/^---[\s\S]*?---\n/, "");
    content = content.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "").replace(/\s+/g, " ").trim();
    if (title) {
      const cleanTitle = title.replace(/\.md$/, "");
      content = `# ${cleanTitle}

${content}`;
    }
    if (!content || content.length < EMBEDDINGS_CONFIG.MIN_CONTENT_LENGTH) {
      return content ? [content] : [""];
    }
    const CHUNK_SIZE = EMBEDDINGS_CONFIG.CHUNK_SIZE;
    const OVERLAP = EMBEDDINGS_CONFIG.CHUNK_OVERLAP;
    const STRIDE = CHUNK_SIZE - OVERLAP;
    const chunks = [];
    if (content.length <= CHUNK_SIZE) {
      return [content];
    }
    let position = 0;
    while (position < content.length) {
      let endPos = Math.min(position + CHUNK_SIZE, content.length);
      if (endPos < content.length) {
        const sentenceEnd = content.lastIndexOf(". ", endPos);
        if (sentenceEnd > position + CHUNK_SIZE * 0.8) {
          endPos = sentenceEnd + 1;
        } else {
          const wordEnd = content.lastIndexOf(" ", endPos);
          if (wordEnd > position + CHUNK_SIZE * 0.8) {
            endPos = wordEnd;
          }
        }
      }
      const chunk = content.substring(position, endPos).trim();
      if (chunk) {
        chunks.push(chunk);
      }
      position += STRIDE;
      if (content.length - position < 200 && position < content.length) {
        const lastChunk = chunks[chunks.length - 1];
        const remaining = content.substring(position).trim();
        if (lastChunk && remaining) {
          chunks[chunks.length - 1] = lastChunk + " " + remaining;
        }
        break;
      }
    }
    return chunks.length > 0 ? chunks : [""];
  }
  averageEmbeddings(embeddings) {
    if (embeddings.length === 0)
      return [];
    if (embeddings.length === 1)
      return embeddings[0];
    const dim = embeddings[0].length;
    const result = new Array(dim).fill(0);
    for (const embedding of embeddings) {
      for (let i = 0; i < dim; i++) {
        result[i] += embedding[i];
      }
    }
    const magnitude = Math.sqrt(result.reduce((sum, val) => sum + val * val, 0));
    if (magnitude > 0) {
      for (let i = 0; i < dim; i++) {
        result[i] /= magnitude;
      }
    }
    return result;
  }
  cosineSimilarity(a, b) {
    if (a.length !== b.length)
      return 0;
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    const denominator = Math.sqrt(normA) * Math.sqrt(normB);
    return denominator === 0 ? 0 : dotProduct / denominator;
  }
  updateProgress() {
    if (this.onProgressCallback) {
      this.onProgressCallback(this.progress);
    }
  }
  async clear() {
    if (!this.db)
      return;
    if (!this.verifyDatabaseSchema()) {
      console.log("[Embeddings] Schema invalid, recreating database for clear operation");
      await this.recreateDatabase();
      this.data = createEmptyEmbeddingsData();
      this.cache.clear();
      new import_obsidian104.Notice("Embeddings data cleared");
      return;
    }
    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction(["files", "embeddings"], "readwrite");
        const filesStore = transaction.objectStore("files");
        const embeddingsStore = transaction.objectStore("embeddings");
        filesStore.clear();
        embeddingsStore.clear();
        transaction.oncomplete = () => {
          this.data = createEmptyEmbeddingsData();
          this.cache.clear();
          new import_obsidian104.Notice("Embeddings data cleared");
          resolve();
        };
        transaction.onerror = () => {
          console.error("[Embeddings] Transaction error clearing data:", transaction.error);
          reject(transaction.error);
        };
      } catch (error) {
        console.error("[Embeddings] Error creating transaction for clear:", error);
        reject(error);
      }
    });
  }
  async isEmpty() {
    await this.initialize();
    return !this.data || Object.keys(this.data.files).length === 0;
  }
  getProgress() {
    return { ...this.progress };
  }
  async getDiagnostics() {
    await this.initialize();
    if (!this.data || !this.db)
      return [];
    const diagnostics = [];
    const allFiles = this.app.vault.getMarkdownFiles();
    const validFiles = allFiles.filter((file) => !this.shouldExcludeFile(file));
    for (const file of validFiles) {
      const hasBeenProcessed = await this.hasEmbeddingInIndexedDB(file.path);
      const hasActualEmbedding = await this.hasActualEmbedding(file.path);
      if (!hasBeenProcessed) {
        const sizeMB = (file.stat.size / 1024 / 1024).toFixed(2);
        diagnostics.push(`Unprocessed: ${file.path} (${sizeMB}MB)`);
        if (file.stat.size > EMBEDDINGS_CONFIG.FILE_SIZE_LIMIT) {
          diagnostics.push(`  \u2192 Will be skipped: exceeds 5MB limit`);
        }
      } else if (!hasActualEmbedding) {
        const sizeMB = (file.stat.size / 1024 / 1024).toFixed(2);
        diagnostics.push(`Processed with empty embedding: ${file.path} (${sizeMB}MB)`);
      }
    }
    return diagnostics;
  }
  isIndexing() {
    return this.isProcessing;
  }
  async enableAutoProcessing() {
    this.autoProcessingEnabled = true;
    if (!this.isProcessing) {
      this.startBackgroundProcessing();
    }
    if (!this.processingCheckInterval) {
      this.processingCheckInterval = window.setInterval(() => {
        if (this.autoProcessingEnabled && !this.isProcessing) {
          this.checkForNewFiles();
        }
      }, EMBEDDINGS_CONFIG.TIMEOUTS.PROCESSING_INTERVAL);
    }
  }
  isAutoProcessingEnabled() {
    return this.autoProcessingEnabled;
  }
  disableAutoProcessing() {
    this.autoProcessingEnabled = false;
    if (this.processingCheckInterval) {
      window.clearInterval(this.processingCheckInterval);
      this.processingCheckInterval = null;
    }
    this.isProcessing = false;
    this.progress = { current: 0, total: 0 };
    console.log("[Embeddings] Auto-processing disabled - stopped any ongoing processing");
  }
  async cleanup() {
    this.disableAutoProcessing();
    this.cache.clear();
    if (this.db) {
      this.db.close();
      this.db = null;
    }
    this.data = null;
    console.log("[Embeddings] Cleanup completed");
  }
  async forceBackgroundProcessing() {
    return this.startBackgroundProcessing();
  }
  async forceRebuildAndComplete() {
    if (this.isProcessing) {
      console.log("[Embeddings] Already processing, skipping rebuild");
      return;
    }
    this.isProcessing = true;
    try {
      await this.initialize();
      if (!this.data || !this.db) {
        this.isProcessing = false;
        return;
      }
      const allFiles = this.app.vault.getMarkdownFiles();
      const filteredFiles = allFiles.filter((file) => !this.shouldExcludeFile(file));
      await this.rebuildMetadataFromIndexedDB();
      const missingFiles = [];
      for (const file of filteredFiles) {
        const hasEmbedding = await this.hasEmbeddingInIndexedDB(file.path);
        if (!hasEmbedding) {
          missingFiles.push(file);
        }
      }
      if (missingFiles.length > 20) {
        console.log(`[Embeddings] Found ${missingFiles.length} missing files to process`);
      }
      if (missingFiles.length > 0) {
        await this.processSpecificFiles(missingFiles);
      }
      await this.cleanupStaleData(filteredFiles);
      if (missingFiles.length > 20) {
        console.log("[Embeddings] Rebuild complete");
      }
    } catch (error) {
      console.error("[Embeddings] Error during rebuild:", error);
    } finally {
      this.isProcessing = false;
    }
  }
  async hasEmbeddingInIndexedDB(filePath) {
    if (!this.db)
      return false;
    return new Promise((resolve) => {
      try {
        const transaction = this.db.transaction(["embeddings"], "readonly");
        const store = transaction.objectStore("embeddings");
        const request = store.get(filePath);
        request.onsuccess = () => {
          resolve(!!request.result);
        };
        request.onerror = () => {
          resolve(false);
        };
        transaction.onerror = () => {
          resolve(false);
        };
      } catch (error) {
        resolve(false);
      }
    });
  }
  async rebuildMetadataFromIndexedDB() {
    if (!this.db || !this.data)
      return;
    this.data.files = {};
    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction(["files"], "readonly");
        const filesStore = transaction.objectStore("files");
        const request = filesStore.openCursor();
        request.onsuccess = (event) => {
          var _a;
          const cursor = event.target.result;
          if (cursor) {
            const file = cursor.value;
            if (this.data) {
              this.data.files[file.path] = {
                mtime: file.mtime,
                embedding: [],
                chunks: []
              };
            }
            cursor.continue();
          } else {
            const count = Object.keys(((_a = this.data) == null ? void 0 : _a.files) || {}).length;
            resolve();
          }
        };
        request.onerror = () => {
          console.error("[Embeddings] Error rebuilding metadata:", request.error);
          reject(request.error);
        };
        transaction.onerror = () => {
          console.error("[Embeddings] Transaction error rebuilding metadata:", transaction.error);
          reject(transaction.error);
        };
      } catch (error) {
        console.error("[Embeddings] Error creating transaction for metadata rebuild:", error);
        reject(error);
      }
    });
  }
  async removeDeletedFilesFromIndexedDB(deletedPaths) {
    if (!this.db || deletedPaths.length === 0)
      return;
    return new Promise((resolve, reject) => {
      try {
        const transaction = this.db.transaction(["files", "embeddings"], "readwrite");
        const filesStore = transaction.objectStore("files");
        const embeddingsStore = transaction.objectStore("embeddings");
        let completed = 0;
        const total = deletedPaths.length * 2;
        for (const path of deletedPaths) {
          const filesRequest = filesStore.delete(path);
          filesRequest.onsuccess = () => {
            completed++;
            if (completed === total) {
              resolve();
            }
          };
          filesRequest.onerror = () => {
            console.error(`[Embeddings] Error deleting ${path} from files:`, filesRequest.error);
            completed++;
            if (completed === total) {
              resolve();
            }
          };
          const embeddingsRequest = embeddingsStore.delete(path);
          embeddingsRequest.onsuccess = () => {
            completed++;
            if (completed === total) {
              resolve();
            }
          };
          embeddingsRequest.onerror = () => {
            console.error(`[Embeddings] Error deleting ${path} from embeddings:`, embeddingsRequest.error);
            completed++;
            if (completed === total) {
              resolve();
            }
          };
        }
        transaction.onerror = () => {
          console.error("[Embeddings] Transaction error during cleanup:", transaction.error);
          reject(transaction.error);
        };
      } catch (error) {
        console.error("[Embeddings] Error creating cleanup transaction:", error);
        reject(error);
      }
    });
  }
  async cleanupStaleData(currentValidFiles) {
    if (!this.db || !this.data)
      return;
    const validPaths = new Set(currentValidFiles.map((f) => f.path));
    const allStoredPaths = Object.keys(this.data.files);
    const stalePaths = [];
    for (const storedPath of allStoredPaths) {
      if (!validPaths.has(storedPath)) {
        stalePaths.push(storedPath);
      } else {
        const file = this.app.vault.getAbstractFileByPath(storedPath);
        if (file instanceof import_obsidian104.TFile && this.shouldExcludeFile(file)) {
          stalePaths.push(storedPath);
        }
      }
    }
    if (stalePaths.length > 0) {
      for (const path of stalePaths) {
        delete this.data.files[path];
      }
      await this.removeDeletedFilesFromIndexedDB(stalePaths);
    }
  }
  async startBackgroundProcessing() {
    if (this.isProcessing)
      return;
    try {
      await this.initialize();
      if (!this.data)
        return;
      const allFiles = this.app.vault.getMarkdownFiles();
      const files = allFiles.filter((file) => !this.shouldExcludeFile(file));
      await this.cleanupStaleData(files);
      const toProcess = [];
      const now = Date.now();
      for (const file of files) {
        const lastProcessed = this.processingCooldown.get(file.path);
        if (lastProcessed && now - lastProcessed < EMBEDDINGS_CONFIG.TIMEOUTS.COOLDOWN) {
          continue;
        }
        const existing = this.data.files[file.path];
        const hasEmbedding = await this.hasEmbeddingInIndexedDB(file.path);
        if (!hasEmbedding || existing && existing.mtime < file.stat.mtime) {
          toProcess.push(file);
        }
      }
      if (toProcess.length > 0) {
        if (toProcess.length >= 50) {
          console.log(`[Embeddings] Auto-processing ${toProcess.length} files in background`);
        }
        for (const file of toProcess) {
          this.processingCooldown.set(file.path, now);
        }
        for (const [path, time] of this.processingCooldown.entries()) {
          if (now - time > 6e4) {
            this.processingCooldown.delete(path);
          }
        }
        if (!this.plugin.settings.embeddingsEnabled || !this.autoProcessingEnabled) {
          if (toProcess.length >= 10) {
            console.log(`[Embeddings] Background processing stopped - embeddings disabled (${toProcess.length} files queued)`);
          }
          return;
        }
        await this.processSpecificFiles(toProcess);
      }
    } catch (error) {
      console.error("[Embeddings] Background processing error:", error);
    }
  }
  async checkForNewFiles() {
    try {
      await this.initialize();
      if (!this.data)
        return;
      const allFiles = this.app.vault.getMarkdownFiles();
      const files = allFiles.filter((file) => !this.shouldExcludeFile(file));
      let hasNewFiles = false;
      for (const file of files) {
        const existing = this.data.files[file.path];
        if (!existing || existing.mtime < file.stat.mtime) {
          hasNewFiles = true;
          break;
        }
      }
      if (hasNewFiles && !this.isProcessing) {
        this.startBackgroundProcessing();
      }
    } catch (error) {
      console.error("[Embeddings] Error checking for new files:", error);
    }
  }
  destroy() {
    this.disableAutoProcessing();
    this.cache.clear();
    if (this.db) {
      this.db.close();
      this.db = null;
    }
  }
  async handleModelMigration() {
    console.log("[EmbeddingsManager] Starting model migration from legacy to SystemSculpt AI");
    try {
      await this.clear();
      await this.forceBackgroundProcessing();
      console.log("[EmbeddingsManager] Model migration initiated successfully");
    } catch (error) {
      console.error("[EmbeddingsManager] Failed to initiate model migration:", error);
    }
  }
  extractTags(content) {
    const tagPattern = /#[a-zA-Z0-9_-]+/g;
    const matches = content.match(tagPattern) || [];
    return [...new Set(matches)].slice(0, 10);
  }
  async findFilesWithEmptyEmbeddings() {
    if (!this.db)
      return [];
    const emptyFiles = [];
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction(["files", "embeddings"], "readonly");
      const filesStore = transaction.objectStore("files");
      const request = filesStore.openCursor();
      request.onsuccess = async (event) => {
        const cursor = event.target.result;
        if (cursor) {
          const path = cursor.value.path;
          const embeddingsStore = transaction.objectStore("embeddings");
          const embRequest = embeddingsStore.get(path);
          embRequest.onsuccess = () => {
            const embeddingData = embRequest.result;
            let reason = "";
            if (!embeddingData) {
              reason = "Missing embedding data";
            } else if (!embeddingData.embedding || embeddingData.embedding.length === 0) {
              reason = "Empty embedding array";
            } else if (embeddingData.embedding.every((val) => val === 0)) {
              reason = "Zero vector embedding";
            }
            if (reason) {
              emptyFiles.push({ path, reason });
            }
            cursor.continue();
          };
          embRequest.onerror = () => {
            cursor.continue();
          };
        } else {
          resolve(emptyFiles);
        }
      };
      request.onerror = () => reject(request.error);
      transaction.onerror = () => reject(transaction.error);
    });
  }
};

// src/services/SystemSculptEmbeddings/EmbeddingsProvider.ts
var import_obsidian105 = __toModule(require("obsidian"));
init_api();
var DEFAULT_MODEL = "voyage-3-large";
var EmbeddingsProvider = class {
  constructor(licenseKey, baseUrl, model = DEFAULT_MODEL) {
    this.licenseKey = licenseKey;
    this.baseUrl = baseUrl;
    this.model = model;
  }
  async embedDocuments(texts) {
    if (!this.licenseKey) {
      throw new Error("License key is required for embeddings");
    }
    if (!texts || texts.length === 0) {
      return { embeddings: [] };
    }
    const textIndices = [];
    const validTexts = [];
    for (let i = 0; i < texts.length; i++) {
      const text = texts[i];
      if (!text || typeof text !== "string" || text.trim().length === 0) {
        continue;
      }
      const sanitizedText = this.sanitizeText(text);
      if (sanitizedText.length < 10) {
        continue;
      }
      textIndices.push(i);
      validTexts.push(sanitizedText);
    }
    if (validTexts.length === 0) {
      return { embeddings: texts.map(() => []) };
    }
    try {
      const batchSize = 20;
      const allEmbeddings = [];
      let modelChanged = false;
      for (let i = 0; i < validTexts.length; i += batchSize) {
        const batch = validTexts.slice(i, i + batchSize);
        const batchResult = await this.processBatch(batch);
        if (batchResult.modelChanged) {
          modelChanged = true;
        }
        allEmbeddings.push(...batchResult.embeddings);
      }
      const result = [];
      let embeddingIndex = 0;
      for (let i = 0; i < texts.length; i++) {
        if (textIndices.includes(i)) {
          result.push(allEmbeddings[embeddingIndex++]);
        } else {
          result.push([]);
        }
      }
      return { embeddings: result, modelChanged };
    } catch (error) {
      console.error("[EmbeddingsProvider] Error:", error);
      throw new Error(`Failed to generate embeddings: ${error.message}`);
    }
  }
  async processBatch(texts) {
    try {
      const response = await (0, import_obsidian105.requestUrl)({
        url: `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS.EMBEDDINGS.GENERATE}`,
        method: "POST",
        headers: SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(this.licenseKey),
        body: JSON.stringify({
          texts,
          model: this.model,
          currentModel: this.model,
          inputType: "document"
        })
      });
      if (response.status === 200) {
        const data = JSON.parse(response.text);
        if (data.embeddings && Array.isArray(data.embeddings)) {
          if (texts.length >= 10) {
            console.log(`[EmbeddingsProvider] Successfully processed batch of ${texts.length} texts with SystemSculpt AI`);
          }
          const modelChanged2 = data.modelChanged || false;
          if (modelChanged2) {
            console.warn("[EmbeddingsProvider] Server detected legacy model usage, triggering re-embedding");
          }
          return { embeddings: data.embeddings, modelChanged: modelChanged2 };
        }
      }
    } catch (error) {
      console.log("[EmbeddingsProvider] Batch request failed, falling back to individual requests:", error.message);
      if (error.message && error.message.includes("400")) {
        console.warn("[EmbeddingsProvider] HTTP 400 error in batch - attempting to process texts individually to identify problematic content");
      }
    }
    const embeddings = [];
    const delay = 100;
    let modelChanged = false;
    for (let i = 0; i < texts.length; i++) {
      const text = texts[i];
      if (i > 0) {
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
      try {
        const response = await (0, import_obsidian105.requestUrl)({
          url: `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS.EMBEDDINGS.GENERATE}`,
          method: "POST",
          headers: SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(this.licenseKey),
          body: JSON.stringify({
            text,
            model: this.model,
            currentModel: this.model,
            inputType: "document"
          })
        });
        if (response.status !== 200) {
          throw new Error(`HTTP ${response.status}: ${response.text || "Unknown error"}`);
        }
        const data = JSON.parse(response.text);
        if (!data.embedding || !Array.isArray(data.embedding)) {
          throw new Error("Invalid response format");
        }
        if (data.modelChanged) {
          console.warn("[EmbeddingsProvider] Server detected legacy model usage during individual request");
          modelChanged = true;
        }
        embeddings.push(data.embedding);
      } catch (error) {
        console.warn(`[EmbeddingsProvider] Failed to process individual text ${i + 1}/${texts.length}: ${error.message}`);
        console.warn(`[EmbeddingsProvider] Problematic text preview: "${text.substring(0, 100)}..."`);
        embeddings.push([]);
      }
    }
    return { embeddings, modelChanged };
  }
  sanitizeText(text) {
    if (!text || typeof text !== "string") {
      return "";
    }
    let cleaned = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, "");
    cleaned = cleaned.normalize("NFC").replace(/[\u200B-\u200D\uFEFF]/g, "").replace(/[\u2028\u2029]/g, "\n").replace(/[\uFFF0-\uFFFF]/g, "").replace(/[\u0080-\u009F]/g, "").replace(/[\u2000-\u200A]/g, " ").replace(/[\uE000-\uF8FF]/g, "").replace(/\s+/g, " ").trim();
    cleaned = cleaned.replace(/!\[.*?\]\((.*?)\)/g, "[image: $1]").replace(/\[([^\]]+)\]\(([^)]+)\)/g, "$1 ($2)").replace(/\s+/g, " ").trim();
    if (cleaned.length > 8e3) {
      console.warn(`[EmbeddingsProvider] Truncating text from ${cleaned.length} to 8000 chars`);
      cleaned = cleaned.substring(0, 8e3);
    }
    const originalLength = text.length;
    const cleanedLength = cleaned.length;
    const reductionPercentage = (originalLength - cleanedLength) / originalLength * 100;
    if (reductionPercentage > 25) {
      const originalSample = text.substring(0, 200).replace(/\n/g, "\\n");
      const cleanedSample = cleaned.substring(0, 200).replace(/\n/g, "\\n");
      console.warn(`[EmbeddingsProvider] Significant content reduction: ${originalLength} -> ${cleanedLength} chars (${reductionPercentage.toFixed(1)}% reduction)`);
      console.warn(`[EmbeddingsProvider] Original sample: "${originalSample}..."`);
      console.warn(`[EmbeddingsProvider] Cleaned sample: "${cleanedSample}..."`);
    }
    if (!cleaned || cleaned.length < 5) {
      console.debug(`[EmbeddingsProvider] Text too short or empty after cleaning (original: ${originalLength} chars)`);
      return "";
    }
    if (/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/.test(cleaned)) {
      console.warn(`[EmbeddingsProvider] Found remaining control characters, performing additional cleanup`);
      cleaned = cleaned.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
    }
    return cleaned;
  }
};

// src/utils/VaultFileCache.ts
var import_obsidian106 = __toModule(require("obsidian"));
var VaultFileCache = class {
  constructor(app) {
    this.markdownFiles = null;
    this.allFiles = null;
    this.fileStats = null;
    this.eventRefs = [];
    this.lastCacheUpdate = 0;
    this.isInitialized = false;
    this.MAX_CACHE_AGE = 3e5;
    this.STATS_CACHE_AGE = 6e4;
    this.cacheHits = 0;
    this.cacheMisses = 0;
    this.startupTime = 0;
    this.STARTUP_GRACE_PERIOD = 5e3;
    this.app = app;
    this.vault = app.vault;
  }
  async initialize() {
    if (this.isInitialized)
      return;
    this.startupTime = Date.now();
    this.setupEventListeners();
    await this.warmCache();
    this.isInitialized = true;
  }
  getMarkdownFiles() {
    if (this.isCacheValid() && this.markdownFiles) {
      this.cacheHits++;
      return [...this.markdownFiles];
    }
    this.cacheMisses++;
    this.refreshMarkdownCache();
    return [...this.markdownFiles || []];
  }
  getAllFiles() {
    if (this.isCacheValid() && this.allFiles) {
      this.cacheHits++;
      return [...this.allFiles];
    }
    this.cacheMisses++;
    this.refreshAllFilesCache();
    return [...this.allFiles || []];
  }
  getMarkdownFileCount() {
    var _a;
    if (this.isStatsCacheValid() && this.fileStats) {
      this.cacheHits++;
      return this.fileStats.count;
    }
    this.cacheMisses++;
    this.refreshFileStats();
    return ((_a = this.fileStats) == null ? void 0 : _a.count) || 0;
  }
  getTotalVaultSize() {
    var _a;
    if (this.isStatsCacheValid() && this.fileStats) {
      this.cacheHits++;
      return this.fileStats.totalSize;
    }
    this.cacheMisses++;
    this.refreshFileStats();
    return ((_a = this.fileStats) == null ? void 0 : _a.totalSize) || 0;
  }
  invalidateCache() {
    this.markdownFiles = null;
    this.allFiles = null;
    this.fileStats = null;
    this.lastCacheUpdate = 0;
  }
  getCacheStats() {
    const total = this.cacheHits + this.cacheMisses;
    const hitRatio = total > 0 ? (this.cacheHits / total * 100).toFixed(1) : "0.0";
    return {
      hits: this.cacheHits,
      misses: this.cacheMisses,
      hitRatio: `${hitRatio}%`
    };
  }
  hasMarkdownFile(path) {
    var _a;
    if (!this.markdownFiles) {
      this.getMarkdownFiles();
    }
    return ((_a = this.markdownFiles) == null ? void 0 : _a.some((file) => file.path === path)) || false;
  }
  getMarkdownFile(path) {
    var _a;
    if (!this.markdownFiles) {
      this.getMarkdownFiles();
    }
    return ((_a = this.markdownFiles) == null ? void 0 : _a.find((file) => file.path === path)) || null;
  }
  destroy() {
    for (const ref of this.eventRefs) {
      this.vault.offref(ref);
    }
    this.eventRefs = [];
    this.invalidateCache();
    this.isInitialized = false;
    const stats = this.getCacheStats();
  }
  isCacheValid() {
    return this.lastCacheUpdate > 0 && Date.now() - this.lastCacheUpdate < this.MAX_CACHE_AGE;
  }
  isStatsCacheValid() {
    return this.fileStats !== null && Date.now() - this.fileStats.lastUpdate < this.STATS_CACHE_AGE;
  }
  refreshMarkdownCache() {
    try {
      this.markdownFiles = this.vault.getMarkdownFiles();
      this.lastCacheUpdate = Date.now();
    } catch (error) {
      console.error("[VaultFileCache] Error refreshing markdown cache:", error);
      this.markdownFiles = [];
    }
  }
  refreshAllFilesCache() {
    try {
      this.allFiles = this.vault.getFiles();
      this.lastCacheUpdate = Date.now();
    } catch (error) {
      console.error("[VaultFileCache] Error refreshing all files cache:", error);
      this.allFiles = [];
    }
  }
  refreshFileStats() {
    try {
      if (!this.markdownFiles) {
        this.refreshMarkdownCache();
      }
      const files = this.markdownFiles || [];
      const totalSize = files.reduce((sum, file) => {
        var _a;
        return sum + (((_a = file.stat) == null ? void 0 : _a.size) || 0);
      }, 0);
      this.fileStats = {
        count: files.length,
        totalSize,
        lastUpdate: Date.now()
      };
    } catch (error) {
      console.error("[VaultFileCache] Error refreshing file stats:", error);
      this.fileStats = { count: 0, totalSize: 0, lastUpdate: Date.now() };
    }
  }
  async warmCache() {
    try {
      this.refreshMarkdownCache();
      this.refreshFileStats();
    } catch (error) {
      console.error("[VaultFileCache] Error warming cache:", error);
    }
  }
  setupEventListeners() {
    this.eventRefs.push(this.vault.on("create", (file) => {
      const timeSinceStartup = Date.now() - this.startupTime;
      const isInGracePeriod = timeSinceStartup < this.STARTUP_GRACE_PERIOD;
      if (isInGracePeriod) {
        return;
      }
      if (file instanceof import_obsidian106.TFile && this.isUserContentFile(file)) {
        this.handleFileChange("create");
      }
    }));
    this.eventRefs.push(this.vault.on("modify", (file) => {
      if (file instanceof import_obsidian106.TFile && this.isUserContentFile(file)) {
        this.fileStats = null;
      }
    }));
    this.eventRefs.push(this.vault.on("delete", (file) => {
      if (file instanceof import_obsidian106.TFile && this.isUserContentFile(file)) {
        this.handleFileChange("delete");
      }
    }));
    this.eventRefs.push(this.vault.on("rename", (file) => {
      if (file instanceof import_obsidian106.TFile && this.isUserContentFile(file)) {
        this.handleFileChange("rename");
      }
    }));
  }
  isUserContentFile(file) {
    const path = file.path;
    if (path.startsWith(".obsidian/")) {
      return false;
    }
    if (path.startsWith(".trash/") || path.startsWith("node_modules/") || path.startsWith(".git/") || path.startsWith("dist/") || path.startsWith("build/")) {
      return false;
    }
    return true;
  }
  handleFileChange(type) {
    this.markdownFiles = null;
    this.allFiles = null;
    this.fileStats = null;
    this.lastCacheUpdate = 0;
  }
};

// src/components/EmbeddingsStatusBar.ts
var import_obsidian107 = __toModule(require("obsidian"));
var EmbeddingsStatusBar = class extends import_obsidian107.Component {
  constructor(plugin) {
    super();
    this.updateInterval = null;
    this.isVisible = false;
    this.plugin = plugin;
    this.initializeStatusBar();
  }
  initializeStatusBar() {
    this.statusBarEl = this.plugin.addStatusBarItem();
    this.statusBarEl.addClass("systemsculpt-embeddings-status-bar");
    this.statusText = this.statusBarEl.createSpan({ cls: "systemsculpt-embeddings-status-text" });
    this.statusBarEl.addEventListener("click", () => {
      this.openEmbeddingsSettings();
    });
    this.statusBarEl.title = "Click to open embeddings settings";
    if (this.plugin.settings.embeddingsEnabled) {
      this.startMonitoring();
    }
    this.plugin.registerSettingsUpdateCallback((oldSettings, newSettings) => {
      this.handleSettingsUpdate(oldSettings, newSettings);
    });
  }
  handleSettingsUpdate(oldSettings, newSettings) {
    const oldEmbeddingsEnabled = (oldSettings == null ? void 0 : oldSettings.embeddingsEnabled) || false;
    const newEmbeddingsEnabled = (newSettings == null ? void 0 : newSettings.embeddingsEnabled) || false;
    if (oldEmbeddingsEnabled !== newEmbeddingsEnabled) {
      if (newEmbeddingsEnabled) {
        this.startMonitoring();
      } else {
        this.stopMonitoring();
      }
    }
  }
  startMonitoring() {
    if (this.updateInterval)
      return;
    this.isVisible = true;
    this.statusBarEl.style.display = "";
    this.updateStatus();
    this.updateInterval = window.setInterval(() => {
      this.updateStatus();
    }, 2e3);
  }
  stopMonitoring() {
    if (this.updateInterval) {
      window.clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
    this.isVisible = false;
    this.statusBarEl.style.display = "none";
  }
  async updateStatus() {
    try {
      if (!this.plugin.settings.embeddingsEnabled) {
        this.stopMonitoring();
        return;
      }
      const manager = this.plugin.embeddingsManager;
      if (!manager) {
        this.statusText.textContent = "0%";
        this.statusBarEl.title = "Embeddings initializing...";
        return;
      }
      const isProcessing = manager.isIndexing();
      const progress = manager.getProgress();
      const totalFiles = manager.getTotalProcessableFiles();
      const processedFiles = await manager.getFilesWithEmbeddingsCount();
      if (isProcessing) {
        this.statusBarEl.style.display = "";
        const percentage = Math.round(processedFiles / totalFiles * 100);
        this.statusText.textContent = `${percentage}%`;
        this.statusBarEl.title = `Processing embeddings: overall ${processedFiles}/${totalFiles} (${percentage}%). Current batch: ${progress.current}/${progress.total}`;
      } else if (processedFiles === totalFiles && totalFiles > 0) {
        this.statusBarEl.style.display = "none";
        this.statusText.textContent = "100%";
        this.statusBarEl.title = `All ${totalFiles} files embedded`;
      } else {
        if (totalFiles > 0) {
          const percentage = Math.round(processedFiles / totalFiles * 100);
          if (percentage === 0) {
            this.statusBarEl.style.display = "none";
          } else {
            this.statusBarEl.style.display = "";
          }
          this.statusText.textContent = `${percentage}%`;
          this.statusBarEl.title = `Embeddings: ${processedFiles}/${totalFiles} files (${percentage}%)`;
        } else {
          this.statusBarEl.style.display = "none";
          this.statusText.textContent = "0%";
          this.statusBarEl.title = "Embeddings ready";
        }
      }
    } catch (error) {
      console.error("[EmbeddingsStatusBar] Error updating status:", error);
      this.statusText.textContent = "Error";
      this.statusBarEl.title = "Embeddings error - click to open settings";
    }
  }
  openEmbeddingsSettings() {
    try {
      this.plugin.app.setting.open();
      this.plugin.app.setting.openTabById(this.plugin.manifest.id);
      setTimeout(() => {
        const embedTab = document.querySelector('.systemsculpt-settings-tabs button[data-tab="embeddings"]');
        if (embedTab) {
          embedTab.click();
        }
      }, 100);
    } catch (error) {
      console.error("[EmbeddingsStatusBar] Error opening settings:", error);
    }
  }
  onload() {
  }
  onunload() {
    if (this.updateInterval) {
      window.clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
  }
};

// src/main.ts
ErrorCollectorService.initializeEarlyLogsCapture();
var SystemSculptPlugin = class extends import_obsidian110.Plugin {
  constructor() {
    super(...arguments);
    this.isUnloading = false;
    this.isPreloadingDone = false;
    this.failures = [];
    this.statusBarEl = null;
    this.statusIconEl = null;
    this.statusTextEl = null;
    this.progressEl = null;
    this._lastActiveFile = null;
    this.hasPromptedForDefaultModel = false;
    this.embeddingsManager = null;
    this.settingsUpdateCallbacks = [];
    this.lastFileCountUpdate = 0;
    this.fileCountCacheInterval = 6e4;
  }
  get settings() {
    return this._internal_settings_systemsculpt_plugin;
  }
  getOrCreateEmbeddingsManager() {
    if (!this.embeddingsManager && this.settings.licenseKey && this.settings.serverUrl) {
      const { normalizeApiUrl: normalizeApiUrl3 } = (init_urlHelpers(), urlHelpers_exports);
      const serverUrl = normalizeApiUrl3(this.settings.serverUrl);
      const provider = new EmbeddingsProvider(this.settings.licenseKey, serverUrl, "voyage-3-large");
      this.embeddingsManager = new EmbeddingsManager(this.app, provider, this, "voyage-3-large");
    }
    if (!this.embeddingsManager) {
      throw new Error("Embeddings manager not available. Please check your license key and server URL.");
    }
    return this.embeddingsManager;
  }
  async onload() {
    var _a;
    this._internal_settings_systemsculpt_plugin = { ...DEFAULT_SETTINGS };
    this.registerEditorExtension(inlineDiffExtension);
    this.settingsManager = new SettingsManager(this);
    await this.settingsManager.loadSettings();
    const { StandardModelSelectionModal: StandardModelSelectionModal2 } = await Promise.resolve().then(() => (init_StandardModelSelectionModal(), StandardModelSelectionModal_exports));
    StandardModelSelectionModal2.cleanupProviderPreferences(this);
    const logLevel = this.settings.debugMode ? LogLevel.DEBUG : (_a = this.settings.logLevel) != null ? _a : LogLevel.WARNING;
    setLogLevel(logLevel);
    try {
      initializeNotificationQueue(this.app);
      this.errorCollectorService = new ErrorCollectorService(500);
      const version = this.manifest.version;
      this.versionCheckerService = VersionCheckerService.getInstance(version, this.app, this);
      this.storage = new StorageManager(this.app, this);
      await this.storage.initialize();
      await Promise.race([
        this.runCriticalInitialization(),
        new Promise((_, reject) => setTimeout(() => reject(new Error("Critical initialization timeout")), 7e3))
      ]);
      await this.runDeferredInitialization();
      try {
        await this.viewManager.restoreChatViews();
      } catch (err) {
        console.error("[SystemSculpt] Failed to preload chat views:", err);
        this.failures.push("chat view preload");
      }
      if (this.settings.embeddingsEnabled) {
        setTimeout(async () => {
          try {
            const manager = this.getOrCreateEmbeddingsManager();
            await manager.enableAutoProcessing();
            await manager.forceRebuildAndComplete();
            if (this.embeddingsStatusBar) {
              this.embeddingsStatusBar.startMonitoring();
            }
          } catch (error) {
            console.error("[SystemSculpt] Failed to enable embeddings auto-processing:", error);
          }
        }, 1e4);
      }
      this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf && leaf.view instanceof import_obsidian110.MarkdownView && leaf.view.file) {
          const file = leaf.view.file;
          const editor = leaf.view.editor;
          if (file && editor) {
            this._lastActiveFile = {
              path: file.path,
              content: editor.getValue(),
              timestamp: Date.now()
            };
          }
        }
      }));
      this.registerCommands();
      if (this.versionCheckerService) {
        this.versionCheckerService.checkForUpdatesOnStartup();
      }
    } catch (error) {
      console.error("[SystemSculpt] Plugin load failed:", error);
      this.failures.push("core initialization");
      if (this.errorCollectorService) {
        this.errorCollectorService.captureError("Plugin load", error);
      }
    }
    this.app.workspace.onLayoutReady(() => {
    });
    if (this.failures.length > 0) {
      this.showErrorNotice(`SystemSculpt had issues with: ${this.failures.join(", ")}. Some features may be unavailable.`, this.collectErrorDetails());
    }
  }
  showUserNotice(message) {
    new import_obsidian110.Notice(message, 8e3);
  }
  showErrorNotice(message, details) {
    const notice = new import_obsidian110.Notice(message + "\n\nClick this notice to copy ALL SystemSculpt logs for reporting.", 15e3);
    if (notice.noticeEl) {
      notice.noticeEl.addEventListener("click", async () => {
        const success = await this.copyAllLogsToClipboard();
        if (success) {
          new import_obsidian110.Notice("All SystemSculpt logs copied! Please share with the developer.", 3e3);
        } else {
          new import_obsidian110.Notice("Failed to copy logs. Try using the 'Copy Logs for Support' button in settings.", 3e3);
        }
      });
      notice.noticeEl.style.cursor = "pointer";
    }
  }
  collectErrorDetails() {
    var _a;
    const details = [];
    details.push(`SystemSculpt Version: ${this.manifest.version}`);
    details.push(`Obsidian Version: ${this.app.vault.configDir.split("/").pop() || "Unknown"}`);
    details.push(`
Failures: ${this.failures.join(", ")}`);
    details.push(`
Initialization State:`);
    details.push(`- Directory Manager Initialized: ${((_a = this.directoryManager) == null ? void 0 : _a.isInitialized()) || false}`);
    details.push(`- Settings Loaded: ${!!this.settings}`);
    details.push(`- Template Manager: ${!!this.templateManager}`);
    if (this.directoryManager) {
      this.directoryManager.verifyDirectories().then(({ valid, issues }) => {
        if (!valid) {
          details.push(`
Directory Issues:`);
          issues.forEach((issue) => details.push(`- ${issue}`));
        }
      }).catch((e) => {
        details.push(`
Error verifying directories: ${e.message}`);
      });
    }
    details.push(`
Recent Error Logs:`);
    const recentErrors = this.getRecentSystemSculptErrors();
    recentErrors.forEach((error) => details.push(error));
    return details.join("\n");
  }
  getRecentSystemSculptErrors() {
    if (this.errorCollectorService) {
      return this.errorCollectorService.getErrorLogs();
    }
    const errors = [];
    const now = new Date();
    this.failures.forEach((failure) => {
      errors.push(`[${now.toISOString()}] Error with: ${failure}`);
    });
    return errors;
  }
  getAllSystemSculptLogs() {
    if (this.errorCollectorService) {
      return this.errorCollectorService.getAllLogs();
    }
    return this.getRecentSystemSculptErrors();
  }
  async copyAllLogsToClipboard() {
    try {
      if (this.errorCollectorService) {
        this.errorCollectorService.enableCaptureAllLogs();
      }
      const logs = this.getAllSystemSculptLogs();
      const logsText = logs.join("\n");
      const headerInfo = [
        `SystemSculpt Version: ${this.manifest.version}`,
        `Date: ${new Date().toISOString()}`,
        `Platform: ${navigator.platform || "Unknown"}`,
        `User Agent: ${navigator.userAgent || "Unknown"}`,
        `Logs Captured: ${logs.length}`,
        `Error Collector Status: ${this.errorCollectorService ? "Active" : "Inactive"}`,
        `
--- LOGS ---
`
      ].join("\n");
      const fullText = headerInfo + logsText;
      await navigator.clipboard.writeText(fullText);
      return true;
    } catch (error) {
      console.error("[SystemSculpt] Failed to copy logs to clipboard:", error);
      return false;
    }
  }
  async runCriticalInitialization() {
    this.emitter = new EventEmitter();
    await this.initializeSettings();
    await this.initializeDirectories();
    this.vaultFileCache = new VaultFileCache(this.app);
    await this.vaultFileCache.initialize();
    await this.initializeBasicServices();
    await this.initializeBasicUI();
  }
  async initializeDirectories() {
    try {
      this.directoryManager = new DirectoryManager(this.app, this);
      await this.directoryManager.initialize();
    } catch (error) {
      console.error("[SystemSculpt] Directory initialization failed:", error);
      this.failures.push("directories");
    }
  }
  async runDeferredInitialization() {
    if (this.isUnloading)
      return;
    try {
      await this.initializeRemainingServices();
      await this.initializeManagers();
      this.initializeLicense().then(() => {
      }).catch((error) => {
        console.warn("[SystemSculpt] Background license initialization failed:", error);
        this.failures.push("license validation");
      });
      await this.preloadDataInBackground();
      try {
        await this.viewManager.restoreChatViews();
      } catch (err) {
        console.error("[SystemSculpt] Failed to restore chat views during deferred init:", err);
      }
      if (this.settings.embeddingsEnabled) {
        try {
          await this.initializeEmbeddingsForFileEvents();
          this.setupEmbeddingsFileWatchers();
          if (this.settings.embeddingsAutoProcess) {
            setTimeout(() => {
              this.autoStartEmbeddingsProcessing();
            }, 1e4);
          }
        } catch (error) {
          console.error("[SystemSculpt] Failed to initialize embeddings file monitoring:", error);
        }
      }
    } catch (error) {
      console.error("[SystemSculpt] Deferred initialization failed:", error);
      this.failures.push("system initialization");
    }
  }
  async initializeEmbeddingsForUser() {
    try {
      const manager = this.getOrCreateEmbeddingsManager();
      await manager.processVault();
    } catch (error) {
      console.error("[SystemSculpt] Failed to process embeddings:", error);
      throw error;
    }
  }
  async initializeEmbeddingsForFileEvents() {
  }
  setupEmbeddingsFileWatchers() {
  }
  async autoStartEmbeddingsProcessing() {
    try {
      const manager = this.getOrCreateEmbeddingsManager();
      if (manager && this.settings.embeddingsEnabled) {
        if (!manager.isAutoProcessingEnabled()) {
        }
        await manager.enableAutoProcessing();
      }
    } catch (error) {
      console.error("[SystemSculpt] Failed to auto-start embeddings processing:", error);
    }
  }
  async initializeSettings() {
    try {
      this.settingsManager = new SettingsManager(this);
      await this.settingsManager.loadSettings();
      this._internal_settings_systemsculpt_plugin = this.settingsManager.getSettings();
    } catch (error) {
      console.error("[SystemSculpt] Error during settings initialization:", error);
      if (!this._internal_settings_systemsculpt_plugin || !this.settingsManager) {
        console.warn("[SystemSculpt] Creating emergency settings manager");
        this.settingsManager = new SettingsManager(this);
        this._internal_settings_systemsculpt_plugin = this.settingsManager.getSettings();
      }
      this.failures.push("settings");
    }
  }
  async initializeBasicServices() {
    try {
      this.customProviderService = new CustomProviderService(this, this.app);
      this.aiService = SystemSculptService.getInstance(this);
      this.favoritesService = FavoritesService.getInstance(this);
      this.modelService = UnifiedModelService.getInstance(this);
    } catch (error) {
      console.warn("[SystemSculpt] Basic service initialization failed:", error);
      this.failures.push("basic services");
    }
  }
  async initializeBasicUI() {
    try {
      this.settingsTab = new SystemSculptSettingTab(this.app, this);
      this.addSettingTab(this.settingsTab);
      if (!this.directoryManager || !this.directoryManager.isInitialized()) {
        await this.directoryManager.initialize();
      }
      this.templateManager = new TemplateManager(this, this.app);
      this.embeddingsStatusBar = new EmbeddingsStatusBar(this);
      this.addChild(this.embeddingsStatusBar);
    } catch (error) {
      console.warn("[SystemSculpt] Basic UI setup failed:", error);
      this.failures.push("UI components");
    }
  }
  async createDirectory(dirPath) {
    if (!this.directoryManager) {
      console.warn("[SystemSculpt] DirectoryManager not available, initializing now");
      this.directoryManager = new DirectoryManager(this.app, this);
      await this.directoryManager.initialize();
    }
    await this.directoryManager.ensureDirectoryByPath(dirPath);
  }
  async createDirectoryOnce(dirPath) {
    await this.createDirectory(dirPath);
  }
  async repairDirectoryStructure() {
    if (!this.directoryManager) {
      console.warn("[SystemSculpt] DirectoryManager not available, initializing now");
      this.directoryManager = new DirectoryManager(this.app, this);
    }
    const result = await this.directoryManager.repair();
    if (result) {
      this.showUserNotice("Directory structure has been repaired successfully.");
    } else {
      this.showUserNotice("Failed to repair directory structure. Check console for details.");
    }
    return result;
  }
  async checkDirectoryHealth() {
    if (!this.directoryManager) {
      console.warn("[SystemSculpt] DirectoryManager not available, initializing now");
      this.directoryManager = new DirectoryManager(this.app, this);
    }
    return await this.directoryManager.verifyDirectories();
  }
  async initializeRemainingServices() {
    try {
      this.transcriptionService = TranscriptionService.getInstance(this);
      this.recorderService = RecorderService.getInstance(this.app, this);
      this.contextMenu = new SystemSculptContextMenu(this.app, this.aiService, this);
    } catch (error) {
      console.warn("[SystemSculpt] Remaining service initialization failed:", error);
      this.failures.push("additional services");
    }
  }
  async initializeManagers() {
    try {
      this.licenseManager = new LicenseManager(this, this.app);
      this.resumeChatService = new ResumeChatService(this);
      this.viewManager = new ViewManager(this, this.app);
      this.viewManager.initialize();
      this.commandManager = new CommandManager(this, this.app);
      this.commandManager.registerCommands();
    } catch (error) {
      console.warn("[SystemSculpt] Manager initialization failed:", error);
      this.failures.push("managers");
    }
  }
  async initializeLicense() {
    try {
      if (this.licenseManager) {
        await this.licenseManager.initializeLicense();
      }
    } catch (error) {
      console.warn("[SystemSculpt] License validation failed:", error);
      this.failures.push("license validation");
    }
  }
  async onunload() {
    this.isUnloading = true;
    try {
      if (this.versionCheckerService) {
        VersionCheckerService.clearInstance();
      }
      if (this.errorCollectorService) {
        this.errorCollectorService.unload();
      }
      if (this.settingsManager) {
        this.settingsManager.destroy();
      }
      if (this.embeddingsManager) {
        await this.embeddingsManager.cleanup();
        this.embeddingsManager = null;
      }
      if (this.embeddingsStatusBar) {
        this.embeddingsStatusBar.stopMonitoring();
        this.removeChild(this.embeddingsStatusBar);
      }
      if (this.settingsTab) {
      }
      if (this.commandManager) {
        const commands = [
          "toggle-audio-recorder",
          "open-systemsculpt-chat",
          "open-chat-history",
          "open-systemsculpt-janitor",
          "reload-obsidian",
          "open-systemsculpt-settings",
          "change-chat-model",
          "chat-with-file",
          "suggest-edits",
          "clear-suggested-edits"
        ];
        commands.forEach((id) => {
          this.app.commands.removeCommand(`${this.manifest.id}:${id}`);
        });
      }
      if (this.viewManager) {
        this.viewManager.unloadViews();
      }
      if (this.templateManager) {
        this.templateManager.unload();
      }
      if (this.recorderService) {
        this.recorderService.unload();
      }
      if (this.transcriptionService) {
        this.transcriptionService.unload();
      }
      if (this.resumeChatService) {
        this.resumeChatService.cleanup();
      }
      if (this.embeddingsManager) {
        this.embeddingsManager = null;
      }
      if (this.vaultFileCache) {
        this.vaultFileCache.destroy();
      }
      UnifiedModelService.clearInstance();
      FavoritesService.clearInstance();
      SystemSculptService.clearInstance();
      CustomProviderService.clearStaticCaches();
      this.modelService = void 0;
      this.aiService = void 0;
      this.customProviderService = void 0;
      try {
        PreviewService.hideAllPreviews();
        PreviewService.cleanup();
      } catch (error) {
        console.error("[SystemSculpt] Error cleaning up PreviewService:", error);
      }
      try {
        if (this.statusBarEl) {
          this.statusBarEl.remove();
          this.statusBarEl = null;
          this.statusIconEl = null;
          this.statusTextEl = null;
          this.progressEl = null;
        }
      } catch (error) {
        console.error("[SystemSculpt] Error cleaning up status bar:", error);
      }
    } catch (error) {
      console.error("[SystemSculpt] Error during plugin cleanup:", error);
    }
  }
  get isReady() {
    return this.isPreloadingDone;
  }
  async loadData() {
    return super.loadData();
  }
  async saveData(data) {
    return super.saveData(data);
  }
  async saveSettings() {
    await this.settingsManager.saveSettings();
  }
  getRecorderService() {
    return this.recorderService;
  }
  getTranscriptionService() {
    return this.transcriptionService;
  }
  getLicenseManager() {
    return this.licenseManager;
  }
  getSettingsManager() {
    return this.settingsManager;
  }
  getInitialModels() {
    return this.modelService.getModels();
  }
  async preloadDataInBackground() {
    if (this.isUnloading)
      return;
    const modelPromise = (async () => {
      try {
        const models = await this.modelService.getModels();
      } catch (error) {
        console.warn("[SystemSculpt] Background model preload failed:", error);
        this.failures.push("model preload");
      }
    })();
    modelPromise.catch((error) => {
      console.error("[SystemSculpt] Fatal error in model preload:", error);
    });
    this.isPreloadingDone = true;
  }
  getVersionCheckerService() {
    return this.versionCheckerService;
  }
  async updateLastSaveAsNoteFolder(folder) {
    await this.settingsManager.updateSettings({ lastSaveAsNoteFolder: folder });
  }
  getViewManager() {
    if (!this.viewManager) {
      console.error("[SystemSculpt] ViewManager accessed before initialization!");
    }
    return this.viewManager;
  }
  registerCommands() {
    this.addCommand({
      id: "audio-chunking-analysis",
      name: "Run Audio Chunking Analysis",
      callback: () => {
        Promise.resolve().then(() => (init_RunAudioAnalysis(), RunAudioAnalysis_exports)).then((module2) => {
          module2.runAudioAnalysis(this);
        }).catch((error) => {
          console.error("[SystemSculpt] Error running audio chunking analysis:", error);
          new import_obsidian110.Notice(`Error running analysis: ${error instanceof Error ? error.message : String(error)}`);
        });
      }
    });
    this.addCommand({
      id: "find-similar-current-note",
      name: "Find Similar Notes (Current Note)",
      editorCallback: async (editor, view) => {
        if (!view.file) {
          new import_obsidian110.Notice("No active file selected.");
          return;
        }
        const currentFilePath = view.file.path;
        const fileContent = editor.getValue();
        if (!fileContent.trim()) {
          new import_obsidian110.Notice("Current note is empty.");
          return;
        }
        try {
          if (!this.settings.embeddingsEnabled) {
            new import_obsidian110.Notice("Embeddings are disabled. Enable them in Settings > SystemSculpt AI > Embeddings.");
            return;
          }
          await this.viewManager.activateEmbeddingsView();
        } catch (error) {
          console.error("[SystemSculpt] Error finding similar notes:", error);
          new import_obsidian110.Notice(`Error finding similar notes: ${error.message}`);
        }
      }
    });
    this.addCommand({
      id: "system-search",
      name: "System Search",
      callback: () => {
        Promise.resolve().then(() => (init_SystemSearchModal(), SystemSearchModal_exports)).then((module2) => {
          const modal = new module2.SystemSearchModal(this.app, this);
          modal.open();
        }).catch((error) => {
          console.error("[SystemSculpt] Error loading SystemSearchModal:", error);
          const message = error instanceof Error ? error.message : String(error);
          const stack = error instanceof Error ? error.stack : void 0;
          const errorDetails = `Error opening System Search: ${message}

${stack != null ? stack : "No stack trace available"}`;
          new import_obsidian110.Notice(errorDetails, 1e4);
        });
      }
    });
    this.addCommand({
      id: "process-embeddings",
      name: "Process Embeddings",
      callback: async () => {
        try {
          if (!this.settings.embeddingsEnabled) {
            new import_obsidian110.Notice("Embeddings are disabled. Enable them in Settings > SystemSculpt AI > Embeddings.");
            return;
          }
          const manager = this.getOrCreateEmbeddingsManager();
          if (manager.isIndexing()) {
            new import_obsidian110.Notice("Embeddings processing is already in progress.");
            return;
          }
          new import_obsidian110.Notice("Starting embeddings processing...");
          await manager.processVault();
        } catch (error) {
          console.error("[SystemSculpt] Error processing embeddings:", error);
          new import_obsidian110.Notice(`Failed to process embeddings: ${error.message}`);
        }
      }
    });
    this.addCommand({
      id: "rebuild-embeddings",
      name: "Rebuild Embeddings",
      callback: async () => {
        try {
          if (!this.settings.embeddingsEnabled) {
            new import_obsidian110.Notice("Embeddings are disabled. Enable them in Settings > SystemSculpt AI > Embeddings.");
            return;
          }
          const manager = this.getOrCreateEmbeddingsManager();
          new import_obsidian110.Notice("Clearing embeddings data...");
          await manager.clear();
          new import_obsidian110.Notice("Rebuilding embeddings... This may take a few minutes.");
          const startTime = Date.now();
          await manager.processVault();
          const duration = ((Date.now() - startTime) / 1e3).toFixed(1);
          new import_obsidian110.Notice(`Embeddings rebuild complete! (${duration}s)`);
        } catch (error) {
          console.error("[SystemSculpt] Error rebuilding embeddings:", error);
          new import_obsidian110.Notice(`Failed to rebuild embeddings: ${error.message}`);
        }
      }
    });
  }
  registerSettingsUpdateCallback(callback) {
    this.settingsUpdateCallbacks.push(callback);
  }
  unregisterSettingsUpdateCallback(callback) {
    const index = this.settingsUpdateCallbacks.indexOf(callback);
    if (index > -1) {
      this.settingsUpdateCallbacks.splice(index, 1);
    }
  }
  notifySettingsUpdate(oldSettings, newSettings) {
    this.settingsUpdateCallbacks.forEach((callback) => {
      try {
        callback(oldSettings, newSettings);
      } catch (error) {
        console.error("[SystemSculpt] Error in settings update callback:", error);
      }
    });
  }
};


/* nosourcemap */